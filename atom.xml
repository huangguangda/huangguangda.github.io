<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>达叔小生</title>
  
  <subtitle>爱好分享的码农</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huangguangda.github.io/"/>
  <updated>2019-01-27T08:19:54.693Z</updated>
  <id>https://huangguangda.github.io/</id>
  
  <author>
    <name>达叔小生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第77节:Java中的事务和数据库连接池和DBUtils</title>
    <link href="https://huangguangda.github.io/2019/01/27/1/"/>
    <id>https://huangguangda.github.io/2019/01/27/1/</id>
    <published>2019-01-27T08:17:07.000Z</published>
    <updated>2019-01-27T08:19:54.693Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/40.jpg" style="width: 100%;height: 100%"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-de1eea934cb6fb28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标题图"><br><a id="more"></a></p><blockquote><p>第77节:Java中的事务和数据库连接池和DBUtiles</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看哭你,字数:8803,承蒙关照,谢谢朋友点赞!</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-b6bfcd0a9cd91b2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字数8803"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><code>Transaction</code>事务,什么是事务,事务是包含一组操作,这组操作里面包含许多个单一的逻辑,只要有一个逻辑没有执行成功就算失败,导致回滚就是指所有的数据都会回到最初的状态.</p><p>有事务,是为了保证逻辑一定要成功,如银行转账.</p><h2 id="回顾一下"><a href="#回顾一下" class="headerlink" title="回顾一下"></a>回顾一下</h2><p>什么是<code>jsp</code>,<code>jsp</code>的三大指令.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page: 定义当前页面的信息</span><br><span class="line">include: 包含其他页面</span><br><span class="line">taglib: 引入标签库</span><br></pre></td></tr></table></figure><p>三大动作标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=&quot;&quot;&gt;:跳转</span><br><span class="line">&lt;jsp:param name=&quot;&quot; value=&quot;&quot;&gt;:跳转到具体页面或是某个页面被包含的时候,可以指定参数</span><br><span class="line">&lt;jsp:include page=&quot;&quot;&gt;:包含</span><br></pre></td></tr></table></figure><p>九大内置对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 四个作用域</span><br><span class="line">pageContext 当前页</span><br><span class="line">request 请求 一次请求 响应后就不行了</span><br><span class="line">session 会话 一次会话</span><br><span class="line">application 都可以 整个项目,直到关闭服务器</span><br><span class="line"></span><br><span class="line">// 5</span><br><span class="line">response</span><br><span class="line">out</span><br><span class="line">exception</span><br><span class="line">config -&gt; ServletConfig</span><br><span class="line">page -&gt; this 翻译成java文件的类对象</span><br></pre></td></tr></table></figure><h2 id="EL"><a href="#EL" class="headerlink" title="EL"></a><code>EL</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123; 表达式 &#125;;</span><br></pre></td></tr></table></figure><p>取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% User user = new User(); %&gt;</span><br><span class="line">$&#123;user.ame&#125;</span><br><span class="line">从四个作用域里面找 </span><br><span class="line">pageContext -&gt; request -&gt; session -&gt; application</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"> User user = new User();</span><br><span class="line"> pageContext.setAttribute(&quot;user&quot;,user);</span><br><span class="line">%&gt;</span><br><span class="line">$&#123;sessionScope.user.name&#125;强制用session找</span><br></pre></td></tr></table></figure><p><code>EL</code>的11个隐式对象:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pageContext</span><br><span class="line">// 作用域</span><br><span class="line">pageScope</span><br><span class="line">requestScope</span><br><span class="line">sessionScope</span><br><span class="line">applicationScope</span><br><span class="line"></span><br><span class="line">头相关</span><br><span class="line">header</span><br><span class="line">headerValues</span><br><span class="line">参数</span><br><span class="line">param</span><br><span class="line">paramValues</span><br><span class="line">cookie</span><br><span class="line">initparam</span><br></pre></td></tr></table></figure><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a><code>JSTL</code></h2><p>导包哦,引入标签库是1.1的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set&gt;: 存储到作用域</span><br><span class="line">&lt;c:set var=&quot;&quot; value=&quot;&quot; scope=&quot;&quot;&gt;</span><br><span class="line">&lt;c: if&gt;: 用来判断</span><br><span class="line">&lt;c:forEach items=&quot;&quot; var=&quot;&quot;&gt;:用于遍历</span><br></pre></td></tr></table></figure><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="https://upload-images.jianshu.io/upload_images/11158618-1fb13fda59aec338.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加两条数据"></p><p>数据库命令行:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-957f27422de5d893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-5c0db96f0c601c3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行"></p><p>关闭自动提交.</p><p>关闭了提交,再减100:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-2c89852209c47240.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行"></p><p>会到数据库查看:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-73c606289c50f5bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="刷新了"></p><p>值没改变!</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-82ccbc226de9aca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入提交后"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-91cc7dc17a30b137.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="刷新改变"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-f0484045a508ef73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开启事务"></p><p>添加改变代码:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-f4b088361405d51c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="先看表"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.test;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.dashucoding.util.JDBCUtil;</span><br><span class="line"> </span><br><span class="line">public class TestDemo &#123; </span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testTransaction() &#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line">ResultSet rs = null;</span><br><span class="line">try &#123;</span><br><span class="line">    conn = JDBCUtil.getConn();</span><br><span class="line">    //查询数据</span><br><span class="line">/*String sql = &quot;select * from account&quot;;</span><br><span class="line">    ps = conn.prepareStatement(sql);*/</span><br><span class="line"></span><br><span class="line">    String sql = &quot;update account set money = money - ? where id = ?&quot;;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">    </span><br><span class="line">    // 扣钱</span><br><span class="line">ps.setInt(1, 100);</span><br><span class="line">ps.setInt(2, 1);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">/*ps.setInt(1, -100);</span><br><span class="line">ps.setInt(2, 1);</span><br><span class="line">ps.executeUpdate();*/</span><br><span class="line"></span><br><span class="line">// 查询数据 </span><br><span class="line">/*rs = ps.executeQuery();</span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">System.out.println(rs.getString(&quot;name&quot;)+&quot;==&quot;+rs.getInt(&quot;money&quot;));</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">JDBCUtil.release(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.util;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class JDBCUtil &#123;</span><br><span class="line"></span><br><span class="line">static String driverClass = null;</span><br><span class="line">static String url = null;</span><br><span class="line">static String name = null;</span><br><span class="line">static String password= null;</span><br><span class="line"></span><br><span class="line">static&#123;</span><br><span class="line">try &#123;</span><br><span class="line">//1. 创建一个属性配置对象</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">InputStream is = new FileInputStream(&quot;jdbc.properties&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用类加载器，去读取src底下的资源文件。 后面在servlet</span><br><span class="line">//InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span><br><span class="line">//导入输入流。</span><br><span class="line">properties.load(is);</span><br><span class="line"></span><br><span class="line">//读取属性</span><br><span class="line">driverClass = properties.getProperty(&quot;driverClass&quot;);</span><br><span class="line">url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">name = properties.getProperty(&quot;name&quot;);</span><br><span class="line">password = properties.getProperty(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取连接对象</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static Connection getConn()&#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">try &#123;</span><br><span class="line">Class.forName(driverClass);</span><br><span class="line">//静态代码块 ---&gt; 类加载了，就执行。 java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span><br><span class="line">//DriverManager.getConnection(&quot;jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb&quot;);</span><br><span class="line">//2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。</span><br><span class="line">conn = DriverManager.getConnection(url, name, password);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 释放资源</span><br><span class="line"> * @param conn</span><br><span class="line"> * @param st</span><br><span class="line"> * @param rs</span><br><span class="line"> */</span><br><span class="line">public static void release(Connection conn , Statement st , ResultSet rs)&#123;</span><br><span class="line">closeRs(rs);</span><br><span class="line">closeSt(st);</span><br><span class="line">closeConn(conn);</span><br><span class="line">&#125;</span><br><span class="line">public static void release(Connection conn , Statement st)&#123;</span><br><span class="line">closeSt(st);</span><br><span class="line">closeConn(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void closeRs(ResultSet rs)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(rs != null)&#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">rs = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void closeSt(Statement st)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(st != null)&#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">st = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void closeConn(Connection conn)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(conn != null)&#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">conn = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/11158618-ba0363848fe54936.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="刷新后"></p><p>事务只针对连接.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.test;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.dashucoding.util.JDBCUtil;</span><br><span class="line"> </span><br><span class="line">public class TestDemo &#123; </span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test02()&#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line">ResultSet rs = null;</span><br><span class="line">try &#123;</span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"></span><br><span class="line">String sql = &quot;update account set money = money - ? where id = ?&quot;;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">//扣钱， 扣ID为1 的100块钱</span><br><span class="line">ps.setInt(1, 100);</span><br><span class="line">ps.setInt(2, 1);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//int a = 10 /0 ;</span><br><span class="line">String s = null;</span><br><span class="line">s.length();</span><br><span class="line"></span><br><span class="line">//加钱， 给ID为2 加100块钱</span><br><span class="line">ps.setInt(1, -100);</span><br><span class="line">ps.setInt(2, 2);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;finally &#123;</span><br><span class="line">JDBCUtil.release(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testTransaction() &#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line">ResultSet rs = null;</span><br><span class="line">try &#123;</span><br><span class="line">    conn = JDBCUtil.getConn();</span><br><span class="line">    </span><br><span class="line">    // 连接</span><br><span class="line">    conn.setAutoCommit(false);</span><br><span class="line">    </span><br><span class="line">    //查询数据</span><br><span class="line">/*String sql = &quot;select * from account&quot;;</span><br><span class="line">    ps = conn.prepareStatement(sql);*/</span><br><span class="line"></span><br><span class="line">    String sql = &quot;update account set money = money - ? where id = ?&quot;;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">    </span><br><span class="line">    // 扣钱</span><br><span class="line">ps.setInt(1, 100);</span><br><span class="line">ps.setInt(2, 1);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">int a = 10 /0 ;</span><br><span class="line"></span><br><span class="line">ps.setInt(1, -100);</span><br><span class="line">ps.setInt(2, 2);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">// 提交事务</span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line">// 查询数据 </span><br><span class="line">/*rs = ps.executeQuery();</span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">System.out.println(rs.getString(&quot;name&quot;)+&quot;==&quot;+rs.getInt(&quot;money&quot;));</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">// 回滚事务</span><br><span class="line">try &#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125; catch (SQLException e1) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">JDBCUtil.release(conn, ps, rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>事务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conn.setAutoCommit(false)来关闭自动提交的设置</span><br><span class="line">conn.commit(); 提交事务</span><br><span class="line">conn.rollback(); 回滚事务</span><br></pre></td></tr></table></figure><p>记住:<br>什么是事务,事务有什么用处,事务怎么用.</p><p>事务的特点:</p><ol><li>原子性: 指的是事务中包含的逻辑,不可以分割(事务中逻辑不可分)</li><li>一致性: 事务执行前和执行后,保持数据的完整性一致(执行前后,数据保持一致)</li><li>隔离性: 事务在执行期间不受到其他事务的影响(隔离不受影响)</li><li>持久性: 事务执行结束,提交或回滚,数据都应该持久化到数据中(数据持久化在数据中)</li></ol><p>安全问题</p><ol><li>读问题<br>脏读,不可重复读,幻读</li><li>写问题<br>丢失更新,解决丢失更新的方法,一悲观锁和乐观锁</li></ol><p>隔离级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Read Uncommitted 读未提交</span><br><span class="line">Read Committed 读已提交</span><br><span class="line">Repeatable Read 重复读</span><br><span class="line">Serializable 可串行化</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/11158618-340d7d7c9fa17391.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="隔离级别"></p><p>脏读:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-d9106d65bda58b29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-5ddc6d9143e31aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><p>一条连接:<br><img src="https://upload-images.jianshu.io/upload_images/11158618-e64e5a5deeb0b1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><p>另一条连接:<br><img src="https://upload-images.jianshu.io/upload_images/11158618-f8bbe6bf9b1edaeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use bank;</span><br><span class="line">start transaction;</span><br><span class="line">select * from account;</span><br><span class="line">select * from account;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use bank;</span><br><span class="line">start transaction;</span><br><span class="line">update account set money = money + 300 where id = 1;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>读未提交</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-c450391d3938cb67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><blockquote><p>例子</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-cdb604cd503e7150.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p>这里查询,然后再看看数据库中的表:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-f7bf143f903f5ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="刷新后"></p><p>命令提交:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-9b76968719b44c3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令提交"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-88e62f1497ebc2e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查询数据"></p><blockquote><p>不可重复读的问题</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-71768cebcf17d9c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><h2 id="Repeatable-Read重复读"><a href="#Repeatable-Read重复读" class="headerlink" title="Repeatable Read重复读"></a><code>Repeatable Read</code>重复读</h2><p><img src="https://upload-images.jianshu.io/upload_images/11158618-36554b379444364c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-2a54bec6bdd2dc42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-d0f4b3b9da1054f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-a4e5431c4351fb69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><h2 id="可串化"><a href="#可串化" class="headerlink" title="可串化"></a>可串化</h2><p><img src="https://upload-images.jianshu.io/upload_images/11158618-1d7f007806a44df5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-748f14ac618bd972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><blockquote><p>读未提交,引发脏读,读已提交解决脏读,引发不可重复读, 可重复读解决脏读解决了脏读,不可重复读,</p></blockquote><p>asss</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>读:<br>脏读 不可重读读 幻读</p><p>脏读:<br>一个事务读到另外一个事务还未提交的数据</p><p>不可重复读:<br>一个事务读到另外一个事务提交的数据,导致前后两次查询结果不一致</p><p>幻读:<br>一个事务读到了另外一个事务已提交的插入的数据,导致多次查询结果不一致.</p><p>读未提交,<br>会导致丢失更新</p><p>读已提交,<br>能够屏蔽 脏读的现象,但是引发不可重复读</p><h2 id="事务的安全隐患脏读"><a href="#事务的安全隐患脏读" class="headerlink" title="事务的安全隐患脏读"></a>事务的安全隐患脏读</h2><p>隔离级别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read uncommitted 读未提交</span><br><span class="line">read committed 读已提交</span><br><span class="line">repeatable read 重复读</span><br><span class="line">serializable 可串化</span><br></pre></td></tr></table></figure><p><code>mysql</code>默认的是重复读.</p><p>设置A窗口的隔离级别为 读未提交 </p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-e9a7fb886f61a2b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a"></p><p>两个窗口都分别开启事务</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-abc1c8eabc71877b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="脏读"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-ab4e57154f848904.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="提交后"></p><p>读未提交是一个事务可以读取到另一个事务还没有提交的数据,会引发脏读现象,读取到的是数据库内存中的数据,并不是真正的磁盘上的数据.</p><p>还未提交时,数据库内存中的数据是不会改变的,只有到commit提交后,数据库中的数据才会提交,从而读取真正在磁盘上的数据.</p><h2 id="Read-Committed读已提交"><a href="#Read-Committed读已提交" class="headerlink" title="Read Committed读已提交"></a><code>Read Committed</code>读已提交</h2><p><img src="https://upload-images.jianshu.io/upload_images/11158618-c7b28ae1809f056d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-cb00c0352e7e6afa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p>在a发生了变化,屏蔽了脏读,引发不可重复读,读已提交.读已提交,在a窗口设置的是读已提交,两边开启事务.在b窗口更新操作.</p><p>在a窗口查询结果不一致,一次是在b窗口提交事务之前,一次的提交之后.</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-ef698665a32c12f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="前后"></p><p>引发了不可重复读</p><p>不可重复读,一个事务读取到了另一个事务提交的数据,导致前后两次查询结果不一致.</p><p>会造成问题是前后读取到的结果不一样,发生了不可重复读,就是不可以 重复读取, 就是不能执行多次读取, 否则会导致结果不一致, 这下好了, 读取已提交导致了 重复读取, 结果还不一致, 就出现了叫 不可重复读 现象.</p><h2 id="安全隐患-可重复读"><a href="#安全隐患-可重复读" class="headerlink" title="安全隐患_可重复读"></a>安全隐患_可重复读</h2><p><code>Repeatable Read</code>重复读, 重复读就是mysql默认的隔离级别,可以让食物在自己的会话中重复读取数据,并且不会出现结果不一致的现象, 就算其他事务提交了, 也还是会在窗口中出现以前的数据, 这就是可重复读了.</p><p>重复读, 就是让它可以重复查询, 结果还是和以前一样的效果出现.</p><h2 id="设置重复读"><a href="#设置重复读" class="headerlink" title="设置重复读"></a>设置重复读</h2><p><img src="https://upload-images.jianshu.io/upload_images/11158618-e0f2d760fae4d676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重复读"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-a536c4ba1f1d6304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重复读"></p><h2 id="安全隐患-可串行化"><a href="#安全隐患-可串行化" class="headerlink" title="安全隐患 _可串行化"></a>安全隐患 _可串行化</h2><p>幻读:什么是幻读呢?<br>就是一个事务读到另一个事务已提交的插入的数据,会导致多次查询结果不一致.就是幻读,是不是幻读理解为我幻想了, 事务已提交的插入数据, 导致幻想了,(幻读) 导致每次查询结果不一样.</p><p>事务已提交,多次查询结果不一致.</p><p>幻读-&gt;<code>Serializable</code>可串行化</p><p>该事务的级别是最高的事务级别,我是可串行化,是最高的.可以解决如下小弟的问题,如脏读,不可重复读,幻读,因为我是可串行化,是大佬,但作为大佬,还是会有缺点的.</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-9fef7bc147a7897b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-9c3847fe44648faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-567b038b4c0f658c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p>是的,a提交才动.现在我们让b先开启事务.</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-1f69b3e6719fe3ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-5439323e10ed52ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-4e07621f4afff961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="提交了"></p><p>可串行化, 谁先打开事务,就谁有权利,这个隔离级别,先打开就有权利让别人等着,等先打开事务的那个家伙,提交或者回滚后,才能进行,这种级别是用得比较少的,因为容易导致性能上效率低下.</p><p>隔离级别有四个哦</p><ol><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>可串行化</li></ol><p>如果按照效率划分,从高到低,排个名次如下:</p><ol><li>读未提交 -&gt; 脏读</li><li>读已提交 -&gt; 不可重复读</li><li>可重复读 -&gt; 解决重复读</li><li>可串行化 -&gt; 以上都是我小弟来着</li></ol><p>按照拦截程度来划分,从高到底,排名如下:</p><ol><li>可串行化 -&gt; 我是大哥</li><li>可重复读 -&gt; 我是二哥</li><li>读已提交 -&gt; 我是三弟</li><li>读未提交 -&gt; 我是小弟</li></ol><h2 id="事务-隔离级别小结"><a href="#事务-隔离级别小结" class="headerlink" title="事务_隔离级别小结"></a>事务_隔离级别小结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 使用事务</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line">// 提交</span><br><span class="line">conn.commit();</span><br><span class="line">// 回滚</span><br><span class="line">conn.rollback();</span><br></pre></td></tr></table></figure><p>事务只是针对连接对象.事务是会自动提交的.</p><p>安全隐患和隔离级别</p><p>安全隐患: 读的安全隐患和写的安全隐患</p><p>读:<br>脏读,读到未提交的数据,一个事务读到了另一个事务未提交的数据;<br>不可重复读,就是一个事务读到了另一个事务已经提交的数据,导致前后两次查询的结果不一致;<br>幻读,就是一个事务读到了另一个事务添加的数据,导致前后查询结果不一致.</p><p>写: 丢失更新…</p><blockquote><p>隔离级别</p></blockquote><p>读未提交,导致脏读<br>读已提交,解决脏读,导致不可重复读<br>可重复读,解决脏读和不可重复读,导致幻读<br>可串行化,解决脏读,不可重复读,幻读</p><p>默认的mysql是可重复读,oracle默认是读已提交</p><h2 id="写的问题-丢失更新"><a href="#写的问题-丢失更新" class="headerlink" title="写的问题_丢失更新"></a>写的问题_丢失更新</h2><p>丢失更新</p><ol><li>乐观锁</li><li>悲观锁</li></ol><p>安全问题包含 读的问题和写的问题</p><blockquote><p>事务的特性是什么?<br>原子性,一致性,隔离性,持久性</p></blockquote><h2 id="写的问题-丢失更新-1"><a href="#写的问题-丢失更新-1" class="headerlink" title="写的问题_丢失更新"></a>写的问题_丢失更新</h2><p><img src="https://upload-images.jianshu.io/upload_images/11158618-28e95bc6dd2e238d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-f849cba99e5c3b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><p>b窗口没有提交.等待提交中:</p><p>案例控制面板,我的a:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-3dd1e1ddb5f434d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a的"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-4535bfedba1a991d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b的"></p><p>哭了,这是设置默认的重复读啊!</p><h2 id="丢失更新的问题"><a href="#丢失更新的问题" class="headerlink" title="丢失更新的问题"></a>丢失更新的问题</h2><blockquote><p>听说丢失更新</p></blockquote><p>a事务和b事务同时查询一个表,a开始修改并提交<code>name</code>字段的名字,然后b事务开始修改该行的<code>money</code>的字段,如果b事务提交,那么之前a事务修改的名字没有了,变回去了哦,当然b事务回滚,也同样导致a事务更新没有了哦.回滚也会把之前b事务的最初的数据还原.</p><p>这里的情况处理序列化级别外,就是可串行化级别大佬哦!</p><blockquote><p>解决丢失更新的方法</p></blockquote><ol><li>悲观锁</li><li>乐观锁</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from account;</span><br></pre></td></tr></table></figure><p>悲观锁的态度,它是悲观的态度,它是一定会丢失更新,它的想法是我一定会出错.</p><p>而乐观锁,它的态度是我一定不会丢失更新.</p><blockquote><p>悲观锁</p></blockquote><p>数据库的锁机制,排他锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from account for update;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-7d92e61a7b2a6340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-b19bc37d5e4ec399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行"></p><blockquote><p>丢失更新的问题</p></blockquote><p>不考虑隔离性,产生写入数据导致的问题为丢失更新的问题,两个事务同时对某一条记录做修改,然后会导致丢失更新的问题.</p><p>a,b两个事务同时获取一条数据,同时做了修改,a事务修改后,提交了事务,b事务修改后,不管是提交还是回滚,都会对数据发生影响.</p><p>悲观锁记住用了这句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from account for update;</span><br><span class="line">for update;</span><br><span class="line">数据库锁机制,排他锁</span><br></pre></td></tr></table></figure><blockquote><p>乐观锁</p></blockquote><p>a事务先提交,数据库版本<code>version</code>变为1,b事务在提交的时候,比对数据库<code>version</code>和自己的<code>version</code>是不一样的,不允许提交,要先更新.</p><p>a提交的时候版本变为1,b提交的时候,发现版本不一致就无法提交,要进行更新后提交.</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>什么是连接池,连接池的作用是什么,自定义连接池,开源的连接池?</p><p>那么什么是数据库连接池?</p><p>数据库连接池是Java程序和数据连接的中介媒介,以前一个Java程序对应一个连接,然后就可以连接到数据了,可以一旦多了呢?</p><p>就有人发明了数据库连接池,可以一下连接多个,但是是有限制的,一旦多了,就会扩容,额外增加3到5个,不会增幅太大,也有最大值的限制.</p><blockquote><p>数据库的连接对象 创建工作 比较消耗性能<br>一开始在内存中会开辟一块空间, 用于是 这个数据库连接池的空间, 可以在池子里放置很多个连接对象, 数据库连接池里有很多个连接对象, 后面需要连接的话会直接从池子里面去, 就不用自己去创建连接了, 因为数据库的连接对象创建工作是比较耗时的, 使用完, 数据库连接池中的 连接对象 ,是要进行归还的, 确保连接对象可以循环连接使用.</p></blockquote><blockquote><p>创建数据库的连接池</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 简单使用数据库连接池</span><br><span class="line">package com.dashucoding.util;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public class TestPool &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testPool() &#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line">MyDataSource dataSource = new MyDataSource();</span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = &quot;insert into account values (null, &apos;xilali&apos;, 10)&quot;;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">ps.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// 归还连接</span><br><span class="line">dataSource.addBack(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/11158618-ab552bda614279ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结构"></p><blockquote><p>自定义数据库连接池</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List &lt;Connection&gt; list = new ArrayList&lt;Connection&gt;();</span><br></pre></td></tr></table></figure><p>解决自定义数据库连接池问题</p><p>因为多了一个<code>addBack</code>方法,要记住这个方法,且不能用面向接口编程.修改<code>close</code>方法,改成不是关闭而是归还连接对象.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MyDataSource implements DataSource &#123;</span><br><span class="line"> // 创建连接池</span><br><span class="line">List&lt;Connection&gt; list = new ArrayList&lt;Connection&gt;();</span><br><span class="line"> public MyDataSource()&#123;</span><br><span class="line">  for(int i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">   Connection conn = JDBCUtil.getConn();</span><br><span class="line">   list.add(conn);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> @Override</span><br><span class="line"> public Connection getConnection() throws SQLException &#123;</span><br><span class="line">   if(list.size() == 0)&#123;</span><br><span class="line">     for(int i=0; i&lt;5; i++) &#123;</span><br><span class="line">      Connection conn = JDBCUtil.getConn();</span><br><span class="line">       list.add(conn);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Connection conn = list.remove(0);</span><br><span class="line">     return conn;</span><br><span class="line">  &#125;</span><br><span class="line">  // 用完后归还 </span><br><span class="line">  public void addBack(Connection conn)&#123;</span><br><span class="line">    list.add(conn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TestPool&#123;</span><br><span class="line"> @Test</span><br><span class="line">  public void testPool()&#123;</span><br><span class="line">   Connection conn = null;</span><br><span class="line">   PreparedStatement ps = null;</span><br><span class="line">   MyDataSource dataSource = new MyDataSource();</span><br><span class="line">  try &#123;</span><br><span class="line">   conn = dataSource.getConnection();</span><br><span class="line">   String sql = &quot;insert into account values(null, &apos;dashu&apos;, 10)&quot;;</span><br><span class="line">   ps = conn.prepareStatement(sql);</span><br><span class="line">   ps.executeUpdate();</span><br><span class="line"> </span><br><span class="line">   &#125;catch(SQLException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">   &#125;finally&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">    ps.close();</span><br><span class="line">    &#125;catch(SQLException e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    // 归还连接</span><br><span class="line">    dataSource.addBack(conn);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如何扩展方法</p></blockquote><p>装饰者模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.test;</span><br><span class="line"></span><br><span class="line">public interface Waiter &#123;</span><br><span class="line">void service();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.test;</span><br><span class="line"></span><br><span class="line">public class Waitress implements Waiter &#123;</span><br><span class="line">@Override</span><br><span class="line">public void service() &#123;</span><br><span class="line">System.out.println(&quot;在服务...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.test;</span><br><span class="line"></span><br><span class="line">public class MainTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Waiter waiter = new Waitress();</span><br><span class="line">waiter.service();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰者模式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.test;</span><br><span class="line"></span><br><span class="line">public class WaitressWrap implements Waiter &#123;</span><br><span class="line"></span><br><span class="line">Waiter watier = null;</span><br><span class="line">public WaitressWrap(Waiter watier) &#123;</span><br><span class="line">this.watier = watier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void service() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;微笑&quot;);</span><br><span class="line">watier.service();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.test;</span><br><span class="line"></span><br><span class="line">public class MainTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/*Waiter waiter = new Waitress();</span><br><span class="line">waiter.service();*/</span><br><span class="line">WaitressWrap waitressWrap = new WaitressWrap(new Waitress());</span><br><span class="line">waitressWrap.service();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Waiter -&gt; service()</span><br><span class="line"></span><br><span class="line">Waitress -&gt; service()</span><br><span class="line"></span><br><span class="line">WaitressWrap -&gt; service()</span><br><span class="line"></span><br><span class="line">Waiter waiter;</span><br><span class="line">public Waitress Wrap(Waiter waiter)&#123;</span><br><span class="line"> this.waiter = watier;</span><br><span class="line">&#125;</span><br><span class="line">void service()&#123;</span><br><span class="line"> syso</span><br><span class="line"> waiter.service();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>装饰者模式</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-1afb55e7867fc95e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结构"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-21b7e26bb44e8949.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.util;</span><br><span class="line"></span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.SQLFeatureNotSupportedException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">// 这是一个数据库连接池</span><br><span class="line">// 一开始 先往连接池放入10个连接</span><br><span class="line">public class MyDataSource implements DataSource&#123;</span><br><span class="line"></span><br><span class="line">// 创建连接池</span><br><span class="line">List&lt;Connection&gt; list = new ArrayList&lt;Connection&gt;();</span><br><span class="line">public MyDataSource() &#123;</span><br><span class="line">// 10个连接</span><br><span class="line">for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">Connection conn = JDBCUtil.getConn();</span><br><span class="line">list.add(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 该连接池对外公布的获取连接的方法</span><br><span class="line">@Override</span><br><span class="line">public Connection getConnection() throws SQLException &#123;</span><br><span class="line">// 来拿连接的时候,看看,池子里面有没有</span><br><span class="line">if(list.size() == 0) &#123;</span><br><span class="line">for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">Connection  conn = JDBCUtil.getConn();</span><br><span class="line">list.add(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">// 那一个 给连接 如果有10个,0,1,2,3,-&gt;10 这样给</span><br><span class="line">// 确保给</span><br><span class="line">// 移除就给了嘛</span><br><span class="line">// remove(0) -&gt; 移除第一个</span><br><span class="line">Connection conn = list.remove(0);</span><br><span class="line">// 把对象抛出去的时候,对这个对象进行包装</span><br><span class="line"></span><br><span class="line">Connection connection = new ConnectionWrap(conn,list);</span><br><span class="line"></span><br><span class="line">return connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用完后记得归还</span><br><span class="line">public void addBack(Connection conn) &#123;</span><br><span class="line">list.add(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public PrintWriter getLogWriter() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getLoginTimeout() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Logger getParentLogger() throws SQLFeatureNotSupportedException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setLogWriter(PrintWriter arg0) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setLoginTimeout(int arg0) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean isWrapperFor(Class&lt;?&gt; arg0) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T unwrap(Class&lt;T&gt; arg0) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Connection getConnection(String arg0, String arg1) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/11158618-c7889696705c734f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.util;</span><br><span class="line"></span><br><span class="line">import java.sql.Array;</span><br><span class="line">import java.sql.Blob;</span><br><span class="line">import java.sql.CallableStatement;</span><br><span class="line">import java.sql.Clob;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DatabaseMetaData;</span><br><span class="line">import java.sql.NClob;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLClientInfoException;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.SQLWarning;</span><br><span class="line">import java.sql.SQLXML;</span><br><span class="line">import java.sql.Savepoint;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.sql.Struct;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line">public class ConnectionWrap implements Connection&#123;</span><br><span class="line"></span><br><span class="line">Connection connection = null;</span><br><span class="line"></span><br><span class="line">List&lt;Connection&gt; list;</span><br><span class="line">public ConnectionWrap(Connection connection,List&lt;Connection&gt; list) &#123;</span><br><span class="line">super();</span><br><span class="line">this.connection = connection;</span><br><span class="line">this.list = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void close() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">//connection.close();</span><br><span class="line">System.out.println(&quot;有人归还连接对象了,归还之前&quot;+list.size());</span><br><span class="line">list.add(connection);</span><br><span class="line">System.out.println(&quot;有人归还连接对象了,归还之后&quot;+list.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public PreparedStatement prepareStatement(String sql) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return connection.prepareStatement(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void abort(Executor executor) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void clearWarnings() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void commit() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Array createArrayOf(String typeName, Object[] elements) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Blob createBlob() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Clob createClob() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public NClob createNClob() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SQLXML createSQLXML() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Statement createStatement() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)</span><br><span class="line">throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Struct createStruct(String typeName, Object[] attributes) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean getAutoCommit() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String getCatalog() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Properties getClientInfo() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String getClientInfo(String name) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getHoldability() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public DatabaseMetaData getMetaData() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getNetworkTimeout() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String getSchema() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int getTransactionIsolation() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Map&lt;String, Class&lt;?&gt;&gt; getTypeMap() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public SQLWarning getWarnings() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean isClosed() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean isReadOnly() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean isValid(int timeout) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String nativeSQL(String sql) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public CallableStatement prepareCall(String sql) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,</span><br><span class="line">int resultSetHoldability) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)</span><br><span class="line">throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,</span><br><span class="line">int resultSetHoldability) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void releaseSavepoint(Savepoint savepoint) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void rollback() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void rollback(Savepoint savepoint) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setAutoCommit(boolean autoCommit) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setCatalog(String catalog) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setClientInfo(Properties properties) throws SQLClientInfoException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setClientInfo(String name, String value) throws SQLClientInfoException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setHoldability(int holdability) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setReadOnly(boolean readOnly) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Savepoint setSavepoint() throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Savepoint setSavepoint(String name) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setSchema(String schema) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setTransactionIsolation(int level) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setTypeMap(Map&lt;String, Class&lt;?&gt;&gt; map) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/11158618-d5023746f361db32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-8078c5a665e3ccce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码"></p><blockquote><p>数据库连接池_DBCP</p></blockquote><p>DBCP开源连接池<br>C3P0,什么是C3P0,怎么用</p><p>DBCP为数据库连接池,是java数据库连接池的一种是Apache开发的,通过数据库连接池可以让程序自动管理数据库的连接.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataBase Connection Pool数据库连接池</span><br></pre></td></tr></table></figure><p>C3P0也是一种开源的连接池,实现了数据库和JNDI绑定,使用它的开源项目:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring, Hibernate</span><br></pre></td></tr></table></figure><blockquote><p>怎么用DBCP</p></blockquote><ol><li>导入jar包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commons-dbcp.jar</span><br><span class="line">commons-pool.jar</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不使用配置文件</span><br><span class="line">BasicDataSource dataSource = new BasicDataSource();</span><br><span class="line">dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">dataSource.setUrl(&quot;jdbc:mysql://loclhost/users&quot;);</span><br><span class="line">dataSource.setUsername(&quot;root&quot;);</span><br><span class="line">dataSource.setPassword(&quot;root&quot;);</span><br><span class="line"></span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line">String sql = &quot;select * from user&quot;;</span><br><span class="line">pstmt = conn.prepareStatement(sql);</span><br></pre></td></tr></table></figure><blockquote><p>DBCP连接数据库使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.dbcp;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbcp.BasicDataSource;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.dashucoding.util.JDBCUtil;</span><br><span class="line"></span><br><span class="line">// 这个连接池要连接数据库, 账号,密码</span><br><span class="line">public class DBCPDemo &#123;</span><br><span class="line">// ctrl + 2 f</span><br><span class="line">private Connection conn;</span><br><span class="line">private PreparedStatement ps;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testDBCP01()&#123;</span><br><span class="line">// 数据库的连接池, 作用创建和连接</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 构建数据源对象</span><br><span class="line">BasicDataSource dataSource = new BasicDataSource();</span><br><span class="line">// 连接什么数据库,用户名和密码</span><br><span class="line">dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">dataSource.setUrl(&quot;jdbc:mysql://localhost/bank&quot;);</span><br><span class="line">dataSource.setUsername(&quot;你的账户&quot;);</span><br><span class="line">dataSource.setPassword(&quot;你的密码&quot;);</span><br><span class="line"></span><br><span class="line">// 得到连接对象</span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = &quot;insert into account values(null, ?, ?)&quot;;</span><br><span class="line"></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">ps.setString(1, &quot;dashucoding&quot;);</span><br><span class="line">ps.setInt(2, 10000);</span><br><span class="line"></span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">JDBCUtil.release(conn, ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是不使用配置文件的情况.</p><blockquote><p>DBCP使用配置文件方式</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-5d7951abe03baa0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结构"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-36d98c1365978dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.dbcp;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbcp.BasicDataSource;</span><br><span class="line">import org.apache.commons.dbcp.BasicDataSourceFactory;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.dashucoding.util.JDBCUtil;</span><br><span class="line"></span><br><span class="line">public class DBCPDemo02 &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testDBCP02() &#123;</span><br><span class="line">/*BasicDataSource dataSource = new BasicDataSource();</span><br><span class="line">dataSource.setConnectionProperties(&quot;dbcpconfig.properties&quot;);*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line"></span><br><span class="line">// 数据库的连接池, 作用创建和连接</span><br><span class="line">try &#123;</span><br><span class="line">BasicDataSourceFactory factory = new BasicDataSourceFactory();</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">InputStream is = new FileInputStream(&quot;src//dbcpconfig.properties&quot;);</span><br><span class="line">properties.load(is);</span><br><span class="line">DataSource dataSource = factory.createDataSource(properties);</span><br><span class="line"></span><br><span class="line">// 得到连接对象</span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = &quot;insert into account values(null, ?, ?)&quot;;</span><br><span class="line"></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">ps.setString(1, &quot;liuliuliu&quot;);</span><br><span class="line">ps.setInt(2, 10000);</span><br><span class="line"></span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">JDBCUtil.release(conn, ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库连接池-C3P0"><a href="#数据库连接池-C3P0" class="headerlink" title="数据库连接池_C3P0"></a>数据库连接池_C3P0</h2><blockquote><p>不使用配置方式</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拷贝jar c3p0...jar</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Just put the jar file [lib/c3p0-0.9.1.2.jar] in your application&apos;s effective CLASSPATH</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ComboPooledDataSource cpds = new ComboPooledDataSource();</span><br><span class="line">cpds.setDriverClass( &quot;org.postgresql.Driver&quot; ); //loads the jdbc driver            </span><br><span class="line">cpds.setJdbcUrl( &quot;jdbc:postgresql://localhost/testdb&quot; );</span><br><span class="line">cpds.setUser(&quot;dbuser&quot;);                                  </span><br><span class="line">cpds.setPassword(&quot;dbpassword&quot;);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/11158618-4613be7b7ae6b406.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结构"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.c3p0;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbcp.BasicDataSource;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.dashucoding.util.JDBCUtil;</span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">public class C3P0Demo &#123;</span><br><span class="line">@Test</span><br><span class="line">public void testC3P0() &#123;</span><br><span class="line"></span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line">try &#123;</span><br><span class="line">// 创建dataSource</span><br><span class="line">ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);        </span><br><span class="line">dataSource.setJdbcUrl( &quot;jdbc:mysql://localhost/bank&quot; );</span><br><span class="line">dataSource.setUser(&quot;root&quot;);                                  </span><br><span class="line">dataSource.setPassword(&quot;admin&quot;);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 得到连接对象</span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = &quot;insert into account values(null, ?, ?)&quot;;</span><br><span class="line"></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">ps.setString(1, &quot;aaa&quot;);</span><br><span class="line">ps.setInt(2, 10000);</span><br><span class="line"></span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">JDBCUtil.release(conn, ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C3P0使用配置文件的方式</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-4f0bb33cbb0d382b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-d7050d50a84bb14f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-f05618d59e909ffc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><p><code>c3p0-config.xml file</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;c3p0-config&gt;</span><br><span class="line">  &lt;default-config&gt;</span><br><span class="line">    &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost/bank&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;user&quot;&gt;你的账户&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot;&gt;你的密码&lt;/property&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/default-config&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/c3p0-config&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/11158618-be73f8e8b3fdc4f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.c3p0;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.dashucoding.util.JDBCUtil;</span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line">// 使用配置文件</span><br><span class="line">public class C3P0Demo02 &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testC3P0() &#123;</span><br><span class="line"></span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement ps = null;</span><br><span class="line">try &#123;</span><br><span class="line">// 配置文件 new了一个对象</span><br><span class="line">ComboPooledDataSource dataSource = new ComboPooledDataSource(); </span><br><span class="line"></span><br><span class="line">// 得到连接对象</span><br><span class="line">conn = dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = &quot;insert into account values(null, ?, ?)&quot;;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setString(1, &quot;bbb&quot;);</span><br><span class="line">ps.setInt(2, 10000);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">JDBCUtil.release(conn, ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以弄oracle:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- This app is massive! --&gt;</span><br><span class="line">  &lt;named-config name=&quot;oracle&quot;&gt; </span><br><span class="line">    &lt;property name=&quot;acquireIncrement&quot;&gt;50&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;initialPoolSize&quot;&gt;100&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;minPoolSize&quot;&gt;50&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;maxPoolSize&quot;&gt;1000&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- intergalactoApp adopts a different approach to configuring statement caching --&gt;</span><br><span class="line">    &lt;property name=&quot;maxStatements&quot;&gt;0&lt;/property&gt; </span><br><span class="line">    &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- he&apos;s important, but there&apos;s only one of him --&gt;</span><br><span class="line">    &lt;user-overrides user=&quot;master-of-the-universe&quot;&gt; </span><br><span class="line">      &lt;property name=&quot;acquireIncrement&quot;&gt;1&lt;/property&gt;</span><br><span class="line">      &lt;property name=&quot;initialPoolSize&quot;&gt;1&lt;/property&gt;</span><br><span class="line">      &lt;property name=&quot;minPoolSize&quot;&gt;1&lt;/property&gt;</span><br><span class="line">      &lt;property name=&quot;maxPoolSize&quot;&gt;5&lt;/property&gt;</span><br><span class="line">      &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;50&lt;/property&gt;</span><br><span class="line">    &lt;/user-overrides&gt;</span><br><span class="line">  &lt;/named-config&gt;</span><br></pre></td></tr></table></figure><p><code>oracle</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br></pre></td></tr></table></figure><h2 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a><code>DBUtils</code></h2><p>什么是DBUtils呢?怎么用呢?</p><p>优化数据库连接,使用C3P0:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.util;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">public class JDBCUtil02 &#123;</span><br><span class="line"></span><br><span class="line">static ComboPooledDataSource dataSource = null;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">dataSource = new ComboPooledDataSource();</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 获取连接对象</span><br><span class="line"> * @return</span><br><span class="line"> * @throws SQLException </span><br><span class="line"> */</span><br><span class="line">public static Connection getConn() throws SQLException&#123;</span><br><span class="line"></span><br><span class="line">return dataSource.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 释放资源</span><br><span class="line"> * @param conn</span><br><span class="line"> * @param st</span><br><span class="line"> * @param rs</span><br><span class="line"> */</span><br><span class="line">public static void release(Connection conn , Statement st , ResultSet rs)&#123;</span><br><span class="line">closeRs(rs);</span><br><span class="line">closeSt(st);</span><br><span class="line">closeConn(conn);</span><br><span class="line">&#125;</span><br><span class="line">public static void release(Connection conn , Statement st)&#123;</span><br><span class="line">closeSt(st);</span><br><span class="line">closeConn(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void closeRs(ResultSet rs)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(rs != null)&#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">rs = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void closeSt(Statement st)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(st != null)&#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">st = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void closeConn(Connection conn)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">if(conn != null)&#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">conn = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DBUtils优化增删改查方法</p></blockquote><p>导包,两行代码交你增删改查,6666!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line">queryRunner.update(&quot;insert into account values(null, ?, ?)&quot;, &quot;bbb&quot;, 10000);</span><br></pre></td></tr></table></figure><p>两行.</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-46c9098f2b9ee519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-c8fa75e19f31660a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.dbutils;</span><br><span class="line"></span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">public class TestDBUtils &#123;</span><br><span class="line">@Test</span><br><span class="line">public void testInsert() throws SQLException &#123;</span><br><span class="line">//ComboPooledDataSource dataSource = new ComboPooledDataSource(); </span><br><span class="line"></span><br><span class="line">// dbutils 简化了CRUD的代码</span><br><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * queryRunner.update(sql);</span><br><span class="line"> * 增删改</span><br><span class="line"> * queryRunner.query(sql, rsh);</span><br><span class="line"> * 查</span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">queryRunner.update(&quot;insert into account values(null, ?, ?)&quot;, &quot;bbb&quot;, 10000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.dbutils;</span><br><span class="line"></span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">public class TestDBUtils &#123;</span><br><span class="line">@Test</span><br><span class="line">public void testInsert() throws SQLException &#123;</span><br><span class="line">//ComboPooledDataSource dataSource = new ComboPooledDataSource(); </span><br><span class="line"></span><br><span class="line">// dbutils 简化了CRUD的代码</span><br><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * queryRunner.update(sql);</span><br><span class="line"> * 增删改</span><br><span class="line"> * queryRunner.query(sql, rsh);</span><br><span class="line"> * 查</span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">queryRunner.update(&quot;insert into account values(null, ?, ?)&quot;, &quot;bbb&quot;, 10000);</span><br><span class="line">queryRunner.update(&quot;delete from account where id = ?&quot;, 8);</span><br><span class="line">queryRunner.update(&quot;update account set money = ? where id = ?&quot;, 0, 10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查询</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-7528888cd0b13a3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.dbutils;</span><br><span class="line"></span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.ResultSetHandler;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.dashucoding.domain.Account;</span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">public class TestDBUtils &#123;</span><br><span class="line">@Test</span><br><span class="line">public void testInsert() throws SQLException &#123;</span><br><span class="line">//ComboPooledDataSource dataSource = new ComboPooledDataSource(); </span><br><span class="line"></span><br><span class="line">// dbutils 简化了CRUD的代码</span><br><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line">// 查询的是一个Bean对象</span><br><span class="line">// new 匿名实现类-&gt;new接口的匿名实现类</span><br><span class="line"></span><br><span class="line">Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new ResultSetHandler&lt;Account&gt;() &#123;</span><br><span class="line">// 去执行查询,查询到的数据在result里面,然后调用handle方法,用户手动去封装</span><br><span class="line">@Override</span><br><span class="line">public Account handle(ResultSet rs) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">Account account = new Account();</span><br><span class="line"></span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">String name = rs.getString(&quot;name&quot;);</span><br><span class="line">int money = rs.getInt(&quot;money&quot;);</span><br><span class="line">account.setName(name);</span><br><span class="line">account.setMoney(money);</span><br><span class="line">&#125;</span><br><span class="line">return account;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1);</span><br><span class="line">System.out.println(account.toString());</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * queryRunner.update(sql);</span><br><span class="line"> * 增删改</span><br><span class="line"> * queryRunner.query(sql, rsh);</span><br><span class="line"> * 查</span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">/*queryRunner.update(&quot;insert into account values(null, ?, ?)&quot;, &quot;bbb&quot;, 10000);</span><br><span class="line">queryRunner.update(&quot;delete from account where id = ?&quot;, 8);</span><br><span class="line">queryRunner.update(&quot;update account set money = ? where id = ?&quot;, 0, 10);*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>查询优化</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-b3e7cdea9f4befed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><p>一个对象: BeanHandler<t></t></p><p>一个集合里面有很多对象: BeanListHandler<t></t></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.domain;</span><br><span class="line"></span><br><span class="line">public class Account &#123;</span><br><span class="line">private String name;</span><br><span class="line">private int money;</span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public int getMoney() &#123;</span><br><span class="line">return money;</span><br><span class="line">&#125;</span><br><span class="line">public void setMoney(int money) &#123;</span><br><span class="line">this.money = money;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Account [name=&quot; + name + &quot;, money=&quot; + money + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.dbutils;</span><br><span class="line"></span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.ResultSetHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.dashucoding.domain.Account;</span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">public class TestDBUtils &#123;</span><br><span class="line">@Test</span><br><span class="line">public void testInsert() throws SQLException &#123;</span><br><span class="line">//ComboPooledDataSource dataSource = new ComboPooledDataSource(); </span><br><span class="line"></span><br><span class="line">// dbutils 简化了CRUD的代码</span><br><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line">// 查询的是一个Bean对象</span><br><span class="line">// new 匿名实现类-&gt;new接口的匿名实现类</span><br><span class="line"></span><br><span class="line">/*Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new ResultSetHandler&lt;Account&gt;() &#123;</span><br><span class="line">// 去执行查询,查询到的数据在result里面,然后调用handle方法,用户手动去封装</span><br><span class="line">@Override</span><br><span class="line">public Account handle(ResultSet rs) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">Account account = new Account();</span><br><span class="line"></span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">String name = rs.getString(&quot;name&quot;);</span><br><span class="line">int money = rs.getInt(&quot;money&quot;);</span><br><span class="line">account.setName(name);</span><br><span class="line">account.setMoney(money);</span><br><span class="line">&#125;</span><br><span class="line">return account;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1);</span><br><span class="line">System.out.println(account.toString());*/</span><br><span class="line"></span><br><span class="line">// 接口的实现类-&gt; ResultSetHandler的实现类</span><br><span class="line">// Ctrl + t 实现类</span><br><span class="line">//ResultSetHandler</span><br><span class="line"></span><br><span class="line">// 一个对象查询一个对象使用BeanHandler</span><br><span class="line">Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class), 1);</span><br><span class="line">System.out.println(account.toString());</span><br><span class="line">/*</span><br><span class="line"> * queryRunner.update(sql);</span><br><span class="line"> * 增删改</span><br><span class="line"> * queryRunner.query(sql, rsh);</span><br><span class="line"> * 查</span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">/*queryRunner.update(&quot;insert into account values(null, ?, ?)&quot;, &quot;bbb&quot;, 10000);</span><br><span class="line">queryRunner.update(&quot;delete from account where id = ?&quot;, 8);</span><br><span class="line">queryRunner.update(&quot;update account set money = ? where id = ?&quot;, 0, 10);*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化成两行代码:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-716550bdcbdd7c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="贴图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class), 1);</span><br><span class="line">System.out.println(account.toString());</span><br></pre></td></tr></table></figure><blockquote><p>查询多个数据</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-5d4dfbddb425954e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查询多个对象</span><br><span class="line">List&lt;Account&gt; list = queryRunner.query(&quot;select * from account&quot;,</span><br><span class="line">new BeanListHandler&lt;Account&gt;(Account.class));</span><br><span class="line">for(Account account : list) &#123;</span><br><span class="line"> System.out.println(account.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">package com.dashucoding.dbutils;</span><br><span class="line"></span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line">import org.apache.commons.dbutils.ResultSetHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line">import org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import com.dashucoding.domain.Account;</span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">public class TestDBUtils &#123;</span><br><span class="line">@Test</span><br><span class="line">public void testInsert() throws SQLException &#123;</span><br><span class="line">//ComboPooledDataSource dataSource = new ComboPooledDataSource(); </span><br><span class="line"></span><br><span class="line">// dbutils 简化了CRUD的代码</span><br><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line">// 查询的是一个Bean对象</span><br><span class="line">// new 匿名实现类-&gt;new接口的匿名实现类</span><br><span class="line"></span><br><span class="line">/*Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new ResultSetHandler&lt;Account&gt;() &#123;</span><br><span class="line">// 去执行查询,查询到的数据在result里面,然后调用handle方法,用户手动去封装</span><br><span class="line">@Override</span><br><span class="line">public Account handle(ResultSet rs) throws SQLException &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">Account account = new Account();</span><br><span class="line"></span><br><span class="line">while(rs.next()) &#123;</span><br><span class="line">String name = rs.getString(&quot;name&quot;);</span><br><span class="line">int money = rs.getInt(&quot;money&quot;);</span><br><span class="line">account.setName(name);</span><br><span class="line">account.setMoney(money);</span><br><span class="line">&#125;</span><br><span class="line">return account;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, 1);</span><br><span class="line">System.out.println(account.toString());*/</span><br><span class="line"></span><br><span class="line">// 接口的实现类-&gt; ResultSetHandler的实现类</span><br><span class="line">// Ctrl + t 实现类</span><br><span class="line">//ResultSetHandler</span><br><span class="line"></span><br><span class="line">// 一个对象查询一个对象使用BeanHandler</span><br><span class="line">/*Account account = queryRunner.query(&quot;select * from account where id = ?&quot;,</span><br><span class="line">new BeanHandler&lt;Account&gt;(Account.class), 1);</span><br><span class="line">System.out.println(account.toString());*/</span><br><span class="line"></span><br><span class="line">/*List&lt;Account&gt; account = queryRunner.query(&quot;select * from account&quot;,</span><br><span class="line">new BeanListHandler&lt;Account&gt;(Account.class));*/</span><br><span class="line">// 查询多个对象</span><br><span class="line">List&lt;Account&gt; list = queryRunner.query(&quot;select * from account&quot;,</span><br><span class="line">new BeanListHandler&lt;Account&gt;(Account.class));</span><br><span class="line">for(Account account : list) &#123;</span><br><span class="line">System.out.println(account.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * queryRunner.update(sql);</span><br><span class="line"> * 增删改</span><br><span class="line"> * queryRunner.query(sql, rsh);</span><br><span class="line"> * 查</span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">/*queryRunner.update(&quot;insert into account values(null, ?, ?)&quot;, &quot;bbb&quot;, 10000);</span><br><span class="line">queryRunner.update(&quot;delete from account where id = ?&quot;, 8);</span><br><span class="line">queryRunner.update(&quot;update account set money = ? where id = ?&quot;, 0, 10);*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 通过类的字节码,获得该类的实例:</span><br><span class="line">Account a = new Account();</span><br><span class="line"></span><br><span class="line">Account a1 = Account.class.newInstance();</span><br><span class="line"></span><br><span class="line">new BeanHandler&lt;Account&gt;(Account.class)</span><br><span class="line"></span><br><span class="line">new BeanListHandler&lt;Account&gt;(Account.class)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/11158618-38c6f62adadcc132.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小结"></p><h2 id="ResultSetHandler-lt-T-gt"><a href="#ResultSetHandler-lt-T-gt" class="headerlink" title="ResultSetHandler&lt;T&gt;"></a><code>ResultSetHandler&lt;T&gt;</code></h2><p>实现类:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-eaeb4582c561c67b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="贴图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>事务,连接池,DBUtils</p></blockquote><p>查询:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-3156e9e65b334c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="贴图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());</span><br><span class="line"></span><br><span class="line">queryRunner.update();</span><br><span class="line">queryRunner.query</span><br></pre></td></tr></table></figure><ol><li>事务<br>脏读<br>不可重复读<br>幻读</li></ol><p>丢失更新 写的问题<br>悲观锁 for update<br>乐观锁 ,添加字段版本级别</p><p>4个隔离级别<br>读未提交<br>读已提交<br>可重复读<br>可串行化</p><p>读未提交,引发脏读<br>读已提交,引发不可重复读,解决了脏读</p><p>可重复读,引发了幻读,解决了脏读,不可重复读<br>可串行化(序列化),解决了脏读,不可重复读,幻读,引发效率低下问题</p><p>数据库连接池</p><ol><li>BCP -&gt; 不使用配置 使用配置</li><li>C3P0 -&gt; 不使用配置 使用配置</li><li>自定义连接池 -&gt; 饰者模式</li></ol><h2 id="结言"><a href="#结言" class="headerlink" title="结言"></a>结言</h2><p>可在评论发表你的总结内容,做功课哦!</p><p>如果看了觉得不错</p><p>点赞！转发！</p><blockquote><p>达叔小生：往后余生，唯独有你<br>You and me, we are family !<br>90后帅气小伙，良好的开发习惯；独立思考的能力；主动并且善于沟通<br>简书博客： 达叔小生<br><a href="https://www.jianshu.com/u/c785ece603d1" target="_blank" rel="noopener">https://www.jianshu.com/u/c785ece603d1</a></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul><li>下面我将继续对 其他知识 深入讲解 ，有兴趣可以继续关注</li><li>小礼物走一走 or 点赞</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/40.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-de1eea934cb6fb28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;标题图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="带你学会Java基础课程" scheme="https://huangguangda.github.io/categories/%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%BC%9AJava%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/"/>
    
    
      <category term="带你学会Java基础课程" scheme="https://huangguangda.github.io/tags/%E5%B8%A6%E4%BD%A0%E5%AD%A6%E4%BC%9AJava%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>公众号开发笔记一</title>
    <link href="https://huangguangda.github.io/2018/10/20/1/"/>
    <id>https://huangguangda.github.io/2018/10/20/1/</id>
    <published>2018-10-20T12:06:52.000Z</published>
    <updated>2018-10-25T12:14:44.332Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/11158618-0caa03f248842845.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标题图"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微信公众平台开发:</p><p>微信公众平台是提供资讯和服务的平台,其中公众平台开发的接口是提供服务的基础.</p><p>在公众平台网站创建公众号,获取接口权限,然后阅读微信公众平台技术文档进行开发.</p><p>用户识别,每个公众号都有对应的一个<code>OpenID</code>.移动应用包含个人以及企业级应用,如果有多个公众号和应用,那么绑定后有多个不同的<code>OpenID</code>,但对这些同一开放平台账号下只有一个<code>UnionID</code>.</p><p>了解<code>UnionID</code>,<strong>用户管理-获取用户基本信息（<code>UnionID</code>机制）文档</strong>,微信公众号开发为这些服务: <strong>移动应用、<code>PC</code>端网站、公众号第三方平台</strong>.</p><p>在申请到认证公众号之前,可以用测试号进行接口测试,<strong>在公众平台官网-开发者中心</strong>查看接口调式的频次.所有接口的调用都需要</p><p><code>access_token</code>为接口调用凭据,<br>且<code>access_token</code>为接口调用凭据在2小时内有效.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取`access_token`有调用接口凭据的文档.</span><br><span class="line">注意:调用接口支持的端口为`80`端口.</span><br></pre></td></tr></table></figure><p>公众号最多的服务看到的是:<strong>公众号消息会话和公众号内网页</strong>,公众号消息会话有:<strong>群发消息(订阅号每天1次，服务号每月4次),被动回复消息,客服消息(微信推送消息与事件说明文档),模板消息(主动向用户发送消息)</strong>,</p><p>被动回复:</p><blockquote><p>文本消息,图片消息,语音消息,视频消息,音乐消息,图文消息</p></blockquote><p>公众号内网页:<strong>网页授权获取用户基本信息(OpenID的获取不用用户同意,获取用户的基本信息就要用户同意),微信JS-SDK(通过JavaScript使用微信原生功能)</strong>,</p><hr><p>开发者规范:</p><blockquote><p>接口的规范限制,调用频率限制,模版消息,用户数据使用规范</p></blockquote><p>用户数据的保护,要明确用户的同意,保证用户的知情权,要保护收集后的数据,不得将用户的数据用在别处,如果腾讯停止了你使用本服务,将要将其收集的数据进行删除.</p><p>公众号接口权限说明:</p><p><strong>微信认证分为<code>资质认证</code>和<code>名称认证</code></strong>,只有认证了才可以获得特有接口.</p><p><strong>订阅号:</strong></p><p>未认证订阅号:获取<code>access_token</code>,获取微信服务器IP地址,接收消息,发送消息-被动回复消息,微信JS-SDK-基础接口,分享接口,图像接口,音频接口,智能接口,设备信息,地理位置,界面操作,微信扫一扫</p><p>微信认证订阅号:获取<code>access_token</code>,获取微信服务器IP地址,接收消息,发送消息-被动回复消息,客服接口,群发接口,模板消息接口,一次性订阅消息接口,用户分组管理,设置用户备注名,获取用户基本信息,获取用户列表,界面丰富-自定义菜单,素材管理-素材管理接口,微信卡券接口-需申请,微信发票接口,微信JS-SDK-基础接口,分享接口,图像接口,音频接口,智能接口,设备信息,地理位置,界面操作,微信扫一扫,微信卡券</p><p><strong>服务号:</strong></p><p>未认证服务号:获取<code>access_token</code>,获取微信服务器IP地址,接收消息,发送消息-被动回复消息,界面丰富-自定义菜单,微信JS-SDK-基础接口,图像接口,音频接口,智能接口,设备信息,地理位置,界面操作,微信扫一扫</p><p>微信认证服务号:啥多有,有的申请就有</p><blockquote><p>全局返回码说明</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-8b4591e8e7fbaa6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-df1db604a7046b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-2783685ee4404e77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-01559526dc7fcef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-9e72d4b3762ddbc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-2f21145231a7016c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图6"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-a068c0adbb060626.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图7"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-6a6e9b3636356774.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图8"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-beb550c8308e5462.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9"></p><hr><p>入门指引:</p><p>开发微信公众号开发者模式,申请服务器,搭建服务,申请公众号,开发者基本配置,重要事情提前交代</p><p>实现你问我答,接受文本消息,被动回复文本消息,回复<code>success</code>问题,流程图,码代码,在线测试,真实体验</p><p>实现图尚往来,接收图片消息,被动回复图片消息,流程图,码代码</p><p><code>access token</code>,查看<code>appid</code>以及<code>appsecret</code>,获取<code>access token</code>,临时方法获取,接口获取,码代码</p><p>临时素材,新建临时素材,获取临时素材<code>MedialD</code>,下载临时素材,手工体验,接口实现</p><p>永久素材,新建永久素材的方式,手工体验,接口实现,获取永久素材<code>MedialD</code>,获取素材列表,删除永久素材</p><p>自定义菜单,创建菜单界面,完善菜单功能,流程图,码代码,体验,关于反馈问题</p><blockquote><p>开启公众号开发者模式</p></blockquote><p>wiki （多人协作的写作系统）,对接口存在的疑问,直接呼叫客服或者微信投诉.</p><h4 id="申请服务器"><a href="#申请服务器" class="headerlink" title="申请服务器:"></a>申请服务器:</h4><p><code>https://buy.cloud.tencent.com/cvm?tab=lite&amp;loginSet=SET_PASSWORD</code></p><h4 id="搭建服务"><a href="#搭建服务" class="headerlink" title="搭建服务"></a>搭建服务</h4><p>安装<code>python2.7</code>版本以上: <code>https://www.python.org/</code><br>安装<code>web.py</code><br>安装<code>libxml2, libxslt, lxml python</code></p><p><code>python</code>文档: <code>https://docs.python.org/2/</code></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-f1323397df9def07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图10"></p><p><code>webpy.org</code>文档: <code>http://webpy.org/</code></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-16ce00c28d01cba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图11"></p><h4 id="申请公众号跳过"><a href="#申请公众号跳过" class="headerlink" title="申请公众号跳过"></a>申请公众号跳过</h4><h4 id="开发者基本配置"><a href="#开发者基本配置" class="headerlink" title="开发者基本配置"></a>开发者基本配置</h4><p>找到“基本配置”菜单栏</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-b93b60605a60adf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图12"></p><p>填写配置:</p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-ba8d3cfb5bd9e8c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图13"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-6cb9a639afc74970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图14"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-dcd5bbcff58fb7b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图15"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-a3f971cf44c12bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图16"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-07e78ff6ca13a0ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图17"></p><hr><h4 id="在线测试"><a href="#在线测试" class="headerlink" title="在线测试"></a>在线测试</h4><p>微信公众平台接口调试工具:</p><p><code>https://mp.weixin.qq.com/debug/</code></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-3c2e22df2e73cc25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图18"></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-8ff254b284d311e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图19"></p><h4 id="AccessToken"><a href="#AccessToken" class="headerlink" title="AccessToken"></a>AccessToken</h4><p>基本配置中: <strong>查看<code>appid</code>(应用<code>ID</code>)及<code>appsecret</code>(应用密钥)</strong>,获取<code>accessToken</code></p><p>微信公众平台接口调试工具: <code>https://mp.weixin.qq.com/debug/</code></p><p>手动到浏览器中查看<code>AccessToken</code>:</p><p><code>https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=###&amp;secret=###</code></p><h4 id="接口的获取需要"><a href="#接口的获取需要" class="headerlink" title="接口的获取需要"></a>接口的获取需要</h4><p>第三方需要: <code>access_token</code></p><p><img src="https://upload-images.jianshu.io/upload_images/11158618-8998074dd08548c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图20"></p><h4 id="关于反馈问题"><a href="#关于反馈问题" class="headerlink" title="关于反馈问题"></a>关于反馈问题</h4><p>请求腾讯客服,微信团队的帮助,提供<code>appid</code></p><hr><blockquote><p>接入指南 <code>https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421135319</code></p></blockquote><ol><li>进行填写服务器配置</li><li>验证服务器地址的有效性</li><li>根据接口文档实现业务逻辑</li></ol><p>公众平台官网开发中的<strong>基本设置页面</strong>,成为开发者,点击修改配置按钮,</p><p><strong>消息加密代码</strong>: </p><p><code>https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419318479&amp;token=&amp;lang=zh_CN</code></p><p>进行配置完信息后,微信服务器会以<code>GET</code>请求发送参数到<code>URL</code>上,有: <code>signature</code>(微信加密签名), <code>timestamp</code>(时间戳), <code>nonce</code>(随机数), <code>echostr</code>(随机字符串).</p><p>随机字符串参数返回,如果验证成功就成为开发者,随机字符串就如验证码? 加密/校验: <code>token、timestamp、nonce</code>三个参数,拼接成一个字符串,进行<code>signature</code>对比.(有PHP示例代码)</p><p>验证<code>URL</code>后,成为有效开发者.有时候<strong>移动应用、网站、公众帐号</strong>共用账号,微信开放平台（<a href="http://open.weixin.qq.com/" target="_blank" rel="noopener">open.weixin.qq.com</a>）提供了<code>UnionID</code>机制.只有被绑定到微信开发平台账号才有,<code>UnionID</code>是唯一的.</p><p><strong>微信开放平台的资源中心–&gt;移动应用开发–&gt;微信登录–&gt;授权关系接口调用指引–&gt;获取用户个人信息（UnionID机制）</strong></p><blockquote><p>接口域名说明: <code>https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1465199793_BqlKA</code></p></blockquote><blockquote><p>获取<code>access_token</code></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/11158618-6f94a85e3d768f2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图21"></p><h4 id="接口测试号申请-https-mp-weixin-qq-com-debug-cgi-bin-sandbox-t-sandbox-login"><a href="#接口测试号申请-https-mp-weixin-qq-com-debug-cgi-bin-sandbox-t-sandbox-login" class="headerlink" title="接口测试号申请: https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login"></a>接口测试号申请: <code>https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</code></h4><h4 id="报警排查指引-https-mp-weixin-qq-com-wiki-t-resource-res-main-amp-id-mp1433747358"><a href="#报警排查指引-https-mp-weixin-qq-com-wiki-t-resource-res-main-amp-id-mp1433747358" class="headerlink" title="报警排查指引: https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433747358"></a>报警排查指引: <code>https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433747358</code></h4><h4 id="常见问题论坛-https-developers-weixin-qq-com"><a href="#常见问题论坛-https-developers-weixin-qq-com" class="headerlink" title="常见问题论坛: https://developers.weixin.qq.com/"></a>常见问题论坛: <code>https://developers.weixin.qq.com/</code></h4><blockquote><p>微信开放平台文档</p></blockquote><p><code>https://open.weixin.qq.com/</code></p><blockquote><p>往后余生，唯独有你<br>简书作者：达叔小生<br>90后帅气小伙，良好的开发习惯；独立思考的能力；主动并且善于沟通<br>简书博客： <a href="https://www.jianshu.com/u/c785ece603d1" target="_blank" rel="noopener">https://www.jianshu.com/u/c785ece603d1</a></p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul><li>下面我将继续对 其他知识 深入讲解 ，有兴趣可以继续关注</li><li>小礼物走一走 or 点赞</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11158618-0caa03f248842845.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;标题图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="微信公众号开发" scheme="https://huangguangda.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信公众号开发" scheme="https://huangguangda.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>腾讯智慧校园开发平台</title>
    <link href="https://huangguangda.github.io/2018/10/19/1/"/>
    <id>https://huangguangda.github.io/2018/10/19/1/</id>
    <published>2018-10-19T01:42:25.000Z</published>
    <updated>2018-10-19T01:43:27.027Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯智慧校园开发平台</p><a id="more"></a><h2 id="腾讯智慧校园开发平台"><a href="#腾讯智慧校园开发平台" class="headerlink" title="腾讯智慧校园开发平台"></a>腾讯智慧校园开发平台</h2><p><strong>优势:</strong></p><ol><li>智慧校园联合登录</li><li>身份角色同一</li><li>消息推送</li></ol><p><strong>智慧校园接入流程:</strong></p><ol><li>创建应用: 填写网站名称,简介和图标,官网地址等信息</li><li>开发应用:</li><li>提交审核:</li><li>审核通过上线:</li></ol><h2 id="第三方应用使用指引"><a href="#第三方应用使用指引" class="headerlink" title="第三方应用使用指引"></a>第三方应用使用指引</h2><p><strong>第三方应用？</strong></p><ol><li>在“应用管理”-&gt; “本校应用”中看到。</li><li>在“应用管理”-&gt; “第三方应用”-&gt;“应用市场”中找到</li></ol><p><strong>安装后如何使用第三方应用？</strong></p><p>使用其PC管理功能，及移动端功能。</p><ol><li>使用PC管理功能<br>点击图标 -&gt; 进入应用PC管理页面</li><li>使用移动端功能<br>(1) 独立应用<br>可直接进入使用<br>(2) 普通应用<br>配置方法：登录学校后台 -&gt; 左侧菜单“应用管理” -&gt; 在“本校应用”或“第三方应用”下找到应用图标 -&gt; 点击图标右上角小齿轮 -&gt; 进入“应用基本信息”页 -&gt; 找到“移动端配置”</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>OpenAPI调用相关问题</strong></p><blockquote><p>请完整的阅读每篇文档，特别注意必传字段及字段格式和说明</p></blockquote><ol><li>使用开放平台后台”API测试工具”</li><li>对照文档中的代码Demo</li></ol><p><strong>反馈时提供信息</strong></p><ol><li>完整的请求url，包括get参数。</li><li>post的数据。</li><li>返回的code与msg。</li><li>sign签名所用的密钥key。</li><li>提供bug的发生时间，至少要以小时为单位（年-月-日-小时），当然越具体越容易查明问题。</li></ol><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul><li>应用接入指引【重要】</li><li>开放API说明【重要】</li></ul><p><strong>使用哪种方式调用API？</strong> ?–&gt;</p><p>1) 使用开发者方式<br>2) 使用应用（openAppID）方式</p><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p>1) 使用开发者方式<br>1.1) 学校或上级单位自己开发：<br>1.2) 以开发者身份，替学校/上级单位开发：<br>调用方式为devCode+devType+keyId，<br>其中keyId和密钥key需要找学校/上级单位创建者索要</p><h2 id="【开发流程】"><a href="#【开发流程】" class="headerlink" title="【开发流程】"></a>【开发流程】</h2><p>获取devCode、devType、密钥key，用于生成后续的sign签名</p><p>开发者类型:学校/上级单位/合作伙伴/开发者，通过创建应用开发</p><p>调用API时，开发者信息、sign签名密钥获取方式：<br>调用方式:</p><p>openAppID<br>开放平台后台==》应用管理==》查看详情==》AppID、AppSecret</p><h2 id="签名生成的步骤"><a href="#签名生成的步骤" class="headerlink" title="签名生成的步骤"></a>签名生成的步骤</h2><p>第一步：</p><p>设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA。<br>特别注意以下重要规则：</p><p>参数名按ASCII码从小到大排序（字典序）；<br>如果参数的值为空不参与传参和签名；<br>参数名区分大小写；<br>get 和 post 参数均参与签名（注意：签名时不要对 get 和 post 的参数进行urlencode）；<br>sign 参数不参与签名；<br>根据HTTP协议要求，传递参数的值中如果存在特殊字符（如：&amp;、@等），那么该值需要做URL Encoding，这样请求接收方才能接收到正确的参数值。这种情况下，待签名数据应该是原始值而不是encoding之后的值。例如：调用某接口需要对请求参数email进行数字签名，那么待签名数据应该是<a href="mailto:email=test@msn.com" target="_blank" rel="noopener">email=test@msn.com</a>，而不是email=test%40msn.com。</p><p>第二步</p><p>在stringA最后拼接上“&amp;key=AppSecret”得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值。</p><p>第三步：</p><p>拼接sign签名，得到最终请求字符串。</p><h2 id="签名算法示例"><a href="#签名算法示例" class="headerlink" title="签名算法示例"></a>签名算法示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;openAppID&quot;:&quot;597882146416&quot;,</span><br><span class="line">    &quot;objectid&quot;:1,</span><br><span class="line">    &quot;objType&quot;:2,</span><br><span class="line">    &quot;userid&quot;:1661,</span><br><span class="line">    &quot;timestamp&quot;:1442401156,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;id&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;张三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对参数按照key=value的格式，并按照参数名ASCII字典序排序如下：</span><br><span class="line">$stringA=&quot;data[id]=1&amp;data[name]=张三&amp;objType=2&amp;objectid=1&amp;openAppID=597882146416&amp;timestamp=1442401156&amp;userid=YmvhAU762R0done&quot;;</span><br></pre></td></tr></table></figure></p><p>第二步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拼接API密钥，md5加密并转成大写，生成sign：</span><br><span class="line">$stringSignTemp=&quot;stringA&amp;key=testtoken123456&quot;</span><br><span class="line">$sign = strtoupper(md5($stringSignTemp));</span><br><span class="line">即$sign为：&quot;5F9F67A5635592A132BA935D44B25D40&quot;</span><br></pre></td></tr></table></figure></p><p>第三步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对请求的数据拼接sign签名：</span><br><span class="line">$param = $stringA . &apos;&amp;sign=5F9F67A5635592A132BA935D44B25D40;</span><br></pre></td></tr></table></figure></p><p>最终请求如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://open.campus.qq.com/api/OpenApi/getUserInfo?timestamp=1442401156&amp;data[id]=1&amp;data[name]=张三&amp;objType=2&amp;objectid=1&amp;openAppID=597882146416&amp;userid=1661&amp;</span><br><span class="line">sign=5F9F67A5635592A132BA935D44B25D40</span><br></pre></td></tr></table></figure></p><p>最终请求如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://open.campus.qq.com/api/OpenApi/getUserInfo?timestamp=1442401156&amp;data[id]=1&amp;data[name]=张三&amp;objType=2&amp;objectid=1&amp;openAppID=597882146416&amp;userid=1661&amp;</span><br><span class="line">sign=5F9F67A5635592A132BA935D44B25D40</span><br></pre></td></tr></table></figure></p><blockquote><p>【注意】</p></blockquote><p>密钥key仅作加密使用，为了保证数据安全请不要在请求参数中传递，并对密钥key进行保密。</p><h2 id="校验签名正确性"><a href="#校验签名正确性" class="headerlink" title="校验签名正确性"></a>校验签名正确性</h2><p>签名校验工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=20_1</span><br></pre></td></tr></table></figure></p><p>校验方式：选择“deeplink”或“自定义参数”<br>PS.校验不通过那个提示不用管，只要对比自己代码生成的sign签名，与工具所生成的sign签名是否一致即可</p><h3 id="【开发流程】-1"><a href="#【开发流程】-1" class="headerlink" title="【开发流程】"></a>【开发流程】</h3><p>获取devCode、devType、密钥key，用于生成后续的sign签名，详见签名参数sign生成说明</p><p>==》获取objectid、objType、userid<br>测试id详见开放平台后台-&gt;测试工具-&gt;沙盒测试环境-&gt;沙盒学校objectid</p><p>正式id详见签名参数sign生成说明、应用管理后台接入、应用H5前台接入</p><p>==》查看公共参数文档，详见API公共参数说明</p><p>==》查看API接口文档</p><p>==》根据接口参数，生成和拼接sign签名，详见签名参数sign生成说明</p><p>==》调用接口</p><p>==》调试接口<br>若接口报错，请参照以下顺序排查：<br>仔细阅读接口文档，特别是必传参数及参数格式<br>使用开放平台后台“API测试工具”，进行排查<br>对照文档中的Demo代码<br>若报签名错误，对照签名参数sign生成说明文档和文档中的“签名校验工具”</p><p>2) 使用应用（需创建应用，openAppID）</p><p>【开发流程】</p><p>登录到开放平台后台（open.campus.qq.com）</p><p>==》创建应用</p><p>==》查看应用详情，获取AppID、AppSecret、H5Secret，用于生成后续的sign签名</p><p>==》获取objectid、objType、userid<br>应用上线前，只能使用测试id，获取方式为：开放平台后台-&gt;测试工具-&gt;沙盒测试环境-&gt;沙盒学校objectid</p><p>应用上线后，正式id的获取方式，详见签名参数sign生成说明、应用管理后台接入、应用H5前台接入</p><p>==》查看公共参数文档，详见API公共参数说明</p><p>==》查看API接口文档</p><p>==》根据接口参数，生成和拼接sign签名，详见签名参数sign生成说明</p><p>==》调用接口</p><p>==》调试接口</p><p>==》沙盒测试环境，测试应用</p><p>==》测试应用无误后，申请上线</p><p>==》一般情况下，腾讯智慧校园会在3个工作日内，审核应用</p><p>==》应用审核通过后，学校/上级单位在PC后台-&gt;应用管理-&gt;第三方应用中，安装应用</p><p>==》学校/上级单位，在PC或移动端使用应用时，会将objectid、objType、userid等参数，以url参数追加的形式传递到第三方应用的url中</p><h2 id="【公共参数及签名密钥相关】"><a href="#【公共参数及签名密钥相关】" class="headerlink" title="【公共参数及签名密钥相关】"></a>【公共参数及签名密钥相关】</h2><ol><li>都有哪些公共参数？</li></ol><p>详见文档：开放API调用说明==》API公共参数说明</p><ol start="2"><li>什么是objectid、objType、userid，如何获取它们？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="3"><li>什么是openAppID、AppSecret、H5Secret，如何获取它们？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="4"><li>什么是devCode、devType、授权密钥、授权密钥ID，如何获取它们？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="5"><li>如何生成和校验sign签名？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明，以及文档中的“签名校验工具”</p><h2 id="【OpenAPI调用方式相关】"><a href="#【OpenAPI调用方式相关】" class="headerlink" title="【OpenAPI调用方式相关】"></a>【OpenAPI调用方式相关】</h2><ol><li>API调用说明？</li></ol><p>详见文档：开放API调用说明==》API调用说明</p><ol start="2"><li>post请求参数demo？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="3"><li>OpenAPI调用代码demo？</li></ol><p>详见文档：开放API调用说明==》Demo下载</p><h2 id="【OpenAPI调用出错相关】"><a href="#【OpenAPI调用出错相关】" class="headerlink" title="【OpenAPI调用出错相关】"></a>【OpenAPI调用出错相关】</h2><ol><li>业务错误码及说明</li></ol><p>详见文档：开放API调用说明==》业务错误码</p><ol start="2"><li>接口返回“1018 密钥不存在“或”1010 AppID或密钥不正确”</li></ol><p>请核对devCode、devType、密钥是否匹配，获取方式详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="3"><li>接口返回“1011 参数错误，请检查必传参数及类型”</li></ol><p>请核对是否传了公共参数，并确认post格式是正确的，注意post数据为数组格式</p><p>详见文档：</p><p>开放API调用说明==》API调用说明</p><p>开放API调用说明==》签名参数sign生成说明</p><p>开放API调用说明==》API公共参数说明</p><p>开放API调用说明==》Demo下载</p><ol start="4"><li>接口返回“1002 签名错误”</li></ol><p>详见文档：</p><p>开放API调用说明==》签名参数sign生成说明，以及文档中的“签名校验工具”</p><p>请仔细对照工具中的每个步骤，看看是哪一步不一致。</p><ol start="5"><li>调用发消息接口时，接口返回“1013 该学校/上级单位尚未安装此AppID应用”</li></ol><p>只有学校/上级单位创建者，在PC后台==》应用管理==》第三方应用中，安装了开发者提供的第三方应用，才能调用发消息接口，进行发消息。</p><h2 id="应用接入流程"><a href="#应用接入流程" class="headerlink" title="应用接入流程"></a>应用接入流程</h2><ol><li>简要介绍</li></ol><p>腾讯智慧校园通过开放平台来满足学校/上级单位的定制化开发需求。 学校/上级单位/合作伙伴可在开放平台创建应用、开发调试、提交审核。应用上线后，学校/上级单位可安装使用。</p><p>第三方开发者也可通过智慧校园开放平台创建并提交第三方应用，供所有学校/上级单位使用。</p><ol start="2"><li>应用类型</li></ol><p>腾讯智慧校园开放平台期待各种富于创新、安全稳定，符合校园5大使用场景的应用，包括：</p><p>（1）校内管理类应用</p><p>（2）学生学习类应用</p><p>（3）家校互动类应用</p><p>（4）移动办公类应用</p><p>（5）校园生活类应用</p><ol start="3"><li>如何创建应用</li></ol><p>（1）学校/上级单位：已加入腾讯智慧校园的学校/上级单位，将自动为其开通开放平台权限。学校超级管理员可直接登录到开放平台，创建并申请应用上线</p><p>（2）合作伙伴：签约的合作伙伴，将自动为其开通开放平台权限。合作伙伴管理员可直接登录到开放平台，创建并申请应用上线</p><p>（3）第三方公司/组织单位：需要先申请开发者资质，资质审核通过后，可登录开放平台，创建并申请应用上线。</p><ol start="4"><li>如何开发调试</li></ol><p>（1）应用程序开发</p><p>开发者可以在本地机器上进行应用程序的开发，实现业务逻辑。同时腾讯智慧校园开放平台开放了许多API，建议开发者先阅读API文档，了解不同场景下有哪些API可以调用。</p><p>（2）测试和联调</p><p>腾讯智慧校园开放平台提供的测试工具包含：沙盒学校测试环境、OpenAPI联调工具。详细信息请登录开放平台后查看“测试工具”。</p><ol start="5"><li>如何部署应用</li></ol><p>需要将应用部署在开发者自己的服务器上，因此需要自己准备服务器、域名等，并进行应用部署和测试。腾讯智慧校园暂不为该过程提供技术支持。</p><ol start="6"><li>上线规范</li></ol><p>为确保接入腾讯智慧校园开放平台应用的质量、提高后续运营服务的稳定性，上线前，请开发者按照接入规范对应用进行仔细检查及测试，对于不符合规范项进行修改。详见应用接入规范</p><ol start="7"><li>应用审核</li></ol><p>应用提交后，腾讯智慧校园将在5个工作日内对应用进行审核。审核中无法修改应用信息。审核通过后，应用将自动上线。</p><ol start="8"><li>应用管理</li></ol><p>开发者登录到腾讯智慧校园开放平台后，可以进入到管理中心统一管理应用，管理中心功能主要：</p><p>（1）服务所有开发者；</p><p>（2）服务于应用全生命周期；</p><p>（3）提供依据用户权限的功能；</p><p>（4）具备足够的帮助指引，可以由开发者自助使用。</p><p>详见管理中心使用说明</p><ol start="9"><li>应用安装及使用</li></ol><p>应用上线后，学校/上级单位可按如下步骤安装应用：</p><p>登录学校管理后台 -&gt; 点击“应用管理”右侧的设置按钮 -&gt; 选择“全部应用” -&gt; 点击要安装的应用icon -&gt; 进入安装页面，安装指引进行安装</p><p>安装成功后，使用方式如下：</p><p>若为独立应用：安装成功后应用将自动出现在菜单栏。可在学校管理后台访问其PC管理后台页面，可在微信企业号内使用其移动端功能。<br>若为普通应用：安装成功后需手动配置其移动端地址。可在“应用管理-&gt;我的应用”中访问其PC管理后台页面，可在配置的应用菜单处使用其移动端功能。</p><h2 id="开发api说明"><a href="#开发api说明" class="headerlink" title="开发api说明"></a>开发api说明</h2><ol><li>PC管理后台、H5前台登录态打通</li></ol><p>学校在管理后台【应用市场】安装了开发者的应用后，可以在学校后台【我的应用】==》【应用管理】中，对应用进行管理。</p><p>同时，学校可以将开发者所提供的H5 url粘贴到企业号应用菜单，或应用的H5页面中。</p><p>关于“PC管理后台应用管理登录态打通方案”，请参见“应用管理后台接入”小节。</p><p>关于“H5页面登录态打通方案”，请参见“应用H5前台接入”小节。</p><ol start="2"><li>通过“API列表”中的接口，获取学校/上级单位信息</li></ol><p>在获取登录态的同时，可以获取到学校ID/上级单位ID、用户ID等信息。</p><p>当开发者获取到学校ID、用户ID后，可以调用“API接口列表”中的接口，进一步获取学校/上级单位信息。</p><p>哪些学校和用户可以使用该应用，由【应用详情】中的“使用范围”和“适用人群”决定。开发者只能获取这部分人的信息。</p><h2 id="API调用说明"><a href="#API调用说明" class="headerlink" title="API调用说明"></a>API调用说明</h2><p>1.开发者调用腾讯智慧校园API时，需使用Https协议、UTF8编码，访问域名为<a href="https://open.campus.qq.com" target="_blank" rel="noopener">https://open.campus.qq.com</a> 数据包不需要加密。<br>注：原有域名<a href="https://m.campus.qq.com" target="_blank" rel="noopener">https://m.campus.qq.com</a> 仍可正常使用，但不会再进行功能的升级和维护，并将于2018年底下线。</p><p>2.请求接口的数据为数组格式。</p><p>3.接口返回的数据为json格式。其中GET接口可以通过传入callback参数，兼容jsonp格式。</p><p>4.接口安全校验采用sign签名的方式，sign由密钥key生成（key为第三方应用AppSecret），sign参数的生成算法详见“签名参数sign生成说明”小节。</p><p>5.合作伙伴、第三方开发者通过在开放平台建立第三方应用的方式，使用openAppID（第三方应用ID）+AppSecret（第三方应用密钥）进行开发。</p><p>openAppID、AppSecret的获取方式：开放平台后台：应用管理==》应用详情，openAppID对应AppID</p><p>注意：应用AppSecret仅作加密生成sign签名使用，为了保证数据安全请不要在请求参数中传递，并对应用AppSecret进行严格保密。因自行泄漏密钥导致的数据安全问题，需要自行承担。</p><p>6.在每次调用智慧校园接口时都需要带上openAppID、objectid、objType、timestamp、sign参数。各参数具体含义及获取方式，详见“API公共参数说明”小节</p><p>7.在开发者调用API接口时，腾讯智慧校园会对签名和时间戳进行验证： 腾讯智慧校园会使用同样的sign签名算法判断接收到的sign与计算的签名是否一致，来验证请求来源的合法性；另外，接收到请求时会判断当前时间戳与接收到的timestamp参数是否在一个合理的范围，相差5分钟内才合法，以防止重放攻击。</p><h2 id="API公共参数说明"><a href="#API公共参数说明" class="headerlink" title="API公共参数说明"></a>API公共参数说明</h2><p>“API接口列表”中有一些请求参数是通用的，在此做以下统一说明：</p><p>数据id，如objectid、userid、departid等，最大长度为50位</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯智慧校园开发平台&lt;/p&gt;
    
    </summary>
    
      <category term="腾讯智慧校园开发平台" scheme="https://huangguangda.github.io/categories/%E8%85%BE%E8%AE%AF%E6%99%BA%E6%85%A7%E6%A0%A1%E5%9B%AD%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="腾讯智慧校园开发平台" scheme="https://huangguangda.github.io/tags/%E8%85%BE%E8%AE%AF%E6%99%BA%E6%85%A7%E6%A0%A1%E5%9B%AD%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发</title>
    <link href="https://huangguangda.github.io/2018/10/18/1/"/>
    <id>https://huangguangda.github.io/2018/10/18/1/</id>
    <published>2018-10-18T01:45:49.000Z</published>
    <updated>2018-10-18T01:47:06.467Z</updated>
    
    <content type="html"><![CDATA[<p>微信公众号开发</p><a id="more"></a><h1 id="微信公众号开发"><a href="#微信公众号开发" class="headerlink" title="微信公众号开发"></a>微信公众号开发</h1><hr><p>request用于网络请求,它是对原生的http request的封装.</p><p>微信的数据包装方式是xml,所以我们要借助ejs这个模板库,把数据作为变量替换到xml字符汇中</p><p>还有一些工具模板:</p><p>lodash是一些常用的方法集,做数组拆分,类型判断等等.Heredoc是一个黑科技,把函数体里面的多行的注解作为字符串提取出来主要用来降低拼接字符串的成本</p><p>raw-body用来获取一个http请求返回的可读流的内容实体.</p><p>sha1进行加密.</p><p>微信服务器返回的数据是xml格式,无法用js函数直接使用,所以要xml2js这个模块把xml数据解析为js对象,方便我们使用.</p><p>微信公众号开发:配置接入流程,加密认证环节,票据access_token.</p><p>利用nodejs开发一些网页或者爬虫工具,来对nodejs api和它的技术特点有一些基本的认知.</p><p>有一些其他的后端经验,php,java,ruby,主要弄明白一个网络http请求从开发到结束中间所经过的环节.</p><p>nodejs和javascript</p><p>进击node.js教程</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>针对微信常用接口进行一个一个单独讲解和实现,并且有许多小案例演示.</p><p>开发电影公众号的网站项目.</p><p>了解一:本地代理环节的搭建以及最入门的加密认证.</p><p>1.域名服务器环境的配置<br>2.利用qq浏览器代理调式端口</p><p>重点:加密认证逻辑</p><h2 id="微信公众号-企业号-订阅号-服务号"><a href="#微信公众号-企业号-订阅号-服务号" class="headerlink" title="微信公众号:企业号,订阅号,服务号"></a>微信公众号:企业号,订阅号,服务号</h2><p>订阅号:个人,小团队,只要是信息的传播,管理用户以及用户的互动. 如消息定制</p><p>服务,企业和组织,提供业务服务与用户管理能力.比如支付,智能接口.</p><p>企业号,管理全学校所有学院等,各个部门上班人员的考勤,活动进程等.</p><p>服务号,管理全学校的水果商店或者打印店,可以直接支持送货上门,以及推送一些特价水果.</p><p>订阅号,管理一个班级,一个学院的信息订阅,通知和互动.</p><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>认证和非认证</p><p>认证:一般需要你有个开户过的企业大家可以法人身份去折腾下开一个小公司.</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>订阅号:认证和非认证账号的区别就是,认证账号别可以直接在添加好友里搜索关键词就能找到你.</p><h2 id="订阅号和服务号三点不同"><a href="#订阅号和服务号三点不同" class="headerlink" title="订阅号和服务号三点不同"></a>订阅号和服务号三点不同</h2><p>出现位置不同.<br>单月发送消息的数量,订阅号一天一篇,服务号一个月最多4篇.<br>订阅号没有9大接口和支付功能.</p><h2 id="服务号9大接口"><a href="#服务号9大接口" class="headerlink" title="服务号9大接口"></a>服务号9大接口</h2><p>1.语音识别<br>2.客服接口<br>3.OAuth 2.0网页的授权:这个授权接口,可以请求用户授权,从而拿到更多用户的信息.</p><p>4.生成带参数二维码:<br>公众号可以获取一系列携带不同参数的二维码,在用户扫描关注公众号后.<br>公众号可以根据参数分析各二维码的效果.这些参数可以自己定制,从而可以实现更多分析结果,比如用户从哪里来的.</p><p>5.获取用户的地理位置:公众号能够获得用户进入公众号会话时的地理位置.可以做微信导航.</p><p>6.获取用户基本信息:公众号可以根据加密后的用户OpenID,通过一系列的参数交互,最终拿到用户基础信息,包括头像,名称,性别,地区.</p><p>7.获取关注者的列表:通过这个接口,可以拿到所有关注者的OpenID,就知道有多少人关注你,是谁在关注你.<br>8.用户分组接口:通过分组接口,可以在后台为用户移动,创建,修改分组,比如把你们班级你们团队分成,男生一组,女生一组<br>9.上传下载多媒体文件</p><h2 id="订阅号"><a href="#订阅号" class="headerlink" title="订阅号"></a>订阅号</h2><p>1.会话界面的自定义菜单<br>2.多客服接口<br>3.获取用户地址位置<br>4.高级群发接口<br>5.用户分组接口</p><h2 id="域名-服务器以及ngrok环境"><a href="#域名-服务器以及ngrok环境" class="headerlink" title="域名,服务器以及ngrok环境"></a>域名,服务器以及ngrok环境</h2><p>微信<->服务器<->域名<->应用服务器<->微信</-></-></-></-></p><p>./ngork</p><blockquote><p><a href="http://www.tunnel.mobl" target="_blank" rel="noopener">www.tunnel.mobl</a></p></blockquote><p>使用:<br>下载配置文件ngrok.cfg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrok -config ngrok.cfg - subdomain example 8080</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br><span class="line">cd text</span><br><span class="line">ls</span><br><span class="line">// 写一个简单的服务器</span><br><span class="line">python m SimpleHTTPServer 3100</span><br><span class="line">python -m SimpleHTTPServer 3100</span><br><span class="line">-config ngrok.cfg subdomain imooc-wechat 3100</span><br></pre></td></tr></table></figure><p>子域名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://imooc-wechat.tunnel.mobi</span><br></pre></td></tr></table></figure><p>使用nodejs的localtunnel服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g localtunnel</span><br><span class="line">lt --port 3100</span><br></pre></td></tr></table></figure><blockquote><p>PageKite 花生壳</p></blockquote><h2 id="配置-接入微信公众号"><a href="#配置-接入微信公众号" class="headerlink" title="配置,接入微信公众号"></a>配置,接入微信公众号</h2><p>点击开发者工具:接口测试申请</p><p>获取:<br>url<br>token</p><p>接入公众号:</p><p>一:配置微信公众号后台<br>二:验证公众号</p><p>配置服务器的url</p><h2 id="验证公众号"><a href="#验证公众号" class="headerlink" title="验证公众号"></a>验证公众号</h2><p>token,timestamp,nonce<br>字典排序,sha1加密<br>r===signature</p><p>一:将token,timestamp,nonce三个参数进行字典序排序<br>二:将三个参数字符串拼接成一个字符串进行sha1加密.<br>三:将加密后的字符串与signature对比,如果相同,表示这个请求来源于微信,我们直接原因返回echostr参数内容,接入验证就成功了.</p><h2 id="实现加密认证逻辑"><a href="#实现加密认证逻辑" class="headerlink" title="实现加密认证逻辑"></a>实现加密认证逻辑</h2><blockquote><p>使用koa,不用express</p></blockquote><p>使用Koa框架,代码可以更加精简,更加易懂,对于反反复复的异步交互更适合用这个框架实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scott/wechat &gt;&gt;</span><br><span class="line"></span><br><span class="line">npm install koa sha1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">node --harmony app.js</span><br><span class="line"></span><br><span class="line">&gt;&gt; ./ngrok -config ngrok.cfg -subdomain scott_wechat 1234</span><br><span class="line"></span><br><span class="line">ls --port 1234</span><br><span class="line">// 把生成的地址配置到接口配置信息中url里面去</span><br><span class="line"></span><br><span class="line">node --harmony app</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084</span><br></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ol><li>填写服务器配置</li><li>验证服务器地址的有效性</li><li>根据接口文档实现业务逻辑</li></ol><p>我们在手机上给微信公众号发送一个消息，这就相当于一个request请求，然后这个request到达微信服务器，紧接着微信服务器对这个request做出解析，然后开始响应一个response给你，这样你就收到了相应的回复。</p><p>当我们进行微信公众号的开发之后，用户的请求就不再有微信服务器去做处理了，而是由我们自己的服务做处理，然后把消息传给微信服务器，微信服务器再将消息返回给我们的用户。</p><p>在这个过程中，微信服务器起了一个中间商的作用，所以经过这样的分析，微信公众号开发要把握的一点就是，你只要返回给微信服务器正确的数据，微信服务器就能帮你做正确的事情。</p><p>所以作为微信公众号开发的第一步就是接入，你需要将自己的服务器和微信服务器做接通，只有接通之后，用户发送的请求到达微信服务器之后，微信服务器才知道该将这个请求转发给哪个服务器来处理。</p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>这个url是用来接收微信服务器发送过来的请求的，要对请求做处理？想一想，request？处理？该怎么做呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class OneServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">       super.doGet(req, resp);</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line"></span><br><span class="line">   protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">       super.doPost(req, resp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="需要"><a href="#需要" class="headerlink" title="需要"></a>需要</h2><p>服务器<br>公众号</p><p>申请测试号<br>这里是申请地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</span><br></pre></td></tr></table></figure><p>appID 和appsecret </p><p>通过他们我们能得到很重要的一个数值就access_token<br>access_token是公众号的全局唯一接口调用凭据</p><p>公众号调用各接口时都需使用access_token</p><h2 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access_token"></a>获取access_token</h2><p>官方技术文档中已经说了，公众号调用接口都需要使用到access_token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// https请求方式: GET</span><br><span class="line">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant_type是获取access_token填写client_credential</span><br><span class="line">appid是第三方用户唯一凭证</span><br><span class="line">secret是第三方用户唯一凭证密钥，即appsecret</span><br></pre></td></tr></table></figure><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>这个接口正确调用会返回什么数据呢？</p><p>正常情况下会返回下述JSON数据包给公众号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125;</span><br></pre></td></tr></table></figure><p>那么这里又包含如下参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access_token获取到的凭证</span><br><span class="line">expires_in凭证有效时间，单位：秒</span><br></pre></td></tr></table></figure></p><p>使用Postman这个工具简单演示一下发起get请求获取access_token 。</p><p>然后把响应的参数填写即可，这里的grant_type 就写默认的即可，剩下的appid和secret就填写你公众号的appID 和appsecret。</p><p>这个时候你就会发现，一个完整的get请求就拼接好了，接下来点击send即可，然后就会看到返回的数据</p><p>这样就得到我们需要的access_token 。</p><p>微信服务器会往我们填写的这个URL上面发送一个get请求，通过这个get请求能够得到微信服务器发送过来的一些消息，然后对消息做响应的处理来与微信服务器对接。</p><p>很显然，这个URL需要填写一个servlet，微信服务区器将消息发送过来之后需要对这个请求做处理，所以这里选择使用servlet对请求做处理。</p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>关于如何验证，文档中给了一个PHP的例子，那么Java中该如何验证呢？</p><p>首先创建一个maven项目，然后创建一个CoreServlet用来接收微信服务器发送过来的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CoreServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        super.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        super.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成servlet之后就需要将这个servlet进行注册了，这个是在web.xml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">           xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</span><br><span class="line">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">           version=&quot;3.0&quot;&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;coreServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;</span><br><span class="line">            com.ithuanqging.wechat.CoreServlet</span><br><span class="line">        &lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!-- url-pattern中配置的/coreServlet用于指定该Servlet的访问路径 --&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;coreServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/coreservlet&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>填写服务器地址（URL）、Token和EncodingAESKey，其中URL是开发者用来接收微信消息和事件的接口URL。Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥。</p><p>开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。</p><h2 id="第二步：验证消息的确来自微信服务器"><a href="#第二步：验证消息的确来自微信服务器" class="headerlink" title="第二步：验证消息的确来自微信服务器"></a>第二步：验证消息的确来自微信服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signature微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</span><br><span class="line">timestamp时间戳</span><br><span class="line">nonce随机数</span><br><span class="line">echostr随机字符串</span><br></pre></td></tr></table></figure><p>1）将token、timestamp、nonce三个参数进行字典序排序 2）将三个参数字符串拼接成一个字符串进行sha1加密 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</p><p>检验signature的PHP示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private function checkSignature()</span><br><span class="line">&#123;</span><br><span class="line">    _GET[&quot;signature&quot;];</span><br><span class="line">    _GET[&quot;timestamp&quot;];</span><br><span class="line">    _GET[&quot;nonce&quot;];</span><br><span class="line"></span><br><span class="line">tmpArr = array(timestamp, $nonce);</span><br><span class="line">sort($tmpArr, SORT_STRING);</span><br><span class="line">$tmpStr = implode( $tmpArr );</span><br><span class="line">$tmpStr = sha1( $tmpStr );</span><br><span class="line"></span><br><span class="line">if( signature )&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">      // 微信加密签名</span><br><span class="line">      String signature = req.getParameter(&quot;signature&quot;);</span><br><span class="line">      // 时间戳</span><br><span class="line">      String timestamp = req.getParameter(&quot;timestamp&quot;);</span><br><span class="line">      // 随机数</span><br><span class="line">      String nonce = req.getParameter(&quot;nonce&quot;);</span><br><span class="line">      // 随机字符串</span><br><span class="line">      String echostr = req.getParameter(&quot;echostr&quot;);</span><br><span class="line"></span><br><span class="line">      PrintWriter out = resp.getWriter();</span><br><span class="line"></span><br><span class="line">      // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败</span><br><span class="line">      if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">          out.print(echostr);</span><br><span class="line">      &#125;</span><br><span class="line">      out.close();</span><br><span class="line">      out = null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>##<br>微信测试公众号基本配置URL和Token的验证-JAVA</p><p>我们填写的URL和Token，微信那边会根据你填的来验证是否正确，URL必须有域名的，Token自己定义的。</p><p>微信调用我们服务器，会通过GET请求，请求带有signature、timestamp、nonce、echostr参数。服务端返回echostr参数，则表示token验证成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">       @GET</span><br><span class="line">@Path(&quot;/tokenVarify&quot;)</span><br><span class="line">@Produces(MediaType.APPLICATION_JSON)</span><br><span class="line">@Consumes(MediaType.APPLICATION_JSON)</span><br><span class="line">@ApiOperation(value = &quot;Vatify wc token&quot;, position = 1)</span><br><span class="line">public void tokenVarify(@Context HttpServletRequest request,</span><br><span class="line">@Context HttpServletResponse response) &#123;</span><br><span class="line">boolean isGet = request.getMethod().toLowerCase().equals(&quot;get&quot;);</span><br><span class="line">PrintWriter print;</span><br><span class="line">if (isGet) &#123;</span><br><span class="line">           // 微信加密签名</span><br><span class="line">           String signature = request.getParameter(&quot;signature&quot;);</span><br><span class="line">           // 时间戳</span><br><span class="line">           String timestamp = request.getParameter(&quot;timestamp&quot;);</span><br><span class="line">           // 随机数</span><br><span class="line">           String nonce = request.getParameter(&quot;nonce&quot;);</span><br><span class="line">           // 随机字符串</span><br><span class="line">           String echostr = request.getParameter(&quot;echostr&quot;);</span><br><span class="line">           // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败</span><br><span class="line">           if (signature != null &amp;&amp; CheckoutUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   print = response.getWriter();</span><br><span class="line">                   print.write(echostr);</span><br><span class="line">                   print.flush();</span><br><span class="line">               &#125; catch (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CheckoutUtil.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.security.MessageDigest;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line"> </span><br><span class="line">public class CheckoutUtil &#123;</span><br><span class="line">// 与接口配置信息中的Token要一致</span><br><span class="line">    private static String token = &quot;bryant.zhang.test&quot;;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 验证签名</span><br><span class="line">     * </span><br><span class="line">     * @param signature</span><br><span class="line">     * @param timestamp</span><br><span class="line">     * @param nonce</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean checkSignature(String signature, String timestamp, String nonce) &#123;</span><br><span class="line">        String[] arr = new String[] &#123; token, timestamp, nonce &#125;;</span><br><span class="line">        // 将token、timestamp、nonce三个参数进行字典序排序</span><br><span class="line">        // Arrays.sort(arr);</span><br><span class="line">        sort(arr);</span><br><span class="line">        StringBuilder content = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            content.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageDigest md = null;</span><br><span class="line">        String tmpStr = null;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            md = MessageDigest.getInstance(&quot;SHA-1&quot;);</span><br><span class="line">            // 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line">            byte[] digest = md.digest(content.toString().getBytes());</span><br><span class="line">            tmpStr = byteToStr(digest);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        content = null;</span><br><span class="line">        // 将sha1加密后的字符串可与signature对比，标识该请求来源于微信</span><br><span class="line">        return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 将字节数组转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param byteArray</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static String byteToStr(byte[] byteArray) &#123;</span><br><span class="line">        String strDigest = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; byteArray.length; i++) &#123;</span><br><span class="line">            strDigest += byteToHexStr(byteArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return strDigest;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 将字节转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param mByte</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static String byteToHexStr(byte mByte) &#123;</span><br><span class="line">        char[] Digit = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos; &#125;;</span><br><span class="line">        char[] tempArr = new char[2];</span><br><span class="line">        tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F];</span><br><span class="line">        tempArr[1] = Digit[mByte &amp; 0X0F];</span><br><span class="line">        String s = new String(tempArr);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sort(String a[]) &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length - 1; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; a.length; j++) &#123;</span><br><span class="line">                if (a[j].compareTo(a[i]) &lt; 0) &#123;</span><br><span class="line">                    String temp = a[i];</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    a[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="qi文档中说的真的很清楚了，包括如何验证等表述的都很清楚，下面我们直接编码"><a href="#qi文档中说的真的很清楚了，包括如何验证等表述的都很清楚，下面我们直接编码" class="headerlink" title="qi文档中说的真的很清楚了，包括如何验证等表述的都很清楚，下面我们直接编码"></a>qi文档中说的真的很清楚了，包括如何验证等表述的都很清楚，下面我们直接编码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">      // 微信加密签名</span><br><span class="line">      String signature = req.getParameter(&quot;signature&quot;);</span><br><span class="line">      // 时间戳</span><br><span class="line">      String timestamp = req.getParameter(&quot;timestamp&quot;);</span><br><span class="line">      // 随机数</span><br><span class="line">      String nonce = req.getParameter(&quot;nonce&quot;);</span><br><span class="line">      // 随机字符串</span><br><span class="line">      String echostr = req.getParameter(&quot;echostr&quot;);</span><br><span class="line"></span><br><span class="line">      PrintWriter out = resp.getWriter();</span><br><span class="line"></span><br><span class="line">      // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败</span><br><span class="line">      if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">          out.print(echostr);</span><br><span class="line">      &#125;</span><br><span class="line">      out.close();</span><br><span class="line">      out = null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上是从request请求中拿到传过来的参数，接下来就是需要创建一个工具类按照文档中说的方法去进行验证了，这里我已经写好了这个工具类SignUtil</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class SignUtil &#123;</span><br><span class="line">    // 与接口配置信息中的Token要一致</span><br><span class="line">    private static String token = &quot;mytoken&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证签名</span><br><span class="line">     */</span><br><span class="line">    public static boolean checkSignature(String signature, String timestamp,String nonce) &#123;</span><br><span class="line">        // 1.将token、timestamp、nonce三个参数进行字典序排序</span><br><span class="line">        String[] arr = new String[] &#123; token, timestamp, nonce &#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        // 2. 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line">        StringBuilder content = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            content.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageDigest md = null;</span><br><span class="line">        String tmpStr = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            md = MessageDigest.getInstance(&quot;SHA-1&quot;);</span><br><span class="line">            // 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line">            byte[] digest = md.digest(content.toString().getBytes());</span><br><span class="line">            tmpStr = byteToStr(digest);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        content = null;</span><br><span class="line">        // 3.将sha1加密后的字符串可与signature对比，标识该请求来源于微信</span><br><span class="line">        return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将字节数组转换为十六进制字符串</span><br><span class="line">     */</span><br><span class="line">    private static String byteToStr(byte[] byteArray) &#123;</span><br><span class="line">        String strDigest = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; byteArray.length; i++) &#123;</span><br><span class="line">            strDigest += byteToHexStr(byteArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return strDigest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将字节转换为十六进制字符串</span><br><span class="line">     */</span><br><span class="line">    private static String byteToHexStr(byte mByte) &#123;</span><br><span class="line">        char[] Digit = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;,&apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos; &#125;;</span><br><span class="line">        char[] tempArr = new char[2];</span><br><span class="line">        tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F];</span><br><span class="line">        tempArr[1] = Digit[mByte &amp; 0X0F];</span><br><span class="line">        String s = new String(tempArr);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>以上这个工具类你可以直接拿来使用。</p><p>这个时候就要回到我们的测试公众号后台了，去填写我们的配置，也就是接口配置信息，但是现在你写的程序还在本地，微信即使发送请求也发不到你这啊，所以这个时候需要将的项目打包传到你的服务器上</p><p>首先将你的项目通过maven打包成war</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\JavaCodeDemo\wechattest:mvn package</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wechattest &gt; target &gt;</span><br><span class="line">classes</span><br><span class="line">generated-sources</span><br><span class="line">maven-archiver</span><br><span class="line">maven-status</span><br><span class="line">wechattest</span><br><span class="line">wechattest.war</span><br></pre></td></tr></table></figure><p>接下来将这个war包上传到你的服务器上，我这里使用的是FileZilla这个工具</p><p>找到刚才生成的war包，远程站点必须是tomcat下的webapps目录下。</p><p>服务器配置的知识涉及到在服务器中安装JDK和tomcat！</p><p>现在只要告诉微信服务器你的这个项目中的CoreServlet的正确路径，就能接收微信服务器发动的消息了，现在回到测试公众号的后台。</p><p>接口配置信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器公网IP地址</span><br><span class="line">coreservlet的路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://139.199.98.152/wechattest/coreservlet</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信公众号开发&lt;/p&gt;
    
    </summary>
    
      <category term="微信公众号开发" scheme="https://huangguangda.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信公众号开发" scheme="https://huangguangda.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>腾讯智慧校园开发平台1</title>
    <link href="https://huangguangda.github.io/2018/05/18/1/"/>
    <id>https://huangguangda.github.io/2018/05/18/1/</id>
    <published>2018-05-18T07:12:23.000Z</published>
    <updated>2018-10-19T07:27:44.490Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯智慧校园开发平台1</p><a id="more"></a><p>OpenAPI参数：</p><p>openAppID（或devCode、devType、keyId）、<br>timestamp、sign、objectid、objType</p><p>openAppID（第三方应用ID）+AppSecret（第三方应用密钥）</p><p>openAppID、AppSecret的获取方式：开放平台后台：应用管理==》应用详情，openAppID对应AppID</p><p>请求接口的数据为数组格式</p><p>接口返回的数据为json格式。其中GET接口可以通过传入callback参数，兼容jsonp格式</p><p>接口安全校验采用sign签名的方式，sign由密钥key生成（key为第三方应用AppSecret），sign参数的生成算法详见“签名参数sign生成说明”小节。</p><p>每次调用智慧校园接口时都需要带上openAppID、objectid、objType、timestamp、sign参数。</p><p>openAppID第三方应用的AppID，请从开发者后台获取。<br>objType    object类型（1：上级单位，2：学校）<br>objectid 学校id。有2种获取方式：1.由学校提供。路径：学校/上级单位后台==》开发==》接口授权==》objectid（仅创建者可见）；2.已创建第三方应用，且学校已安装和使用该应用时，可由腾讯智慧校园在url中返回。详见应用管理后台接入和应用H5前台接入<br>sign 接口签名。sign是由应用“开发者密钥或学校授权码”和未经URL-encode的请求字符串计算获取，sign的生成规则参考签名参数sign生成说明小节<br>timestamp 10位/13位时间戳，请确保服务器时间与北京时间一致。否则会导致接口校验失败，报“时间戳错误”。</p><p>通过“API列表”中的接口，获取学校/上级单位信息</p><p>在获取登录态的同时，可以获取到学校ID/上级单位ID、用户ID等信息。</p><p>当开发者获取到学校ID、用户ID后，可以调用“API接口列表”中的接口，进一步获取学校/上级单位信息。</p><p>哪些学校和用户可以使用该应用，由【应用详情】中的“使用范围”和“适用人群”决定。开发者只能获取这部分人的信息。</p><p>请求示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.campus.qq.com/api/open/sendMsg?timestamp=TIMESTAMP&amp;sign=SIGN&amp;openAppID=OPENAPPID&amp;objectid=OBJECTID&amp;objType=OBJTYPE</span><br></pre></td></tr></table></figure></p><p>wxuserid 接收消息的用户微信ID列表<br>wxdepartid 接收消息的部门微信ID列表</p><h2 id="OpenAPI调用相关问题"><a href="#OpenAPI调用相关问题" class="headerlink" title="OpenAPI调用相关问题"></a>OpenAPI调用相关问题</h2><p>【公共参数及签名密钥相关】</p><ol><li>都有哪些公共参数？</li></ol><p>详见文档：开放API调用说明==》API公共参数说明</p><ol start="2"><li>什么是objectid、objType、userid，如何获取它们？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="3"><li>什么是openAppID、AppSecret、H5Secret，如何获取它们？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="4"><li>什么是devCode、devType、授权密钥、授权密钥ID，如何获取它们？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="5"><li>如何生成和校验sign签名？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明，以及文档中的“签名校验工具”</p><p>【OpenAPI调用方式相关】</p><ol><li>API调用说明？</li></ol><p>详见文档：开放API调用说明==》API调用说明</p><ol start="2"><li>post请求参数demo？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="3"><li>OpenAPI调用代码demo？</li></ol><p>详见文档：开放API调用说明==》Demo下载</p><p>调用API时，开发者信息、sign签名密钥获取方式：<br>开放平台后台==》应用管理==》查看详情==》AppID、AppSecret</p><p>objectid获取方式：<br>学校/上级单位后台==》基本信息==》objectid（仅创建者可见）</p><p>userid有以下几种获取方式：<br>1.通过开放API获取，详见文档 API接口列表==》获取/搜索用户列表<br>2.在学校/上级单位/教师工作台后台，应用管理的iframe url参数中返回，详见文档 应用接入指引==》应用管理后台接入。前提是此应用提供了管理后台url/教师工作台url，并且此应用已被学校/上级单位安装。<br>3.当用户在手机上使用第三方应用时，在H5 url参数中返回，详见文档 应用接入指引==》应用H5前台接入。前提是此应用提供了移动端url，并且此应用已被学校/上级单位安装。</p><h2 id="微信登录插件"><a href="#微信登录插件" class="headerlink" title="微信登录插件"></a>微信登录插件</h2><p>第三方应用接入智慧校园微信登录插件后，学校用户可使用智慧校园绑定的微信号登录第三方应用，登录后将向第三方返回用户的智慧校园userid，可通过userid查询用户的其他信息。</p><p>智慧校园提供H5和PC端的微信登录插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AppID：</span><br><span class="line">AppSecret：</span><br><span class="line">H5Secret：</span><br></pre></td></tr></table></figure><p>通过openAppID+AppSecret方式请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.campus.qq.com/api/open/getObjectInfo?timestamp=TIMESTAMP&amp;objectid=OBJECTID&amp;objType=OBJTYPE&amp;openAppID=OPENAPPID&amp;sign=SIGN</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://open.campus.qq.com/api/open/getObjectInfo?openAppID=521430153974</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯智慧校园开发平台1&lt;/p&gt;
    
    </summary>
    
      <category term="腾讯智慧校园开发平台" scheme="https://huangguangda.github.io/categories/%E8%85%BE%E8%AE%AF%E6%99%BA%E6%85%A7%E6%A0%A1%E5%9B%AD%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="腾讯智慧校园开发平台" scheme="https://huangguangda.github.io/tags/%E8%85%BE%E8%AE%AF%E6%99%BA%E6%85%A7%E6%A0%A1%E5%9B%AD%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTML入门教材</title>
    <link href="https://huangguangda.github.io/2018/05/17/1/"/>
    <id>https://huangguangda.github.io/2018/05/17/1/</id>
    <published>2018-05-17T03:48:02.000Z</published>
    <updated>2018-10-19T12:04:26.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><h2 id="HTML-基本结构及实体"><a href="#HTML-基本结构及实体" class="headerlink" title="HTML 基本结构及实体"></a>HTML 基本结构及实体</h2><ul><li>了解 HTML 文档的基本结构</li><li>掌握 HTML 结构标签<html><head><title><body></body></title></head></html></li><li>掌握 HTML 字符实体</li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h4 id="HTML-文件是什么？"><a href="#HTML-文件是什么？" class="headerlink" title="HTML 文件是什么？"></a>HTML 文件是什么？</h4><p>HTML 表示超文本标记语言（Hyper Text Markup Language）。<br>HTML 文件是一个包含标记的文本文件。<br>这些标记保证浏览器怎样显示这个页面。<br>HTML 文件必须有 htm 或者 html 扩展名。<br>HTML 文件可以用一个简单的文本编辑器创建。</p><h4 id="想不想尝试一下？"><a href="#想不想尝试一下？" class="headerlink" title="想不想尝试一下？"></a>想不想尝试一下？</h4><p>假如你运行的是 windows 系统，打开记事本，在其中输入以下文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Title of page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is my first homepage.</span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>将此文件保存为“mypage.htm”。</p><h4 id="例子解释"><a href="#例子解释" class="headerlink" title="例子解释:"></a>例子解释:</h4><p>HTML 文档中，第一个标签是<html>。</html></p><p>这个标签告诉浏览器这是 HTML 文档的开始。</p><p>HTML</p><p>文档的最后一个标签是，这个标签告诉浏览器这是 HTML 文档的终止。</p><p>在<head>和</head>标签之间文本的是头信息。</p><p>在浏览器窗口中，头信息是不被显示的 。</p><p>在<title>和</title>标签之间的文本是文档标题，它被显示在浏览器窗口的标题栏 。</p><p>在<body>和</body>标签之间的文本是正文，会被显示在浏览器中。</p><p>在<b>和</b>标签之间的文本会以加粗字体显示。</p><h4 id="关于-HTML-编辑器："><a href="#关于-HTML-编辑器：" class="headerlink" title="关于 HTML 编辑器："></a>关于 HTML 编辑器：</h4><p>用一些所见即所得的编辑器，比如 frontpage，dreamwaver，你可以很容易创建一个<br>页面，而不需要在纯文本中编写代码。</p><p>但是假如你想成为一名熟练的网络开发者，我们强烈推荐你用纯文本编辑器编写代码 ，<br>这有助于学习 HTML 基础。</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题:"></a>常见问题:</h4><p>问：我编写完了 HTML 文件，但是不能在浏览器中看见结果，为什么？</p><p>答 ： 请确 认 你 保 存了 文 件 ， 并且 使 用 了 正确 的 文 件 名和 扩 展 名 ，例 如 ：<br>“c:\mypage.htm”，并且确认你用浏览器打开时使用同样的文件名。</p><p>问：我编辑了 HTML 文件，但是修改结果并没有在浏览器中显示，为什么？</p><p>答：浏览器缓存了你的页面，所以它不需要两次读取同样的页面。你修改了这个页面 ，<br>浏览器并不知道。请使用“刷新/重载”按钮来强迫浏览器读取编辑过的页面。</p><h4 id="HTML-元素："><a href="#HTML-元素：" class="headerlink" title="HTML 元素："></a>HTML 元素：</h4><p>HTML 文档是由 HTML 元素组成的文本文件。</p><p>HTML 元素是预定义的正在使用的 HTML 标签。</p><h5 id="HTML-标签："><a href="#HTML-标签：" class="headerlink" title="HTML 标签："></a>HTML 标签：</h5><p>HTML 标签用来组成 HTML 元素。</p><p>HTML 标签两端有两个包括字符：“&lt;”和“&gt;”,这两个包括字符被称为角括号。</p><p>HTML 标签通常成对出现，比如<b>和</b>。</p><p>一对标签的前面一个是开始标签，第二个是结束标签,在开始和结束标签之间的文本是元素内容。</p><p>HTML 标签是大小写无关的，<b>跟<b>表示的意思是一样的。</b></b></p><h5 id="HTML-元素：-1"><a href="#HTML-元素：-1" class="headerlink" title="HTML 元素："></a>HTML 元素：</h5><p>回忆一下上面的 HTML 例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Title of page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is my first homepage.</span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>下面是一个 HTML 元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br></pre></td></tr></table></figure></p><p>此 HTML 元素以开始标签<b>起始， 内容是：This text is bold，以结束标签</b>中止 。</p><p><b>标签的目的是定义一个需要被显示成粗体的 HTML 元素。</b></p><p>下面也是一个 HTML 元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">This is my first homepage.</span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>此 HTML 标签以开始标签<body>起始，终止于结束标签<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hibiki"},"display":{"position":"right","width":75,"height":150},"mobile":{"show":false},"log":false});</script></body>。</p><p><body>标签的目的</body></p><p>是定义一个 HTML 元素，使其包含 HTML 文档的主体。</p><p>为什么使用小写标签？</p><p>我们刚说过，HTML 标签是大小写无关的：</p><p><b>跟<b>含义相同。</b></b></p><p>当你上网的时候，你会注意到多数教程在示例中使用大写的 HTML 标签，我们总是使用小写标签。</p><p>为什么？</p><p>假如你想投入到下一代 HTML 中，你应该开始使用小写标签。</p><p>W3C 在他们的 HTML4建议中提倡使用小写标签，XHTML（下一代 HTML）也需要小写标签。</p><h5 id="标签属性："><a href="#标签属性：" class="headerlink" title="标签属性："></a>标签属性：</h5><p>标签可以拥有属性。</p><p>属性能够为页面上的 HTML 元素提供附加信息。</p><p>标签<body>定义了 HTML 页面的主体元素。</body></p><p>使用一个附加的 bgcolor 属性，你可以告诉浏览器：你页面的背景色是红色的，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body bgcolor=&quot;red&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>标签<table>定义了一个 HTML 表格。</table></p><p>使用一个附加的 border 属性，你可以告诉浏览器：这个表格是没有边框的，代码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;0&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>属性通常由属性名和值成对出现，就像这样：name=”value”。</p><p>属性通常是附加给 HTML元素的开始标签的。</p><h4 id="引号样式："><a href="#引号样式：" class="headerlink" title="引号样式："></a>引号样式：</h4><p>属性值应该被包含在引号中。<br>双引号是最常用的，但是单引号也可以使用。</p><p>在很少情况下，比如说属性值本身包含引号，使用单引号就很必要了。</p><blockquote><p>比如：name=’John “ShotGun” Nelson’。</p></blockquote><p>注意：中文引号跟英文引号是不一样的。<br>上面所指的引号都是英文状态下的引号。</p><h4 id="HTML-实体"><a href="#HTML-实体" class="headerlink" title="HTML  实体"></a>HTML  实体</h4><p>有些字符，比如说“&lt;”字符，在 HTML 中有特殊的含义，因此不能在文本中使用。<br>想要在 HTML 中显示一个小于号“&lt;”，需要用到字符实体。</p><h5 id="字符实体："><a href="#字符实体：" class="headerlink" title="字符实体："></a>字符实体：</h5><p>在 HTML 中，有些字符拥有特殊含义，比如小于号“&lt;”定义为一个 HTML 标签的开始 。</p><p>假如我们想要浏览器显示这些字符的话，必须在 HTML 代码中插入字符实体。</p><p>一个字符实体拥有三个部分：<br>一个 and 符号（&amp;），<br>一个实体名或者一个实体号，<br>最后是一个分号（;）</p><p>想要在 HTML 文档中显示一个小于号，我们必须这样写：&lt;或者&#60;</p><p>使用名字相对于使用数字的优点是容易记忆，缺点是并非所有的浏览器都支持最新的实体名，但是几乎所有的浏览器都能很好地支持实体号。</p><p>注意：实体名是大小写敏感的。</p><p>下面这个例子能够让你针对 HTML 实体实践一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;This is a character entity: &amp;#123;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h4 id="不可拆分的空格"><a href="#不可拆分的空格" class="headerlink" title="不可拆分的空格"></a>不可拆分的空格</h4><p>在 HTML 中，最常见的字符实体就是不可拆分空格。</p><p>通常，HTML 会合并你文档中的空格。<br>假如在你的 HTML 文本中连续写了 10 个空格 ，其中 9 个会被去掉。<br>想要在 HTML 中插入空格，可以使用实体：&nbsp;</p><h2 id="HTML-基本元素的运用"><a href="#HTML-基本元素的运用" class="headerlink" title="HTML  基本元素的运用"></a>HTML  基本元素的运用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">段落相关标签&lt;p&gt;&lt;br&gt;&lt;hr&gt;</span><br><span class="line">格式化相关标签&lt;small&gt;&lt;sub&gt;&lt;sup&gt;&lt;pre&gt;</span><br><span class="line">列表相关标签&lt;ol&gt;&lt;ul&gt;&lt;li&gt;</span><br><span class="line">图片相关标签&lt;img&gt;</span><br><span class="line">超链相关标签&lt;a&gt;</span><br></pre></td></tr></table></figure><h3 id="段落-相关-标签"><a href="#段落-相关-标签" class="headerlink" title="段落 相关 标签"></a>段落 相关 标签</h3><p>标题元素：<br>标题元素由标签</p><h1>到<h6>定义。<h1>定义了最大的标题元素，<h6>定义了最小的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;This is a heading&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;This is a heading&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;This is a heading&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;This is a heading&lt;/h4&gt;</span><br><span class="line">&lt;h5&gt;This is a heading&lt;/h5&gt;</span><br><span class="line">&lt;h6&gt;This is a heading&lt;/h6&gt;</span><br></pre></td></tr></table></figure></h6></h1></h6></h1><p></p><blockquote><p>HTML 自动在一个标题元素前后各添加一个空行。</p></blockquote><h4 id="段落："><a href="#段落：" class="headerlink" title="段落："></a>段落：</h4><p>段落是用</p><p>标签定义的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is another paragraph&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>HTML 自动在一个段落前后各添加一个空行。</p></blockquote><h4 id="换行："><a href="#换行：" class="headerlink" title="换行："></a>换行：</h4><p>当需要结束一行，并且不想开始新段落时，使用<br>标签。<br>标签不管放在什么位置，都能够强制换行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This &lt;br&gt; is a para&lt;br&gt;graph with line breaks&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p><br>标签是一个空标签，它没有结束标记。</p></blockquote><h4 id="格式化-相关-标签"><a href="#格式化-相关-标签" class="headerlink" title="格式化 相关 标签"></a>格式化 相关 标签</h4><p>格式化文字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;&lt;br&gt;</span><br><span class="line">&lt;strong&gt;</span><br><span class="line">This text is strong</span><br><span class="line">&lt;/strong&gt;&lt;br&gt;</span><br><span class="line">&lt;big&gt;</span><br><span class="line">This text is big</span><br><span class="line">&lt;/big&gt;&lt;br&gt;</span><br><span class="line">&lt;em&gt;</span><br><span class="line">This text is emphasized</span><br><span class="line">&lt;/em&gt;&lt;br&gt;</span><br><span class="line">&lt;i&gt;</span><br><span class="line">This text is italic</span><br><span class="line">&lt;/i&gt;&lt;br&gt;</span><br><span class="line">&lt;small&gt;</span><br><span class="line">This text is small</span><br><span class="line">&lt;/small&gt;&lt;br&gt;</span><br><span class="line">This text contains</span><br><span class="line">&lt;sub&gt;</span><br><span class="line">subscript</span><br><span class="line">&lt;/sub&gt;&lt;br&gt;</span><br><span class="line">This text contains</span><br><span class="line">&lt;sup&gt;</span><br><span class="line">superscript</span><br><span class="line">&lt;/sup&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="列表相关标签"><a href="#列表相关标签" class="headerlink" title="列表相关标签"></a>列表相关标签</h3><h4 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h4><p>无序列表是一个项目的序列。各项目前加有标记（通常是黑色的实心小圆圈）。</p><p>无序列表以<ul>标签开始。每个列表项目以<li>开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;Coffee&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Milk&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li></ul></p><p>无序列表的项目中可以加入段落、换行、图像，链接，其他的列表等等。</p><h4 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h4><p>有序列表也是一个项目的序列。各项目前加有数字作标记。</p><p>有序列表以<ol>标签开始。每个列表项目以<li>开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">Web程序开发基础</span><br><span class="line">12</span><br><span class="line">&lt;li&gt;Coffee&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Milk&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure></li></ol></p><h2 id="不同类型："><a href="#不同类型：" class="headerlink" title="不同类型："></a>不同类型：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol type=&quot;A&quot;&gt;</span><br><span class="line">&lt;ol type=&quot;a&quot;&gt;</span><br><span class="line">&lt;ol type=&quot;I&quot;&gt;</span><br><span class="line">&lt;ol type=&quot;i&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul type=&quot;disc&quot;&gt;</span><br><span class="line">&lt;ul type=&quot;circle&quot;&gt;</span><br><span class="line">&lt;ul type=&quot;square&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="图片相关标签"><a href="#图片相关标签" class="headerlink" title="图片相关标签"></a>图片相关标签</h2><h4 id="Img-标签和-src属性："><a href="#Img-标签和-src属性：" class="headerlink" title="Img 标签和 src属性："></a>Img 标签和 src属性：</h4><p>在 HTML 里面，图像是由<img>标签定义的。</p><p><img>是空标签，意思是说，它只拥有属性，而没有结束标签。</p><p>想要在页面上显示一个图像，需要使用 src属性。<br>“src”表示“源”的意思。“src”属性的值是所要显示图像的 URL。</p><h5 id="插入图像的语法："><a href="#插入图像的语法：" class="headerlink" title="插入图像的语法："></a>插入图像的语法：</h5><p>URL 指向图像存储的地址。</p><p>alt 属性：</p><p>alt 属性用来给图像显示一个“交互文本”。<br>alt 属性的值是由用户定义的。</p><p>“alt”属性在浏览器装载图像失败的时候告诉用户所丢失的信息，此时，浏览器显示这个“交互文本”来代替图像。给页面上的图像都加上 alt 属性是一个好习惯，它有助于更好地显示信息，而且，对纯文本浏览器很有用。</p><h5 id="基本注意点——有用的技巧"><a href="#基本注意点——有用的技巧" class="headerlink" title="基本注意点——有用的技巧:"></a>基本注意点——有用的技巧:</h5><p>如果一个 HTML 文档包含 10 个图像，那么为了正确显示这个页面，需要加载 11 个文件 。<br>加载图像是需要时间的，所以请谨慎使用图像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;./images/hackanm.gif&quot; width=&quot;20&quot; height=&quot;20&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;body background=&quot;./images/background.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;back.htm&quot;&gt;</span><br><span class="line">&lt;img border=&quot;0&quot; src=&quot;./images/next.gif&quot;&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="超链相关标签"><a href="#超链相关标签" class="headerlink" title="超链相关标签"></a>超链相关标签</h2><h3 id="锚标签和-href-属性："><a href="#锚标签和-href-属性：" class="headerlink" title="锚标签和 href 属性："></a>锚标签和 href 属性：</h3><p>HTML 使用锚标签（<a>）来创建一个连接到其他文件的链接。<br>锚可以指向网络上的任何资源：HTML 页面，图像，声音，影片等等。</a></p><p>标签<a>被用来创建一个链接指向的锚，href 属性用来指定连接到的地址，在锚的起始标签<a>和结束标签</a>中间的部分将被显示为超级链接。</a></p><h4 id="target-属性："><a href="#target-属性：" class="headerlink" title="target 属性："></a>target 属性：</h4><p>使用 target 属性，你可以定义从什么地方打开链接地址。</p><h4 id="锚标签和-name-属性"><a href="#锚标签和-name-属性" class="headerlink" title="锚标签和 name 属性"></a>锚标签和 name 属性</h4><p>name 属性用来创建一个命名的锚。使用命名锚以后，可以让链接直接跳转到一个页面的某一章节，而不用用户打开那一页，再从上到下慢慢找。</p><p>下面是命名锚的语法：</p><p>你可以为锚随意指定名字，只要你愿意。</p><h4 id="基本注意点——有用的技巧："><a href="#基本注意点——有用的技巧：" class="headerlink" title="基本注意点——有用的技巧："></a>基本注意点——有用的技巧：</h4><p>命名锚通常用来在大型文档的开头创建章节表。这个页面的每个章节被加上一个命名锚，到这些锚的链接被放在页面的顶端。</p><p>如果浏览器无法找到指定的命名锚，它将转到这个页面的顶部，而不显示任何错误提示。</p><h4 id="更多示例："><a href="#更多示例：" class="headerlink" title="更多示例："></a>更多示例：</h4><p>在新浏览器窗口中打开链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=&quot;lastpage.htm&quot; target=&quot;_blank&quot;&gt;Last Page&lt;/a&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">If you set the target attribute of a link to &quot;_blank&quot;,</span><br><span class="line">the link will open in a new window.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="用-HTML-创建表格"><a href="#用-HTML-创建表格" class="headerlink" title="用 HTML  创建表格"></a>用 HTML  创建表格</h2><ul><li><p>了解掌握表格的基本结构<table><tr><th></th><td></td></tr></table></p></li><li><p>掌握跨行、跨列属性 colspan rowspan</p></li><li><p>掌 握 表 格 相 关 修 饰 属 性 border width height bgcolor</p></li><li><p>background height cellpadding cellspacing</p></li></ul><h2 id="HTML-表格"><a href="#HTML-表格" class="headerlink" title="HTML  表格"></a>HTML  表格</h2><p>表格 :</p><p>表格是用<table>标签定义的。</table></p><p>表格被划分为行（使用<tr>标签），每行又被划分为数据单</tr></p><p>元格（使用<td>标签）。td 表示“表格数据”（ Table Data），即数据单元格的内容。</td></p><h4 id="数据单元格可以包含文本，图像，列表，段落，表单，水平线，表格等等。想不想尝试一下？"><a href="#数据单元格可以包含文本，图像，列表，段落，表单，水平线，表格等等。想不想尝试一下？" class="headerlink" title="数据单元格可以包含文本，图像，列表，段落，表单，水平线，表格等等。想不想尝试一下？"></a>数据单元格可以包含文本，图像，列表，段落，表单，水平线，表格等等。想不想尝试一下？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;td&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;caption&gt;table title and/or explanatory text&lt;/caption&gt;</span><br><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;header&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;data&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;table border=&quot;1&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;th colspan=&quot;&quot; rowspan=&quot;&quot; headers=&quot;&quot; scope=&quot;&quot;&gt;&lt;/th&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;td&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/td&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;td&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;td&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h2 id="基本注意点——有用的技巧-1"><a href="#基本注意点——有用的技巧-1" class="headerlink" title="基本注意点——有用的技巧"></a>基本注意点——有用的技巧</h2><p>通常很少使用<thead>，<tbody>，<tfoot>标签，因为浏览器对它们的支持不好。希望这<br>个在 XHTML 的未来版本中得到改变。</tfoot></tbody></thead></p><blockquote><p>cellpadding 属性在表格内容和边框之间留出更多空白<br>cellspacing 属性来增加单元格间距<br>使用“align”属性来设置单元格的对齐方式</p></blockquote><h2 id="HTML-表单页面的运用"><a href="#HTML-表单页面的运用" class="headerlink" title="HTML  表单页面的运用"></a>HTML  表单页面的运用</h2><p>掌握表单基本结构<form><br>掌握各种表单元素<br>能理解 post 和 get 两种提交方式的区别</form></p><h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML  表单"></a>HTML  表单</h2><p>表单：<br>表单是一个能够包含表单元素的区域。</p><p>表单元素是能够让用户在表单中输入信息的元素（比如文本框，密码框，下拉菜单，单<br>选框，复选框等等）。</p><h2 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h2><p>最常用的表单标签是<input>标签。Input 的类型用 type属性指定。最常用的 input 类型解释如下：</p><p>文本框：在表单中，文本框用来让用户输入字母、数字等等。</p><p>表单的 action 属性和提交按钮：<br>当用户点击提交按钮的时候，表单的内容会被提交到其他文件。</p><p>表单的 action 属性定义了所要提交到的目的文件，该目的文件收到信息后通常进行相关的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form name=&quot;input&quot; action=&quot;xxxx&quot; method=&quot;get&quot;&gt;</span><br><span class="line"> &lt;input type=&quot;&quot; name=&quot;&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>简单的下拉列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;select name=&quot;cars&quot;&gt;</span><br><span class="line">&lt;option value=&quot;volvo&quot;&gt;Volvo</span><br><span class="line">&lt;option value=&quot;saab&quot;&gt;Saab</span><br><span class="line">&lt;option value=&quot;fiat&quot;&gt;Fiat</span><br><span class="line">&lt;option value=&quot;audi&quot;&gt;Audi</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>创建一个含有预先选定元素的下拉列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">文本域：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line"> This example demonstrates a text-area.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;textarea rows=&quot;10&quot; cols=&quot;30&quot;&gt;</span><br><span class="line"> The cat was playing in the garden.</span><br><span class="line">&lt;/textarea&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Hello world!&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">&lt;legend&gt;</span><br><span class="line"> Health information:</span><br><span class="line">&lt;/legend&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">     Height&lt;input type=&quot;text&quot; size=&quot;3&quot;&gt;</span><br><span class="line"> Weight&lt;input type=&quot;text&quot; size=&quot;3&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line"> If there is no border around the input form, your browser is too old.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;x&quot; method=&quot;post&quot;</span><br><span class="line">enctype=&quot;text/plain&quot;&gt;</span><br><span class="line">&lt;h3&gt;xxxxxxxxxxx&lt;/h3&gt;</span><br><span class="line"> Name:&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;yourname&quot; size=&quot;20&quot;&gt;</span><br><span class="line"> &lt;br&gt;</span><br><span class="line"> Mail:&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;mail&quot; value=&quot;yourmail&quot; size=&quot;20&quot;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"> Comment:&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;comment&quot; value=&quot;yourcomment&quot; size=&quot;40&quot;&gt;</span><br><span class="line"> &lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;Send&quot;&gt;</span><br><span class="line">&lt;input type=&quot;reset&quot; value=&quot;Reset&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="使用样式表美化页面-1-1"><a href="#使用样式表美化页面-1-1" class="headerlink" title="使用样式表美化页面 1 1"></a>使用样式表美化页面 1 1</h2><p>掌握在网页中使用 CSS 的方法<br>熟悉 CSS 的不同选择器的使用方法<br>熟悉字体属性：font-family，font-size，font-style，<br>font-weight<br>熟悉文本属性：text-align，text-indent，text-decoration，<br>text-transform，vertical-align，word-spacing，<br>letter-spacing</p><h2 id="CSS-的工作原理"><a href="#CSS-的工作原理" class="headerlink" title="CSS  的工作原理"></a>CSS  的工作原理</h2><p>在这一节，你将学习如何制作自己的第一个样式表。</p><p>你将了解基本的 CSS 模型，以及在HTML 文档里使用 CSS 所必需的代码。</p><p>级联样式表（CSS）里用到的许多 CSS 属性都与 HTML 属性相似，所以，假如你熟悉<br>采用 HTML 进行布局的话，那么这里的许多代码你都不会感到陌生。我们先来看一个具<br>体的例子。</p><h2 id="基本的-CSS-语法："><a href="#基本的-CSS-语法：" class="headerlink" title="基本的 CSS 语法："></a>基本的 CSS 语法：</h2><p>比方说，我们要用红色作为网页的背景色：<br>用  L HTML 的话，我们可以这样：<br>用  CSS的话，我们可以这样获得同样的效果：</p><h4 id="为一个-HTML-文档应用-CSS："><a href="#为一个-HTML-文档应用-CSS：" class="headerlink" title="为一个 HTML 文档应用 CSS："></a>为一个 HTML 文档应用 CSS：</h4><p>为 HTML 文档应用 CSS，有三种方法可供选择。</p><p>下面对这三种方法进行了概括。我们建议你对第三种方法（即外部样式表）予以关注。</p><p>方法 1：行内样式表（style 属性）</p><p>方法 2：内部样式表（style 元素）</p><p>方法 3：外部样式表（引用一个样式表文件）</p><h2 id="元素的分类与标识（-class-和-和-id-）"><a href="#元素的分类与标识（-class-和-和-id-）" class="headerlink" title="元素的分类与标识（ class  和 和  id ）"></a>元素的分类与标识（ class  和 和  id ）</h2><p>有时，你希望对特定元素或者特定一组元素应用特殊的样式。<br>在这一节，我们将深入学习如何利用 class 和 id 来为所选元素指定属性。</p><p>如何实现为网站上许多标题中的某一个单独应用颜色？<br>如何实现把网站上的链接分为不同的类，并对各类链接分别应用不同的样式？<br>这只是本节将解决的诸多问题中的最具代表性的两个问题。</p><h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><p>这一节，你将学习字体以及如何用 CSS 来设置字体。我们还会考虑如何解决“网站所选<br>的字体仅当访问者的 PC 上安装有该字体时才会被显示”这一难题。本节将对下列 CSS<br>属性进行讲解：</p><p>• font-family<br>• font-style<br>• font-variant<br>• font-weight<br>• font-size<br>• font</p><h4 id="字体族-font-family-："><a href="#字体族-font-family-：" class="headerlink" title="字体族[font-family]："></a>字体族[font-family]：</h4><p>CSS 属性 font-family 的作用是设置一组按优先级排序的字体列表，如果该列表中的<br>第一个字体未在访问者计算机上安装，那么就尝试列表中的下一个字体，依此类推，直<br>到列表中的某个字体是已安装的。</p><p>有两种类型的名称可用于分类字体：字体族名称（family-name）和族类名称（generic<br>family）。下面来解释这两个术语。</p><p>字体族名称（family-name）：</p><p>字体族名称（就是我们通常所说的“字体”）的例子包括<br>“Arial”、“Times New Roman” 、“宋体”、“黑体”等等。</p><p>字体样式[font-style]：<br>CSS 属性 font-style 定义所选字体的显示样式： normal （正常）、 c italic （斜体）或  oblique<br>（倾斜）。</p><p>字体变化[font-variant]：<br>CSS 属性 font-variant 的值可以是： normal（正常）或  s small-caps（小体大写字母） 。<br>small-caps 字体是一种以小尺寸显示的大写字母来代替小写字母的字体。</p><p>字体浓淡[font-weight]：<br>CSS 属性 font-weight 指定字体显示的浓淡程度。其值可以是  l normal（正常）或  bold<br>（加粗）。</p><p>字体大小[font-size]：<br>字体的大小用 CSS 属性 font-size 来设置。字体大小可通过多种不同单位（比如像素或百分比等）来设置。</p><h2 id="文本-属性"><a href="#文本-属性" class="headerlink" title="文本 属性"></a>文本 属性</h2><p>文本的显示格式与式样对于网页设计师来说是一个重要问题。<br>这一节将向你介绍 CSS 在文本布局方面令人激动的特性。本节将对下列 CSS 属性进行讲解：</p><p>• text-indent<br>• text-align<br>• text-decoration<br>• letter-spacing<br>• text-transform</p><p>文本缩进[text-indent]：<br>CSS 属性 text-indent 用于为段落设置首行缩进，以令其具有美观的格式。</p><p>文本对齐[text-align]：<br>CSS 属性 text-align 与 HTML 属性 align 的功能相同。该属性的值可以是：<br>left（左对齐）、 right（右对齐）或者  center（居中）。</p><p>文本装饰[text-decoration]：<br>CSS 属性 text-decoration 令我们可以为文本增添不同的“装饰”或“效果”。</p><p>字符间距[letter-spacing]：<br>CSS 属性 letter-spacing 用于设置文本的水平字间距。</p><p>文本转换[text-transform]：<br>CSS 属性 text-transform 用于控制文本的大小写。<br>无论字母本来的大小写，你可以通过该属性令它<br>首字母大写（capitalize）、全部大写（uppercase）或者全部小写（lowercase）。</p><h2 id="使用样式表美化页面"><a href="#使用样式表美化页面" class="headerlink" title="使用样式表美化页面"></a>使用样式表美化页面</h2><p>熟悉显示属性：display<br>熟悉边框属性：Border , border-style 等<br>熟悉定位属性：top , Width , Height , Left</p><h4 id="显示-属性"><a href="#显示-属性" class="headerlink" title="显示 属性"></a>显示 属性</h4><p>显示属性允许使用四个值中的一个来定义一个元素：<br>block ：在元素的前和后都会有换行<br>inline ：在元素的前和后都不会有换行<br>list-item ：与 block 相同，但增加了目录项标记<br>none ：没有显示</p><h2 id="边框-属性"><a href="#边框-属性" class="headerlink" title="边框 属性"></a>边框 属性</h2><p>边框（border）可以有多种用途，比如作为装饰元素或者作为划分两物的分界线。在设<br>置边框方面，CSS 为你提供了无尽选择。</p><p>• border-width<br>• border-color<br>• border-style</p><h2 id="边框宽度-border-width-："><a href="#边框宽度-border-width-：" class="headerlink" title="边框宽度[border-width]："></a>边框宽度[border-width]：</h2><p>边框宽度由 CSS 属性 border-width 定义，其值可以是“thin”（薄）、“medium”（普通 ）<br>或“thick”（厚）等，也可以是像素值。</p><h2 id="边框颜色-border-color-："><a href="#边框颜色-border-color-：" class="headerlink" title="边框颜色[border-color]："></a>边框颜色[border-color]：</h2><p>CSS 属性 border-color 用于定义边框的颜色。其值就是正常的颜色值，例如：“#123456”、<br>“rgb(123,123,123)”、“yellow”等。</p><h2 id="边框样式-border-style-："><a href="#边框样式-border-style-：" class="headerlink" title="边框样式[border-style]："></a>边框样式[border-style]：</h2><p>边框样式有多种可供选择。</p><h2 id="缩写-border-："><a href="#缩写-border-：" class="headerlink" title="缩写[border]："></a>缩写[border]：</h2><p>跟许多其他属性一样，你也可以将有关边框的 CSS 属性缩写为一个 border 属性。</p><h2 id="相对定位："><a href="#相对定位：" class="headerlink" title="相对定位："></a>相对定位：</h2><p>要对元素进行相对定位，应将 position 属性的值设为relative。<br>绝对定位与相对定位的区别在于计算位置的方式。</p><p>采用相对定位的元素，其位置是相对于它在文档中的原始位置计算而来的。<br>这意味着 ，相对定位是通过将元素从原来的位置向右、向左、向上或向下移动来定位的。<br>采用相对定位的元素会获得相应的空间。</p><h2 id="HTML-中框架、层的运用"><a href="#HTML-中框架、层的运用" class="headerlink" title="HTML  中框架、层的运用"></a>HTML  中框架、层的运用</h2><p>掌握框架结构<frameset><frame><iframe><br>掌握组织元素：span 和 div</iframe></frameset></p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>使用框架，可以在一个浏览器窗口中显示不止一个 HTML 文档。<br>这样的 HTML 文档被称为框架页面，它们是相互独立的。：</p><p>使用框架的不利因素有：</p><p>• 网站开发者需要关心更多 HTML 文档的情况。<br>• 打印整个页面变得困难。</p><p>frameset 标签：</p><p>• <frameset>标签定义了如何将窗口拆分成框架。<br>• 每个 frameset 标签定义了一组行和列。<br>• 行/列的值指明了每个行/列在屏幕上所占的大小</frameset></p><p>frame标签：</p><p>• <frame>标签定义了每个框架中放入什么文件。</p><p>基本注意点——有用的技巧：</p><p>假如一个框架有可见边框，用户可以拖动边框来改变它的大小。<br>如果不想让用户改变大小，可以在<frame>标签中加入：noresize=”noresize”。<br>给不支持框架的浏览器写上<noframes>标签。</noframes></p><h2 id="内联框架："><a href="#内联框架：" class="headerlink" title="内联框架："></a>内联框架：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;iframe src=&quot;intro.htm&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;p&gt;Some older browsers don&apos;t support iframes.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;If they don&apos;t, the iframe will not be visible.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="组织元素-：-span-和-和-div"><a href="#组织元素-：-span-和-和-div" class="headerlink" title="组织元素 ： span  和 和  div"></a>组织元素 ： span  和 和  div</h2><p>span 和 div 元素用于组织和结构化文档，并经常联合 class 和 id 属性一起使用。</p><p>用 span 组织元素：</p><p>span 元素可以说是一种中性元素，因为它不对文档本身添加任何东西。<br>但是与 CSS 结合使用的话，span 可以对文档中的部分文本增添视觉效果。</p><h2 id="XML-基本知识"><a href="#XML-基本知识" class="headerlink" title="XML  基本知识"></a>XML  基本知识</h2><p>XML  的应用范围<br>人类一直在不断地尝试改进自己的发明，其中也包括人类最伟大的发明——文字的构成。<br>第一个文本处理系统是用纸笔记录文字。现在，计算机文本处理器已经取代了手工处理，它不仅包含原始文档，还负责设置格式、出版和管理。在这些方便的功能整合到字处理之前，是由排字工人遵循书面标记说明来完成所有格式编排的。<br>正是利益于这种实践，人们将“标记”这个词加入到 HTML 和 XML。顾名思义，标记是指加上记号。<br>文本处理环境（如 XML）中使用了相同的标记过程。</p><p>使用脚本语言或 DHTML 能够以各种方式显示信息。<br>这就要求必须为相同的输出编写不同的代码以供不同的浏览器使用，因为这些语言不能跨浏览器兼容。</p><p>XML（eXtensible Markup Language，可扩展标记语言）克服了这些缺点。<br>顾名思义，XM L是可扩展的，即开发人员可以定义自己的一组标签，并使其他的人或程序能够理解这些标签。</p><p>HTML 是单标记语言，为特定应用设计，而 XML 则是一系列的标记语言。<br>因此 ，XML 比 HTML 灵活得多。</p><p>实际上，由于 XML 标签表示了数据的逻辑结构，不同的应用可以通过不同的方式来解释和使用这些标签。<br>Web 上的数据大多是继承的，XML 继承了 SGML 和 HTML 的优点。<br>也就是说，它不仅继承了 SGML 的特色，还结合了 HTM L的特色。</p><p>它采用了 SGML 的主要框架，有时，人们也将 XML 称为 SGML 的子集。<br>因此 ，HTML 是 SGML 的应用，而 XML 是 SGML 的子集。</p><p>使用标签对文档进行标记以提供有关内容的信息，不仅能加快搜索速度，而且还能降低网络流量。<br>XML 是由 SGML 修整并改造而来，它是一种元语言，用于描述其他语言。</p><p>我们可以使用 XML 为特定目的创建自己的标记语言（如化学标记语言）。</p><p>XML 是基于文本的格式，允许开发人员描述结构化数据并在各种应用之间发送和交换这些数据，这样客户端就可以显示并自定义数据。</p><p>XML 还有助于在服务器之间传输结构化数据。</p><p>有许多信息是分布在不同的和不匹配的数据库中。</p><p>如有必要，XML 允许通过使用自定义格式来标识、交换和处理这些数据库可以理解的数据。</p><p>XML 和 HTML 有许多相同点和不同点。XML描述数据，如城市名称、温度和气压；HTML定义描述数据显示方式的标签，如使用项目符号列表或表格。</p><p>但 XML 允许开发人员定义任意数量的标签集，使用开发人员有很大的灵活性来决定要使用哪些数据，并确定数据的适用标准或自定义标签。</p><h2 id="L-XML-的-文档-结构"><a href="#L-XML-的-文档-结构" class="headerlink" title="L XML  的 文档 结构"></a>L XML  的 文档 结构</h2><p>XML 文档是由一组使用唯一名称标识的实体组成。</p><p>所有文档都以根或文档实体开始，而且所有实体都是可选的。</p><p>实体可以被视为更复杂功能的别名。单个实体名称可以代替许多文本。</p><p>在别名方案中，每当需要引用某个文本时，只需要使用别名，处理器会展开别名的内容。</p><p>XML 文档也有一种逻辑结构。</p><p>ok,完</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HTML" scheme="https://huangguangda.github.io/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://huangguangda.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>必背面试题</title>
    <link href="https://huangguangda.github.io/2018/05/16/1/"/>
    <id>https://huangguangda.github.io/2018/05/16/1/</id>
    <published>2018-05-16T00:57:24.000Z</published>
    <updated>2018-07-23T18:37:59.919Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>1 抽象类和接口的区别?</p><p>抽象类：</p><p>1）抽象方法，只有行为的概念，没有具体的行为实现。使用abstract关键字修饰，没有方法体。子类必须重写这些抽象方法。<br>2）包含抽象方法的类，一定是抽象类。<br>3）抽象类只能被继承，一个类只能继承一个抽象类。</p><p>接口：</p><p>1）全部的方法都是抽象方法，属型都是常量<br>2）不能实例化，可以定义变量。<br>3）接口变量可以引用具体实现类的实例<br>4）接口只能被实现，一个具体类实现接口，必须实现全部的抽象方法<br>5）接口之间可以多实现<br>6）一个具体类可以实现多个接口，实现多继承现象</p><h2 id="列举你所知道的线程同步的方法"><a href="#列举你所知道的线程同步的方法" class="headerlink" title="列举你所知道的线程同步的方法"></a>列举你所知道的线程同步的方法</h2><p>wait():让线程等待。将线程存储到一个线程池中。</p><p>notify()：唤醒被等待的线程。通常都唤醒线程池中的第一个。让被唤醒的线程处于临时阻塞状态。</p><p>notifyAll(): 唤醒所有的等待线程。将线程池中的所有线程都唤醒。</p><h2 id="简述String和StringBuffer、ArrayList和LinkedList、HashMap和HashTable的特点及区别。"><a href="#简述String和StringBuffer、ArrayList和LinkedList、HashMap和HashTable的特点及区别。" class="headerlink" title="简述String和StringBuffer、ArrayList和LinkedList、HashMap和HashTable的特点及区别。"></a>简述String和StringBuffer、ArrayList和LinkedList、HashMap和HashTable的特点及区别。</h2><p>答:</p><p>String 对象的长度一旦定义就固定就不可以改变，</p><p>对于已经存在的String对象的修改都是创建一个新的对象，</p><p>然后把新的值存进去,</p><p>String类不能被继承。</p><p>StringBuffer是一个可变对象，</p><p>当对它进行修改的时候不会像String那样重新建立对象。</p><p>它只能通过构造函数来建立对象。</p><p>另外StringBuffer还是一个线程安全的类。</p><p>ArrayList是实现了基于动态数组的数据结构用于，LinkedList基于连表的数据结构，</p><p>二者都可以存储对象的引用。</p><p>对于随机访问get和set，ArrayList优于LinkedList，</p><p>因为LinkedList要移动指针。</p><p>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），</p><p>他们都完成了Map接口，</p><p>主要区别在于HashMap允许空（null）键值（key）,</p><p>由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。</p><p>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p><p>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。</p><p>因为contains方法容易让人引起误解。</p><p>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</p><p>最大的不同是，</p><p>Hashtable的方法是Synchronize的，而HashMap不是，</p><p>在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</p><p>Hashtable和HashMap</p><p>采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</p><p>就HashMap与HashTable主要从三方面来说。</p><p>一. 历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现<br>二. 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的<br>三. 值：只有HashMap可以让你将空值作为一个表的条目的key或value</p><h2 id="什么是java序列化，如何事件java序列化"><a href="#什么是java序列化，如何事件java序列化" class="headerlink" title="什么是java序列化，如何事件java序列化"></a>什么是java序列化，如何事件java序列化</h2><p>序列化就是一种用来处理对象流的机制，<br>所谓对象流也就是将对象的内容进行流化。</p><p>可以对流化后的对象进行读写操作，<br>也可将流化后的对象传输于网络之间。</p><p>序列化是为了解决在对对象流进行读写操作时所引发的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Cat implements Serializable ｛｝</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">Try&#123;</span><br><span class="line">   FileOutputStream fos = new FileOutputStream(&quot;catDemo.out&quot;);</span><br><span class="line">   ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class="line">   System.out.println(&quot; 1&gt; &quot; + cat.getName());</span><br><span class="line">   cat.setName(&quot;My Cat&quot;);                        </span><br><span class="line">   oos.writeObject(cat);</span><br><span class="line">   oos.close();        </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="多线程有几种实现方式，同步有几种实现方式，stop-和suspend-方法为什么不推荐使用"><a href="#多线程有几种实现方式，同步有几种实现方式，stop-和suspend-方法为什么不推荐使用" class="headerlink" title="多线程有几种实现方式，同步有几种实现方式，stop()和suspend()方法为什么不推荐使用"></a>多线程有几种实现方式，同步有几种实现方式，stop()和suspend()方法为什么不推荐使用</h2><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 </p><p>同步的实现方面有两种，分别是synchronized,wait与notify”</p><p>反对使用stop()，是因为它不安全。</p><p>它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。</p><p>结果很难检查出真正的问题所在。</p><p>suspend()方法容易发生死锁。 </p><p>调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。</p><p>此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。</p><p>对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。</p><p>所以不应该使用suspend()，而应在自己的 Thread类中置入一个标志，</p><h2 id="简述你对java反射机制的理解"><a href="#简述你对java反射机制的理解" class="headerlink" title="简述你对java反射机制的理解"></a>简述你对java反射机制的理解</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</p><p>对于任意一个对象，都能够调用它的任意一个方法和属性</p><h2 id="写下你对多线程的理解，怎么创建一个线程以及线程同步的方法。"><a href="#写下你对多线程的理解，怎么创建一个线程以及线程同步的方法。" class="headerlink" title="写下你对多线程的理解，怎么创建一个线程以及线程同步的方法。"></a>写下你对多线程的理解，怎么创建一个线程以及线程同步的方法。</h2><p>1.多线程是操作系统的重要部分，可以提高应用程序的效率，将耗时操作放进工作线程，可以有效提高用户体验。</p><p>2.new Thread().start，在方法中重写run方法；新建类实现Runable接口，重写其抽象方法</p><p>3.public static synchronized void test() {  }<br>  public void test2() { synchronized(lock){  }}</p><h2 id="从操作系统角度请阐述一下线程与进程的区别"><a href="#从操作系统角度请阐述一下线程与进程的区别" class="headerlink" title="从操作系统角度请阐述一下线程与进程的区别"></a>从操作系统角度请阐述一下线程与进程的区别</h2><p>答：</p><p>进程是系统进行资源分配和调度的一个独立单位，线程是CPU调度和分派的基本单位</p><p>进程和线程的关系：</p><p>（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</p><p>（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。</p><p>（3）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p>（5）线程是指进程内的一个执行单元，也是进程内的可调度实体。</p><p>线程与进程的区别：</p><p>（1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。</p><p>（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。</p><p>（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p><p>（4）系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。</p><h2 id="Android系统的架构，采用了分层的架构，从高层到底层分别是："><a href="#Android系统的架构，采用了分层的架构，从高层到底层分别是：" class="headerlink" title="Android系统的架构，采用了分层的架构，从高层到底层分别是："></a>Android系统的架构，采用了分层的架构，从高层到底层分别是：</h2><p>1.Android系统架构之应用程序</p><p>Android会同一系列核心应用程序包一起发布，该应用程序包包括email客户端，SMS短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA语言编写的。</p><p>2.Android系统架构之应用程序框架</p><p>开发人员可以完全访问核心应用程序所使用的API框架（android.jar）。该应用程序的架构设计简化了组件的重用;任何一个应用程序都可以发布它的功能块并且任何其它的应用程序都可以使用其所发布的功能块。</p><p>3.Android系统架构之系统运行库</p><p>1)程序库<br>Android 包含一些C/C++库，这些库能被Android系统中不同的组件使用。它们通过 Android 应用程序框架为开发者提供服务。</p><p>4.Android系统架构之Linux 内核</p><p>Android 的核心系统服务依赖于 Linux 2.6 内核，如安全性，内存管理，进程管理， 网络协议栈和驱动模型。 Linux 内核也同时作为硬件和软件栈之间的抽象层。</p><h2 id="消息推送的方式有哪几种，每种方式的优缺点是什么？"><a href="#消息推送的方式有哪几种，每种方式的优缺点是什么？" class="headerlink" title="消息推送的方式有哪几种，每种方式的优缺点是什么？"></a>消息推送的方式有哪几种，每种方式的优缺点是什么？</h2><p>前Android上主要的推送实现方案有以下几种：</p><p>方案1、使用极光和友盟推送。</p><p>方案2、使用XMPP协议（Openfire + Spark + Smack）</p><p>简介：基于XML协议的通讯协议，前身是Jabber，目前已由IETF国际标准化组织完成了标准化工作。</p><p>优点：协议成熟、强大、可扩展性强、目前主要应用于许多聊天系统中，且已有开源的Java版的开发实例androidpn。</p><p>缺点：协议较复杂、冗余（基于XML）、费流量、费电，部署硬件成本高。</p><p>方案3、使用MQTT协议（更多信息见：<a href="http://mqtt.org/）" target="_blank" rel="noopener">http://mqtt.org/）</a></p><p>简介：轻量级的、基于代理的“发布/订阅”模式的消息传输协议。</p><p>优点：协议简洁、小巧、可扩展性强、省流量、省电，目前已经应用到企业领域（参考：<a href="http://mqtt.org/software），且已有C++版的服务端组件rsmb。" target="_blank" rel="noopener">http://mqtt.org/software），且已有C++版的服务端组件rsmb。</a></p><p>缺点：不够成熟、实现较复杂、服务端组件rsmb不开源，部署硬件成本较高。</p><p>方案4、使用HTTP轮循方式</p><p>简介：定时向HTTP服务端接口（Web Service API）获取最新消息。</p><p>优点：实现简单、可控性强，部署硬件成本低。</p><p>缺点：实时性差。</p><h2 id="android的数据存储的方式"><a href="#android的数据存储的方式" class="headerlink" title="android的数据存储的方式?"></a>android的数据存储的方式?</h2><p>答：</p><p>Android提供了5种方式存储数据：</p><p>（1）使用SharedPreferences存储数据；</p><p>它是Android提供的用来存储一些简单配置信息的一种机制，采用了XML格式将数据存储到设备中。只能在同一个包内使用，不能在不同的包之间使用。</p><p>（2）文件存储数据；</p><p>文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。</p><p>（3）SQLite数据库存储数据；</p><p>SQLite是Android所带的一个标准的数据库，它支持SQL语句，它是一个轻量级的嵌入式数据库。</p><p>（4）使用ContentProvider存储数据；</p><p>主要用于应用程序之间进行数据交换，从而能够让其他的应用保存或读取此Content Provider的各种数据类型。</p><p>（5）网络存储数据；</p><p>通过网络上提供给我们的存储空间来上传(存储)和下载(获取)我们存储在网络空间中的数据信息。</p><h2 id="横竖屏切换时候activity的生命周期"><a href="#横竖屏切换时候activity的生命周期" class="headerlink" title="横竖屏切换时候activity的生命周期?"></a>横竖屏切换时候activity的生命周期?</h2><p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新 调用各个生命周期，只会执行onConfigurationChanged方法</p><h2 id="Android中动画分为哪几类-他们的特点和区分有那些"><a href="#Android中动画分为哪几类-他们的特点和区分有那些" class="headerlink" title="Android中动画分为哪几类?他们的特点和区分有那些?"></a>Android中动画分为哪几类?他们的特点和区分有那些?</h2><p>一种是tweened animation(补间动画) </p><p>一种是frame by frame(逐帧动画) </p><p>特点：</p><p>补间动画是通过改变view的大小、旋转的角度、透明度、位置来产生动画，可以控制动画的播放快慢以及加速度。</p><p>逐帧动画是用一组图片轮流绘制，产生动画的感觉。类似于gif图片。</p><p>区别：</p><p>补间动画的所有操作是通过矩阵变换对同一个物体（绘制的一个view或者图片）进行操作产生动画。</p><p>而逐帧动画是多个物体（多张图片）进行绘制，可以说这多张图片是不相关的（从播放的角度来看只能说是内容相关）。</p><h2 id="请解释下在单线程模式中Message-Handler-MessageQueue-Looper之间的关系解释下"><a href="#请解释下在单线程模式中Message-Handler-MessageQueue-Looper之间的关系解释下" class="headerlink" title="请解释下在单线程模式中Message,Handler,MessageQueue,Looper之间的关系解释下."></a>请解释下在单线程模式中Message,Handler,MessageQueue,Looper之间的关系解释下.</h2><p>Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理. </p><p>Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列. </p><p>Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息. </p><p>Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。 </p><p>Looper也把消息队列里的消息广播给所有的Handler：Handler接受到消息后调用handleMessage进行处理.</p><h2 id="说说mvc模式的原理-它在android中的运用"><a href="#说说mvc模式的原理-它在android中的运用" class="headerlink" title="说说mvc模式的原理,它在android中的运用"></a>说说mvc模式的原理,它在android中的运用</h2><p>答：</p><p>android的官方建议应用程序的开发采用mvc模式。何谓mvc？</p><p>mvc是model,view,controller的缩写，mvc包含三个部分：</p><p>l模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。</p><p>2视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。</p><p>3控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，想用用户出发的相关事件，交给m哦得了处理。</p><p>在android中mvc的具体体现如下：</p><p>  1)视图层（view）：</p><p>一般采用xml文件进行界面的描述，</p><p>使用的时候可以非常方便的引入，当然，如何你对android了解的比较的多了话，就一定 可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通 信，幸运的是，android提供了它们之间非常方便的通信实现。</p><p>　2)控制层（controller）：</p><p>android的控制层的重 任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理， 这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。</p><p>　3)模型层（model）：</p><p>对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p><h2 id="请描述下Activity的生命周期"><a href="#请描述下Activity的生命周期" class="headerlink" title="请描述下Activity的生命周期."></a>请描述下Activity的生命周期.</h2><p>onCreate(Bundle savedInstanceState)：创建activity时调用。</p><p>设置在该方法中，还以Bundle的形式提供对以前储存的任何状态的访问！</p><p>onStart()：activity变为在屏幕上对用户可见时调用。</p><p>onResume()：activity开始与用户交互时调用（无论是启动还是重新启动一个活动，该方法总是被调用的）。 </p><p>onPause()：activity被暂停或收回cpu和其他资源时调用，该方法用于保存活动状态的，也是保护现场，压栈吧！</p><p>onStop()：activity被停止并转为不可见阶段及后续的生命周期事件时调用。</p><p>onRestart()：重新启动activity时调用。该活动仍在栈中，而不是启动新的活动。</p><p>OnDestroy()：activity被完全从系统内存中移除时调用该方法</p><h2 id="Android中4大组件有哪些-他们的作用是什么"><a href="#Android中4大组件有哪些-他们的作用是什么" class="headerlink" title="Android中4大组件有哪些?他们的作用是什么?"></a>Android中4大组件有哪些?他们的作用是什么?</h2><p>Activity：</p><p>Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑。 </p><p>service：</p><p>后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事务，定义好需要接受的Intent提供同步和异步的接口。 </p><p>Content Provider：</p><p>是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的接口模型，大大简化上层应用，对数据的整合提 供了更方便的途径。 </p><p>BroadCast Receiver：</p><p>接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型。 </p><h2 id="Activity有哪4种启动模式-有哪些特点"><a href="#Activity有哪4种启动模式-有哪些特点" class="headerlink" title="Activity有哪4种启动模式?有哪些特点?"></a>Activity有哪4种启动模式?有哪些特点?</h2><p>standard 默认模式 ——— 来了intent，每次都创建新的实例。</p><p>singleTop ——– 来了intent, 每次都创建新的实例，仅一个例外：当栈顶的activity恰恰就是该activity的实例（即需要创建的实例)时，不再创建新实例。</p><p>这解决了栈顶复用问题，想一想，你按两次back键，退出的都是同一个activity，这感觉肯定不爽。</p><p>singleTask ———- 来了intent后，检查栈中是否存在该activity的实例，如果存在就把intent发送给它，否则就创建一个新的该activity的实例，栈中只能有它一个该activity实例，但允许其他activity加入该栈。解决了在一 个task中共享一个activity。</p><p>singleInstance ———– 肯定位于一个task的栈底,并且是该栈唯一的activity。解决了多个task共享一个activity。</p><h2 id="注册广播有几种方式-这些方式有何特点"><a href="#注册广播有几种方式-这些方式有何特点" class="headerlink" title="注册广播有几种方式,这些方式有何特点?"></a>注册广播有几种方式,这些方式有何特点?</h2><p>1)动态代码注册不是常驻型广播，也就是说广播跟随程序的生命周期。</p><p>2)清单文件注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p><h2 id="谈谈对android内存优化的方法-方案-规则及对内存泄漏如何避免"><a href="#谈谈对android内存优化的方法-方案-规则及对内存泄漏如何避免" class="headerlink" title="谈谈对android内存优化的方法,方案,规则及对内存泄漏如何避免"></a>谈谈对android内存优化的方法,方案,规则及对内存泄漏如何避免</h2><p>OOM即Out Of Memory,一般是由程序编写者对内存使用不当，如对该释放的内存资源没有释放，导致其一直不能被再次使用而使内存被耗尽的现象。根本的解决办法是对代码进行优化:在内存引用上做些处理，使用软引用、虚引用、和弱引用；在内存中加载图片时直接在内存中做处理，如边界压缩等；建立动态回收内存机制；优化Dalvik虚拟机的堆内存分配；自定义堆内存大小等。</p><p>一般而言，android中常见的原因主要有以下几个：</p><p>1.数据库的cursor没有关闭。<br>2.构造adapter没有使用缓存contentview。<br>3.调用registerReceiver()后未调用unregisterReceiver().<br>4.未关闭InputStream/OutputStream。<br>5.Bitmap使用后未调用recycle()。<br>6.Context泄漏。<br>7.static关键字等。</p><h2 id="启动service有几种方式，说出他们之间的主要区别"><a href="#启动service有几种方式，说出他们之间的主要区别" class="headerlink" title="启动service有几种方式，说出他们之间的主要区别"></a>启动service有几种方式，说出他们之间的主要区别</h2><p>答：</p><p>调用startService()：通过此种方法启动的service会一直运行在后台直到stopService()或stopSelf()方法被调用。</p><p>调用bindService()：通过此种方法启动的service会与调用者绑定，如果这个service还没有被启动，那么service启动时将不会调用onStart()，只调用onCreate()和onBind()，调用者被销毁时，service也被销毁</p><h2 id="intent-putExtra时，如果传递的不是基本类型，而是一个”Object”，那么对这个对象有什么要求？还是说任何对象都可以进行传递？"><a href="#intent-putExtra时，如果传递的不是基本类型，而是一个”Object”，那么对这个对象有什么要求？还是说任何对象都可以进行传递？" class="headerlink" title="intent.putExtra时，如果传递的不是基本类型，而是一个”Object”，那么对这个对象有什么要求？还是说任何对象都可以进行传递？"></a>intent.putExtra时，如果传递的不是基本类型，而是一个”Object”，那么对这个对象有什么要求？还是说任何对象都可以进行传递？</h2><p>答：</p><p>必须实现Serializable接口，或者实现Parcelable接口的对象才可以进行传递。  </p><h2 id="当调用startActivityForResult时，如何获取并处理返回的结构"><a href="#当调用startActivityForResult时，如何获取并处理返回的结构" class="headerlink" title="当调用startActivityForResult时，如何获取并处理返回的结构"></a>当调用startActivityForResult时，如何获取并处理返回的结构</h2><p>答：</p><p>通过onActivityResult(int requestCode, int resultCode, Intent data)处理返回的数据<br>requestCode：调用startActivityForResult(Intent intent, int requestCode)时传递过去的请求码。</p><p>resultCode：被调用的Activity执行setResult(int resultCode, Intent intent)时传递的结果码，一般有RESULT_CANCELED，RESULT_OK等，用于区分被调用的Activity传回的不同结果</p><p>data：被调用的Activity传回来的数据，可以用data.getExtras()得到数据，用Bundle类型的变量来接收，调用get…(String key)来获取对应的值</p><h2 id="使用startService（）和bindService（）启一个Service，这个Sercice的生命周期会有哪里不同？"><a href="#使用startService（）和bindService（）启一个Service，这个Sercice的生命周期会有哪里不同？" class="headerlink" title="使用startService（）和bindService（）启一个Service，这个Sercice的生命周期会有哪里不同？"></a>使用startService（）和bindService（）启一个Service，这个Sercice的生命周期会有哪里不同？</h2><p>  答:</p><p>   1.Context.startService()方式的生命周期： </p><p>   启动时，startService –&gt; onCreate() –&gt; onStart()停止时，stopService –&gt; onDestroy()</p><p>   如果调用者直接退出而没有停止Service，则Service 会一直在后台运行</p><p>   Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，</p><p>   接着调用onStart()方法。</p><p>   如果调用startService()方法前服务已经被创建，</p><p>   多次调用startService()方法并不会导致多次创建服务，</p><p>   但会导致多次调用onStart()方法。</p><p>   采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法附代码</p><p>2.Context.bindService()方式启动：</p><p>①Context.bindService()方式的生命周期： </p><p>绑定时,bindService -&gt; onCreate() –&gt; onBind()调用者退出了，</p><p>即解绑定时,Srevice就会unbindService –&gt;onUnbind() –&gt; onDestory()</p><p>Context.bindService()方式启动 </p><p>Service的方法：</p><p>绑定Service需要三个参数：bindService(intent, conn, Service.BIND_AUTO_CREATE);</p><p>第一个：Intent对象</p><p>第二个：ServiceConnection对象，</p><p>创建该对象要实现它的onServiceConnected()和 onServiceDisconnected()来判断连接成功或者是断开连接</p><p>第三个：如何创建Service，一般指定绑定的时候自动创建。</p><h2 id="Android中什么是ANR-如何应对或者如何避免它？"><a href="#Android中什么是ANR-如何应对或者如何避免它？" class="headerlink" title="Android中什么是ANR,如何应对或者如何避免它？"></a>Android中什么是ANR,如何应对或者如何避免它？</h2><p>答:  ANR 就是application not responding<br>    在android中Activity的最长执行时间是5秒.</p><p>BroadcastReceiver的最长执行时间则是10秒.</p><p>超出执行时间就会产生ANR.</p><p>解决方法: </p><ol><li>运行在主线程里的任何方法都尽可能少做事情。</li></ol><p>特别是，Activity应该在它的关键生命周期方法 （如onCreate()和onResume()）里尽可能少的去做创建操作。<br>（可以采用重新开启子线程的方式，然后使用Handler+Message 的方式做一些操作，比如更新主线程中的ui等）</p><ol start="2"><li>应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。</li></ol><p>但不再是在子线程里做这些任务（因为 BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个 Service。</p><h2 id="AIDL-的全称是什么？如何工作？能处理哪些类型的数据？"><a href="#AIDL-的全称是什么？如何工作？能处理哪些类型的数据？" class="headerlink" title="AIDL 的全称是什么？如何工作？能处理哪些类型的数据？"></a>AIDL 的全称是什么？如何工作？能处理哪些类型的数据？</h2><p> 答:  AIDL: (Android Interface Definition Language)跨进程通信传输语言</p><p>   如何工作:AIDL文件由自己定义,在被绑定的Service中和绑定的客户端中都要部署</p><p>1.创建AIDL文件, 在这个文件里面定义接口, 该接口定义了可供客户端访问的方法和属性。<br>2、编译AIDL文件, 用Ant的话, 可能需要手动, 使用Eclipse plugin的话,可以根据adil文件自动生产java文件并编译, 不需要人为介入.<br>3、在Java文件中, 实现 AIDL中定义的接口. 编译器会根据AIDL接口, 产生一个JAVA接口。这个接口有一个名为Stub的内部抽象类，它继承扩展  了接口并实现了远程调 用需要的几个方法(是Binder的子类)。</p><p>接下来就需   要自己去实现自定义的几个接口了.</p><p>4.第一个程序的Service:因为跨进程传递时利用Binder对象来实现的,所以我们要在Service端构建Binder对象,又因为我们定义的接口AIDL文件在编译转成.java时的内部类Sub实现了Binder,所以我们构建Binder对象时构建实例内部类直接继承Sub内部类,在类中我们可以调用Service中的方法,此类的对象也就是Binder对象.</p><p>5.第二个程序的Activity:在Activity中我们利用bindService方法启动一个绑定的Service的同时需要传入连接对象,所以我们先在Activity中构建Service的连接对象,在该对象的匿名内部类中重写获得Binder对象的方法,参数含有Binder对象,将此对象强制转换成我们在Service中继承Sub的类的对象,强转后我们可以利用该对象调用Service中的方法,从而实现跨进程通信,控制Service.</p><h2 id="请简单介绍一下NDK。"><a href="#请简单介绍一下NDK。" class="headerlink" title="请简单介绍一下NDK。"></a>请简单介绍一下NDK。</h2><p>NDK全称：Native Development Kit。</p><p>1、NDK是一系列工具的集合。</p><ul><li>NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。</li></ul><h2 id="你后台的Activity被系统回收怎么办："><a href="#你后台的Activity被系统回收怎么办：" class="headerlink" title="你后台的Activity被系统回收怎么办："></a>你后台的Activity被系统回收怎么办：</h2><p>当你的程序中某一个Activity A 在运行时中，主动或被动地运行另一个新的Activity B 这个时候A会执行<br>Java代码</p><p>public<br>void onSaveInstanceState(Bundle outState) {<br>super.onSaveInstanceState(outState);<br>outState.putLong(“id”, 1234567890);<br>}<br>public void<br>onSaveInstanceState(Bundle outState) {</p><p>B 完成以后又会来找A, 这个时候就有两种情况，一种是A被回收，一种是没有被回收，被回 收的A就要重新调用onCreate()方法，不同于直接启动的是这回 onCreate()里是带上参数 savedInstanceState，没被收回的就还是onResume就好了。</p><p>savedInstanceState是一个Bundle对象，你基本上可以把他理解为系统帮你维护的一个Map对象。在onCreate()里你可能会用到它，如果正常启动onCreate就不会有它，所以用的时候要判断一下是否为空。</p><p>Java代码<br>if(savedInstanceState !=null){<br>long id =savedInstanceState.getLong(“id”);<br>}<br>if(savedInstanceState !=null){<br>就像官方的Notepad教程里的情况，你正在编辑某一个note，突然被中断，那么就把这个note的id记住，再起来的时候就可以根据这个id去把那个note取出来。</p><h2 id="怎么优化listview"><a href="#怎么优化listview" class="headerlink" title="怎么优化listview"></a>怎么优化listview</h2><p>1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。<br>2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。<br>3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。<br>4、设置listview的监听器，如果listview是飞快滑动状态则不更新view</p><h2 id="根据自己的理解描述下Android数字签名。"><a href="#根据自己的理解描述下Android数字签名。" class="headerlink" title="根据自己的理解描述下Android数字签名。"></a>根据自己的理解描述下Android数字签名。</h2><p>(1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序</p><p>(2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证</p><p>(3)如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名。</p><p>(4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。</p><h2 id="简述Android-root机制"><a href="#简述Android-root机制" class="headerlink" title="简述Android root机制"></a>简述Android root机制</h2><p>答:</p><p>root指的是你有权限可以再系统上对所有档案有 “读” “写” “执行”的权力。root机器不是真正能让你的应用程序具有root权限。它原理就跟linux下的像sudo这样的命令。在系统的bin目录下放个su程序并属主是root并有suid权限。则通过su执行的命令都具有Android root权限。当然使用临时用户权限想把su拷贝的/system/bin目录并改属性并不是一件容易的事情。这里用到2个工具跟2个命令。把busybox拷贝到你有权限访问的目录然后给他赋予4755权限，你就可以用它做很多事了。</p><h2 id="进程间通信机制，传统IPC-和-Binder"><a href="#进程间通信机制，传统IPC-和-Binder" class="headerlink" title="进程间通信机制，传统IPC 和 Binder"></a>进程间通信机制，传统IPC 和 Binder</h2><p>答:</p><p>传统的进程间通信机制IPC 有管道（Pipe）、信号（Signal）和跟踪（Trace），这三项通信手段只能用于父进程和子进程之间，或者兄弟进程之间；后来又增加了命令管道（Named Pipe）,使得进程间通信不再局限于父子进程或兄弟进程之间。后来又出现了报文队列（Message）、共享内存（Share Memeory）和信号量（Semaphore）。Android系统没有采用上述提到的各种进程间通信机制，而是采用Binder机制，它是基于OpenBinder来实现的。<br>它提供了远程过程调用（RPC）功能，在Android系统的Binder机制中，有一系列组件组成包括 Client、Server、ServiceManager和Binder驱动程序。</p><h2 id="Serializable和Parcelable的特点及比较"><a href="#Serializable和Parcelable的特点及比较" class="headerlink" title="Serializable和Parcelable的特点及比较"></a>Serializable和Parcelable的特点及比较</h2><p>答:</p><p>Serializable和Parcelable二者都是实现序列化的接口。Parcelable,定义了将数据写入Parcel，和从Parcel中读出的接口。一个实体（用类来表示），如果需要封装到消息中去，就必须实现这一接口，实现了这一接口，该实体就成为“可打包的”了。</p><p>一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才是可序列化的。</p><p>因此如果要序列化某些类的对象，这些类就必须实现Serializable接口。而实际上，Serializable是一个空接口，没有什么具体内容，它的目的只是简单的标识一个类的对象可以被序列化。Serializable的实现，只需要implements Serializable即可，这只是给对象打了一个标记，系统会自动将其序列化。</p><p>Parcelable的实现，需要在类中添加一个静态成员变量CREATOR，这个变量需要继承Parcelable.Creator接口。</p><p>比较:</p><p>Serializable是Java.io中的，不可被activity中的内部类被继承，否则出错；Parcelable是Android特有的，比Serializable节省内存，可以传递Bundle对象，当我们有boolean型的变量可以现存在Bundle中。</p><h2 id="View、surfaceView、GLSurfaceView有什么区别"><a href="#View、surfaceView、GLSurfaceView有什么区别" class="headerlink" title="View、surfaceView、GLSurfaceView有什么区别"></a>View、surfaceView、GLSurfaceView有什么区别</h2><p>View：</p><p>显示视图，<br>内置画布，<br>提供图形绘制函数、<br>触屏事件、<br>按键事件函数等，<br>必须在UI主线程内更新画面，速度较慢</p><p>SurfaceView：</p><p>基于view视图进行拓展的视图类，<br>更适合2D游戏的开发，<br>是view的子类，<br>类似使用双缓机制，<br>在新的线程中更新画面所以刷新界面速度比view快</p><p>GLSurfaceView：</p><p>基于SurfaceView视图再次进行拓展的视图类，<br>专用于3D游戏开发的视图，<br>是surfaceView的子类，<br>openGL专用</p><h2 id="你曾经用到的android手机访问服务端的方式有哪些？"><a href="#你曾经用到的android手机访问服务端的方式有哪些？" class="headerlink" title="你曾经用到的android手机访问服务端的方式有哪些？"></a>你曾经用到的android手机访问服务端的方式有哪些？</h2><p>Android手机访问服务端的方式有两种，分别是：通过socket访问和通过Http协议发送Post和Get请求。</p><p>   Socket是长连接，服务端和客户端之间通过Socket建立连接，首先ServerSocket将在服务端监听某个端口，当发现客户端有Socket来试图连接它时，它会接受该Socket的连接请求，同时在服务端建立一个对应的Socket与之进行通信。这样就有两个Socket了，客户端和服务端各一个。</p><p>   发送get和post协议，通过HTTP协议建立短连接。客户端发送请求（Request），服务器端收到后根据请求的类型返回相应的响应（response）。</p><h2 id="什么是TCP和IP，它们位于网络模型的哪层？"><a href="#什么是TCP和IP，它们位于网络模型的哪层？" class="headerlink" title="什么是TCP和IP，它们位于网络模型的哪层？"></a>什么是TCP和IP，它们位于网络模型的哪层？</h2><p>TCP是传输控制协议，<br>IP是internet协议，</p><p>TCP在网络模型中与UDP一样同属于第二层(传输层)，</p><p>IP属于三层(网络层)，</p><p>IP用于确定主机在网络中的位置，而TCP与UDP用于标示不同的服务，即应用程序。</p><h2 id="Xml和json的区别"><a href="#Xml和json的区别" class="headerlink" title="Xml和json的区别"></a>Xml和json的区别</h2><p>1．可读性　　<br>JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。</p><p>2可扩展性　　<br>XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。</p><p>3.编码难度　　<br>XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。</p><p>4．解码难度　　<br>XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。</p><p>5.流行度　　<br>XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。</p><h2 id="SAX-、DOM4J-、PULL解析的区别"><a href="#SAX-、DOM4J-、PULL解析的区别" class="headerlink" title="SAX 、DOM4J  、PULL解析的区别"></a>SAX 、DOM4J  、PULL解析的区别</h2><p>Sax特点</p><pre><code>1. 解析效率高，占用内存少2.可以随时停止解析3.不能载入整个文档到内存4.不能写入xml5.SAX解析xml文件采用的是事件驱动</code></pre><p>pull与sax的不同之处</p><pre><code>1.pull读取xml文件后触发相应的事件调用方法返回的是数字。2.pull可以在程序中控制，想解析到哪里就可以停止到哪里</code></pre><p>3.Android中更推荐使用pull解析</p><p>DOM的特点<br>         &gt;优点<br>                  1.整个文档树在内存中，便于操作；支持删除、修改、重新排列等多种功能<br>                  2.通过树形结构存取xml文档<br>                  3.可以在树的某个节点上向前或向后移动<br>         &gt;缺点<br>                  1.将整个文档调入内存（包括无用的节点），浪费时间和空间<br>         &gt;适用场合<br>                  一旦解析了文档还需多次访问这些数据；硬件资源充足（内存，cpu）</p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题总结</title>
    <link href="https://huangguangda.github.io/2018/05/15/1/"/>
    <id>https://huangguangda.github.io/2018/05/15/1/</id>
    <published>2018-05-15T00:42:00.000Z</published>
    <updated>2018-07-04T00:51:54.435Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>Android面试题总结</p><p>1.简述Activity的生命周期？</p><p>1）Activity的生命周期通过7个生命周期方法<br>onCreate(),<br>onRestart(),<br>onStart(),<br>onResume(),<br>onPause(),<br>onStop(),<br>onDestroy()<br>来体现。</p><p>2）其中6个生命周期方法是<br>成对对应起来的,<br>哪里创建的对象，一般应该在其对应的方法中销毁。</p><p>onCreate() – onDestroy()<br>onStart() – onStop()<br>onResume() – onPause()</p><p>3）当程序启动之后，<br>第一个Activity经过的生命周期方法是：<br>onCreate() →onStart() → onResume()方法,</p><p>当第一个Activity<br>A启动第二个Activity B的时候</p><p>(备注:第二个Activity完全遮盖住第一个Activity，并且这个过程中没有出现点击Home键，或者第一个Activity被杀死等异常情况，并且两个Activity的启动模式是标准模式)，</p><p>这两个Activity经历的生命周期方法是：</p><p>A onPause() → B onCreate() → B onStart() → B onResume() → A onStop() → (此时Activity A已经在回退栈的最低端， Activity B已经在Activity A的上面，在回退栈的最顶端)</p><p>当通过点击后退键退出Activity B的时候：</p><p>(此时Activity B 弹出回退栈) → B onPause() → A onRestart() → A onStart() → A onResume() → B onStop() → B onDestroy() 此时B<br>被销毁</p><p>简述Service的生命周期？</p><p>1).如果在Activity中通过调用</p><p>startService()</p><p>方法启动一个Service的话，<br>那么生命周期是：</p><p>onCreate() → onStartCommand() → 运行中 → (如果自己或者客户端(如Activity)调用了stop Service的方法的话) → onDestroy()</p><p>2).如果在Activity中通过调用</p><p>bindService()</p><p>方法启动一个Service的话，<br>那么生命周期是：</p><p>onCreate() → onBind() → 运行中 → (如果有客户端(Activity)调用了unBindService()方法与Service解除绑定时) → onUnbind() → onDestroy()</p><p>有几种控件布局的方式？</p><p>1）RelativeLayout:相对布局，<br>可以根据相对位置来调整控件的位置。推荐使用相对布局，更利于屏幕的自适应。</p><p>2）LinearLayout:线性布局，<br>控件之间的水平排列或者垂直排列。但是如果要想构建复杂布局，要进行多层的LinearLayout布局嵌套，但是这样会运行布局载入效率。</p><p>3）FrameLayout:帧布局，<br>控件与控件之间处于上下叠加的状态。</p><p>备注：还有两个已经不怎么用的布局：<br>TableLayout：表格布局 AbsoluteLayout 绝对布局。</p><p>布局实现方式有两种：xml文件静态实现，代码动态实现。</p><p>一般xml文件中可以实现布局控制的话，就不建议放在代码中实现布局控制，因为在xml文件中实现布局控制，可以做到布局与代码分离。</p><p>4.有几种数据存储方式，分别是什么？</p><p>1）SQLite数据库存储结构化数据。</p><p>2）文件存储：分为内部存储和外部存储(SD卡)两种存储方式。</p><p>3）SharedPreferences共享参数，键值对形式存储。</p><p>4）网络存储。</p><p>5.IntentService与Service有什么区别？</p><p>IntentService是Service的子类</p><p>1）Service如果要处理异步请求(如耗时操作)的话，</p><p>需要自己启动一个worker thread,</p><p>如果启动多个worker thread来处理相关事务的话，各线程之间无法很好的控制。</p><p>而IntentService可以将多个异步请求的Intent放入队列中，封装了一个开启worker thread的onHandleIntent()方法，来依次处理放入队列中的Intent，只有一个worker thread在运行，同一时刻只有一个Intent被处理，当一个Intent处理完了之后才会处理另外一个Intent。</p><p>2）Service可以通过startService()或者bindService()方法来启动，</p><p>而IntentService则是通过startService()方法来启动。</p><p>3）Service适合多线程处理异步请求。</p><p>而IntentService则适合处理需要排队的请求。</p><p>6.StartService与bindService之间的区别？</p><p>1）StartService启动了Service之后无法与Activity之间进行通信，与现有的Activity分离，即使Activity被杀掉了之后，Service还可以运行，同时通过设置Service的粘性，还可以让Service被杀掉之后，可以自启动。而bindService启动Service之后，与绑定的Activity之间有关系，可以依据Server/Client模式来进行通信(binder客户端主动请求模式，或者通过信使)，但是无法设置Serrvice的粘性。</p><p>2) StartService启动的Service,Activity中可以调用stopService()方法来结束一个Service，或者通过Service自己调用stopSelf()方法来结束Service。而bindService只能通过Activity()来调用unbindService()方法来结束Service，Service会调用onUnBind()方法，以及onDestroy()方法。</p><p>7.ArrayAdapter BaseAdapter CursorAdapter的区别？</p><p>ArrayAdpter CursorAdapter都是BaseAdapter的子类。<br>都是用来填充那些含有item的控件。</p><p>1）主要区别是数据来源不同。</p><p>ArrayAdapter数据来源是Object数组，<br>CursorAdapter数据来源是数据库的Cursor,<br>而BaseAdapter适合创建复杂自定义的item内容，</p><p>通过继承BaseAdapter类，重写相关方法来实现。</p><p>8.Handler与Looper之间的关系?</p><p>1) Handler和Looper的关系就好比，坐地铁过安检时候：每一个人可以理解为一个Handler，一个人的一个或者多个东西看做Message而循环滚动的检查台装置可以看做是Looper，而要检查的东西排成队列可以理解为MessageQueue消息队列。</p><p>2)Looper是Handler和MessageQuene之间的桥梁，Looper将Handler发送过的消息放入MessageQueue,同时Looper也将MessageQueue中的Message发送给Handler来处理。</p><p>9.res文件夹与assets文件夹有什么区别?</p><p>1)res文件夹中的资源在会在R.java文件中生成ID，<br>代码中可以直接通过R.id的形式来访问。</p><p>而assets文件夹中的资源不会在R.java文件中生成ID,</p><p>需要通过AssetsManager通过IO流的方式来访问。</p><p>2)res文件夹中的文件会被压缩，</p><p>而assets文件中的文件不会被压缩。</p><p>3)Res不能自定义目录名，不支持多层目录。</p><p>而assets支持自定义目录名，支持多层目录。</p><p>10.广播接收器有几种注册方式，分别是什么？</p><p>1)动态注册：在代码中注册，创建一个IntentFilter(意图过滤器)对象，设置想要就收的广播，在onCreate()方法中通过调用registerReceiver()方法来注册广播接收器，在onDestroy()方法中通过调用unregisterReceiver()方法来注销广播接收器。</p><p>2)静态注册：在AndroidManifest.xml文件中注册，<receiver>标签注册类，通过<intentfilter>标签中的<action>来过滤意图。静态注册的好处是，当程序关闭或者没有打开的时候，同样可以接收相关的广播。比如实现开机启动。</action></intentfilter></receiver></p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java就业面试题大全</title>
    <link href="https://huangguangda.github.io/2018/05/14/1/"/>
    <id>https://huangguangda.github.io/2018/05/14/1/</id>
    <published>2018-05-14T13:40:52.000Z</published>
    <updated>2018-07-02T15:41:26.139Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>仅供学习</p><p>1、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</p><p>2、Java有没有goto?<br>java中的保留字，现在没有在java中使用。</p><p>3、说说&amp;和&amp;&amp;的区别。<br>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。</p><p>&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式</p><p>4、在JAVA中如何跳出当前的多重嵌套循环？ </p><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。</p><p>5、switch语句能否作用在byte上，能否作用在long上，能否作用在String上? </p><p>由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 </p><p>6、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? </p><p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。<br>对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 </p><p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。<br>对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p><p>7、char型变量中能不能存贮一个中文汉字?为什么? </p><p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</p><p>8、用最有效率的方法算出2乘以8等於几? </p><p>2 &lt;&lt; 3，<br>因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 &lt;&lt; 3。</p><p>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ </p><p>使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于如下语句：</span><br><span class="line"> final StringBuffer a=new StringBuffer(&quot;immutable&quot;);</span><br><span class="line">执行如下语句将报告编译期错误：</span><br><span class="line">a=new StringBuffer(&quot;&quot;);</span><br><span class="line">但是，执行如下语句则可以通过编译：</span><br><span class="line">a.append(&quot; broken!&quot;);</span><br></pre></td></tr></table></figure></p><p>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method(final  StringBuffer  param)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：<br>        param.append(“a”);</p><p>“==”和equals方法究竟有什么区别？<br>==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。</p><p>equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。</p><p>静态变量和实例变量的区别？<br>在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。</p><p>在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p><p>是否可以从一个static方法内部发出对非static方法的调用？ </p><p>不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。</p><p>Integer与int的区别</p><p>int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</p><p>下面的代码有什么不妥之处?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. if(username.equals(“zxx”)&#123;&#125;</span><br><span class="line">2.int  x = 1;</span><br><span class="line">return x==1?true:false;</span><br></pre></td></tr></table></figure></p><p>abstract class和interface有什么区别? </p><p>含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p><p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p><p>下面比较一下两者的语法区别：<br>1.抽象类可以有构造方法，接口中不能有构造方法。<br>2.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p><ol start="4"><li>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然<br>eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</li><li>抽象类中可以包含静态方法，接口中不能包含静态方法</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li></ol><p>什么是内部类？Static Nested Class 和 Inner Class的不同。</p><p>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中.</p><p>jdk中哪些类是不能继承的？<br>不能继承的是类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中System,String,StringBuffer等都是基本类型。</p><p>String是最基本的数据类型吗?<br>基本数据类型包括byte、int、char、long、float、double、boolean和short。<br>java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 </p><p>是否可以继承String类?<br>String类是final类故不可以继承。 </p><p>String 和StringBuffer的区别</p><p>JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。String类表示内容不可改变的字符串。而StringBuffer类表示内容可以被修改的字符串。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。</p><p>StringBuffer与StringBuilder的区别</p><p>StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</p><p>如何把一段逗号分割的字符串转换成一个数组?<br>如果不查jdk api，我很难写出来！我可以说说我的思路：<br>1.用正则表达式，代码大概为：String [] result = orgStr.split(“,”);<br>2.用 StingTokenizer ,代码为：StringTokenizer  tokener = StringTokenizer(orgStr,”,”);<br>String [] result = new String[tokener .countTokens()];<br>Int i=0;<br>while(tokener.hasNext(){result[i++]=toker.nextToken();}</p><p>数组有没有length()这个方法? String有没有length()这个方法？<br>数组没有length()这个方法，有length的属性。String有有length()这个方法。</p><p>final, finally, finalize的区别。<br>　　final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br>内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码……</p><p>finally是异常处理语句结构的一部分，表示总是执行。</p><p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用</p><p>运行时异常与一般异常有何异同？<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p><p>error和exception有什么区别?<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 </p><p>java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？ </p><p>java5以前，有如下两种：</p><p>第一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Thread()&#123;&#125;.start();这表示调用Thread子类对象的run方法，new Thread()&#123;&#125;表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：</span><br><span class="line">new Thread()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第二种：</span><br><span class="line">new Thread(new Runnable()&#123;&#125;).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable()&#123;&#125;表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：</span><br><span class="line">new Thread(new Runnable()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><p>sleep() 和 wait() 有什么区别? </p><p>（网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。） </p><p>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThread &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">new Thread(new Thread1()).start();</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">new Thread(new Thread2()).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static class Thread1 implements Runnable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">//由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。</span><br><span class="line"></span><br><span class="line">synchronized (MultiThread.class) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;enter thread1...&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread1 is waiting&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">//释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。</span><br><span class="line"></span><br><span class="line">MultiThread.class.wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread1 is going on...&quot;);</span><br><span class="line">System.out.println(&quot;thread1 is being over!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class Thread2 implements Runnable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">synchronized (MultiThread.class) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;enter thread2...&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread2 notify other thread can release wait status..&quot;);</span><br><span class="line">//由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。</span><br><span class="line"></span><br><span class="line">MultiThread.class.notify();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread2 is sleeping ten millisecond...&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread2 is going on...&quot;);</span><br><span class="line">System.out.println(&quot;thread2 is being over!&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步和异步有何异同，在什么情况下分别使用他们？举例说明。 </p><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。<br>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 </p><p>多线程有几种实现方法?同步有几种实现方法? </p><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>同步的实现方面有两种，分别是synchronized,wait与notify<br>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p><p>启动一个线程是用run()还是start()?<br>启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。 </p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>MVC的各个部分都有那些技术来实现?如何实现? </p><p>答:MVC是Model－View－Controller的简写。Model 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， View 是应用的表示面（由JSP页面产生），Controller 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。 </p><p>数据库部分<br>1、用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。<br>employee:<br>     eid,ename,salary,deptid;<br> select * from employee order by deptid desc,salary</p><p>j2ee常用的设计模式？说明工厂模式。<br>总共23种，分为三大类：创建型，结构型，行为型<br>我只记得其中常用的6、7种，分别是：<br>创建型（工厂、工厂方法、抽象工厂、单例）<br>结构型（包装、适配器，组合，代理）<br>行为（观察者，模版，策略）<br>然后再针对你熟悉的模式谈谈你的理解即可。  </p><p>Java中的23种设计模式：<br>Factory（工厂模式），      Builder（建造模式），       Factory Method（工厂方法模式），<br>Prototype（原始模型模式），Singleton（单例模式），    Facade（门面模式），<br>Adapter（适配器模式），    Bridge（桥梁模式），        Composite（合成模式），<br>Decorator（装饰模式），    Flyweight（享元模式），     Proxy（代理模式），<br>Command（命令模式），      Interpreter（解释器模式）， Visitor（访问者模式），<br>Iterator（迭代子模式），   Mediator（调停者模式），    Memento（备忘录模式），<br>Observer（观察者模式），   State（状态模式），         Strategy（策略模式），<br>Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式） </p><p>J2EE是什么？<br>答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。</p><p>一个另类的回答：j2ee就是增删改查。 </p><p>J2EE是技术还是平台还是框架？ 什么是J2EE<br>   J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。<br>   J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。</p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>四级考试听力场景词汇大全</title>
    <link href="https://huangguangda.github.io/2018/05/13/1/"/>
    <id>https://huangguangda.github.io/2018/05/13/1/</id>
    <published>2018-05-13T05:34:14.000Z</published>
    <updated>2018-07-01T06:10:34.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>仅供学习</p><p>你永远也无法找到一个比这个更全更准的听力复习资料</p><p>一、机场、飞机上、客轮</p><p>常考思路：<br>　　1) 票已售完<br>　　2) 接人(飞机)晚点<br>　　3) 送人伤感 see somebody off<br>　　常见线索词：<br>　　departure 离港<br>　　sect belt 安全带<br>　　arrival 进港<br>　　pick up 接机<br>airplane, flight 航班, direct flight直航，transfer转机，<br>first class头等舱， economy class经济舱，<br>circle 盘旋<br>　　wing: a.建筑物的附属楼 b.飞机的翅膀 c.鸡翅<br>　　terminal: a.终端(机房里面 Should I use this terminal?)<br>　　b. =final station公交站最后一站<br>　　c.候机大厅<br>　　domestic terminal国内候机大厅，international terminal国际候机大厅</p><p>1.机场地点­<br>    Terminal (航站楼)­  Check-in counter (换票柜台)　　Customs (海关)­</p><ol start="2"><li>机场人物­<br>　　Airhostess/stewardess (空姐)　 steward (空哥、空少)　 flight attendant (飞机乘务员)­</li><li>飞机动作­<br>　　Take off/land (起飞、降落)　　 ascend/descend(上升、下降)­<br>wait for further notice等候进一步通知<br> minor mechanical errors轻微的机械故障 terminal候机大厅<br> clear up天晴起来 　　　　　　swing不稳定,极端<br> weather forecast天气预报 　   freezing非常冷 　<br>coupled with strong wind伴有强风</li></ol><p>二、餐厅　<br>　　1)cafeteria学校饭堂：meal card/ticket饭卡/饭票，helping一人份<br>　　2)restaurant: fancy高档的, menu菜谱, order, manager经理, waiter<br>　　book/reserve预订 ，make a reservation预定<br>　　上菜顺序：soup汤——&gt; main course主菜——&gt; salad沙拉(chef salad招牌沙拉)——&gt; dessert甜点 (pudding布丁, cheese , fruit)</p><p>赞美人家做菜好吃：<br>　　1) Even my mother’s can’t match this.即使我妈妈做的也比不上这个好吃。<br>　　2) I took the last one and it was out of the world.(太好吃了以至于)我把最后一块也吃掉了。<br>　　3) You wouldn’t have to force me to help another one. 你不用叫我吃，我自己也会拿来吃的。<br>1.点菜：­ French Fries (薯条)­</p><ol start="2"><li>买单：­Check the bill please!(买单！) Treat (请客)　 split the bill (分开付)­</li></ol><p>三、图书馆　<br>　　1.书籍：journal 学术类刊物　(08-6)­<br>　　volume 卷　 current/back issue 现/过刊　 periodical　 期刊­<br>2.人物：librarian 图书管理员­</p><p>四、Campus life　校园生活­</p><ol><li>课程分类<br>　　Optional course 选修课<br>　　Required course 必修课<br>Literature 文学<br>09-12出现的一些新课程名称：­<br>advanced physics (高级物理)<br>data processing (数据处理)­<br>　　computer programming (计算机程序)­<br>be through with sth　结束，完成(两次考到)­<br>　due　到期<br>　have sb’s hands full with sth　忙于做某事(07-12)­<br>apply for申请<br>business degree商学院学位<br>pay your own way自己支付各种费用</li></ol><p>2.　课程形式词汇：­<br>　　Seminar(06-6、07年6月词汇，研讨会)　　<br>　　presentation (展示或演示课，多次考到)­<br>biology生物学<br>    class permit听课证<br>informative信息量大</p><p>senior(大四)(05年考点)­<br>graduate(毕业生)<br>undergraduate (在校生，本科生)<br>postgraduate (研究生)­<br>tutor(导师)<br>graduate school　(研究生院)­<br>Position/post　(职位。多次考到)　　<br>recruit (招聘。连续考到)<br>　　resign　(退休，多次考到)­<br>benefit (package)　(福利，两次考到)<br>paid vacation　 (带薪假期)­<br>social security (美国的社会保险)<br>phased retirement (08-12 阶段性退休)<br>be laid off (解雇 09-12考点)­<br>hotel consultant (08-6 酒店咨询)<br>sales manager(08-12 销售经理)­<br>　　Administrative work (08-12 行政工作)­<br>　　promotion(升职，09-6/12连续考到)­</p><p>4.抱怨的作业：<br>　　1)paper a.论文 b.=newspaper 报纸 c. document文件 d.纸张<br>　　写论文的步骤：<br>　　a. choose a topic选题<br>　　area: The area is too board for me. 题目的范围太广了<br>　　narrow the topic down 把题目范围缩小<br>　　b. do some research 做调查 (去图书馆library 做调查)<br>　　c. type it out打印<br>　　typewriter打字机，computer, lap top手提电脑， printer打印机， laser printer激光打印机， ribbon色带<br>　　2) presentation口头演讲——oral form = speech = report = address<br>　　a.时间性 20分钟，一般演讲18-19分钟，留下几分钟时间别人发问<br>　　b.正式着装——formal clothes<br>　　change(穿的衣服不合适就要换)<br>　　You can’t go like that. You need a change.你这样穿不行，要换一套衣服。<br>　　c.内心感受——nervous (演讲前心里很害怕)<br>　　3) Reading assignment / list 阅读作业/清单<br>　　Do you think the reading list is enormous? 你觉不觉要读的书太多了?<br>　　4) Research<br>　　Financial Aid经济资助<br>　　a. Tuition wavier学费减免<br>　　b. RA——Researching Assistant助研<br>　　TA——Teaching Assistant 助教<br>　　Fellowship奖学金<br>5.缺课<br>　　缺课原因：<br>　　1) get ill 由于生病而缺课<br>　　2) oversleep睡过头了<br>　　3)traffic jam交通堵塞/ (car)break down车抛锚</p><p>.考试<br>middle exam 期中考试<br>　　make up 补考<br>　　test测验<br>　　pop test 事先没有说好的测验<br>　　quiz 测验<br>　　oral test 口试<br>be through with结束，完成<br>release发布（分数）</p><p>　　考试临近<br>　　draw on 、 in sight of 、 draw nearly<br>　　<br>考试延期或取消<br>　 defer / hold up / postpone / put off / suspend</p><p>酒店、宾馆与约会　　</p><p> make a reservation 预订房间<br>　　confirm a reservation 确认预订<br>　　cancel a reservation 取消预订<br>　　fully booked / full up / full 客满<br>　　porter 行旅员<br>　　reception 前台<br>　　check in 登记入住<br>　　single room 单人房<br>　　suite 套房<br>　　room service 客房服务 (四级听力中的客房服务一般只有考一种——送餐)<br>　　lobby 大堂<br>salon 美容厅<br>　　night club 夜总会<br>　　check out 退房<br>　　饭店<br>    hotel clerk (07年6月词汇，等于receptionist)<br>eat out 出去吃<br>　　take away 外带<br>appetizer 开胃菜<br>　　main course 主食<br>　　dessert 餐后甜点<br>　　keep the change 不用找零了<br>move on to继续<br>　　the next item下一议题个<br>    come in one’s place代表某人来<br>on behalf of代表</p><p>罚款 fine<br>　　校内：library里面，书过期<br>　　校外： break the traffic rules违反交通规则，go speeding超速<br>　　各种费用：<br>　　fare交通费(车费，船费)， fee杂费， tuition学费， tuition and fee学杂费，rent 房租， utilities水电费，rate 按比例收取的费用， post rate=postage邮资</p><p>1．交通<br>　　常考思路：<br>　　1) 交通堵塞 traffic jam<br>　　back up: a.作业堆积如山 b. 车辆很多 c. back somebody up支持某人<br>　　2) 交通违章——&gt;fine罚款<br>　　break the traffic rule违反交通规则, go speeding超速<br>　　3) 晚点 behind schedule<br>　　parking lot停车场 　　　　maintain保养<br>    break down抛锚 　　　　　garage修车场<br>    scratches刮蹭 　　　　　　highway高速公路<br>    single lane单行道 　　　　 No-parking sign禁止停车标志<br>   sleeper卧铺 　　　be supposed to应该</p><p>打电话<br>　　常考思路：<br>　　1) 约人约不到<br>　　2) 约会去不了<br>　　sth comes up/ I’d like to reschedule/ Could you fit me in (the doctor’s schedule)?<br>　　3) 电话打不通(包括打错电话)<br>　　线索词：<br>　　run out of coins(在公共电话亭里)没钱了<br>   cut off被迫断线，hang up主动挂断电话，<br>   receiver听筒，slot 电话上的小投币口　</p><p>   九、医院<br>　　常考思路：<br>　　1) 医生难找<br>　　2) 病情如何(getting better/worse)<br>　　3) 有病耽误课miss the class<br>　　线索词：<br>　　treat治疗(表过程)， cure治疗,治愈(表结果)<br>　　infirmary / students’ help center学校的医院<br>prescribe开药方，prescription处方<br>　　Send him to Ward Three. 把他送去3号病房。 Send him toward three.把他送到东方去。(因为时钟三点指向东(上北下南左西右东) )<br>　　fill the prescription按方抓药， refill the prescription继续按方抓药，<br>dizzy头晕<br>    a fever发烧<br>    have the ankle twisted扭到脚踝<br>    blood vessel血管</p><p>(四)买东西<br>　　<br>1．采购衣服<br>size型号 　　　come in all sizes号全<br>2．采购电器<br>model款<br>latest technology最新的科技 </p><ol start="3"><li>1) supermarket超级市场: supplies生活用品，price tag价格签，<br>special offer/ on sale打折，cart手推车，vender售货员，cashier收银员<br>2)  appliance家用电器, costume服装, floor 层,<br>men’s 男装区,<br>for sale 热卖中,待售中,<br>70% off 三折, </li></ol><p>十一、 阅读与写作　<br>intensively精细地<br>reading assignment阅读任务 　　　　selectively有选择地<br>chapter by chapter一章一章地 　　　theory理论<br>read through从头到尾地读 　　　　　cover a few chapters涉及了几个章节<br>revise修订<br>quality paper好纸 　　　　　       get it published出版<br>proofread[pru:fri:d]校对 　　</p><p>十二、.求职与工作　　<br>常考思路:<br>　　1) 找到工作高兴<br>　　2) 失去工作伤心 a.被解雇 b.离开旧工作<br>　　3) 拒绝工作令人感到奇怪<br>　　线索词<br>　　找工作的过程:<br>　　1) 信息<br>　　a. classified ads分类广告<br>　　help and wanted section供求关系栏<br>　　b. bulletin board公告栏<br>　　c. flyer传单<br>　　2) make a phone call<br>　　Is the position still available? 工作职位还仍然空缺吗?<br>　　3) resume个人简历<br>　　certification 学历证, ID身份证,<br>qualification资历,<br>　　recommendation letter推荐信<br>　　fill out= fill in = fill up填表格</p><p>interview面试<br>　　 interview　面试　　　　　　finance金融<br>    suit西装 　　　　　　　　 accounting会计<br>    tie领带 　　　　　　　　　brush up on温习，复习<br>    travel出差                annual vacation年假<br>job vacancy 有空缺职位<br>　　academic background 教育背景<br>　　offer 聘用信<br>　　ask for a raise 加钱<br>　　salary 日薪<br>　　bonus奖金<br>　　allowance 津贴<br>　　promotion 升职　　</p><p>十三. 租房子<br>　　常考思路<br>　　live on campus 住校<br>　　live off campus 住校外<br>　　for sale 可销售的房子<br>　　for rent / lease 可出租的房子<br>　　to let 同上<br>　　utilities 公用事业费<br>　　suburb / downtown 市郊 / 市中心<br>　　leaking 漏水<br>　　blackout 断电<br>　　transportation 交通<br>　　land lord 房东<br>　　land lady 房东太太<br>　　tenant 房客<br>　　roommate 室友<br>　　好的室友：neat 整洁的 considerate 体贴的，细心的<br>　　不好的室友：messy / untidy 脏乱的 noisy 吵闹的<br>　　apartment 公寓<br>　　dorm/dormitory 寝室<br>    for rent房子出租，rest-room厕所　</p><p>十四、 理发<br>　　线索词<br>　　cut大剪，trim小修剪，bang男生刘海儿，fringe女生刘海儿，parting分头(I want parting to the left.我想要左分头。)<br>　　plait 辫子　　</p><p>十五、医院场景<br>　　send for a doctor 让医生出诊<br>　　health center / clinic 卫生所 / 门诊部<br>　　physician 内科医生<br>　　surgeon 外科医生<br>　　make an appointment 预约<br>　　liquid 喝药水<br>　　injection =&gt; shot 注射<br>　　medical result 诊断结果</p><p>8.宾馆和约会场景<br>　　　　<br>　十六、邮局场景<br>　　rate 费率<br>　　overweight 超重<br>　　postage 邮资<br>　　forward the mail to把邮件转发给<br>　　cc(carbon copy) 抄送<br>　　bcc(blind carbon copy)秘密抄送<br>　　attach 附件</p><p>   log in登录</p><p>   log off登出<br>　　<br>十七、其他场景<br>　　be mad with对某人生气<br>　　干杯cheers<br>    the last man 最不愿意见的人<br>　　sell off 低价处理库存商品<br>　　selling machine 自动售货机<br>　　count for little 无足轻重<br>　　count for much 举足轻重<br>　　count down 倒计时<br>　　count up 相加<br>健忘 forgetful, absent-minded, slip one’s mind</p><p>　　count up to 共计</p><p>短对话考前嘱咐<br>　　1. 学习——基于学生的角度，一定是抱怨学习<br>　　2. 生活——poor,很穷。<br>　　Student ID 学生证 用于discount 打折， bargain 讨价还价<br>　　3. 学习vs 生活——忙，忙于学习</p><p>长对话十大类标志词<br>　　据研究有90%以上的考点都是由标志词引导活提示的，因此在语段听力中听到下列标志词时要引起高度的重视，集中注意力听清标志词前后的句子。<br>　　1.最高级标志词<br>　　形容词、副词最高级、most / chief / primary / main / leading / ……<br>　　2.唯一级标志輯div&gt; 　　only / unique / prefer / every / one / of all / perfect / ……<br>　　3.因果项标志词<br>　　cause / lead to / contribute to / thanks to / owing to / question / answer / why / reason / 其他形式的问句 / ……<br>　　4.转则项关键词<br>　　despite / in spite of / instead / while / from ~ to ~ / although ~ (yet)~ / not only ~ but also ~ / ……<br>　　5.序数项标志词<br>　　所有的序数词(first , second)/ another / the other / next / last / in addition / on the other hand / ……<br>　　6.时间项标志词<br>　　when / how / today / as / before / after / since / then / until / ……<br>　　7.解释项标志词<br>　　or / namely / in other words / that is / that is to say / ……<br>　　8.目的项标志词<br>　　to / for / ……<br>　　9.总结项标志词<br>　　all in all / in brief / to conclude / at last / in summary / in short / ……<br>　　10.强调项标志词<br>　　副词：especially / particularly / almost / always / usually / ……<br>　　动词：show / remember / note / notice / say / pronounce / ……</p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语" scheme="https://huangguangda.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="https://huangguangda.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Android面试常考题目</title>
    <link href="https://huangguangda.github.io/2018/05/12/1/"/>
    <id>https://huangguangda.github.io/2018/05/12/1/</id>
    <published>2018-05-12T04:04:50.000Z</published>
    <updated>2018-06-22T05:24:53.056Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>来源网络资料</p><p>1、 Android的四大组件是哪些，它们的作用？</p><p>答：</p><p>Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑，Activity：不可见，只是一种容器，view组件（UI控件，容器控件的基类）用来显示可以看到的东西。</p><p>service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事物，定义好需要接受的Intent提供同步和异步的接口</p><p>Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的接口模型，大大简化上层应用，对数据的整合提供了更方便的途径</p><p>BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型</p><p>2、 请介绍下Android中常用的五种布局。</p><p>常用五种布局方式，<br>分别是：<br>FrameLayout（框架布局），<br>LinearLayout （线性布局），<br>AbsoluteLayout（绝对布局），<br>RelativeLayout（相对布局），<br>TableLayout（表格布局）。</p><p>一、FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。</p><p>二、LinearLayout：线性布局，<br>每一个LinearLayout里面又可分为垂直布局（android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）。</p><p>当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。</p><p>三、AbsoluteLayout：绝对布局用X,Y坐标来指定元素的位置，</p><p>这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。</p><p>四、RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。</p><p>主要属性有：<br>相对于某一个元素<br>android:layout_below、 android:layout_toLeftOf<br>相对于父元素的地方<br>android:layout_alignParentLeft、android:layout_alignParentRigh；</p><p>五、TableLayout：表格布局，<br>每一个TableLayout里面有表格行TableRow，<br>TableRow里面可以具体定义每一个元素。<br>每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。</p><p>3、 android中的动画有哪几类，它们的特点和区别是什么</p><p>答：两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</p><p>4、 android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。</p><p>答：XML解析主要有三种方式，SAX、DOM、PULL。常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。</p><p>5、 ListView的优化方案</p><p>答：</p><p>1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。</p><p>2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。</p><p>3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。</p><p>6、 请介绍下Android的数据存储方式。</p><p>答：</p><p>使用SharedPreferences存储数据；文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据；</p><p>Preference，File， DataBase这三种方式分别对应的目录是/data/data/Package Name/Shared_Pref, /data/data/Package Name/files, /data/data/Package Name/database 。</p><p>一：使用SharedPreferences存储数据</p><p>首先说明SharedPreferences存储方式，它是 Android提供的用来存储一些简单配置信息的一种机制，</p><p>例如：登录用户的用户名与密码。</p><p>其采用了Map数据结构来存储数据，以键值的方式存储，可以简单的读取与写入，具体实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void ReadSharedPreferences()&#123;</span><br><span class="line"></span><br><span class="line">String strName,strPassword;</span><br><span class="line"></span><br><span class="line">SharedPreferences user = getSharedPreferences(“user_info”,0);</span><br><span class="line"></span><br><span class="line">strName = user.getString(“NAME”,””);</span><br><span class="line">strPassword = user getString(“PASSWORD”,””);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WriteSharedPreferences(String strName,String strPassword)&#123;</span><br><span class="line"></span><br><span class="line">SharedPreferences user = getSharedPreferences(“user_info”,0);</span><br><span class="line"></span><br><span class="line">uer.edit();</span><br><span class="line">user.putString(“NAME”, strName);</span><br><span class="line">user.putString(“PASSWORD” ,strPassword);</span><br><span class="line">user.commit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据读取与写入的方法都非常简单，只是在写入的时候有些区别：先调用edit()使其处于编辑状态，然后才能修改数据，最后使用commit()提交修改的数据。</p><p>实际上SharedPreferences是采用了XML格式将数据存储到设备中，在DDMS中的File Explorer中的/data/data//shares_prefs下。</p><p>使用SharedPreferences是有些限制的：只能在同一个包内使用，不能在不同的包之间使用。</p><p>二：文件存储数据</p><p>文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与 Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。具体实例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String fn = “moandroid.log”;</span><br><span class="line">FileInputStream fis = openFileInput(fn);</span><br><span class="line">FileOutputStream fos = openFileOutput(fn,Context.MODE_PRIVATE);</span><br></pre></td></tr></table></figure><p>三：网络存储数据</p><p>网络存储方式，需要与Android 网络数据包打交道，关于Android 网络数据包的详细说明，请阅读Android SDK引用了Java SDK的哪些package？。</p><p>四：ContentProvider</p><p>1、ContentProvider简介</p><p>当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。</p><p>2、Uri类简介</p><p>Uri代表了要操作的数据，Uri主要包含了两部分信息：</p><p>1.需要操作的ContentProvider ，<br>2.对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成：</p><p>1.scheme：ContentProvider（内容提供者）的scheme已经由Android所规定为：content://…<br>2.主机名（或Authority）：用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。</p><p>3.路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下：<br>要操作contact表中id为10的记录，可以构建这样的路径:/contact/10<br>要操作contact表中id为10的记录的name字段， contact/10/name<br>要操作contact表中的所有记录，可以构建这样的路径:/contact?<br>要操作的数据不一定来自数据库，也可以是文件等他存储方式，如下:<br>要操作xml文件中contact节点下的name节点，可以构建这样的路径：/contact/name<br>如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：<br>Uri uri = Uri.parse(“content://com.changcheng.provider.contactprovider/contact”)</p><p>3、UriMatcher、ContentUrist和ContentResolver简介</p><p>因为Uri代表了要操作的数据，所以我们很经常需要解析Uri，并从 Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher 和ContentUris 。掌握它们的使用，会便于我们的开发工作。</p><p>UriMatcher：用于匹配Uri，它的用法如下：</p><p>1.首先把你需要匹配Uri路径全部给注册上，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码(-1)。</span><br><span class="line">UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">//如果match()方法匹配content://com.changcheng.sqlite.provider.contactprovider /contact路径，返回匹配码为1</span><br><span class="line">uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact”, 1);//添加需要匹配uri，如果匹配就会返回匹配码</span><br><span class="line">//如果match()方法匹配 content://com.changcheng.sqlite.provider.contactprovider/contact/230路径，返回匹配码为2</span><br><span class="line">uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact/#”, 2);//#号为通配符</span><br></pre></td></tr></table></figure><p>2.注册完需要匹配的Uri后，就可以使用uriMatcher.match(uri)</p><p>方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用 addURI()方法传入的第三个参数，假设匹配 content://com.changcheng.sqlite.provider.contactprovider/contact路径，返回的匹配码为1。<br>ContentUris：用于获取Uri路径后面的ID部分，它有两个比较实用的方法：<br>withAppendedId(uri, id)用于为路径加上ID部分<br>parseId(uri)方法用于从路径中获取ID部分<br>ContentResolver：当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用 ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver使用insert、delete、update、query方法，来操作数据。</p><p>7、 activity的启动模式有哪些？是什么含义？</p><p>答：</p><p>在android里，有4种activity的启动模式，分别为：</p><p>“standard” (默认)<br>“singleTop”<br>“singleTask”<br>“singleInstance”</p><p>它们主要有如下不同：</p><ol><li><p>如何决定所属task<br>“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。<br>如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。<br>“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。</p></li><li><p>是否允许多个实例<br>“standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例；<br>“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。</p></li><li><p>是否允许其它activity存在于本task内<br>“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。<br>而另外三种模式，则可以和其它activity共存。</p></li><li><p>是否每次都生成新实例<br>“standard”对于没一个启动Intent都会生成一个activity的新实例；<br>“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。</p></li></ol><p>比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。<br>如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D<br>如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。<br>“singleInstance”是其所在栈的唯一activity，它会每次都被重用。<br>“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。</p><p>当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。</p><p>8、 跟activity和Task 有关的 Intent启动方式有哪些？其含义？</p><p>核心的Intent Flag有：<br>FLAG_ACTIVITY_NEW_TASK<br>FLAG_ACTIVITY_CLEAR_TOP<br>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED<br>FLAG_ACTIVITY_SINGLE_TOP<br>FLAG_ACTIVITY_NEW_TASK</p><p>如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的 Activity）定义了用户可以迁移的Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。<br>这个标志一般用于呈现“启动”类型的行为：它们提供用户一系列可以单独完成的事情，与启动它们的Activity完全无关。</p><p>使用这个标志，如果正在启动的Activity的Task已经在运行的话，那么，新的Activity将不会启动；代替的，当前Task会简单的移入前台。参考FLAG_ACTIVITY_MULTIPLE_TASK标志，可以禁用这一行为。</p><p>这个标志不能用于调用方对已经启动的Activity请求结果。</p><p>FLAG_ACTIVITY_CLEAR_TOP</p><p>如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。</p><p>例如，假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。<br>上例中正在运行的Activity B既可以在onNewIntent()中接收到这个新的Intent，也可以把自己关闭然后重新启动来接收这个Intent。</p><p>如果它的启动模式声明为 “multiple”(默认值)，并且你没有在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，那么它将关闭然后重新创建；对于其它的启动模式，或者在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，都将把这个Intent投递到当前这个实例的onNewIntent()中。<br>这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。</p><p>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</p><p>如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。</p><p>FLAG_ACTIVITY_SINGLE_TOP</p><p>如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的<br>FLAG_ACTIVITY_BROUGHT_TO_FRONT<br>这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。</p><p>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</p><p>如果设置，这将在Task的Activity stack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。</p><p>这在你的程序有分割点的时候很有用。</p><p>例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个 Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。</p><p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</p><p>如果设置，新的Activity不会在最近启动的Activity的列表中保存。</p><p>FLAG_ACTIVITY_FORWARD_RESULT</p><p>如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的 Activity。</p><p>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</p><p>这个标志一般不由应用程序代码设置，如果这个Activity是从历史记录里启动的（常按HOME键），那么，系统会帮你设定。</p><p>FLAG_ACTIVITY_MULTIPLE_TASK</p><p>不要使用这个标志，除非你自己实现了应用程序启动器。与FLAG_ACTIVITY_NEW_TASK结合起来使用，可以禁用把已存的Task送入前台的行为。当设置时，新的Task总是会启动来处理Intent，而不管这是是否已经有一个Task可以处理相同的事情。</p><p>由于默认的系统不包含图形Task管理功能，因此，你不应该使用这个标志，除非你提供给用户一种方式可以返回到已经启动的Task。</p><p>如果FLAG_ACTIVITY_NEW_TASK标志没有设置，这个标志被忽略。</p><p>FLAG_ACTIVITY_NO_ANIMATION</p><p>如果在Intent中设置，并传递给Context.startActivity()的话，这个标志将阻止系统进入下一个Activity时应用 Acitivity迁移动画。这并不意味着动画将永不运行——如果另一个Activity在启动显示之前，没有指定这个标志，那么，动画将被应用。这个标志可以很好的用于执行一连串的操作，而动画被看作是更高一级的事件的驱动。</p><p>FLAG_ACTIVITY_NO_HISTORY</p><p>如果设置，新的Activity将不再历史stack中保留。用户一离开它，这个Activity就关闭了。这也可以通过设置noHistory特性。</p><p>FLAG_ACTIVITY_NO_USER_ACTION</p><p>如果设置，作为新启动的Activity进入前台时，这个标志将在Activity暂停之前阻止从最前方的Activity回调的onUserLeaveHint()。</p><p>典型的，一个Activity可以依赖这个回调指明显式的用户动作引起的Activity移出后台。这个回调在Activity的生命周期中标记一个合适的点，并关闭一些Notification。</p><p>如果一个Activity通过非用户驱动的事件，如来电或闹钟，启动的，这个标志也应该传递给Context.startActivity，保证暂停的Activity不认为用户已经知晓其Notification。</p><p>FLAG_ACTIVITY_PREVIOUS_IS_TOP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If set and this intent is being used to launch a new activity from an existing one, the current activity will not be counted as the top activity for deciding whether the new intent should be delivered to the top instead of starting a new one. The previous activity will be used as the top, with the assumption being that the current activity will finish itself immediately.</span><br></pre></td></tr></table></figure><p>FLAG_ACTIVITY_REORDER_TO_FRONT</p><p>如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。</p><p>例如，假设一个Task由四个Activity组成：A,B,C,D。</p><p>如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。</p><p>9、 请描述下Activity的生命周期。</p><p>答：activity的生命周期方法有：onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()；</p><p>可见生命周期：从onStart()直到系统调用onStop()<br>前台生命周期：从onResume()直到系统调用onPause()</p><p>10、 activity在屏幕旋转时的生命周期</p><p>答：</p><p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p><p>11、 如何启用Service，如何停用Service。</p><p>服务的开发比较简单，如下：</p><p>第一步：继承Service类<br>public class SMSService extends Service {}</p><p>第二步：在AndroidManifest.xml文件中的节点里对服务进行配置:<br>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。</p><p>如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。</p><p>如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。</p><p>如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。</p><p>服务常用生命周期回调方法如下：</p><p>onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。</p><p>onDestroy()该方法在服务被终止时调用。</p><p>与采用Context.startService()方法启动服务有关的生命周期方法<br>onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。</p><p>多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。</p><p>与采用Context.bindService()方法启动服务有关的生命周期方法<br>onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。</p><p>onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。</p><p>该方法在调用者与服务解除绑定时被调用</p><p>12、 注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。</p><p>答：首先写一个类要继承BroadcastReceiver</p><p>第一种:在清单文件中声明,添加</p><p>第二种使用代码进行注册如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);</span><br><span class="line">IncomingSMSReceiver receiver = new IncomgSMSReceiver();</span><br><span class="line">registerReceiver(receiver.filter);</span><br></pre></td></tr></table></figure><p>两种注册类型的区别是：</p><p>1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。<br>2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p><p>13、 请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。</p><p>答：</p><p>简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理.</p><p>Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列</p><p>Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息</p><p>Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的</p><p>Handler：Handler接受到消息后调用handleMessage进行处理</p><p>Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理<br>在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。</p><p>下面将对它们进行分别介绍：</p><ol><li><p>Message<br>Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。</p></li><li><p>Handler<br>Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。</p></li><li><p>Message Queue<br>Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。<br>每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。</p></li><li><p>Looper<br>Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。</p></li></ol><p>对于子线程使用Looper，API Doc提供了正确的使用方法：这个Message机制的大概流程：</p><ol><li><p>在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。</p></li><li><p>一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。</p></li></ol><p>随后Looper取出了那个Message，则调用 该Message的target指向的Hander的dispatchMessage函数对Message进行处理。</p><p>在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：</p><p>1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；<br>2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；<br>3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。<br>由此可见，我们实现的handleMessage方法是优先级最低的！</p><ol start="3"><li><p>Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！<br>在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！</p></li><li><p>当Handler对象的构造函数的参数为空，则为当前所在线程的Looper；</p></li><li><p>Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。</p></li></ol><p>14、 简要解释一下activity、 intent 、intent<br>filter、service、Broadcase、BroadcaseReceiver</p><p>答：</p><p>一个activity呈现了一个用户可以操作的可视化用户界面；一个service不包含可见的用户界面，而是在后台运行，可以与一个activity绑定，通过绑定暴露出来接口并与其进行通信；一个broadcast receiver是一个接收广播消息并做出回应的component，broadcast receiver没有界面；一个intent是一个Intent对象，它保存了消息的内容。</p><p>对于activity和service来说，它指定了请求的操作名称和待操作数据的URI，Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。</p><p>但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。它是通过将Intent对象和目标的intent filter相比较来完成这一工作的；一个component的intent filter告诉android该component能处理的intent。</p><p>intent filter也是在manifest文件中声明的。</p><p>15、 说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？</p><p>mvc是model,view,controller的缩写，mvc包含三个部分：</p><p>　　模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。</p><p>　　视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。</p><p>　　控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。</p><p>　　android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：</p><p>　　1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。</p><p>　　2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。</p><p>　　3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p><p>16、 什么是ANR 如何避免它？</p><p>答：</p><p>ANR：Application Not Responding。在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作的在5s内应用程序没能做出反应，BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，这既是ANR。</p><p>避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成。主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。</p><p>17、 什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？</p><p>答：程序出现异常，比如nullpointer。</p><p>避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息</p><p>18、 描述一下android的系统架构</p><p>android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层。</p><p>linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。</p><p>libraries和 android runtime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit（引擎），该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。android的runtime负责解释和执行生成的dalvik格式的字节码。</p><p>　　applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。</p><p>　　applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。</p><p>　　上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。</p><p>android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个 applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。</p><p>19、 请介绍下ContentProvider是如何实现数据共享的。</p><p>一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。</p><p>要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。<br>如何通过一套标准及统一的接口获取其他应用程序暴露的数据？<br>Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。</p><p>20、 Service和Thread的区别？</p><p>答：</p><p>servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。</p><p>1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。</p><p>2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。</p><p>如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。</p><p>既然这样，那么我们为什么要用 Service 呢？</p><p>其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。</p><p>另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。</p><p>举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。</p><p>因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。</p><p>因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。</p><p>21、 Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？</p><p>答：</p><p>会，比如nullpointerException。我遇到过，比如textview.setText()时，textview没有初始化。会导致程序无法正常运行出现forceclose。打开控制台查看logcat信息找出异常信息并修改程序。</p><p>22、 IntentService有何优点?</p><p>答：</p><p>Acitivity的进程，当处理Intent的时候，会产生一个对应的Service； Android的进程处理器现在会尽可能的不kill掉你；非常容易使用</p><p>23、 </p><p>如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？</p><p>答：重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据</p><p>24、 如何将一个Activity设置成窗口的样式。</p><p>答：</p><p>中配置：android :theme=”@android:style/Theme.Dialog”<br>另外android:theme=”@android:style/Theme.Translucent” 是设置透明</p><p>25、 如何退出Activity？如何安全退出已调用多个Activity的Application？</p><p>答：</p><p>对于单一Activity的应用来说，退出很简单，直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。</p><p>对于多个activity，</p><p>1、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。</p><p>2、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。</p><p>3、递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。为了编程方便，最好定义一个Activity基类，处理这些共通问题。</p><p>在2.1之前，可以使用ActivityManager的restartPackage方法。</p><p>它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。<br>注意不要被它的名字迷惑。</p><p>可是，在2.2，这个方法失效了。在2.2添加了一个新的方法，killBackground Processes()，需要权限 android.permission.KILL_BACKGROUND_PROCESSES。可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。<br>另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。</p><p>它需要权限android.permission.FORCE_STOP_PACKAGES。</p><p>并且需要添加android:sharedUserId=”android.uid.system”属性。同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。</p><p>因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。</p><p>而Android.mk是用于在Android源码下编译程序用的。</p><p>从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。</p><p>现提供几个方法，供参考：</p><p>1、抛异常强制退出：<br>该方法通过抛异常，使程序Force Close。<br>验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。</p><p>2、记录打开的Activity：<br>每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。</p><p>3、发送特定广播：<br>在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。</p><p>4、递归退出<br>在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。</p><p>除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。</p><p>但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。</p><p>26、 AIDL的全称是什么？如何工作？能处理哪些类型的数据？</p><p>答：</p><p>全称是：Android Interface Define Language<br>在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢?</p><p>显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. </p><p>在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。</p><p>AIDL(AndRoid接口描述语言)是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.</p><p>AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。</p><p>它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: </p><ol><li><p>引入AIDL的相关类.; </p></li><li><p>调用aidl产生的class.</p></li></ol><p>AIDL的创建方法:</p><p>AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 </p><p>由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:</p><ol><li>不需要import声明的简单Java编程语言类型(int,boolean等)</li><li>String, CharSequence不需要特殊声明</li><li>List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.</li></ol><p>(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持)</p><p>27、 请解释下Android程序运行时权限与文件系统权限的区别。</p><p>答：运行时权限Dalvik( android授权)</p><p>文件系统 linux 内核授权</p><p>28、 系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。</p><p>通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性</p><p>29、 android系统的优势和不足</p><p>答：Android平台手机 5大优势：</p><p>一、开放性<br>在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。</p><p>二、挣脱运营商的束缚<br>在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市 ，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。</p><p>三、丰富的硬件选择<br>这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？</p><p>四、不受任何限制的开发商<br>Android平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、方面的程序和游戏如可控制正是留给Android难题之一。</p><p>五、无缝结合的Google应用<br>如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。</p><p>再说Android的5大不足：</p><p>一、安全和隐私<br>由于手机 与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。</p><p>二、首先开卖Android手机的不是最大运营商<br>众所周知，T-Mobile在23日，于美国纽约发布 了Android首款手机G1。但是在北美市场，最大的两家运营商乃AT&amp;T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！</p><p>三、运营商仍然能够影响到Android手机<br>在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。</p><p>四、同类机型用户减少<br>在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。</p><p>五、过分依赖开发商缺少标准配置<br>在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。但入手开始使用默认的程序同样可以应付多样的需要。在 Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐 播放器，全部依赖第三方开发，缺少了产品的统一性。</p><p>30、 Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念<br>答：DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。</p><p>31、 sim卡的EF文件是什么？有何作用<br>答：sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的</p><p>32、 嵌入式操作系统内存管理有哪几种， 各有何特性<br>　　页式，段式，段页，用到了MMU,虚拟空间等技术</p><p>33、 什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?</p><p>嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。</p><p>34、 一条最长的短信息约占多少byte?</p><p>　　中文70(包括标点)，英文160，160个字节。　　</p><p>35、 有一个一维整型数组int[]data保存的是一张宽为width，高为height的图片像素值信息。请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50% ###。</p><p>36、 如何将SQLite数据库(dictionary.db文件)与apk文件一起发布<br>解答：可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中</p><p>37、 如何将打开res aw目录中的数据库文件?</p><p>解答：在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。</p><p>复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。</p><p>在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。</p><p>38、 DDMS和TraceView的区别?</p><p>DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器 。</p><p>39、 java中如何引用本地语言</p><p>可以用JNI（java native interface java 本地接口）接口 。</p><p>40、 谈谈Android的IPC（进程间通信）机制</p><p>IPC是内部进程通信的简称， 是共享”命名管道”的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。</p><p>41、 NDK是什么</p><p>NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。<br>NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android课程体系</title>
    <link href="https://huangguangda.github.io/2018/05/11/1/"/>
    <id>https://huangguangda.github.io/2018/05/11/1/</id>
    <published>2018-05-11T02:59:53.000Z</published>
    <updated>2018-06-22T03:17:06.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>来源网络收集</p><p>第一阶段：Java se阶段</p><p>阶段    课程    课程内容    讲解知识点</p><p>Java语言基础    入门基础    </p><p>1.Java开发环境搭建<br>（第一天只能使用文本文档编写代码）    </p><p>1.Java语言发展史介绍<br>2.Java体系与特点<br>3.JVM与GC介绍<br>4.Java跨平台原理<br>5.JavaSE组成概念<br>6.JDK与JRE介绍<br>7.Java开发环境搭建<br>8.实现 HelloWorld 程序<br>9.HelloWorld程序编写与分析<br>10.Java中的三种注释<br>11.常见Java开发工具介绍<br>12.Wiki文档的使用技巧    </p><p>1.基本语法与命名规范<br>2.程序分支结构控制<br>3.数组及常用算法<br>（可以考虑使用Editplus编辑器）    </p><p>1.1    变量<br>1.2  数据类型<br>1.3  二进制以及进制间转换<br>1.4  标识符<br>1.5  类型转换<br>1.6  关键字<br>1.7  常量<br>1.8  转义字符<br>1.9  算术运算符<br>1.10  赋值运算符<br>1.11  关系运算符<br>1.12  逻辑运算符<br>1.13  位运算符<br>1.14  移位运算符<br>1.15  字符串连接运算符<br>1.16  三目运算符<br>1.17  运算符优先级</p><p>2.1   if条件语句<br>2.2   switch语句<br>2.3   for循环语句<br>2.4   while循环语句<br>2.5   do while循环语句</p><p>3.1数组四种声明方式以及特性<br>3.2数组插入、遍历等常用操作<br>3.3常用算法：最大、最小、平均值<br>3.4多维数组声明及原理<br>3.5多维数组的存储、遍历等操作    </p><p>面向对象</p><p>基础</p><p>1.面向过程与面向对象思想分析<br>2.封装性<br>3.String类<br>4.this关键字<br>5.static关键字<br>6.对象数组<br>7.JDK1.5新特性<br>8.代码块<br>9.内部类    1.1面向对象思想介绍<br>1.2面向过程与面向对象分析<br>1.3什么是类？什么是对象？<br>1.4类与对象之间的关系<br>1.5类的定义格式<br>1.6对象的定义格式<br>1.7创建对象时的内存分析<br>1.8调用类中的属性，调用方法<br>1.9方法的重载</p><p>2.1   封装性介绍<br>2.2   构造方法<br>2.3   构造方法的重载<br>2.4   匿名对象<br>2.5   如何设计一个类</p><p>3.1   String的两种赋值方式<br>3.2   String的比较<br>3.3   String两种赋值方式的区别<br>3.4   String的值不可改变<br>        （字符串常量池）<br>3.5   String类的常用操作方法<br>3.6   引用传递深入讲解<br>        （课件中三个范例）<br>3.6一对一关系讲解</p><p>4.1   this关键字<br>4.2   this调用类中的属性<br>4.3   this调用类中的方法<br>4.4   this表示当前对象<br>4.5   this接收本类引用<br>        （自定义对象的比较）</p><p>5.1   static关键字介绍<br>5.2   static特点<br>5.3   static访问限制<br>5.4   成员变量和类变量<br>5.5   static属性内存分析<br>5.6   应用案例- - 计数器<br>5.7   main方法讲解<br>5.8   设计模式—单例（懒汉、饿汉）</p><p>6.1   自定义对象定义数组<br>6.2   对象数组案例-商品管理系统</p><p>7.1   foreach输出<br>7.2   可变参数</p><p>8.1   普通代码块<br>8.2   构造块<br>8.3   静态代码块<br>8.4   三种代码块以及构造方法执行顺序</p><p>9.1内部类概念<br>9.2内部类的访问规则<br>9.3内部类的访问限制<br>9.4递归<br>9.5链表（添加、删除、输出）    </p><p>高级    </p><p>1.继承<br>2.super关键字<br>3.final关键字<br>4.抽象类<br>5.接口<br>6.多态性<br>7.instanceOf关键字<br>8.Object类<br>9.抽象类和接口的关系<br>10.接口应用<br>11.匿名内部类<br>12.包装类<br>13.包与访问修饰符<br>14.Eclipse介绍    </p><p>1.1继承的概念（定义）<br>1.2继承的格式<br>1.3继承的好处<br>1.4继承的限制<br>1.5子类的实例化过程<br>1.6访问修饰符讲解<br>1.7重载和重写的区别</p><p>2.1   super关键字<br>2.2   super调用父类中的属性<br>2.3   super调用父类中的方法</p><p>3.1   final关键字<br>3.2   final修饰类<br>3.3   final修饰方法<br>3.4   final修饰属性</p><p>4.1   抽象类概念、定义<br>4.2   抽象方法<br>4.3   抽象类特点<br>4.4   设计模式—模板方法<br>（大保健的例子）</p><p>5.1   接口的定义<br>5.2   接口的特点<br>5.3   接口多实现、不能实例化…<br>5.4   设计模式—策略模式<br>5.5   接口总结（接口中定义什么？）</p><p>6.1   多态概念<br>6.2   两种多态<br>6.3   向上、向下转型<br>6.4   多态的体现<br>6.5   多态的好处<br>6.6   多态的弊端<br>6.7   多态的前提</p><p>7.1   instanceOf关键字<br>7.2   抽象类的实际应用<br>7.3   接口的实际应用</p><p>8.1   Object类讲解<br>8.2   toString方法<br>8.3   equals方法<br>8.4   Object接收任意引用参数</p><p>9.1   （简单介绍即）</p><p>10.1  简单工厂设计模式<br>10.2  代理设计模式<br>（课件案例或潘金莲案例）<br>10.3  适配器模式（课件案例）<br>10.4  面向对象六大原则其中三个</p><p>12.1匿名内部类</p><p>12.1  包装类概念介绍<br>12.2  装箱、拆箱概念<br>12.3  JDK1.5新特性—<br>自动装箱、自动拆箱<br>12.4  转型操作<br>12.5  Integer—享元设计模式</p><p>13.1   包介绍<br>13.2  包的命名规则<br>13.3  访问修饰符的访问范围整理</p><p>14.1Eclipse接受<br>14.2发放Eclipse工具<br>14.3发放Eclipse配色、快捷键大全    </p><p>Java语言高级    异常处理    </p><p>1.认识并处理异常<br>2.异常的处理流程、<br>3.标准的异常处理格式<br>4.RuntimeException和<br>Exception的区别<br>5.自定义异常<br>6.Eclipse  Debug    </p><p>1.1演示算数异常的产生<br>1.2讲解异常结构图<br>1.3讲解Exception和Error的区别<br>1.4使用if语句先处理异常<br>1.5使用try catch处理异常<br>1.6演示数组下标越界异常<br>1.7处理数组下标越界异常</p><p>2.1   讲解异常捕获的流程<br>2.2   异常的统一出口finally<br>2.3   面试题：在try块中有return</p><p>语句并且正常执行，问Finally语句块中的内容是否会执行</p><p>2.4   throws关键字<br>2.5   throw关键字</p><p>3.1   演示标准的异常处理格式<br>3.2   添加多个catch语句块<br>3.3   多个catch块继承关系的顺序<br>3.4   JDK1.7多个catch的新支持<br>4.1   讲解RuntimeException<br>4.2   讲解 Exception<br>4.3   总结区别</p><p>5.1   自定义异常<br>5.2   使用自定义异常</p><p>6.1   讲解Eclipse Debug使用    </p><p>常用类库    </p><p>1.深入StringBuffer类及其操作方法<br>2.国际化程序的实现<br>3.日期操作，Date、DateFormat、SimpleDateFormat等<br>4.比较器的实现及原来二分查找、二叉树、以及对象的克隆    </p><p>1.1由String特性引出<br>1.2介绍StringBuffer特性<br>1.3StringBuffer实现原理：<br>A.默认缓冲区大小<br>B.缓冲区扩充算法<br>1.4StringBuilder介绍<br>1.5面试题：Builder与Buffer区别？</p><p>2.1   介绍国际化程序<br>2.2   Locale类介绍<br>2.3   ResourceBundle类介绍<br>2.2   实现国际化程序<br>2.5   处理动态文本</p><p>3.1   Math类介绍及常用方法演示<br>3.2   Random介绍及演示<br>3.3   Arrays类介绍及演示<br>3.4   演示Arrays类中的binarySearch方法<br>3.5   二分查找法（折半查找）<br>3.6   Date类介绍<br>3.7   Calendar类介绍<br>3.8   使用Calendar实现中国式时间<br>3.9   使用SimpleDateFormat格式化时间</p><p>4.1   Arrays的sort方法引出<br>4.2   Comparable接口讲解<br>4.3   排序规则的讲解<br>4.4   二叉树算法（添加、输出）<br>4.5   Comparator接口讲解<br>4.6   Cloneable接口讲解<br>4.7   对象的克隆实现</p><p>IO操作    </p><p>1.File类的使用及利用递归实现文件搜索器<br>2.字节操作流，InputStream、OutputStream、FileInputStream、ByteArrayInputStream等等<br>3.字符操作流，缓冲流、管道流、合并流<br>4.对象序列化及对象序列化原理，源码解析<br>5.装饰者设计模式    1.1File类的介绍<br>1.2 创建文件<br>1.3 删除文件<br>1.4 判断文件类型<br>1.5 列出目录中的文件<br>1.6 递归遍历文件</p><p>2.1    FileOutputStream<br>2.2    FileInputStream<br>2.3    一次读取一个字节示例<br>2.4    一次读取整个文件示例<br>2.5    定义缓冲区读取文件<br>2.6    文件复制习题</p><p>3.1    字节流读取中文引出乱码<br>3.2    字符流处理中文讲解<br>3.3    示例：使用字节流字符流分别写入文件<br>3.4    引出缓冲区概念，讲解字节流字符流区别<br>3.5    位字节流添加缓冲功能BufferedOutputStream<br>3.6    字节字符转换流OutputStreamWriter</p><p>InputStreamReader</p><p>3.7    使用字符流向文件输出‘97’<br>3.8    引出PrintStream打印流<br>3.9    文件分割、合并练习</p><p>4.1    对象序列化概念介绍<br>4.2    Serializable接口介绍<br>4.2    序列化：ObjectOutputStream<br>4.3    反序列化：ObjectInputStream<br>4.4    序列化一组对象<br>4.5    transient关键字作用<br>4.6    内存操作流ByteArrayInputStream<br>         ByteArrayOutputStream<br>4.7    缓冲区读取：BufferedReader类<br>4.7    数据流DataOutputStream<br>         DataInputStream<br>4.8    将管理系统序列化存储<br>4.9    字符编码介绍<br>4.10  IO体系结构梳理</p><p>5.1    装饰者设计模式讲解    </p><p>集合    </p><p>1.集合与数组的区别，缓存的管理，Collection 、List、Set接口的作用及相关的子类<br>2.Map集合与Conllection的区别，Map的好处及用法HashMap、HashTable、Properties等<br>3.Object 类中的方法及Object类存在的意义泛型的作用、枚举与泛型、泛型的好处<br>4.常用集合工具类Collections<br>5.哈希算法实现原来剖析    </p><p>1.1类集引出<br>1.2集合结构图讲解<br>1.3Collection接口讲解<br>1.4List接口讲解<br>1.5ArrayList实现原理及使用<br>1.6Vector实现原理及使用<br>1.7ArrayList和Vector区别<br>1.8LinkedList实现原理及使用<br>1.9LinkedList当做队列、堆栈使用<br>1.10Set接口讲解<br>1.11HashSet实现原理及使用<br>1.12TreeSet实现原理及使用<br>1.13平衡二叉树介绍<br>1.14集合输出Iterator接口<br>1.15双向输出ListIterator接口<br>1.16介绍废弃的接口Enumeration<br>1.17Foreach输出集合</p><p>2.1Map接口介绍<br>2.2HashMap实现原理及使用<br>2.3Object类中的hashCode方法<br>2.4哈希算法的存储实现原理<br>2.5哈希表的重新散列<br>2.6HashTable实现原理及使用<br>2.7HashMap和HashTable区别<br>2.8TreeMap实现原理 及使用<br>2.9Map集合的输出讲解</p><p>3.1一对多关系讲解<br>3.2多对多关系讲解</p><p>4.1Collections和Collection区别</p><p>5.1   分析hashCode、equals和内存泄露    </p><p>多线程    </p><p>1.进程和线程关系及区别<br>2.Thread与Runnable底层原理及使用作用原理<br>3.线程的优先级、线程池<br>4.线程的同步与死锁线程的并发处理    </p><p>1.1进程的概念<br>1.2线程的概念<br>1.3多线程概念介绍<br>1.4线程的两种实现方式<br>2<br>2.1两种实现方式的区别<br>2.2线程的操作状态<br>2.3线程的常用操作方法<br>2.4线程的强制执行<br>2.5线程的休眠<br>2.6线程的中断原理<br>3<br>3.1线程的优先级介绍<br>3.2线程池介绍及使用<br>4<br>4.1买票例子引出线程同步问题<br>4.2同步方法与同步代码块解决问题<br>4.3JDK1.5 新的加锁方式Lock<br>4.4模拟线程死锁<br>4.5生产者消费者案例讲解<br>4.6线程的生命周期    通过本章学习，可以掌握Java中线程的两种实现方式，熟练使用Java中的多线程，要求掌握Java中线程的同步并且避免Java中线程的死锁问题。理解并熟练使用线程池。    2<br>    网络编程    1.TCP、UDP程序的实现<br>2.ServerSocket  和Scoket 类的使用<br>3.URLConnection的使用    1.1计算机网络介绍<br>1.2网络通信协议介绍<br>1.3网络通信接口介绍<br>1.4CS/BS程序介绍<br>1.5TCP/IP协议介绍<br>1.6三次握手原理讲解<br>2<br>2.1使用Socket、和ServerSocket<br>编写服务器端程序<br>2.2使用Socket写客户端程序<br>2.3为服务器端加入ECHO<br>2.4为服务器端加入多线程<br>2.5UDP协议介绍<br>2.6使用DatagramPacket、<br>DatagramSocket实现UDP程序</p><p>3.1   URL介绍<br>3.2   URLConnection介绍<br>3.3   连网下载图片案例讲解    </p><p>GUI编程    </p><p>1.常用组件了解<br>2.事件与监听器<br>3.观察者设计模式    1.1GUI介绍<br>1.2AWT组成结构介绍<br>1.3Component类介绍<br>1.4Frame类介绍<br>1.5Panel讲解<br>1.6实现我们的第一个窗体<br>1.7Toolkit介绍<br>1.8使用Toolkit设置初始化位置<br>1.9布局介绍<br>1.10四种布局讲解</p><p>2.1实现事件处理的步骤<br>2.23种事件处理方式</p><p>3.1观察者设计模式实现<br>3.2使用JDK提供的观察者<br>3.3Swing介绍<br>3.4使用swing画登录窗体    </p><p>反射内省    1.Java Reflection API的作用、检查运行时的对象、动态更新字段、调用方法</p><p>2.反射主要的类 Class 、Method 、Field 、Constructor<br>3.内省机制的使用    </p><p>1.1什么是反射<br>1.2Class类讲解<br>1.3Class类的三种实例化方式<br>1.4使用Class类实例化对象<br>1.5反射调用无参构造方法<br>1.6反射调用有参构造方法<br>1.7反射类所在的包<br>1.8反射获取类中的属性（公有）<br>1.9反射获取类中的私有属性<br>1.10反射调用类中的私有方法</p><p>2.1Constructor类介绍<br>2.2Method类介绍<br>2.3Field类介绍</p><p>3.1内省概念介绍<br>3.2JavaBean介绍<br>3.3标准的get/set介绍<br>3.4使用trospector模拟框架底层</p><p>XML    </p><p>1.XML基础简介<br>2.XML的解析方式<br>3.深入XML两种解析思想DOM与SAX<br>4.DOM4J与JDOM    </p><p>1.1XML介绍<br>1.2XML用途</p><p>2.1XML的两种解析原理<br>2.2DOM原理讲解<br>2.3DOM解析示例<br>2.4SAX原理讲解<br>2.5SAX解析示例</p><p>3.1JDOM解析示例<br>3.2DOM4J解析示例<br>3.3通过对象生成XML文件<br>3.4各种解析方法分析比较    </p><p>XML文件可以用作数据的存储，数据传输，配置文件。</p><p>第二阶段：Java Web（2周/10天共60课时）</p><p>数据库应用    MySQL    </p><p>1.Mysql安装、基础语法、DDL、DML、DCL语法的操作、事务管理、数据库设计范式等    </p><p>JDBC    </p><p>1.JDBC实现对Mysql实现CURD操作<br>2.Sql注入问题及解决方案<br>3.批处理与事务控制<br>4.DAO设计模式</p><p>Java Web<br>前台与服务器端应用    </p><p>1.HTML标签<br>2.Web服务器环境搭建与配置<br>3.Web三大组件，Servlet<br>4.使用httpwatch解析Http协议原理<br>5.Web程序设计及MVC设计模式<br>6.Html5与JavaScript    </p><p>第三阶段：Android阶段</p><p>Android基础<br>Android入门    </p><p>1.Android简史<br>2.Android体系结构<br>3.DVM与JVM<br>4.SDK的获取(搭环境)<br>5.SDK目录结构<br>6.创建模拟器启动<br>7.运行HelloWord<br>8.项目目录结构<br>9.应用打包安装过程<br>10.DDMS使用<br>11.Logcat的使用</p><p>Android基础UI    </p><p>1.常用基本控件<br>2.Toast<br>3.常用响应事件<br>4.Menu<br>5.Dialog<br>6.常用布局</p><p>掌握Android<br>常用Menu 与 各种Dialog, 以及Android的五种布局    </p><p>Android文件读写<br>1.内部存储与外部存   储概念<br>2.内部存储读写文件<br>3.使用路径API在内部存储中读写文件<br>4.文件访问权限<br>5.外部存储读写文件<br>6.导入Setting源码<br>7.获取SD卡剩余容量<br>8.SharedPreference的使用    </p><p>掌握</p><p>SharedPreference的使用方式    </p><p>生成XML文件,Android单元测试与数据库操作    </p><p>1.Xml生成与解析 并通过debug 查看解析过程<br>2.Android中的单元测试<br>3.SQLite数据库简介<br>4.创建数据库<br>5.增删改查<br>6.SQLite事物<br>7.数据展示</p><p>Android单元测试</p><p>SQLite数据库的使用;<br>    AdapterView    </p><p>1.ListView 预览<br>2.Adapter简介<br>3.ListView的使用<br>4.ArrayAdapter ,SimpleAdapter ,CursorAdapter , SimpleCursorAdapter 等adapter的使用<br>5.BaseAdapter的使用(自定义Adapter)<br>6.Spinner选择列表的使用<br>7.GridView网格视图的使用<br>8.ListView , Spinner , GridView与BaseAdapter结合;<br>9.ListView , Spinner , GridView缓存原理与BaseAdapter优化    </p><p>Android进阶    Activity与 Intent    </p><p>1.Activity使用<br>2.Activity四大加载模式<br>2.Activity 生命周期<br>3.Activity 启动与关闭<br>4.Activity 横竖屏<br>5.Intent属性与使用<br>6.Activity 显式 隐式 带返回值跳转<br>7.IntentFilter(过滤器)<br>8.Activity回退栈原理</p><p>多线程与Android网络编程    </p><p>1.Android进程与线程<br>2.UI线程模型<br>3.Handler机制<br>4.使用消息队列刷新UI<br>5.AsyncTask的使用<br>6.进程通信<br>7.Android网络编程简介<br>8.获取网络状态<br>9.Get Post提交数据<br>10.Http协议<br>11.下载数据并建立本地缓存<br>12.JSON生成与解析 , Gson.jar包使用</p><p>1.服务介绍<br>2.启动Service与生命周期<br>3.绑定Service与生命周期<br>4.混合启动Service与声明周期<br>5.启动远程服务</p><ol start="6"><li>AIDL的使用</li></ol><p>Android四大组件之广播    </p><p>1.Android广播机制与概念<br>2.定义广播接收者<br>3.无序广播与有序广播<br>4.短信拦截系统<br>5.内存卡状态监听<br>6.监控应用状态<br>7.发送无序广播与有序广播<br>8.发送系统级广播</p><p>Android四大组件之内容提供者    </p><p>1.内容提供者简介<br>2.增删改差<br>3.URL匹配器<br>4.备份系统短信<br>5.插入系统短信<br>6.备份通讯录<br>7.插入联系人</p><p>Android多媒体编程    </p><p>1.摄像头的使用<br>2.图片处理<br>3.画板<br>4.音乐播放<br>5.视频播放    </p><p>Android动画    </p><p>1.动画简介<br>2.逐帧动画<br>3.补间动画<br>4.XML与JAVA代码形式实现<br>5.混合使用补间动画    </p><p>Android高级    </p><p>高级UI组件<br>与<br>常用开源组件</p><p>1.widget 桌面控件<br>2.XlistView 上拉刷新, 下拉加载更多<br>3.Drawerlayout抽屉效果<br>4.PopupWindow 定点弹窗<br>5.ExpandableListView 二级展开列表<br>6.ViewPager 滑动<br>7.WebView 网页加载    </p><p>Android碎片化之Fragment    </p><p>1.Android碎片化介绍<br>2.Fragment简介<br>3.FragmentManager使用<br>4.Fragment生命周期<br>5.Fragment使用方式<br>6.Fragment事物<br>7.Fragment 常见错误使用方式<br>8.Fragment与Viewpager结合使用    </p><p>开源框架之Volly    </p><p>1.Volly框架简介<br>2.创建请求队列<br>3.请求对象 StringRequest , JsonObjecyRequest,<br>JsonArrayRequest,<br>4.GET/POST请求<br>5.绑定Activity<br>6.二次回调封装<br>7.ImageRequest,<br>ImageLoader,<br>NetWorkImageView, 加载网络图片 并 监听<br>8.lruCache与ImageCache 本地缓存    </p><p>开源框架之Xutils    </p><p>1.Xutils四大模块简介<br>2.ViewUtils模块: 简化界面代码<br>3.DBUtils模块: 简化数据库操作<br>4.BitmapUtils模块: 优化图片加载<br>5.HttpUtils 模块: GET/POST请求网络    </p><p>开源框架之UniversalImageLoader    </p><p>1.图片加载器ImageLoader的单例模式简介<br>2.ImageLoaderConfiguration的作用<br>3.使用默认的ImageLoaderConfiguration给图片加载器ImageLoader配置加载参数<br>4.通过API方法自行创建ImageLoaderConfiguration对象设置加载参数<br>5.通过displayImage()异步加载图片<br>6.通过loadImage()异步加载图片<br>7.PauseOnScrollListener监听器的使用    </p><p>开源框架之Glide    </p><p>1.Glide简介<br>2.Glide中Gif动图与视频的解码方式介绍,<br>3.使用Glide加载gif图<br>4.使用Glide加载缩略图    </p><p>开源框架之Cropper    </p><p>1.Cropper简介<br>2.使用Cropper剪裁图片<br>3.使用Cropper实现图片旋转等    </p><p>LSB应用    百度地图</p><p>1.百度地图API简介<br>2.注册百度开发者以及地图访问密钥<br>3.集成百度地图SDK并成功调用出地图页面<br>5.设置地图显示类型<br>6.百度地图图层概念介绍<br>7.添加实时交通状况图层、添加热力图图层、添加标注点图层、添加弹出窗图层<br>8.使用百度地图实现定位<br>9.使用百度地图实现路径规划（步行、公共交通、驾车）<br>10.使用百度地图实现POI检索（附近检索、全程检索、详情检索</p><p>Android6.0新特性</p><p>Android M特点及Android Studio    </p><p>1.Android Studio下载与安装<br>2.Studio项目结构与运行HelloWord<br>3.常用功能介绍<br>4.常用快捷键介绍<br>5.导出导入Eclipse项目<br>6.APK打包签名设置<br>7.Gradle Plugin 中 buildTypes 、 productFlavors<br>8.Android6.0与新特性<br>9.Gradle自动化项目构建工具    </p><p>高级应用    </p><p>项目构建工具、项目版本管理、Android测试与发布、阿里云服务器    </p><p>1.Gradle项目构建工具<br>2.Git项目版本控制<br>3.JUnit单元测试<br>4.Android应用发布流程<br>5.阿里云服务器搭建及使用技巧    </p><p>编辑 ：达叔</p><p>定位：分享 Android&amp;Java 知识点</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android技术面试整理附有详细答案(包括百度、新浪、中科软等多家公司笔试面试题)</title>
    <link href="https://huangguangda.github.io/2018/05/10/1/"/>
    <id>https://huangguangda.github.io/2018/05/10/1/</id>
    <published>2018-05-10T02:30:45.000Z</published>
    <updated>2018-06-22T02:34:47.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>1、Android的四大组件是哪些，它们的作用？</p><p>答：</p><p>Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑</p><p>service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的食物，定义好需要接受的Intent提供同步和异步的接口</p><p>Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的借口模型，大大简化上层应用，对数据的整合提供了更方便的途径</p><p>BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型</p><p>2、请介绍下Android中常用的五种布局。</p><p>常用五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。</p><p>一、</p><p>FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。</p><p>二、</p><p>LinearLayout：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）。</p><p>当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。</p><p>三、</p><p>AbsoluteLayout：绝对布局，用X,Y坐标来指定元素的位置，这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。</p><p>四、</p><p>RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。</p><p>主要属性有：</p><p>相对于某一个元素<br>android:layout_below、android:layout_toLeftOf</p><p>相对于父元素的地方<br>android:layout_alignParentLeft、android:layout_alignParentRigh；</p><p>五、</p><p>TableLayout：表格布局，每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素。每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。</p><p>3、android中的动画有哪几类，它们的特点和区别是什么  </p><p>答：</p><p>两种，</p><p>一种是Tween动画、还有一种是Frame动画。</p><p>Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;</p><p>另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</p><p>4、android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。</p><p>答：</p><p>XML解析主要有三种方式，SAX、DOM、PULL。</p><p>常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。</p><p>而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。</p><p>SAX和PULL使用</p><p>Pull解析器的运行方式与 SAX 解析器相似</p><pre><code>区别为：SAX解析器的工作方式是自动将事件推入事件处理器进行处理，因此你不能控制事件的处理主动结束；而Pull解析器的工作方式为允许你的应用程序代码主动从解析器中获取事件，正因为是主动获取事件，因此可以在满足了需要的条件后不再获取事件，结束解析。你随便找个sax和pull的例子比较一下就可以发现，pull是一个while循环，随时可以跳出，而sax不是，sax是只要解析了，就必须解析完成。</code></pre><p>5、ListView的优化方案</p><p>答：</p><p>1、</p><p>如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。</p><p>2、</p><p>给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。</p><p>3、</p><p>如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。</p><p>6、请介绍下Android的数据存储方式。</p><p>答：</p><p>使用SharedPreferences存储数据；<br>文件存储数据；<br>SQLite数据库存储数据；<br>使用ContentProvider存储数据；<br>网络存储数据；</p><p>Preference，File， DataBase这三种方式</p><p>分别对应的目录是</p><p>/data/data/Package Name/Shared_Pref, </p><p>/data/data/Package Name/files, </p><p>/data/data/Package Name/database 。</p><p>一：使用SharedPreferences存储数据</p><p>首先说明SharedPreferences存储方式，它是 Android提供的用来存储一些简单配置信息的一种机制，例如：登录用户的用户名与密码。</p><p>其采用了Map数据结构来存储数据，以键值的方式存储，可以简单的读取与写入，具体实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void ReadSharedPreferences()&#123;</span><br><span class="line"></span><br><span class="line">String strName,strPassword;</span><br><span class="line"></span><br><span class="line">SharedPreferences user = getSharedPreferences(“user_info”,0);</span><br><span class="line"></span><br><span class="line">strName = user.getString(“NAME”,””);</span><br><span class="line">strPassword = user.getString(“PASSWORD”,””);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WriteSharedPreferences(String strName,String strPassword)&#123;</span><br><span class="line"></span><br><span class="line">SharedPreferences user = getSharedPreferences(“user_info”,0);</span><br><span class="line"></span><br><span class="line">uer.edit();</span><br><span class="line">user.putString(“NAME”, strName);</span><br><span class="line">user.putString(“PASSWORD” ,strPassword);</span><br><span class="line">user.commit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据读取与写入的方法都非常简单，只是在写入的时候有些区别：先调用edit()使其处于编辑状态，然后才能修改数据，最后使用commit()提交修改的数据。</p><p>实际上SharedPreferences是采用了XML格式将数据存储到设备中，<br>在DDMS中的File Explorer中的/data/data/<package name="">/shares_prefs下。</package></p><p>使用SharedPreferences是有些限制的：只能在同一个包内使用，不能在不同的包之间使用。</p><p>二：文件存储数据</p><p>文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与 Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。具体实例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String fn = “moandroid.log”;</span><br><span class="line">FileInputStream fis = openFileInput(fn);</span><br><span class="line">FileOutputStream fos = openFileOutput(fn,Context.MODE_PRIVATE);</span><br></pre></td></tr></table></figure><p>三：网络存储数据</p><p>网络存储方式，需要与Android 网络数据包打交道，关于Android 网络数据包的详细说明，请阅读Android SDK引用了Java SDK的哪些package？。</p><p>四：ContentProvider</p><p>1、ContentProvider简介</p><p>当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。</p><p>2、Uri类简介</p><p>Uri代表了要操作的数据，Uri主要包含了两部分信息：</p><p>1.需要操作的ContentProvider ，</p><p>2.对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成：</p><p>1.scheme：ContentProvider（内容提供者）的scheme已经由Android所规定为：content://…<br>2.主机名（或Authority）：用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。<br>3.路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下：</p><p>要操作contact表中id为10的记录，可以构建这样的路径:/contact/10</p><p>要操作contact表中id为10的记录的name字段， contact/10/name</p><p>要操作contact表中的所有记录，可以构建这样的路径:/contact?</p><p>要操作的数据不一定来自数据库，也可以是文件等他存储方式，如下:</p><p>要操作xml文件中contact节点下的name节点，可以构建这样的路径：/contact/name<br>如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：<br>Uri uri = Uri.parse(“content://com.changcheng.provider.contactprovider/contact”)</p><p>3、UriMatcher、ContentUrist和ContentResolver简介</p><p>因为Uri代表了要操作的数据，所以我们很经常需要解析Uri，并从 Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher 和ContentUris 。掌握它们的使用，会便于我们的开发工作。<br>UriMatcher：用于匹配Uri，它的用法如下：</p><p>1.首先把你需要匹配Uri路径全部给注册上，如下：</p><p>//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码(-1)。<br>UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);</p><p>//如果match()方法匹配content://com.changcheng.sqlite.provider.contactprovider /contact路径，返回匹配码为1</p><p>uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact”, 1);//添加需要匹配uri，如果匹配就会返回匹配码</p><p>//如果match()方法匹配 content://com.changcheng.sqlite.provider.contactprovider/contact/230路径，返回匹配码为2</p><p>uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact/#”, 2);//#号为通配符</p><p>2.注册完需要匹配的Uri后，就可以使用uriMatcher.match(uri)</p><p>方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用 addURI()方法传入的第三个参数，假设匹配 content://com.changcheng.sqlite.provider.contactprovider/contact路径，返回的匹配码为1。</p><p>ContentUris：用于获取Uri路径后面的ID部分，它有两个比较实用的方法：</p><p>withAppendedId(uri, id)用于为路径加上ID部分<br>parseId(uri)方法用于从路径中获取ID部分<br>ContentResolver：当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用 ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver使用insert、delete、update、query方法，来操作数据。</p><p>7、activity的启动模式有哪些？是什么含义？</p><p>答：</p><p>在android里，有4种activity的启动模式，分别为：<br>“standard” (默认)<br>“singleTop”<br>“singleTask”<br>“singleInstance”</p><p>它们主要有如下不同：</p><ol><li>如何决定所属task </li></ol><p>“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。<br>如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。<br>“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。</p><ol start="2"><li>是否允许多个实例 </li></ol><p>“standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例； </p><p>“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 </p><p>singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。</p><ol start="3"><li>是否允许其它activity存在于本task内 </li></ol><p>“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。<br>而另外三种模式，则可以和其它activity共存。</p><ol start="4"><li>是否每次都生成新实例 </li></ol><p>“standard”对于没一个启动Intent都会生成一个activity的新实例；<br>“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。 </p><p>比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。 </p><p>如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D<br>如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。</p><p>“singleInstance”是其所在栈的唯一activity，它会每次都被重用。<br>“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。</p><p>当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。</p><p>8、跟activity和Task 有关的 Intent启动方式有哪些？其含义？</p><p>核心的Intent Flag有：<br>FLAG_ACTIVITY_NEW_TASK<br>FLAG_ACTIVITY_CLEAR_TOP<br>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED<br>FLAG_ACTIVITY_SINGLE_TOP<br>FLAG_ACTIVITY_NEW_TASK </p><p>  如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的 Activity）定义了用户可以迁移的Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。 </p><p>  这个标志一般用于呈现“启动”类型的行为：它们提供用户一系列可以单独完成的事情，与启动它们的Activity完全无关。 </p><p>  使用这个标志，如果正在启动的Activity的Task已经在运行的话，那么，新的Activity将不会启动；代替的，当前Task会简单的移入前台。参考FLAG_ACTIVITY_MULTIPLE_TASK标志，可以禁用这一行为。 </p><p>  这个标志不能用于调用方对已经启动的Activity请求结果。</p><p>FLAG_ACTIVITY_CLEAR_TOP </p><p>  如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。 </p><p>  例如，假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。 </p><p>  上例中正在运行的Activity B既可以在onNewIntent()中接收到这个新的Intent，也可以把自己关闭然后重新启动来接收这个Intent。如果它的启动模式声明为 “multiple”(默认值)，并且你没有在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，那么它将关闭然后重新创建；对于其它的启动模式，或者在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，都将把这个Intent投递到当前这个实例的onNewIntent()中。 </p><p>  这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。 </p><p>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED </p><pre><code>如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。</code></pre><p>FLAG_ACTIVITY_SINGLE_TOP </p><p>  如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的<br>FLAG_ACTIVITY_BROUGHT_TO_FRONT<br>  这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。 </p><p>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET </p><p>  如果设置，这将在Task的Activity stack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。 </p><p>  这在你的程序有分割点的时候很有用。例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个 Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。 </p><p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS </p><p>  如果设置，新的Activity不会在最近启动的Activity的列表中保存。<br>FLAG_ACTIVITY_FORWARD_RESULT<br>  如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的 Activity。<br>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY<br>  这个标志一般不由应用程序代码设置，如果这个Activity是从历史记录里启动的（常按HOME键），那么，系统会帮你设定。 </p><p>FLAG_ACTIVITY_MULTIPLE_TASK </p><p>  不要使用这个标志，除非你自己实现了应用程序启动器。与FLAG_ACTIVITY_NEW_TASK结合起来使用，可以禁用把已存的Task送入前台的行为。当设置时，新的Task总是会启动来处理Intent，而不管这是是否已经有一个Task可以处理相同的事情。 </p><p>  由于默认的系统不包含图形Task管理功能，因此，你不应该使用这个标志，除非你提供给用户一种方式可以返回到已经启动的Task。 </p><p>  如果FLAG_ACTIVITY_NEW_TASK标志没有设置，这个标志被忽略。 </p><p>FLAG_ACTIVITY_NO_ANIMATION </p><p>  如果在Intent中设置，并传递给Context.startActivity()的话，这个标志将阻止系统进入下一个Activity时应用 Acitivity迁移动画。这并不意味着动画将永不运行——如果另一个Activity在启动显示之前，没有指定这个标志，那么，动画将被应用。这个标志可以很好的用于执行一连串的操作，而动画被看作是更高一级的事件的驱动。 </p><p>FLAG_ACTIVITY_NO_HISTORY </p><p>  如果设置，新的Activity将不再历史stack中保留。用户一离开它，这个Activity就关闭了。这也可以通过设置noHistory特性。 </p><p>FLAG_ACTIVITY_NO_USER_ACTION </p><p>  如果设置，作为新启动的Activity进入前台时，这个标志将在Activity暂停之前阻止从最前方的Activity回调的onUserLeaveHint()。 </p><p>  典型的，一个Activity可以依赖这个回调指明显式的用户动作引起的Activity移出后台。这个回调在Activity的生命周期中标记一个合适的点，并关闭一些Notification。 </p><p>  如果一个Activity通过非用户驱动的事件，如来电或闹钟，启动的，这个标志也应该传递给Context.startActivity，保证暂停的Activity不认为用户已经知晓其Notification。<br>FLAG_ACTIVITY_PREVIOUS_IS_TOP </p><p>  If set and this intent is being used to launch a new activity from an existing one, the current activity will not be counted as the top activity for deciding whether the new intent should be delivered to the top instead of starting a new one. The previous activity will be used as the top, with the assumption being that the current activity will finish itself immediately. </p><p>FLAG_ACTIVITY_REORDER_TO_FRONT </p><p>  如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。<br>  例如，假设一个Task由四个Activity组成：A,B,C,D。如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。 </p><p>9、请描述下Activity的生命周期。</p><p>答：</p><p>activity的生命周期方法有：</p><p>onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()；</p><p>可见生命周期：从onStart()直到系统调用onStop()</p><p>前台生命周期：从onResume()直到系统调用onPause()</p><p>10、activity在屏幕旋转时的生命周期</p><p>答：</p><p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p><p>11、如何启用Service，如何停用Service。</p><p>服务的开发比较简单，如下：</p><p>第一步：继承Service类</p><p>public class SMSService extends Service {}</p><p>第二步：在AndroidManifest.xml文件中的<application></application></p><p>节点里对服务进行配置:<service android:name=".SMSService"></service></p><p>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。</p><p>这两个方法都可以启动Service，但是它们的使用场合有所不同。</p><p>使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。</p><p>使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。</p><p>如果打算采用Context.startService()</p><p>方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。</p><p>如果调用startService()<br>方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。</p><p>采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。</p><p>如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。</p><p>这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。</p><p>如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。</p><p>如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。</p><p>服务常用生命周期回调方法如下： </p><p>onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。</p><p>onDestroy()该方法在服务被终止时调用。</p><p>与采用Context.startService()方法启动服务有关的生命周期方法<br>onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。</p><p>该方法在服务开始运行时被调用。</p><p>多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。<br>与采用Context.bindService()方法启动服务有关的生命周期方法<br>onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。</p><p>该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。</p><p>onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。</p><p>该方法在调用者与服务解除绑定时被调用</p><p>12、注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。</p><p>答：</p><p>首先写一个类要继承BroadcastReceiver</p><p>第一种:在清单文件中声明,添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receive android:name=&quot;.IncomingSMSReceiver &quot; &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">   &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;)</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;receiver&gt;</span><br></pre></td></tr></table></figure><p>第二种使用代码进行注册如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);</span><br><span class="line">IncomingSMSReceiver receiver = new IncomgSMSReceiver();</span><br><span class="line">registerReceiver(receiver.filter);</span><br></pre></td></tr></table></figure><p>两种注册类型的区别是：</p><p>1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。<br>2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p><p>13、请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。</p><p>答：</p><p>简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理.</p><p>Message Queue(消息队列)</p><p>：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列</p><p>Handler：</p><p>可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息</p><p>Looper：</p><p>是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的</p><p>Handler：</p><p>Handler接受到消息后调用handleMessage进行处理</p><p>Message：</p><p>消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理<br>在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。</p><p>下面将对它们进行分别介绍：</p><ol><li><p>Message<br> Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。</p></li><li><p>Handler<br> Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。</p></li><li><p>Message Queue<br> Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。<br> 每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。</p></li><li><p>Looper<br> Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。对于子线程使用Looper，API Doc提供了正确的使用方法：</p></li></ol><p>这个Message机制的大概流程：</p><ol><li><p>在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。</p></li><li><p>一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。</p></li></ol><p>随后Looper取出了那个Message，则调用 该Message的target指向的Hander的dispatchMessage函数对Message进行处理。在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：</p><pre><code>1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。由此可见，我们实现的handleMessage方法是优先级最低的！</code></pre><ol start="3"><li>Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！</li></ol><p>在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！ </p><pre><code>1. 当Handler对象的构造函数的参数为空，则为当前所在线程的Looper； </code></pre><ol start="2"><li>Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。</li></ol><p>14、简要解释一下activity、 intent 、intent filter、service、Broadcase、BroadcaseReceiver</p><p>答：</p><p>一个activity呈现了一个用户可以操作的可视化用户界面；一个service不包含可见的用户界面，而是在后台运行，可以与一个activity绑定，通过绑定暴露出来接口并与其进行通信；一个broadcast receiver是一个接收广播消息并做出回应的component，broadcast receiver没有界面；一个intent是一个Intent对象，它保存了消息的内容。</p><p>对于activity和service来说，它指定了请求的操作名称和待操作数据的URI，Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。它是通过将Intent对象和目标的intent filter相比较来完成这一工作的；一个component的intent filter告诉android该component能处理的intent。intent filter也是在manifest文件中声明的。</p><p>15、说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？</p><p>mvc是model,view,controller的缩写，mvc包含三个部分：</p><p>　　模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。<br>　　视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。<br>　　控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。</p><p>　　android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：</p><p>　　1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。</p><p>　　2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。</p><p>　　3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p><p>16、什么是ANR 如何避免它？</p><p>答：</p><p>ANR：Application Not Responding。在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作的在5s内应用程序没能做出反应，BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，这既是ANR。</p><p>避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成。主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。</p><p>17、什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？</p><p>答：程序出现异常，比如nullpointer。</p><p>避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息</p><p>18、描述一下android的系统架构</p><p>android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层。</p><p>linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。</p><p>libraries和 android runtime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit（引擎），该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。</p><p>android的runtime负责解释和执行生成的dalvik格式的字节码。</p><p>　　applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。</p><p>　　applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。</p><p>　　上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。</p><p>android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个 applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。</p><p>19、请介绍下ContentProvider是如何实现数据共享的。</p><p>一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。</p><p>要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。</p><p>如何通过一套标准及统一的接口获取其他应用程序暴露的数据？</p><p>Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。</p><p>20、Service和Thread的区别？</p><p>答：</p><p>servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。</p><p>1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。</p><p>2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。</p><p>既然这样，那么我们为什么要用 Service 呢？</p><p>其实这跟 android 的系统机制有关，我们先拿 Thread 来说。</p><p>Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。</p><p>因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。</p><p>另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。  </p><p>举个例子：</p><p>如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。  </p><p>因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。</p><p>21、Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？</p><p>答：</p><p>会，比如nullpointerException。我遇到过，比如textview.setText()时，textview没有初始化。会导致程序无法正常运行出现forceclose。打开控制台查看logcat信息找出异常信息并修改程序。</p><p>22、IntentService有何优点?</p><p>答：Acitivity的进程，当处理Intent的时候，会产生一个对应的Service； Android的进程处理器现在会尽可能的不kill掉你；非常容易使用</p><p>23、如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？</p><p>答：重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据</p><p>24、如何将一个Activity设置成窗口的样式。</p><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity&gt;中配置：android :theme=&quot;@android:style/Theme.Dialog&quot; </span><br><span class="line">另外android:theme=&quot;@android:style/Theme.Translucent&quot; 是设置透明</span><br></pre></td></tr></table></figure><p>25、如何退出Activity？如何安全退出已调用多个Activity的Application？</p><p>答：</p><p>对于单一Activity的应用来说，退出很简单，直接finish()即可。</p><p>当然，也可以用killProcess()和System.exit()这样的方法。</p><p>对于多个activity，</p><p>1、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。</p><p>2、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。</p><p>3、递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。</p><p>为了编程方便，最好定义一个Activity基类，处理这些共通问题。</p><p>在2.1之前，可以使用ActivityManager的restartPackage方法。</p><p>它可以直接结束整个应用。</p><p>在使用时需要权限android.permission.RESTART_PACKAGES。</p><p>注意不要被它的名字迷惑。</p><p>可是，在2.2，这个方法失效了。</p><p>在2.2添加了一个新的方法，killBackground Processes()，需要权限 android.permission.KILL_BACKGROUND_PROCESSES。</p><p>可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。</p><p>另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。</p><p>它需要权限android.permission.FORCE_STOP_PACKAGES。并且需要添加android:sharedUserId=”android.uid.system”属性。</p><p>同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。</p><p>因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。</p><p>而Android.mk是用于在Android源码下编译程序用的。</p><p>从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。<br>现提供几个方法，供参考：</p><p>1、抛异常强制退出：<br>该方法通过抛异常，使程序Force Close。<br>验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。</p><p>2、记录打开的Activity：<br>每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。</p><p>3、发送特定广播：<br>在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。</p><p>4、递归退出<br>在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。</p><p>除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。</p><p>但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。</p><p>26、AIDL的全称是什么？如何工作？能处理哪些类型的数据？</p><p>答：</p><p>全称是：Android Interface Define Language<br>在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢?</p><p>显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. 在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。</p><p>AIDL(AndRoid接口描述语言)是一种接口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.</p><p>AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.</p><p>AIDL的创建方法:</p><p>AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 </p><p>由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:</p><ol><li>不需要import声明的简单Java编程语言类型(int,boolean等)</li><li>String, CharSequence不需要特殊声明</li><li>List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.<br>(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持)</li></ol><p>27、请解释下Android程序运行时权限与文件系统权限的区别。</p><p>答：</p><p>运行时权限Dalvik( android授权)<br>文件系统 linux 内核授权</p><p>28、</p><p>系统上安装了多种浏览器，能否指定某浏览器访问指定页面？</p><p>请说明原由。<br>通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性</p><p>29、android系统的优势和不足</p><p>答：Android平台手机 5大优势： </p><p>一、开放性 </p><p>在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。</p><p>二、挣脱运营商的束缚 </p><p>在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市 ，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。</p><p>三、丰富的硬件选择 </p><p>这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？</p><p>四、不受任何限制的开发商 </p><p>Android平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、情色方面的程序和游戏如可控制正是留给Android难题之一。</p><p>五、无缝结合的Google应用 </p><p>如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。<br>再说Android的5大不足：</p><p>一、安全和隐私 </p><p>由于手机 与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。</p><p>二、首先开卖Android手机的不是最大运营商 </p><p>众所周知，T-Mobile在23日，于美国纽约发布 了Android首款手机G1。</p><p>但是在北美市场，最大的两家运营商乃AT&amp;T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！</p><p>三、运营商仍然能够影响到Android手机 </p><p>在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。</p><p>Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。</p><p>四、同类机型用户减少 </p><p>在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。</p><p>举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。</p><p>五、过分依赖开发商缺少标准配置 </p><p>在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。</p><p>但入手开始使用默认的程序同样可以应付多样的需要。</p><p>在 Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐 播放器，全部依赖第三方开发，缺少了产品的统一性。</p><p>30、Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念 </p><p>答：</p><p>DVM指dalivk的虚拟机。</p><p>每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。</p><p>而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。</p><p>31、sim卡的EF文件是什么？有何作用</p><p>答：</p><p>sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的</p><p>32、嵌入式操作系统内存管理有哪几种， 各有何特性</p><p>　　页式，段式，段页，用到了MMU,虚拟空间等技术</p><p>33、什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?</p><p>嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。</p><p>主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。</p><p>34、一条最长的短信息约占多少byte?</p><p>　　中文70(包括标点)，英文160，160个字节。<br>　　<br>35、有一个一维整型数组int[]</p><p>data保存的是一张宽为width，高为height的图片像素值信息。</p><p>请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50%。</p><p>36、如何将SQLite数据库(dictionary.db文件)与apk文件一起发布</p><p>解答：</p><p>可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。</p><p>所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。</p><p>可以将dictionary.db文件复制到res aw目录中</p><p>37、如何将打开res aw目录中的数据库文件?</p><p>解答：</p><p>在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。</p><p>复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。</p><p>在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。</p><p>38、DDMS和TraceView的区别? </p><p>DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器 。</p><p>39、java中如何引用本地语言 </p><p>可以用JNI（java native interface  java 本地接口）接口 。</p><p>40、谈谈Android的IPC（进程间通信）机制 </p><p>IPC是内部进程通信的简称， 是共享”命名管道”的资源。</p><p>Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。</p><p>Servier端实现IPC接口，Client端调用IPC接口本地代理。</p><p>41、NDK是什么</p><p>NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。</p><p>NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so</p><p>编辑 ：达叔</p><p>定位：分享 Android&amp;Java 知识点</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>制作个人简历模板网页效果 | 码云端的开源项目</title>
    <link href="https://huangguangda.github.io/2018/05/09/1/"/>
    <id>https://huangguangda.github.io/2018/05/09/1/</id>
    <published>2018-05-09T13:58:37.000Z</published>
    <updated>2018-06-18T14:11:33.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="http://upload-images.jianshu.io/upload_images/11158618-21bb875427cf1436?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="达叔"></p><a id="more"></a><p>制作个人简历模板网页效果<br>文 / 达叔 原创</p><p><strong>制作个人简历模板网页效果</strong></p><p>PC 端</p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-d644e9636633a877?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p><p>移动端</p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-d163bfb23d1159b7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p><p>首先要注册并登陆码云的网站：<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-c7b4ce6fc98184a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p><p>然后学会用 Git，就可以了，如图所示给出了文档</p><p>程序员技术交流群<br>群号：711613774</p><p><strong>大概教程：</strong></p><p>就是下载源代码下来，然后更改 index.html 文件即可，再次用Git上传到自己的项目中，然后申请Pages模式，即可就可以在自己的网页中显示自己的简历。</p><p>在大学毕业季，需要找工作，还用什么纸质的吗？还用pdf文件吗？</p><p>跟HR说：可以上网看</p><h4 id="安装教程-使用说明"><a href="#安装教程-使用说明" class="headerlink" title="安装教程 - 使用说明"></a><strong>安装教程 - 使用说明</strong></h4><ol><li><p>Fork 此项⽬目</p></li><li><p>将项⽬目 Clone 到本地</p></li><li><p>更更改⾃自⼰己的信息并更更新到远程</p></li><li><p>发布到⾃自⼰己的 Pages</p></li></ol><h4 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a><strong>贡献</strong></h4><p>一个开源项⽬目提交贡献代码 项⽬目地址 <a href="https://gitee.com/itsay/resume" target="_blank" rel="noopener">https://gitee.com/itsay/resume</a></p><p><strong>须知</strong></p><p>码云可以支持 Pages 功能，跟 Github 一样了，用过 Github Pages 的朋友就会很快的上手的，跟 Github 一样，默认的根文件是 index.html ，</p><p>登陆码云创建新的项目 ，+ ，这个加创建项目</p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-c85d7d70a938e372?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>项目名称：自己看可以定义：例如：Pages</p><p>然后记得这个要打勾：使用 Readme 文件初始化这个项目，点击创建就好</p><p>创建好后，定义一个 index.html 文件即可，写一段简单代码，展示效果</p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-c46ef16ad57bf964?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p><p>如图点击后，进入Gitee Pages 服务，点击部署分支为 master 即可，然后点击开启 Gitee Pages 服务，网站地址就会自动给你，这时你就可以看到了哦~</p><p>如果你没用过 Git ，可以去看文档，我已上传教程，很简单的</p><p>Git Bash here ，表示在这个目录中提交并使用；</p><p>这里我展示一下 Git 的过程，你可以参考一下，其他的你就 Google Chrome ，展示一下代码，其实这文档中也有展示的：</p><p>注意：git config –global user.name 中，是 –  ，两个 “-”；</p><h1 id="GitHub-手把手教你如何把本地项目或代码提交到Github托管"><a href="#GitHub-手把手教你如何把本地项目或代码提交到Github托管" class="headerlink" title="GitHub 手把手教你如何把本地项目或代码提交到Github托管"></a>GitHub 手把手教你如何把本地项目或代码提交到Github托管</h1><p><a href="https://blog.csdn.net/qq_36232611/article/details/78509671" target="_blank" rel="noopener">https://blog.csdn.net/qq_36232611/article/details/78509671</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的码云名字&quot;</span><br><span class="line"></span><br><span class="line">回车</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;你的登录邮箱&quot;</span><br><span class="line"></span><br><span class="line">回车</span><br><span class="line"></span><br><span class="line">git clone https://....git</span><br><span class="line"></span><br><span class="line">cd 到你的目录</span><br><span class="line"></span><br><span class="line">然后把你下载好的源代码改一下，然后复制到次目录中即可--1</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">表示添加所有代码git commit -m &quot;chance log &quot;</span><br><span class="line"></span><br><span class="line">表示你提交代码后，进行备注，这个步骤一定要的，否则会出错</span><br><span class="line"></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">表示进行提交</span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">大功告成</span><br><span class="line"></span><br><span class="line">如果提交后，要进行更改内容如：index.html 中的代码：</span><br><span class="line"></span><br><span class="line">这是后你是已经复制代码到目录中了--1</span><br><span class="line"></span><br><span class="line">更新：</span><br><span class="line"></span><br><span class="line">你所需代码：</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">即可看到你的更新代码</span><br><span class="line"></span><br><span class="line">git commit -m &quot;随便写的&quot;</span><br><span class="line"></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">表示再次提交的步骤，🆗，大功告成</span><br></pre></td></tr></table></figure><p>编辑 ：达叔</p><p>信箱：<a href="mailto:2397923107@qq.com" target="_blank" rel="noopener">2397923107@qq.com</a></p><p>定位：分享 Android&amp;Java 知识点</p><p>我是简书的达叔小生。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/11158618-21bb875427cf1436?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;达叔&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://huangguangda.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://huangguangda.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>零基础入门Android语法与界面笔记</title>
    <link href="https://huangguangda.github.io/2018/05/08/1/"/>
    <id>https://huangguangda.github.io/2018/05/08/1/</id>
    <published>2018-05-08T12:08:15.000Z</published>
    <updated>2018-07-01T06:11:04.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/83.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>来源零基础入门Android语法与界面做笔记</p><p>面向对象</p><p>1、什么是对象<br>2、什么是面向对象<br>3、什么是类<br>4、什么是属性<br>5、什么是方法<br>6、类和对象的关系</p><p>什么是对象<br>•   万物皆对象、客观存在的事物<br>•   对象：用来描述客观事物的一个实体，由一组属性和方法构成</p><p>什么是面向对象<br>•   人关注对象<br>•   人关注事物信息</p><p>类<br>•   类是模子，确定对象将会拥有的特征（属性）和行为（方法）<br>•   类的特点<br>•   类是对象的类型<br>•   具有相同属性和方法的一组对象的集合</p><p>什么是对象的属性和方法<br>•   属性：对象具有的各种静态特征<br>•   “有什么”<br>•   方法：对象具有的各种动态行为<br>•   “能做什么”</p><p>类和对象的关系<br>•   类是抽象的概念，仅仅是模板<br>•   对象是一个你能够看得到、摸得着的具体实体<br>•   类是对象的类型<br>•   对象是特定类型的数据<br>•   具体开发过程中，先定义类再实例化对象</p><p>单一职责原则<br>•   单一职责原则，也称为单一功能原则<br>•   英文Single Responsibility Principle 缩写SRP<br>•   是面向对象设计中的一个重要原则<br>•   一个类，应该有且只有一个引起变化的原因<br>•   在程序设计中，尽量把不同的职责，放在不同的职责中，即把<br>不同的变化原因，封装到不同的类中。</p><p>对象实例化需要了解的</p><p>对象实例化<br>•   实例化对象的过程可以分为两部分：<br>–  声明对象   Cat one<br>–  实例化对象   new Cat();<br>–  Cat one=new Cat();</p><p>对象实例化<br>•   每次new对象会产生新的实例化对象<br>–  Cat one=new Cat();<br>–  Cat two=new Cat();</p><p>对象实例化<br>•   多个对象可以指向同一块实例化空间<br>–  Cat one=new Cat();<br>–  Cat two=one;</p><p>对象实例化<br>•   对象必须被实例化之后才能使用<br>•   对象间的引用传递，实际上传递的是堆内存空间的使用权</p><p>构造方法<br>1、构造方法与类同名且没有返回值<br>2、构造方法的语句格式<br>3、只能在对象实例化的时候调用</p><p>构造方法<br>4、当没有指定构造方法时，系统会自动添加无参的构造方法<br>5、当有指定构造方法，无论是有参、无参的构造方法，都不会自<br>动添加无参的构造方法<br>6、一个类中可以有多个构造方法</p><p>单一职责原则（SRP：Single responsibility principle）又称单一功能原<br>则，面向对象五个基本原则（SOLID：  SRP 单一责任原则、OCP  开放封闭原<br>则、LSP 里氏替换原则、DIP 依赖倒置原则、ISP  接口分离原则）之一。它规<br>定一个类应该只有一个发生变化的原因。该原则由罗伯特·C·马丁（Robert C.<br>Martin）于《敏捷软件开发：原则、模式和实践》一书中给出的。马丁表示此<br>原则是基于汤姆·狄马克(Tom DeMarco)和 Meilir Page-Jones  的著作中的内<br>聚性原则发展出的。</p><p>所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么<br>这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有<br>且只有一个改变的原因。</p><p>单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类<br>（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一<br>个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化<br>时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责<br>封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总<br>是同时发生改变则可将它们封装在同一类中。</p><p>之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：T<br>负责两个不同的职责：职责 P1，职责 P2。当由于职责 P1  需求发生改变而需要<br>修改类 T P2  功能发生故障。也就是说<br>职责 P1 和 P2<br>解决办法：遵守单一职责原则，将不同的职责封装到不同的类或模块中。<br>分别建立两个类 T1、T2，使 T1 完成职责 P1 功能，T2 完成职责 P2  功能。这<br>样，当修改类 T1 时，不会使职责 P2 发生故障风险；同理，当修改 T2  时，也<br>不会使职责 P1  发生故障风险。</p><p>关键字的用法</p><p>this 在类中就是代表当前对象，可以通过 this  关键字完成当前<br>对象的成员属性、成员方法和构造方法的调用。<br>那么何时用 this？<br>当在定义类中的方法时，如果需要调用该类对象，就可以用  this<br>来表示这个对象。也就是说，但凡在本类功能内部使用到了本类对象，<br>都用 this  表示。至于代表哪个对象，就看其所在功能被哪个对象调<br>用，这样就知道谁在参与运算。</p><p>封装<br>•   将类的某些信息隐藏在类内部，不允许外部程序直接访问<br>•   通过该类提供的方法来实现对隐藏信息的操作和访问<br>•   隐藏对象的信息<br>•   留出访问的接口</p><p>封装<br>特点：<br>1、只能通过规定的方法访问数据<br>2、隐藏类的实例细节，方便修改和实现</p><p>封装<br>设为private<br>修改属性的可见性<br>设为public<br>创建getter/setter方法<br>用于属性的读写<br>对属性值的合<br>法性进行判断<br>在getter/setter方法中加<br>入属性控制语句</p><p>包<br>作用：<br>1、管理Java文件<br>2、解决同名文件冲突</p><p>定义包<br>语法：<br>package 包名;<br>例：package com.imooc.animal;<br>注意：<br>1、必须放在Java源文件中的第一行<br>2、一个Java源文件中只能有一个package语句<br>3、包名全部英文小写<br>4、命名方式：域名倒序+模块+功能</p><p>导入包<br>语法：<br>import 包名.类名;<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导入包中全部类：</span><br><span class="line">import com.imooc.*;</span><br><span class="line">导入包中指定类：</span><br><span class="line">import com.imooc.animal.Cat;</span><br></pre></td></tr></table></figure></p><p>常用系统包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang   包含java语言基础的类</span><br><span class="line">java.util     包含java语言中各种工具类</span><br><span class="line">java.io       包含输入、输出相关功能的类</span><br></pre></td></tr></table></figure></p><p>static<br>1、static+属性—静态属性<br>2、static+方法—静态方法<br>3、static+类—不存在<br>4、static+方法内局部变量—不存在<br>静态成员随类加载产生，直至类销毁才回收</p><p>静态方法<br>1、可以直接调用同类中的静态成员<br>2、不可以直接调用同类中的非静态成员<br>3、可以通过实例化对象后，对象调用的方式完成非静态成员调用</p><p>代码块<br>1、通过{ }可以形成代码块<br>2、方法内的代码块称为：普通代码块<br>3、类内的代码块称为：构造代码块<br>4、构造代码块前+static：静态代码块</p><p>代码块执行顺序<br>1、无论实例产生多少对象，静态代码块只执行一次<br>2、构造代码块随实例化过程调用<br>3、普通代码块随方法调用执行</p><h2 id="kage-和-import-的使用"><a href="#kage-和-import-的使用" class="headerlink" title="kage 和 import 的使用"></a>kage 和 import 的使用</h2><p>1、打包–package<br>包名一般为小写，而类名的第一个字母一般为大写，这样在引用时，可以明显的分<br>辨出包名和类名。如果在类的定义之前没有使用package定义包名，那么该类就属于缺<br>省的包。</p><p>1.1、包的作用<br>可以更好的组织类，包与文件夹类似，文件夹可以将不同的文件放在同一个文件夹<br>中，而包也可以将不同的类文件放在同一包中。<br>减少类名的冲突问题，这也与文件夹类似，同一文件夹中的文件不能重名，不同文<br>件中的 文件可以重名，同一包中的类名不能重复，不同包中的类名可以重复。<br>对包中的类起了一定的保护作用，详见 Java  的访问控制（在后面的课程中会详细<br>讲解~~）。</p><p>1.2、包的使用<br>使用 package 关键字指明类所在的包。 package 语句必须在文件的最前面。 编译<br>时可使用 javac –d . Test.java 自动产生包需要目录。 可以使用 java testPackage.Test<br>来执行编译后的代码。</p><p>2、导入–import<br>使用了包机制后，如果在一个类中使用了其他包中的类，需要使用 import  来引入。</p><p>2.1 import的使用<br>直接引用指定的类，如 import java.util.Vector。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">引用一个包中的多个类，如 import java.awt.*。*号代替类名，但不能代替包名，如</span><br><span class="line">import java.awt.*，只引用 java.awt 下的类，而不引用 java.awt  下的子包里面的类。</span><br><span class="line">import java.awt.F*，这种使用方法是错误的。</span><br><span class="line">import 语句在所有类定义之前，在 package 定义之后。import  只告诉编译器及解</span><br><span class="line">释器哪里可以找到类、变量、方法的定义，而并没有将这些定义 引入代码中。</span><br><span class="line">2.2  包中类的使用</span><br><span class="line">如果要使用的类是属于 java.lang  包的，那么可以直接使用类名来引用指定的类，而</span><br><span class="line">不需要加上包名，因为包 java.lang 不用显示使用 import，它是缺省引入的。 如果要使</span><br><span class="line">用的类在其它包（java.lang 除外）中，那么可以通过包名加上类名来引用该类， 如</span><br><span class="line">java.awt.Font。</span><br><span class="line">对于经常要使用的类（该类在其它包中），那么最好使用 import  引用指定的包，如</span><br><span class="line">java.awt.*。</span><br><span class="line">如果 import  引入的不同的包中包含有相同的类名，那么这些类的使用必须加上包名。</span><br></pre></td></tr></table></figure><p>生活中的继承<br>•   孩子像爸妈<br>•   富二代<br>•   师徒关系</p><p>程序中的继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-表示私有</span><br><span class="line">Dog</span><br><span class="line">- name:String</span><br><span class="line">- month:int</span><br><span class="line">- species:String</span><br><span class="line">- sex:String</span><br><span class="line">- name:String</span><br><span class="line">- month:int</span><br><span class="line">- species:String</span><br><span class="line">- weight:double</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+表示公有</span><br><span class="line">+ eat():void</span><br><span class="line">+ eat():void</span><br><span class="line">+ getName():String</span><br><span class="line">+ getMonth ():int</span><br><span class="line">+ getSpecies ():String</span><br><span class="line">+ getSex():String</span><br><span class="line">+ sleep():void</span><br><span class="line">+ getName():String</span><br><span class="line">+ getMonth ():int</span><br><span class="line">+ getSpecies ():String</span><br><span class="line">+ getWeight():double</span><br><span class="line">+ run():void</span><br><span class="line">+ Dog()</span><br><span class="line">+ Cat()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序中的继承</span><br><span class="line">Cat</span><br><span class="line">Dog</span><br><span class="line">Animal</span><br><span class="line">- sex:String</span><br><span class="line">+ sleep():void</span><br><span class="line">+ Dog()</span><br><span class="line">- weight:double</span><br><span class="line">- name:String</span><br><span class="line">- month:int</span><br><span class="line">- species:String</span><br><span class="line">+ run():void</span><br><span class="line">+ Cat()</span><br><span class="line">+ eat():void</span><br><span class="line">+ getName():String</span><br><span class="line">+ getMonth ():int</span><br><span class="line">+ getSpecies ():String</span><br><span class="line">+ getWeight():double</span><br></pre></td></tr></table></figure><p>继承<br>特点：<br>1、利于代码复<br>2、缩短开发周期</p><p>继承<br>•  一种类与类之间的关系<br>•  使用已存在的类的定义作为基础建立新类<br>•  新类的定义可以增加新的数据或新的功能，也可以用父类的<br>功能，但不能选择性地继承父类<br>•父类 基类<br>•子类 派生类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">继承的关系</span><br><span class="line">• 满足“A is a B  ”的关系就可以形成继承关系</span><br><span class="line">如：</span><br><span class="line">猫、狗是动物==》猫，狗继承自动物</span><br><span class="line">学生、老师是人==》学生，老师继承自人</span><br><span class="line">小轿车、大卡车是汽车==》小轿车，大卡车继承自汽车</span><br></pre></td></tr></table></figure><p>实现继承<br>使用extends实现封装<br>–编写父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">//公共的属性和方法</span><br><span class="line">&#125;</span><br><span class="line">–编写子类，继承父类</span><br><span class="line">class Dog extends  Animal&#123;</span><br><span class="line">//子类特有的属性和方法</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends  Animal&#123;</span><br><span class="line">&#125;</span><br><span class="line">只能继承一个父类</span><br></pre></td></tr></table></figure></p><p>方法重写<br>语法规则：<br>•  返回值类型<br>•  方法名<br>•  参数类型、顺序、个数<br>都要与父类继承的方法相同</p><p>方法重写 PK  方法重载<br>•   方法重写：<br>•   方法重载：<br>–  在满足继承关系的子类中<br>–  在同一个类中<br>–  方法名相同<br>–  方法名、参数个数、顺序、类型与<br>父类、返回值相同<br>–  参数个数、顺序、类型不同<br>–  返回值类型、访问修饰符任意<br>–  访问修饰符的限定范围大于等于<br>父类方法</p><p>方法重写存在<br>属性重写不存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符</span><br><span class="line">•   公有的：public</span><br><span class="line">•   私有的：private</span><br><span class="line">•   受保护的 ：protected</span><br><span class="line">•   默认</span><br></pre></td></tr></table></figure><p>如何区分调用的是继承父类的方法<br>还是子类自己重写的方法？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">super</span><br><span class="line">•   子类访问父类成员</span><br><span class="line">–   访问父类成员方法</span><br><span class="line">super.print();</span><br><span class="line">super.name;</span><br><span class="line">–   访问父类属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实例化顺序</span><br><span class="line">•继承后的初始化顺序</span><br><span class="line">父类静态成员</span><br><span class="line">子类静态成员</span><br><span class="line">父类对象构造</span><br><span class="line">（属性（赋值）、构造代码块、构造方法）</span><br><span class="line">子类对象构造</span><br><span class="line">（属性（赋值）、构造代码块、构造方法）</span><br></pre></td></tr></table></figure><p>子类对象实例化时，能否选择父类的构造<br>形式（调用指定的构造方法）？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">super</span><br><span class="line">•   子类访问父类成员</span><br><span class="line">–   访问父类成员方法</span><br><span class="line">super.print();</span><br><span class="line">super.name;</span><br><span class="line">super();</span><br><span class="line">–   访问父类属性</span><br><span class="line">–   访问父类构造方法</span><br></pre></td></tr></table></figure><p>super<br>•   子类的构造的过程中必须调用其父类的构造方法<br>•   如果子类的构造方法中没有显示调用父类的构造方法，则系统<br>系默认调用父类无参的构造方法<br>•   如果子类构造方法中既没有显式调用父类的构造方法，而父类<br>又没有无参的构造方法，则编译出错<br>•   使用super调用父类指定构造方法，必须在子类的构造方法的<br>第一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">super pk this</span><br><span class="line">•   this:  当前类对象的引用</span><br><span class="line">–   访问当前类的成员方法</span><br><span class="line">–   访问当前类的成员属性</span><br><span class="line">–   访问当前类的构造方法</span><br><span class="line">–   不能在静态方法中使用</span><br><span class="line">•   super:  父类对象的引用</span><br><span class="line">–   访问父类的成员方法</span><br><span class="line">–   访问父类的成员属性</span><br><span class="line">–   访问父类的构造方法</span><br><span class="line">–   不能在静态方法中使用</span><br><span class="line">•   构造方法调用时，super和this不能同时出现</span><br></pre></td></tr></table></figure><p>设计模式<br>•   设计模式（Design pattern）是一套被反复使用、多数人知晓的、<br>经过分类编目的、代码设计经验的总结。<br>•   设计模式是软件开发人员在软件开发过程中面临的一般问题的解决<br>方案。</p><p>设计模式<br>•   项目中合理的运用设计模式可以完美的解决很多问题<br>•   每种模式在现在中都有相应的原理来与之对应<br>•   每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题<br>的核心解决方案</p><p>设计模式<br>•   面向对象的设计模式很多，但大家认为这23个模式是其它模式的基础</p><p>单例模式（Singleton）<br>•   滚滚历史，朝代更迭，永恒定律：<br>–  一个朝代皇帝只有一个<br>–  军队的最高司令官只有一个<br>–  一山不容二虎<br>•   计算机系统：<br>–   驱动程序<br>–   打印机后台处理程序（Printer Spooler）<br>–   线程池<br>–   缓存<br>–   日志</p><p>单例模式（Singleton）<br>目的：<br>使得类的一个对象成为该类系统中的唯一实例<br>定义：<br>一个类有且仅有一个实例，并且自行实例化向整个系统提供</p><p>单例模式<br>要点：<br>1、某个类只能有一个实例<br>2、必须自行创建实例<br>3、必须自行向整个系统提供这个实例<br>实现：<br>1、只提供私有的构造方法<br>2、含有一个该类的静态私有对象<br>3、提供一个静态的公有方法用于创建、获取静态私有对象</p><p>单例模式<br>代码实现方案：<br>1、饿汉式<br>2、懒汉式</p><p>饿汉式 PK  懒汉式<br>1、饿汉式在类加载时就创建实例， 第一次加载速度快；<br>懒汉式第一次使用时才进行实例化，第一次加载速度慢<br>饿汉式：空间换时间<br>懒汉式：时间换空间<br>2、饿汉式线程安全；懒汉式存在线程风险<br>解决方案：<br>1、同步锁<br>3、静态内部类<br>4、枚举<br>2、双重校验锁</p><p>单例模式<br>优点：<br>1、在内存中只有一个对象，节省内存空间<br>2、避免频繁的创建销毁对象，提高性能<br>3、避免对共享资源的多重占用<br>缺点：<br>1、扩展比较困难<br>2、如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，<br>造成对象状态丢失</p><p>单例模式<br>适用场景：<br>1、创建对象时占用资源过多，但同时又需要用到该类对象<br>2、对系统内资源要求统一读写，如读写配置信息<br>3、当多个实例存在可能引起程序逻辑错误，如号码生成器</p><p>UML  中表示类与类的关系</p><p>UML(Unified Modeling Language), 又称统一建模语言或标准建模语言，它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，可用于多种类型软件系统开发建模的各个阶段。我们可以用 UML  图例来表示类与类之间的<br>各种关系。</p><p>类的层次结构代表类与类之间的关系，类的关系有很多种，包括泛化、依赖、关联、聚<br>合和组合。这些关系在大的类别上还可分为两种：横向关系和纵向关系，纵向关系就是泛化关系，而横向关系就是剩下的 4 种，</p><p>它们的强弱关系：依赖 &lt;  关联  &lt; 聚合  &lt;  组合。</p><p>理解这些类的关系，并应用于类的层次结构设计中，有助于优化代码组织结构。</p><p>接下来我们用 Enterprise Architect 12.0.1210 Corporate Edition  建模软件为大家演示这几种类与类关系的表示。</p><ol><li>泛化</li></ol><p>泛化关系就是继承，表示一般与特殊的关系，即“一般”元素是“特殊”元素的泛<br>化。在继承中，一般类就是父类，特殊类就是子类。</p><p>它们之间是“is a”的关系。</p><p>如：一个 Cat 类继承 Animal 类，也就是说 Cat is an Animal。在 UML类图设计中，继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父<br>接口。</p><ol start="2"><li>依赖</li></ol><p>表示一个元素以某种方式依赖于另一种元素。</p><p>依赖就是一个类 A 使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类 B  的变化会影响到类 A。</p><p>它们之间是“use a”的关系。</p><p>依赖的例子有：一个类把另一个类的对象作为参数，一个类访问另一个类的全局变<br>量，或者一个类调用另一个类的类操作。</p><p>比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码<br>层面，为类 B 作为参数被类 A 在某个 method 方法中使用。在 UML  类图设计中，依赖关系用由类 A 指向类 B  的带箭头虚线表示。</p><ol start="3"><li>关联</li></ol><p>关联体现的是两个类之间一种强依赖关系，这种关系比依赖更强、不存在依赖关系<br>的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。<br>关联可以是单向、双向的。</p><p>比如老师和学生是双向关联，老师有多名学生，学生也可能有多名老师。学生跟学<br>生学号之间是单向关联，一个学生只能对应一个唯一的学号。在 UML  类图设计中,  双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p><ol start="4"><li>聚合</li></ol><p>聚合关系是关联关系的一种，是强的关联关系，它体现的是整体与部分的关系  ，<br>且部分可以离开整体而单独存在；关联和聚合在语法上无法区分，必须考察具体的<br>逻辑关系。</p><p>它们之间是“use a”的关系。<br>此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多<br>个整体对象，也可以为多个整体对象共享。</p><p>在 UML  类图设计中，聚合关系以空心菱形加实线表示。如学校有很多老师。</p><ol start="5"><li>组合</li></ol><p>是整体与部分的关系，是比聚合关系还要强的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，如公司和部门是整体和部分的关系,  没有公司就不存在部门。</p><p>它体现的是一种“contains-a”的关系。<br>在 UML  类图设计中，组合关系以实心菱形加实线表示。</p><p>抽象类和抽象方法</p><p>一：知识梳理</p><p>1.基本概念：</p><p>在面向对象的概念中，所有的对象都是通过类来描述的，但并不是说所有的类都是用<br>来描述对象的，当一个类中没有包含足够的信息以描绘一个具体的对象时，这样的类<br>就是抽象类。</p><p>例：形状就是一个抽象的概念。不同的子类计算形状面积的方法是不一样的。可提供<br>抽象方法来被不同的子类所实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从例子中可看出，抽象类是用关键字 abstract   修饰的。抽象类中有一种特殊方法，即用 abstract 关键字来修饰的方法，称为“抽象方法”。</p><p>2.抽象类和抽象方法的声明格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class &lt;类名&gt;&#123;</span><br><span class="line">成员变量;</span><br><span class="line">方法（）&#123;方法体&#125;;</span><br><span class="line">    abstract 方法（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.抽象类和抽象方法的特点：</p><p>（1）抽象方法不允许直接实例化，换句话说抽象类不能创建对象，它只能作为其他类的父类。  但可以通过向上转型，指向实例化。</p><p>（2）抽象方法只有声明，不能有实现，也就是仅有方法头，而没有方法体和操作实现。</p><p>如：abstract double area( );</p><p>4.定义抽象类的意义在于：</p><p>（1）为其子类提供一个公共的类型（父类引用指向子类对象）；<br>（2）封装子类中的重复内容（成员变量和方法）;<br>（3）将父类设计成抽象类后，既可借由父子继承关系限制子类的设计随意性，在一定程度上避免了无意义父类的实例化。</p><p>二．重点注意</p><p>含有抽象方法的类，只能被定义成抽象类。</p><p>如下面，不定义为抽象类时会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Shape&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正确的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape()&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象类不一定包含抽象方法。<br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">public void girth()&#123;</span><br><span class="line">System.out.println(&quot;图形周长为...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在抽象类中的成员方法可以包括一般方法和抽象方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">public void girth()&#123;</span><br><span class="line">System.out.println(&quot;图形周长为..&quot;);</span><br><span class="line">&#125;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象类不能被实例化，即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。<br>抽象类的构造方法主要是用于被其子类调用。</p><p>例子：<br>Shape  抽象类中不含抽象方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">public void girth()&#123;</span><br><span class="line">System.out.println(&quot;图形周长为..&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类中实例化 Shape,编译器会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape s=new Shape();</span><br></pre></td></tr></table></figure></p><p>一个类继承抽象类后，必须实现其所有抽象方法，否则也是抽象类，不同的子类对<br>父类的抽象方法可以有不同的实现。</p><p>如父类为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则其子类 Circle  有两种做法：</p><p>方案一：重写抽象方法 area( ),使方法得以实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Circle extends Shape&#123;</span><br><span class="line">public double r;</span><br><span class="line">public Circle(double r)&#123;</span><br><span class="line">this.r=r;</span><br><span class="line">&#125;</span><br><span class="line">public double area()&#123;</span><br><span class="line">return(double)(3.14*r*r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方案二：子类 Circle  类也定义为抽象类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Circle extends Shape&#123;</span><br><span class="line">public double r;</span><br><span class="line">public Circle(double r)&#123;</span><br><span class="line">this.r=r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使父类是具体的，但其子类也可以是抽象的。如  Object  是具体的，但可以创建<br>抽象子类。</p><p>abstract 方法不能用 static 和 private 修饰；对于类，不能同时用 final 和 abstract  修饰，因为 final 关键字使得类不可继承，而 abstract  修饰的类如果不可以继承将没有任何意义。两者放在一起，会起冲突</p><p>如以下用法都会引起编译器报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static abstract double area();</span><br><span class="line"></span><br><span class="line">private abstract double area();</span><br><span class="line"></span><br><span class="line">abstract final class Shape()&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三：一个完整准确的抽象类例子</p><p>声明一个抽象类 Shape,有抽象成员方法  area()。Shape 派生出两个子类圆  Circle  类和矩形 Rectangle  类。Shape 里声明了抽象方法area(),该方法分别在两个子类里得到实<br>现。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shape&#123;</span><br><span class="line">public double r;</span><br><span class="line">Circle()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public Circle(double r)&#123;</span><br><span class="line">this.r=r;</span><br><span class="line">&#125;</span><br><span class="line">public double getR()&#123;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">public void setR(double r)&#123;</span><br><span class="line">this.r=r;</span><br><span class="line">&#125;</span><br><span class="line">public double area()&#123;</span><br><span class="line">return(double)(3.14*r*r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rectangle extends Shape&#123;</span><br><span class="line">public double lenghth;</span><br><span class="line">public double wide;</span><br><span class="line">Rectangle()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public Rectangle(double lenghth,double wide)&#123;</span><br><span class="line">this.lenghth=lenghth;</span><br><span class="line">this.wide=wide;</span><br><span class="line">&#125;</span><br><span class="line">public double getLenghth()&#123;</span><br><span class="line">return lenghth;</span><br><span class="line">&#125;</span><br><span class="line">public void setLenghth(double lenghth)&#123;</span><br><span class="line">this.lenghth = lenghth;</span><br><span class="line">&#125;</span><br><span class="line">public double getWide()&#123;</span><br><span class="line">return wide;</span><br><span class="line">&#125;</span><br><span class="line">public void setWide(double wide)&#123;</span><br><span class="line">this.wide=wide;</span><br><span class="line">&#125;</span><br><span class="line">public double area()&#123;</span><br><span class="line">return lenghth*wide;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(Stirng[] args)&#123;</span><br><span class="line">Circle c=new Circle(3.5);</span><br><span class="line">Rectangle re=new Rectangle(6,5);</span><br><span class="line">System.out.println(c.area());</span><br><span class="line">System.out.println(re.area());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中的内部类</p><p>我们在实际开发过程中，如果想要创建某些公共代码，使得它们可以被某个接口的所有<br>不同实现所共用，那么接口内部的嵌套类会显得很方便。</p><p>也就是说，在接口中可以含有内部类。</p><p>在这里，向大家展示接口中放置普通成员内部类和抽象成员内部类的情况。</p><p>首先创建接口，接口中定义了普通内部类 InnerClass 和抽象内部类  AbInnerClass</p><p>普通成员内部类的实例化</p><p>创建接口的实现类  ClassDemo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface IOuterInterface&#123;</span><br><span class="line">int TEMP=100;</span><br><span class="line">void abMethod();</span><br><span class="line">public default void deMethod()&#123;</span><br><span class="line">System.out.println(&quot;默认&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void stMethod()&#123;</span><br><span class="line">System.out.println(&quot;静态&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public class InnerClass&#123;</span><br><span class="line">public void show()&#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbInnerClass&#123;</span><br><span class="line">public abstract void abInfo();</span><br><span class="line">public void info()&#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通成员内部类的实例化<br>创建接口的实现类  ClassDemo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ClassDemo implements IOuterInterface&#123;</span><br><span class="line">public void abMethod()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public InnerClass getInner()&#123;</span><br><span class="line">return new InnerClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">IOuterInterface.InnerClass inner=new IOuterInterface.InnerClass();</span><br><span class="line">inner.show();</span><br><span class="line"></span><br><span class="line">ClassDemo demo=new ClassDemo();</span><br><span class="line">demo.getInner().show();</span><br><span class="line"></span><br><span class="line">InnerClass innerTwo = new InnerClass();</span><br><span class="line">innerTwo.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象成员内部类的实例化<br>创建接口的实现类  AbClassDemo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AbClassDemo implements IOuterInterface&#123;</span><br><span class="line">public void abMethod()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class AbDemo extends AbInnerClass&#123;</span><br><span class="line">public void abInfo()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TestOne&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line"> IOuterInterface.AbInnerClass abInner=new IOuterInterface.AbInnerClass()&#123;</span><br><span class="line"> public void abInfo()&#123;</span><br><span class="line"> System.out.println();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> aabInner.abInfo();</span><br><span class="line"> abInner.info();</span><br><span class="line"> System.out.println();</span><br><span class="line"></span><br><span class="line"> IOuterInterface.AbInnerClass abInner=new AbClassDemo().new AbDemo();</span><br><span class="line"> abInnerOne.abInfo();</span><br><span class="line"> abInnerOne.info();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类详解</p><p>概  念</p><p>匿名内部类也就是没有名字的内部类正因为没有名字，所以匿名内部类只能使用一次，</p><p>它通常用来简化代码编写但使用匿名内部类还有个前提条件：</p><p>必须继承一个父类或实现一个接口</p><p>注意事项：</p><p>   编译后的文件命名：外部类$数字 . class<br>   无法使用 public、private、abstract、static  修饰，匿名内部类不能出现抽象方法<br>   无法编写构造方法，但可以添加构造代码块<br>   不能出现静态成员<br>   匿名内部类可实现接口也可以继承类，但是不可兼得<br>   匿名内部类不能是抽象的，它必须要实现继承的类或者实现接口的所有抽象方法</p><p>匿  名 内  部  类 初  始  化</p><p>我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造<br>器的，那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内<br>部类创建一个构造器的效果。<br>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class OutClass&#123;</span><br><span class="line">public InnerClass getInnerClass(final int age, final Stirng name)&#123;</span><br><span class="line">return new InnerClass()&#123;</span><br><span class="line">int age_;</span><br><span class="line">Stirng name_;</span><br><span class="line">&#123;</span><br><span class="line">if(0&lt;age&amp;&amp;age&lt;200)&#123;</span><br><span class="line">age_=age;</span><br><span class="line">nam_=name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public String getName()&#123;</span><br><span class="line">return name_;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge()&#123;</span><br><span class="line">return age_;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">OutClass out = new OutClass();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实  例<br>匿名内部类可以有不同的表现形式，下面用实例向大家展示一下：<br>继承式的匿名内部类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">abstract class Car&#123;</span><br><span class="line">public abstract void drive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Car car=new Car()&#123;</span><br><span class="line">public void drive()&#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">car.drive();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Vehicle&#123;</span><br><span class="line">public void drive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test&#123;</span><br><span class="line">public static void main(Stirng[] args)&#123;</span><br><span class="line">Vehicle v=new Vehicle()&#123;</span><br><span class="line">public void drive()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">v.drive();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abstract class Bar&#123;</span><br><span class="line">void doStuff(Foo f)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BarOne extends Bar&#123;</span><br><span class="line">void doStuff(Foo f)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Foo&#123;</span><br><span class="line">void foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test&#123;</span><br><span class="line">static void go()&#123;</span><br><span class="line">Bar b = new BarOne();</span><br><span class="line">b.doStuff(new Foo())&#123;</span><br><span class="line">public void foo()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread  类的匿名内部类实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Thread t = new Thread()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">for (int i=1;i&lt;=5;i++)&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable  接口的匿名内部类实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">public static void main(Stirng[] args)&#123;</span><br><span class="line">Runnable r=new Runnable()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">for(int i=1;i&lt;=5;i++)&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread t=new Thread(r);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>向上转型和动态绑定机制</p><p>知  识 梳  理</p><ol><li>向上转型的概念：</li></ol><p>向上转型又叫自动转型、隐式转型。向上转型就是父类引用指向子类实例，也就是子类<br>的对象可以赋值给父类的对象。</p><p>如：Animal dog=new Dog( );   //Dog 类是 Animal  类的子类</p><p>注：向上转型是安全的，因为任何子类都继承并接受了父类的方法。从例子中也可以理<br>解，所有的狗狗都属于狗的父类——动物，这是可行的，但是向下转型则不行，若说所<br>有的动物都是狗狗就不成立了。（所以向下转型要通过强制类型转换，后续章节中会讲<br>解）</p><p>2、向上转型的应用</p><p>1）当一个子类对象向上转型父类类型以后，就被当成了父类的对象，所能调用的方法会<br>减少，只能调用子类重写了父类的方法以及父类派生的方法（如 set()、get()方法），<br>而不能调用子类独有的方法。<br>例如：</p><p>对象实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pen pc = new Pencil();</span><br></pre></td></tr></table></figure></p><p>此时，调用方法调用时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc.writing();</span><br><span class="line">pc.show();</span><br></pre></td></tr></table></figure><p>可以调用子类重写父类的方法 writing(),但调用子类独有的方法 show()时就是无效的</p><p>2）父类中的静态方法是不允许被子类重写的。</p><p>如父类 Pen 中含有静态方法 draw( )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void draw()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子类 Pencil 中也定义同名方法时，此时 draw( )算 Pencil  类自己独有的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void draw()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类中调用时：</p><p>返回结果为：</p><p>也就是实际上调用的是父类的静态方法 draw( )</p><p>知  识 扩  展</p><p>多态的实现可以通过向上转型和动态绑定机制来完成，向上转型实现了将子类对象向上<br>转型为父类类型，而动态绑定机制能识别出对象转型前的类型，从而自动调用该类的方法，<br>两者相辅相成。</p><p>动态绑定：</p><p>绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动<br>态绑定两种。</p><p>静态绑定：在程序运行之前进行绑定（由编译器和链接程序完成的），也叫做前期绑定。</p><p>动态绑定：在程序运行期间由 JVM  根据对象的类型自动的判断应该调用哪个方法，也叫做<br>后期绑定。</p><p>静态绑定的例子：</p><p>如有一类 Human,它派生出来三个子类 Chinese 类、American 类和 British  类，三个<br>子类中都重写了父类中的方法    speak(  )：void,在测试类中用静态绑定的方式调用方法<br>speak( )。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Chinese c = new Chinese();</span><br><span class="line">c.speak();</span><br><span class="line"></span><br><span class="line">American a=new American();</span><br><span class="line">a.speak();</span><br><span class="line"></span><br><span class="line">British b=new British();</span><br><span class="line">b.speak();</span><br></pre></td></tr></table></figure></p><p>这种调用方式是在代码里指定的，编译时编译器就知道 c 调用的是 Chinese 的 speak(  ),a调用的是 American 的 speak( )。</p><p>动态绑定的例子：</p><p>如果我们在测试类中做以下改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human[] human = new Human[5];</span><br></pre></td></tr></table></figure><p>此时，Human 类中随机生成 Chinese 类、American 类和 British  类的对象，编译器不能<br>根据代码直接确定调用哪个类中的 speak(  )方法，直到运行时才能根据产生的随机数 n  的值来确定  human[i]到底代表哪一个子类的对象，这样才能最终确定调用的是哪个类中的<br>speak( )方法，这就是动态绑定。</p><p>向下转型和 instanceof  运算符的应用</p><p>知  识 梳  理</p><p>一：向下转型</p><ol><li>向下转型</li></ol><p>向下转型是与向上转型相对的概念，它是用子类引用指向父类实例。</p><p>如：下图，在进行转换是会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a = new Dog();</span><br><span class="line">Dog d=a;</span><br></pre></td></tr></table></figure><p>这时就告诉我们向下转型不能自动转换，我们需要强转，所以向下转型又叫做强制类型<br>转换。</p><p>正确的转换语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a=new Dog();</span><br><span class="line">Dog d=(Dog)a;</span><br></pre></td></tr></table></figure><ol start="2"><li>向下转型后，可以调用子类自己独有的方法。<br>例如：（承接上一文档例子）</li></ol><p>测试类中通过强制类型转换后，可调用 Pencil 类中独有的方法 show( )了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pen pc = new Pencil();</span><br><span class="line">Pencil p = (Pencil)pc;</span><br><span class="line">p.show();</span><br></pre></td></tr></table></figure></p><ol start="3"><li>兄弟类之间不能进行强制类型转换。</li></ol><p>如：父类 Pen 类派生出另一个子类 Brush。</p><p>将指向 Brush 对象的父类引用 b 强制转换为 Brush 的兄弟类 Pencil  的对象，此时编译<br>器并没有报错，但在运行时会报出如下错误：</p><p>二：instanceof  运算符</p><p>1． 基本概念<br>instanceof  运算符用来判断对象是否可满足某个特定类型实例特征。返回值为<br>true/false。一般用于 if  语句中。</p><p>表示方法为：<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean result;</span><br><span class="line">Pen pc=new Pencil();</span><br><span class="line">result=pc instanceof Pencil;</span><br></pre></td></tr></table></figure><p>如果左边对象是右边类的实例则返回 true,否则返回 false。</p><p>2.instanceof  运算符的应用</p><p>1）用  instanceof  运算符用来判断对象是否可满足某个特定类型实例特征<br>例子：</p><p>父类 Parents 类，Father 类和 Mother  类分别为它的两个子类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parents f=new Father();</span><br><span class="line">Parents m=new Mother();</span><br></pre></td></tr></table></figure></p><p>运行结果为：<br>注：java 中所有类都直接或间接继承于 Object  类。</p><h2 id="Four"><a href="#Four" class="headerlink" title="Four"></a>Four</h2><p>依赖与关联关系</p><p>依赖关系<br>依赖关系(Dependency)  是一种使用关系，特定事物的改变有可能会影响到使用<br>该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。如人要过河<br>时要使用到船，人与船之间就是依赖关系；我用锤子在墙上锤了一下，我和锤子之间就<br>是依赖关系；装修工人安装灯具时需要使用工具，装修工人和工具之间就是依赖关系。<br>大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。<br>依赖关系有下列三种情况：</p><p>A 类是 B  类中（某种方法的）局部变量<br>A 类是 B  类方法当中的一个参数<br>A 类向 B 类发送消息，从而影响 B  类发生变化</p><p>我们这里就依赖关系最常出现的情况—在某个类的方法使用另一个类的对象作为参数<br>进行举例说明：<br>课程表与课程之间就是依赖关系，<br>UML  图表示为：<br>对应的 java  代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CourseTable&#123;</span><br><span class="line">public void addCourse(Course course)&#123;</span><br><span class="line">course.show();</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public void reCourse(Course course)&#123;</span><br><span class="line">course.show();</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public class Course&#123;</span><br><span class="line">public void show()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>课程表类中用课程的对象作为参数，进行增加课程和删除课程的功能。课程的变化<br>会引起课程表的实时变更，这就是一种“use a”的关系，也就是课程表依赖于课程。</p><p>关联关系</p><p>关联关系是类与类之间最常用的一种关系，它是一种结构化关系，代表类的对象之<br>间的一组连接。如客户与订单、老师与学生、公司与职员，人体与大脑，这些关系不是<br>是使用时才有的，而是一种长期且稳定的关系。<br>关联关系可以分为双向关联、单向关联、自关联。</p><p>a)<br>双向关联：<br>指双方都知道对方的存在，都可以调用对方的公共属性和方法。默认情况下，关<br>联是双向的。如供货商和顾客之间的关系，一家供货商可以向多个顾客供货，一个顾<br>客也可以向多家供货商进货</p><p>UML  图表示为：<br>对应的 java  代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Customer&#123;</span><br><span class="line">private Supplier[] supplier;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Supplier&#123;</span><br><span class="line">public Customer[] customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>b)<br>单向关联：<br>类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如：顾客<br>(Customer)拥有地址(Address)，则 Customer 类与 Address  类具有单向关联关系<br>UML  图表示为：</p><p>对应的 java  代码片段：<br>c)<br>自身关联（反身关联）：<br>在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称<br>为自关联。顾客自身需要用到自己对象时，自己引用自己，带着一个自己的引用。<br>UML  图表示为：</p><p>对应的 java  代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Customer&#123;</span><br><span class="line">private Address address;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Address&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充扩展：<br>重数性关联:  表示一个类的对象与另一个类的对象连接的个数。<br>在 UML  中多重性关系可以直接在关联直线上增加一个数字表示与之对应的另一个类<br>的对象的个数。在关联的两端可写上一个被称为重数的范围，表示该类有多少个对象可与<br>对方一个对象连接，重数的默认值为 1，重数的符号通常有：<br>表示方式</p><p>多重性说明<br>表示“1”，表示另一个类的一个对象只与一个该类对象有关系<br>表示“零或多”，表示另一个类的一个对象与零个或多个该类对象有关系<br>表示“1 或多”，表示另一个类的一个对象与一个或多个该类对象有关系<br>表示“零或 1”，表示另一个类的一个对象没有或只与一个该类对象有关系<br>表示另一个类的一个对象与最少 m、最多 n 个该类对象有关系 (m&lt;=n)</p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/83.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>毕向东Java基础视频教程光碟01笔记</title>
    <link href="https://huangguangda.github.io/2018/05/07/1/"/>
    <id>https://huangguangda.github.io/2018/05/07/1/</id>
    <published>2018-05-07T05:29:18.000Z</published>
    <updated>2018-06-11T05:37:02.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/82.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>学习笔记</p><p>本套视频共计33天。<br>第1天~第5天讲解Java基础知识，带着读者轻松掌握Java中的字词句如何使用。并实现Java版的计算器。<br>第6天~第11天讲解Java的对象细节：培养面向对象思想，掌握对象和类的关系，封装、继承、多态的细节。如何使用内部类简化代码，<br>第12天~第13天讲解Java中的异常和包的使用。<br>第14天~第16天讲解Java中的多线程，实现多生产多消费，解决人妖问题。eclipse使用。<br>第17天~第18天讲解String类和JDK5中的特性。<br>第19天~第21天讲解Java中的各种集合容器使用。实现学生信息管理。<br>第22天~第26天讲解Java中的IO操作，并且时间文件切合和合并。<br>第27天讲解Java中的图形界面使用，实现自己想要的各种心动界面。<br>第28天~第29天讲解Java中的网络编程，实现网络聊天，群聊，文件上传，自己的浏览器实现。<br>第30天讲解Java中的正则表达式和反射技术。<br>第31天讲解网页标签语言HTML<br>第32天讲解网页布局，以及JavaScript揭秘<br>第33天讲解Javascript和DOM技术结合，实现各种网页常见效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/82.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>小码哥的MySQL笔记</title>
    <link href="https://huangguangda.github.io/2018/05/06/1/"/>
    <id>https://huangguangda.github.io/2018/05/06/1/</id>
    <published>2018-05-06T02:10:09.000Z</published>
    <updated>2018-06-07T11:04:27.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/69.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>可联系删除，做复习用，看不懂可以问哦~</p><p>数据库(DataBase:DB)：数据库是一个按数据结构来存储和管理数据的计算机软件系统。<br>     存储和管理数据的仓库.</p><p>数据库管理系统（Database Management System:DBMS）：是专门用于管理数据库的计算机系统软件。数据库管理系统能够为数据库提供数据的定义、建立、维护、查询和统计等操作功能，并完成对数据完整性、安全性进行控制的功能。</p><p>我们一般说的数据库,就是指的DBMS:  数据库服务器</p><p>数据库应用系统（Database Application System）：使用数据库技术的系统； 数据库应用系统有很多，基本上所有的信息系统都是数据库应用系统。它通常由软件、数据库和数据管理员组成。</p><p>常见的数据库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Oracle     :   Oracle </span><br><span class="line">DB2        :   IBM</span><br><span class="line">SQLServer  :   MS</span><br><span class="line">MySQL      :   AB--&gt;SUN--&gt;Oracle</span><br></pre></td></tr></table></figure></p><h2 id="什么是表？"><a href="#什么是表？" class="headerlink" title="什么是表？"></a>什么是表？</h2><p>我们说MYSQL是一种关系型数据库。关系数据库最重要的概念就是表。<br>表具有固定的列数和任意的行数，在数学上称为“关系”。</p><p>二维表是同类实体的各种属性的集合，每个实体对应于表中的一行，在关系中称为元组，相当于通常的一条记录；<br>表中的列表示属性，称为Field，相当于通常记录中的一个数据项，也叫列、字段。</p><p><img src="/images/70.png" style="width: 100%;height: 100%"></p><p><img src="/images/71.png" style="width: 100%;height: 100%"></p><p>MySQL安装过程中:注意:</p><p>MySQL的常用存储引擎:<br>  InnoDB:支持外键关系,支持事务(Transaction).           性能低.<br>  MyISAM:不支持外键关系,不支持事务管理.   性能高.</p><p>一般的,开发中外键关系可以不要,但是事务必须得有.  InnoDB.</p><p>MySQL的默认端口是:3306.</p><p>注意1: 选择MySQL的存储引擎:</p><p>注意2:  选择数据库的编码:UTF8,以后在MySQL中创建的数据库和表都是UTF8.</p><p>密码:admin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装成功之后:要修改MySQL的配置.</span><br><span class="line">进入MySQL的安装路径:C:\Program Files\MySQL\MySQL Server 5.5\bin</span><br><span class="line">找到.MySQLInstanceConfig.exe</span><br></pre></td></tr></table></figure></p><p><img src="/images/72.png" style="width: 100%;height: 100%"></p><p><img src="/images/73.png" style="width: 100%;height: 100%"></p><p><img src="/images/74.png" style="width: 100%;height: 100%"></p><h2 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">MySQL常用命令:</span><br><span class="line">打开数据库连接之前:一定要保证MySQL服务已经开启了.</span><br><span class="line">net start 命令名字:开启一个服务</span><br><span class="line">net stop  命令名字:关闭一个服务器</span><br><span class="line">---------------------------------------</span><br><span class="line">1 连接MySQL数据库:</span><br><span class="line">  进入 mysql, 在命令行中输入: </span><br><span class="line">  格式:mysql -u账户 -p密码 -h数据库服务器安装的主机 -P数据库端口</span><br><span class="line">  mysql -uroot -padmin -h127.0.0.1 -P3306</span><br><span class="line">  若连接的是本机,端口也是3306:</span><br><span class="line">  简写: mysql -uroot -padmin</span><br><span class="line">---------------------------------------  </span><br><span class="line">2 查看 mysq 中有哪些数据库: </span><br><span class="line">   show databases;</span><br><span class="line">---------------------------------------</span><br><span class="line">3 指定使用哪一个数据库: </span><br><span class="line">   use 数据库名称; </span><br><span class="line">---------------------------------------</span><br><span class="line">4 查看指定的数据库中有哪些数据表: </span><br><span class="line">    show tables</span><br><span class="line">---------------------------------------</span><br><span class="line">5 查看表的结构：</span><br><span class="line"> desc 表名</span><br><span class="line">---------------------------------------</span><br><span class="line">新建一个数据库: </span><br><span class="line"> create database 数据库名</span><br><span class="line">---------------------------------------</span><br><span class="line">删除一个数据库：</span><br><span class="line">drop database 数据库名</span><br><span class="line">---------------------------------------</span><br><span class="line">创建一张表:</span><br><span class="line">  create table  表名(</span><br><span class="line">   ....</span><br><span class="line">  )</span><br><span class="line">---------------------------------------</span><br><span class="line">删除一张表:</span><br><span class="line"> drop table  表名</span><br></pre></td></tr></table></figure><p>和数据库建立连接:<br>三要素:<br>URL: 连接地址: IP/端口/[数据库名字]<br>账户: root<br>密码: admin</p><p><img src="/images/75.png" style="width: 100%;height: 100%"></p><p>开发的时候,每个系统都应该由一个数据库实例.<br>都要自己建立新的数据库.不要使用系统自带的.</p><h2 id="MySQL中常见的列的数据类型"><a href="#MySQL中常见的列的数据类型" class="headerlink" title="MySQL中常见的列的数据类型"></a>MySQL中常见的列的数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">数据库中不区分大小写.</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">数据类型                 说明</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">char(size)            定长字符，0 - 255字节,size指N个字符数</span><br><span class="line">                  name char(20):</span><br><span class="line">                  存储will这4个字符:  底层依然占了20个字符. 不足以空格占位.---&gt;&apos;will                &apos;</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">varchar(size)      变长字符，0 - 255字节</span><br><span class="line">                  name  varchar(20):</span><br><span class="line">                  存储will这4个字符:  底层只占了4个字符. &apos;will&apos;</span><br><span class="line"></span><br><span class="line">注意:在MySQL中,字符使用单引号引起来. 相当于Java中字符串(String,StringBuilder/StringBuffer);</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">date                         日期数据:年月日，MySQL用&apos;YYYY-MM-DD&apos;格式检索和显示DATE值 </span><br><span class="line">                  格式受国际化影响.在中国YYYY-MM-DD: 在美国: 月日年(英文)</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">datetime               日期数据:年月日时分秒，要比date数据更确切，包含时分秒。MySQL以&apos;YYYY-MM-DD HH:MM:SS&apos;格式检索和显示DATETIME值 </span><br><span class="line">注意:在MySQL中,日期使用单引号引起来</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">int(size)              整型数据(size是显示的宽度):int</span><br><span class="line">                  int类型中的size表示宽度,但是没有任何意义.</span><br><span class="line">                  int(1)或者int(2)...其实底层都是int(11);</span><br><span class="line">                  一般定义int类型不需要指定size位数.               age  int</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">bigint            大整型:                Java:long</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">double[(s,p)]      小数类型，可存放实型和整型 ,精度(p)和范围(s)</span><br><span class="line">                  money double(5,2): 整数和小数一共占5为.其中小数占2位.    MAX:999.99,/ MIN:-999.99</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">decimal           小数类型，BigDecimal</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">blob                        存放图形、声音和影像，二进制对象，0-4GB:</span><br><span class="line">                  开发中,我们一般存储二进制文件保存路径.</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">text                      存放大文本文件， 0-4GB : 变长  :相当于Java中字符串(String,StringBuilder/StringBuffer);</span><br><span class="line">-----------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="创建表和约束"><a href="#创建表和约束" class="headerlink" title="创建表和约束"></a>创建表和约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.先进入某一个数据库.</span><br><span class="line">2.输入建表的命令:</span><br><span class="line">--------------------------------------------</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">   列名1    列的类型   [约束],</span><br><span class="line">   列名2    列的类型   [约束],</span><br><span class="line">   ....</span><br><span class="line">   列名N    列的类型   约束    </span><br><span class="line">);</span><br><span class="line">注意:最后一行没有逗号</span><br><span class="line">--------------------------------------------</span><br><span class="line">DROP TABLE IF EXISTS `student`;</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20) AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20),</span><br><span class="line">  `age` int(11),</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;</span><br><span class="line">等价于:</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20)  PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20),</span><br><span class="line">  `age` int(11)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;</span><br><span class="line">-------------------------------------------</span><br><span class="line">若在建表中使用到了数据库的关键字.</span><br><span class="line">比如新建一张订单表:(order),但是order是数据库中的关键字(排序使用).</span><br><span class="line">表名:t_order,若费用使用order这个单词.此时使用反撇(`)括起来,`order`.</span><br><span class="line">-------------------------------------------</span><br><span class="line">常见的约束(针对于某一列):</span><br><span class="line">1.非空约束: NOT NULL, 不允许某列的内容为空.</span><br><span class="line">2.唯一约束: UNIQUE  , 在该表中,该列的内容必须唯一.</span><br><span class="line">3.主键约束: PRIMARY KEY, 非空且唯一.</span><br><span class="line">4.主键自增长:AUTO_INCREMENT</span><br></pre></td></tr></table></figure><h2 id="SQL和数据库导入导出-备份"><a href="#SQL和数据库导入导出-备份" class="headerlink" title="SQL和数据库导入导出/备份"></a>SQL和数据库导入导出/备份</h2><p>DQl语句分类 :<br>Select查询语句<br>    SELECT</p><p>DML语句（数据操作语言）    INSERT / UPDATE / DELETE</p><p>DDL语句(数据定义语言)<br>    CREATE / DROP / ALTER</p><p>DCL语句（数据控制语言）<br>事务控制语句</p><p><img src="/images/76.png" style="width: 100%;height: 100%"></p><p>Sql语句的书写规则:<br>在mysql数据库中，Sql 语句大小写不敏感.<br>Sql语句可单行或多行书写.<br>在Sql语句中，关键字不能跨多行或缩写.<br>为了提高可读性，一般关键字大写，其他小写.<br>空格和缩进使程序易读.</p><p><img src="/images/77.png" style="width: 100%;height: 100%"></p><p><img src="/images/78.png" style="width: 100%;height: 100%"></p><h2 id="简单查询-单表"><a href="#简单查询-单表" class="headerlink" title="简单查询(单表)"></a>简单查询(单表)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">------------------------------------</span><br><span class="line">SELECT *</span><br><span class="line">FROM  表名</span><br><span class="line">如果为 * 和创建表时的顺序一致。</span><br><span class="line">可以自己调整顺序，在select后边加上要查询的列名。</span><br><span class="line">-------------------------------------------</span><br><span class="line">定义字段的别名:</span><br><span class="line">1、改变列的标题头</span><br><span class="line">2、用于表示计算结果的含义</span><br><span class="line">3、作为列的别名</span><br><span class="line">4、如果别名中使用特殊字符,或者是强制大小写敏感,或有空格时,都需加双引号,不建议使用引号.</span><br><span class="line">   定义别名起有意义的英文单词或单词短语.(不要出现空格)</span><br><span class="line">SELECT 列名1 [AS] 别名,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">------------------------------------------</span><br><span class="line">带有限制条件的查询:过滤</span><br><span class="line">SELECT 列名1,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">WHERE 条件1 AND/OR 条件2...</span><br><span class="line">注意:字符串和日期要用单引号扩起来</span><br><span class="line">执行顺序:</span><br><span class="line">1.先执行FROM,确定查哪一张表</span><br><span class="line">2.再执行WHERE,过滤</span><br><span class="line">3.接着执行SELECT,筛选哪一些列</span><br><span class="line">4.接着执行ORDER子句,对查询的结果排序</span><br><span class="line">5.再接着执行GROUP BY子句,分组查询</span><br><span class="line">6.再接着执行HAVING子句,对分组的结果再筛选</span><br><span class="line">----------------</span><br><span class="line">比较运算符:</span><br><span class="line">BETWEEN 最小值 AND 最大值:在两个值之间（闭区间）: &gt;= 最小值 AND &lt;=最大值</span><br><span class="line">IN                                              :包含在什么之间: 或者等于,或者等于</span><br><span class="line">LIKE                                          :像..:模糊查询,有两种占位符:</span><br><span class="line">%:可表示零或多个字符</span><br><span class="line">_:就只表示一个字符</span><br><span class="line">------------------------------------</span><br><span class="line">对查询结果排序:</span><br><span class="line">使用ORDER BY 子句将记录排序</span><br><span class="line">ASC: 升序,缺省</span><br><span class="line">DESC: 降序</span><br><span class="line">SELECT 列名1,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">WHERE 条件1 AND/OR 条件2...</span><br><span class="line">ORDER BY 列名1 ASC/DESC, 列表2 ASC/DESC;</span><br></pre></td></tr></table></figure><p><img src="/images/79.png" style="width: 100%;height: 100%"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">需求1:查询所有货品信息</span><br><span class="line">需求2:查询所有货品的id,productName,salePrice</span><br><span class="line">需求3:查询所有货品的id，名称和批发价(批发价=卖价*折扣)</span><br><span class="line">需求4:查询所有货品的id，名称，和各进50个的成本价(成本=costPirce)</span><br><span class="line">需求5:查询所有货品的id，名称，各进50个，并且每个运费1元的成本</span><br><span class="line">需求6:查询所有货品的id，名称，各进50个，并且每个运费1元的成本(使用别名)</span><br><span class="line">需求7:查询货品零售价为119的所有货品信息</span><br><span class="line">需求8: 查询货品名为罗技G9X的所有货品信息.</span><br><span class="line">需求9: 查询货品名 不 为罗技G9X的所有货品信息.</span><br><span class="line">不区分大小写的查询:</span><br><span class="line">区分大小写的查询:</span><br><span class="line">需求10:查询分类编号不等于2的货品信息</span><br><span class="line">需求11:查询货品名称,零售价小于等于200的货品</span><br><span class="line">需求12:查询id，货品名称，批发价大于350的货品  </span><br><span class="line">需求13:选择id，货品名称，批发价在300-400之间的货品</span><br><span class="line">需求14:选择id，货品名称，分类编号为2,4的所有货品</span><br><span class="line">需求15:查询id，货品名称，货品名称匹配&apos;%罗技M9_&apos;</span><br><span class="line">需求16:选择id，货品名称，批发价 不 在300-400之间的货品</span><br><span class="line">查询id,名称, 分类为2或者 名字不带有M并且零售价大于100的货品</span><br><span class="line">需求17:选择id，货品名称，分类编号,零售价并且按零售价降序排序</span><br><span class="line"></span><br><span class="line">需求18:选择id，货品名称，分类编号,零售价先按分类编号排序,再按零售价排序</span><br><span class="line"></span><br><span class="line">需求19:查询M系列并按照批发价排序(加上别名)</span><br><span class="line"></span><br><span class="line">需求20:查询分类为2并按照批发价排序(加上别名)</span><br></pre></td></tr></table></figure><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">分组函数:分组函数作用于一组数据，并对一组数据返回一个值。</span><br><span class="line">分组函数类型:</span><br><span class="line">--------------------------------------</span><br><span class="line">AVG(列名)：  平均值</span><br><span class="line">COUNT(列名)：总数  ,查询结果是bigint类型(long),不是int类型</span><br><span class="line">MAX(列名)：  最大值</span><br><span class="line">MIN(列名)：  最小值</span><br><span class="line">SUM(列名)：  求和</span><br><span class="line">--------------------------------------</span><br><span class="line">需求:查询所有商品平均零售价</span><br><span class="line">需求:查询商品总记录数</span><br><span class="line">需求:查询分类为2的商品总数</span><br><span class="line">需求:查询商品的最小零售价，最高零售价，以及所有商品零售价总和</span><br><span class="line"></span><br><span class="line">分组查询:</span><br><span class="line"></span><br><span class="line">SELECT 列名1,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">WHERE 条件1 AND/OR 条件2...</span><br><span class="line">GROUP BY 分组的列名</span><br><span class="line">ORDER BY 列名1 ASC/DESC, 列表2 ASC/DESC;</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">可以使用GROUP BY 子句将表中的数据分成若干组</span><br><span class="line">注意：在SELECT子句中所有未包含在组函数中的列都应该包含在 GROUP BY 子句中。</span><br><span class="line">包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</span><br><span class="line">--------------------------------------</span><br><span class="line">需求:查询每个商品分类编号和每个商品分类各自的平均零售价</span><br><span class="line">需求:查询每个商品分类编号和每个商品分类各自的商品总数。</span><br><span class="line">需求:查询每个商品分类编号和每个商品分类中零售价大于100的商品总数：</span><br><span class="line">注意:</span><br><span class="line">不能在 WHERE 子句中使用组函数（注意）。</span><br><span class="line">可以在 HAVING 子句中使用组函数。</span><br><span class="line">HAVING子句:</span><br><span class="line">  对分组之后的结果做筛选/过滤.</span><br><span class="line">需求:查询零售价总和大于1500的商品分类编号以及总零售价和：</span><br></pre></td></tr></table></figure><p><img src="/images/80.png" style="width: 100%;height: 100%"></p><p><img src="/images/81.png" style="width: 100%;height: 100%"></p><h2 id="MySQL的分页查询"><a href="#MySQL的分页查询" class="headerlink" title="MySQL的分页查询"></a>MySQL的分页查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MySQL分页查询: MySQL方言:</span><br><span class="line">语法:</span><br><span class="line">SELECTcolumn1, column2...</span><br><span class="line">FROMtable</span><br><span class="line">[WHEREcondition]</span><br><span class="line">LIMIT beginIndex,pageSize</span><br><span class="line">beginIndex:是开始索引(从0开始):第一条记录:0,第二条记录:1</span><br><span class="line">beginIndex = (当前页数 - 1) * pageSize</span><br><span class="line">---------------------------------</span><br><span class="line">每页最多3条记录: pageSize = 3:</span><br><span class="line">------------------------------------------</span><br><span class="line">第一页: SELECT * FROM `product` LIMIT 0, 3  :   0,1,2</span><br><span class="line">第二页: SELECT * FROM `product` LIMIT 3, 3  :   3,4,5</span><br><span class="line">第三页: SELECT * FROM `product` LIMIT 6, 3  :   6,7,8</span><br><span class="line">第四页: SELECT * FROM `product` LIMIT 9, 3</span><br><span class="line">第七页: SELECT * FROM `product` LIMIT 18,3  :   18,19,20</span><br><span class="line">第N页:  SELECT * FROM `product` LIMIT beginIndex,3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/69.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>小码哥JAVA大神班MySql</title>
    <link href="https://huangguangda.github.io/2018/05/05/1/"/>
    <id>https://huangguangda.github.io/2018/05/05/1/</id>
    <published>2018-05-04T23:00:49.000Z</published>
    <updated>2018-06-06T18:25:47.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>可联系删除，做复习用，看不懂可以问哦~</p><h2 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h2><p>数据库(DataBase:DB)：数据库是按照数据结构来组织、存储和管理数据的仓库。—-&gt;存储和管理数据的仓库.</p><p>数据库管理系统（Database Management System:DBMS）：是专门用于管理数据库的计算机系统软件。数据库管理系统能够为数据库提供数据的定义、建立、维护、查询和统计等操作功能，并完成对数据完整性、安全性进行控制的功能。</p><p>MIS:管理信息系统.<br>我们一般说的数据库,就是指的DBMS: 数据库服务器.</p><h2 id="数据库技术发展历程："><a href="#数据库技术发展历程：" class="headerlink" title="数据库技术发展历程："></a>数据库技术发展历程：</h2><ol><li>层次数据库和网状数据库技术阶段；<br> 使用指针来表示数据之间的联系。</li><li>关系数据库技术阶段；<br> 经典的里程碑阶段。代表DBMS:Oracle、DB2、MySQL、SQL Server、SyBase等。</li><li>后关系数据库技术阶段；<br> 关系型数据库存在数据模型，性能，拓展伸缩性的缺点，出现了：<br> ORDBMS：面向对象数据库技术。<br> NoSQL ：结构化数据库技术。</li></ol><p>随着大数据的不断发展，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速，出色的NoSQL数据库：</p><h3 id="常见的NoSQL数据库分为四大类："><a href="#常见的NoSQL数据库分为四大类：" class="headerlink" title="常见的NoSQL数据库分为四大类："></a>常见的NoSQL数据库分为四大类：</h3><p>1):键值存储数据库：Oracle BDB,Redis,BeansDB<br>2):列式储数数据库：HBase,Cassandra,Riak<br>3):文档型数据库：MongoDB,CouchDB<br>4):图形数据库：Neo4J,InfoGrid,Infinite Graph</p><p>常见的关系数据库:</p><h2 id="数据库系统-所属公司"><a href="#数据库系统-所属公司" class="headerlink" title="  数据库系统        所属公司"></a>  数据库系统        所属公司</h2><p>  Oracle            Oracle(甲骨文)<br>  DB2               IBM<br>  SQL Server        MS<br>  MySQL             AB–&gt;SUN–&gt;Oracle</p><p>Oracle:运行稳定，可移植性高，功能齐全，性能超群！适用于大型企业领域。</p><p>DB2：速度快、可靠性好，适于海量数据，恢复性极强。适用于大中型企业领域。</p><p>SQL Server:全面，效率高，界面友好，操作容易，但是不跨平台。适用于于中小型企业领域。</p><p>MySQL:开源，体积小，速度快。适用于中小型企业领域。</p><h2 id="SQL：结构化查询语言-Structured-Query-Language-。"><a href="#SQL：结构化查询语言-Structured-Query-Language-。" class="headerlink" title="SQL：结构化查询语言(Structured Query Language)。"></a>SQL：结构化查询语言(Structured Query Language)。</h2><p>是关系型数据库标准语言。<br>特点：简单，灵活，功能强大。</p><h3 id="SQL包含6个部分："><a href="#SQL包含6个部分：" class="headerlink" title="SQL包含6个部分："></a>SQL包含6个部分：</h3><p>一：数据查询语言（DQL）：<br>其语句，也称为“数据检索语句”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。</p><p>二：数据操作语言（DML）：<br>其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动作查询语言。</p><p>三：事务处理语言（TPL）：<br>它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。</p><p>四：数据控制语言（DCL）：<br>它的语句通过GRANT或REVOKE获得许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。</p><p>五：数据定义语言（DDL）：<br>其语句包括动词CREATE和DROP。在数据库中创建新表或删除表（CREAT TABLE 或 DROP TABLE）；为表加入索引等。DDL包括许多与人数据库目录中获得数据有关的保留字。它也是动作查询的一部分。</p><p>六：指针控制语言（CCL）：<br>它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。</p><h3 id="书写规则："><a href="#书写规则：" class="headerlink" title="书写规则："></a>书写规则：</h3><p>1.数据库中，SQL语句大小写不敏感<br>2.SQL语句可单行或多行书写<br>3.在SQL语句中，关键字不能跨多行或缩写<br>4.为了提高可读性，一般关键字大写，其他小写<br>5.空格和缩进使程序易读</p><h2 id="什么是表？"><a href="#什么是表？" class="headerlink" title="什么是表？"></a>什么是表？</h2><p>我们说MySQL是一种关系型数据库。关系数据库最重要的概念就是表。 </p><p>表:又称之为二维表.(有行和列)—-&gt;存储数据.<br>表具有固定的列数和任意的行数，在数学上称为“关系”。</p><p>二维表是同类实体的各种属性的集合，每个实体对应于表中的一行，在关系中称为元组，相当于通常的一条记录；</p><p>表中的列表示属性，称为Field，相当于通常记录中的一个数据项，也叫列、字段。</p><p><img src="/images/42.png" style="width: 100%;height: 100%"></p><p><img src="/images/43.png" style="width: 100%;height: 100%"></p><p><img src="/images/44.png" style="width: 100%;height: 100%"></p><p><img src="/images/45.png" style="width: 100%;height: 100%"></p><p><img src="/images/46.png" style="width: 100%;height: 100%"></p><p><img src="/images/47.png" style="width: 100%;height: 100%"></p><p><img src="/images/48.png" style="width: 100%;height: 100%"></p><p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供不同的功能和能力。<br>通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p><p>MyISAM：拥有较高的插入，查询速度，但不支持事务，不支持外键。<br>InnoDB：支持事务，支持外键，支持行级锁定，性能较低。<br>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但对比MyISAM，处理效率差，且会占用更多的磁盘空间以保留数据和索引。</p><p><img src="/images/49.png" style="width: 100%;height: 100%"></p><p><img src="/images/50.png" style="width: 100%;height: 100%"></p><p>最常用的整数类型：<br>MySQL列类型               Java数据类型</p><p>INT:                       int/Integer<br>BIGINT:                    long/Long</p><p>MySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。</p><p>例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。</p><p>需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。一般不用指定位宽。</p><p><img src="/images/51.png" style="width: 100%;height: 100%"></p><p><img src="/images/52.png" style="width: 100%;height: 100%"></p><p><img src="/images/53.png" style="width: 100%;height: 100%"></p><h2 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h2><p>创建表:<br>1.先进入某一个数据库.<br>2.输入建表的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">   列名1    列的类型   [约束],</span><br><span class="line">   列名2    列的类型   [约束],</span><br><span class="line">   ....</span><br><span class="line">   列名N    列的类型   约束    </span><br><span class="line">);</span><br><span class="line">注意:最后一行没有逗号</span><br></pre></td></tr></table></figure></p><p>使用SQL的时候,不要使用SQL的关键字,如果使用到,怎么办.<br>建立一张表,表用来装订单的信息,订单叫做:ORDER.<br>此时,SQL出错,因为ORDER是SQL中的关键字.</p><p>   解决方案一:使用反引号(<code>)把自定义的标识符引起来:</code>order`.<br>   解决方案二:使用表名的前缀,一般的,习惯t_order.</p><p>需求:在jdbcdemo数据库中,创建一张学生表(包含了id,name,age).<br>第一步:进入jdbcdemo数据库.<br>  USE jdbcdemo;<br>第二步:输入建立表的语句.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20) DEFAULT NULL,</span><br><span class="line">  `name` varchar(20) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>删除表:<br>DROP TABLE  student;</p><p>查看表结构：<br>DESC table_name;<br>查看表的详细定义：<br>SHOW CREATE TABLE table_name; 其实现实的建立表的SQL语句.</p><p><img src="/images/54.png" style="width: 100%;height: 100%"></p><h2 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h2><p>表的约束(针对于某一列):<br>1.非空约束：NOT NULL，不允许某列的内容为空。<br>2.设置列的默认值：DEFAULT。<br>3.唯一约束：UNIQUE，在该表中，该列的内容必须唯一。<br>4.主键约束：PRIMARY KEY， 非空且唯一。<br>5.主键自增长：AUTO_INCREMENT，从1开始，步长为1。<br>6.外键约束：FOREIGN KEY. A表中的外键列的值必须参照于B表中的某一列(B表主键)-明天讲解。</p><p>主键设计：<br>1：单字段主键，单列作为主键，建议使用。<br>   复合主键，使用多列充当主键，不建议。<br>2：主键分为两种:<br>   1）.自然主键:使用有业务含义的列作为主键(不推荐使用);<br>   2）.代理主键:使用没有业务含义的列作为主键(推荐使用);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20) PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) UNIQUE ,</span><br><span class="line">  `age` int(11) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/images/55.png" style="width: 100%;height: 100%"></p><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><p><img src="/images/56.png" style="width: 100%;height: 100%"></p><p>简单查询:<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT&#123;*, column [alias],...&#125;</span><br><span class="line">FROM     table_name;</span><br></pre></td></tr></table></figure></p><p>说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT   选择查询列表</span><br><span class="line">FROM  提供数据源(表、视图或其他的数据源)</span><br></pre></td></tr></table></figure></p><p>如果为 * 和创建表时的顺序一致。<br>可以自己调整顺序，在select后边加上要查询的列名。</p><p>需求:查询所有货品信息<br>需求:查询所有货品的id,productName,salePrice</p><p>消除结果中重复的数据:<br>需求:查询商品的分类编号。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 列名，...</span><br><span class="line"></span><br><span class="line">FROMtable_name;</span><br></pre></td></tr></table></figure></p><p>实现数学运算查询:<br>对NUMBER型数据可以使用算数操作符创建表达式（+  -  *  /）<br>对DATE型数据可以使用部分算数操作符创建表达式 （+  -）</p><h3 id="运算符优先级："><a href="#运算符优先级：" class="headerlink" title="运算符优先级："></a>运算符优先级：</h3><p>1、乘法和除法的优先级高于加法和减法<br>2、同级运算的顺序是从左到右<br>3、表达式中使用”括号”可强行改变优先级的运算顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">需求:查询所有货品的id，名称和批发价(批发价=卖价*折扣)</span><br><span class="line"></span><br><span class="line">需求:查询所有货品的id，名称，和各进50个的成本价(成本=costPirce)</span><br><span class="line"></span><br><span class="line">需求:查询所有货品的id，名称，各进50个，并且每个运费1元的成本</span><br></pre></td></tr></table></figure><p>设置列名的别名。<br>1、改变列的标题头；<br>2、用于表示计算结果的含义；<br>3、作为列的别名；<br>4、如果别名中使用特殊字符，或者是强制大小写敏感，或有空格时，都需加双引号；</p><p>需求:查询所有货品的id，名称，各进50个，并且每个运费1元的成本(使用别名)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,productName,(costPrice+1) * 50 AS pf FROM product</span><br><span class="line">SELECT id,productName,(costPrice+1) * 50 pf FROM product</span><br><span class="line">SELECT id,productName,(costPrice+1) * 50 &quot;p f&quot; FROM product</span><br></pre></td></tr></table></figure></p><h2 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h2><p>过滤查询:<br>使用WHERE子句限定返回的记录：<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT  &lt;selectList&gt; </span><br><span class="line">FROM      table_name</span><br><span class="line">WHERE  条件;</span><br></pre></td></tr></table></figure></p><p>注意：<br>WHERE子句在 FROM 子句后</p><p>比较运算符:<br>运算符               含义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=               等于</span><br><span class="line">&gt;               大于</span><br><span class="line">&gt;=               大于或等于</span><br><span class="line">&lt;               小于</span><br><span class="line">&lt;=               小于或等于</span><br><span class="line">!=(&lt;&gt;)           不等于</span><br></pre></td></tr></table></figure></p><p>需求: 查询货品零售价为119的所有货品信息.<br>需求: 查询货品名为罗技G9X的所有货品信息.<br>需求: 查询货品名 不为 罗技G9X的所有货品信息.<br>需求: 查询分类编号不等于2的货品信息<br>需求: 查询货品名称,零售价小于等于200的货品<br>需求: 查询id，货品名称，批发价大于350的货品<br>思考：使用where后面使用别名不行,总结select和where的执行顺序</p><p>注意：字符串和日期要用单引号扩起来.<br>要让MySQL查询区分大小写，可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE BINARY productName=&apos;g9x&apos;</span><br><span class="line">SELECT * FROM table_name WHERE BINARY productName=&apos;G9X&apos;</span><br></pre></td></tr></table></figure></p><p>SQL中不同子句执行先后顺序:<br>1):首先执行FROM子句. 明确从哪一张表中做查询.<br>2):其次执行WHERE子句.筛选符合条件的数据.<br>3):接着执行SELECT子句.选择出要显示哪些列的数据.<br>4):最后执行ORDER BY子句.对查询筛选的结果再做排序.</p><p>逻辑运算符:<br>运算符                含义</p><p>AND(&amp;&amp;)            如果组合的条件都是TRUE,返回TRUE<br>OR(||)             如果组合的条件之一是TRUE,返回TRUE<br>NOT(!)             如果下面的条件是FALSE,返回TRUE.</p><p>需求: 选择id，货品名称，批发价在300-400之间的货品<br>需求: 选择id，货品名称，分类编号为2,4的所有货品<br>需求: 选择id，货品名词，分类编号不为2的所有商品<br>需求: 选择id，货品名称，分类编号的货品零售价大于等于250或者是成本大于等于200</p><p>运算符优先级规则:<br>优先级            运算符</p><p>1                所有比较运算符<br>2                NOT<br>3                AND<br>4                OR</p><p>范围查询:<br>使用BETWEEN运算符显示某一值域范围的记录，这个操作符最常见的使用在数字类型数据的范围上，但对于字符类型数据和日期类型数据同样可用。<br>格式：<br>SELECT * FROM 表名 WHERE 列名 BETWEEN minvalue AND maxvalue：闭区间。<br>需求: 选择id，货品名称，批发价在300-400之间的货品<br>需求: 选择id，货品名称，批发价不在300-400之间的货品</p><p>集合查询:<br>使用IN运算符，判断列的值是否在指定的集合中。<br>格式： WHERE 列名 IN (值1，值2….);<br>需求:选择id，货品名称，分类编号为2,4的所有货品<br>需求:选择id，货品名称，分类编号不为2,4的所有货品</p><p>空值判断:<br>IS NULL:判断列的值是否为空。<br>格式：WHERE  列名 IS NULL;<br>需求:查询商品名为NULL的所有商品信息。</p><p>模糊查询:</p><p>使用LIKE运算符执行通配查询，查询条件可包含文字字符或数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%:通配符：可表示零或多个字符。</span><br><span class="line">_:通配符：可表示一个字符。</span><br><span class="line">通配符：用来实现匹配部分值得特殊字符。</span><br></pre></td></tr></table></figure></p><p>需求: 查询id，货品名称，货品名称匹配’%罗技M9_’<br>需求: 查询id，货品名称，分类编号,零售价大于等于200并且货品名称匹配’%罗技M1__’<br>模糊查询不是搜索引擎. Lucene </p><h2 id="对查询结果排序"><a href="#对查询结果排序" class="headerlink" title="对查询结果排序"></a>对查询结果排序</h2><p>使用ORDER BY子句将记录排序</p><p>ASC : 升序，缺省。<br>DESC: 降序。<br>ORDER BY </p><p>子句出现在SELECT语句的最后。<br>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;selectList&gt; </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE 条件</span><br><span class="line">ORDER BY 列名1 [ASC/DESC],列名2 [ASC/DESC]...;</span><br></pre></td></tr></table></figure></p><p>按照某一列来排序:<br>需求:选择id，货品名称，分类编号,零售价并且按零售价降序排序<br>按多列排序:<br>需求: 选择id，货品名称，分类编号,零售价先按分类编号排序,再按零售价排序<br>列的别名排序:<br>需求:查询M系列并按照批发价排序(加上别名)<br>需求:查询分类为2并按照批发价排序(加上别名)<br>注意：不能对使用了引号的别名排序。</p><p>SELECT语句执行顺序：<br>先执行FROM—&gt;接着执行WHERE—&gt;再执行SELECT—&gt;最后执行ORDER BY</p><h2 id="MySQL的分页查询"><a href="#MySQL的分页查询" class="headerlink" title="MySQL的分页查询"></a>MySQL的分页查询</h2><p>分页设计:<br>    假分页/逻辑分页/内存  分页:<br>        一次性把数据全部查询出来,存放在内存中,翻页的时候,只需要从内存中去截取指定的条数即可.<br>        优缺点:缺点:若数据过多,可能造成内存溢出;优点:简单,翻页比较快.<br>    真分页/物理分页/数据库分页:<br>        每次翻页的时候,都从数据库中去截取指定条数的数据.<br>        优缺点:缺点:复杂,翻页比较慢;优点:不会造成内存溢出.</p><p>此时,我们讲解MySQL特有的分页方式(LIMIT,在Oracle12C中也提供该语法了).</p><p>此时设置每页最多显示3条数据:<br>Integer pageSize = 3;<br>语法:  LIMIT  ?,?;<br>第一个?:从哪一个索引位置开始截取数据(从0开始的). beginIndex<br>第二个?:每页显示最多的条数.                       pageSize<br>LIMIT  beginIndex, pageSize;<br>beiginIndex = (currentPage - 1) * pageSize;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一页: SELECT * FROM `product` LIMIT 0, 3</span><br><span class="line">第二页: SELECT * FROM `product` LIMIT 3, 3</span><br><span class="line">第三页: SELECT * FROM `product` LIMIT 6, 3</span><br><span class="line">第四页: SELECT * FROM `product` LIMIT 9, 3</span><br><span class="line">第N页:  SELECT * FROM `product` LIMIT (N-1)*3, 3</span><br></pre></td></tr></table></figure><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>什么是聚集函数(分组函数/统计函数)：<br>聚集函数作用于一组数据，并对一组数据返回一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COUNT：统计结果记录数  </span><br><span class="line">MAX：  统计计算最大值</span><br><span class="line">MIN：  统计计算最小值</span><br><span class="line">SUM：  统计计算求和</span><br><span class="line">AVG：  统计计算平均值</span><br></pre></td></tr></table></figure><p>需求:查询所有商品平均零售价<br>需求:查询商品总记录数(注意在Java中必须使用long接收)<br>需求:查询分类为2的商品总数<br>需求:查询商品的最小零售价，最高零售价，以及所有商品零售价总和</p><p><img src="/images/57.png" style="width: 100%;height: 100%"></p><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>单表查询:从一张表中查询数据</p><p>多表查询:从多张表中联合查询出数据</p><p>为什么需要多表查询:<br>简单说分别操作:类似于咱们Java中的分类.不同的事物使用不同的类型(类)来表示.<br>                每一张表存储该类型的事物的数据,不同事物咱们采取分表操作.</p><p>单表查询:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;selectList&gt;</span><br><span class="line"></span><br><span class="line">FROM  表名</span><br></pre></td></tr></table></figure></p><p>注意:没有连接条件的表关系返回的结果:<br>多表查询会产生笛卡尔积:<br>假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。<br>实际运行环境下，应避免使用全笛卡尔集(笛卡尔积的数据存在大量的不合理)。</p><p>消除笛卡尔积最简单最直接的方式:<br>  使用等值连接.<br>如果是N张表做连接查询,等值连接关系至少是N-1个.<br>需求:查询所有的货品信息+对应的货品分类信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT productName,dirName FROM product,productdir</span><br><span class="line">WHERE dir_id = productdir.id</span><br></pre></td></tr></table></figure></p><p><img src="/images/59.png" style="width: 100%;height: 100%"></p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>主键约束: PRIMARY KEY. 在表中主键列的值,非空且唯一.<br>外键约束：FOREIGN KEY. A表中的外键列的值必须参照于B表中的主键列,外键列允许为NULL.</p><p>在MySQL中,只有InnoDB存储引擎才只能事务和外键,MyISAM不支持事务不支持外键.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改表的存储引擎: ALTER TABLE product engine = &apos;InnoDB&apos;;</span><br></pre></td></tr></table></figure></p><p><img src="/images/60.png" style="width: 100%;height: 100%"></p><p><img src="/images/61.png" style="width: 100%;height: 100%"></p><p><img src="/images/62.png" style="width: 100%;height: 100%"></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select &lt;select_list&gt; from tablea a left join tableb b on a.key=b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a left join tableb b on a.key = b.key where b.key is null</span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a right join tableb b on a.key = b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a on a.key = b.key where a.key is null</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select &lt;select_list&gt; from tablea a inner join tableb b on a.key = b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a full outer join tableb b on a.key = b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a full outer join tableb b on a.key = b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a full outer join table b on a.key = b.key where a.key is null or b.key is null</span><br></pre></td></tr></table></figure><p><img src="/images/63.png" style="width: 100%;height: 100%"></p><p>内连接查询:<br>   隐式内连接:<br>   显示内连接:<br>外连接查询:<br>   左外连接:<br>   右外连接:<br>   全外连接:<br>子查询:<br>字连接查询:</p><p>内连接查询：是相对于外连接。<br>内连接分为：隐式内连接、显示内连接，其查询效果相同,仅仅是语法不一样而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">隐式内连接：</span><br><span class="line">SELECT &lt;selectList&gt;</span><br><span class="line">FROM   A ,B  WHERE A.列 = B.列</span><br><span class="line"></span><br><span class="line">显示内连接(推荐写法)：</span><br><span class="line">SELECT &lt;selectList&gt;</span><br><span class="line">FROM  A [INNER] JOIN B ON A.列 = B.列</span><br></pre></td></tr></table></figure></p><p>需求:查询所有商品的名称和分类名称:<br>隐式内连接: SELECT p.productName,pd.dirName FROM product p,productdir pd WHERE p.dir_id = pd.id<br>显示内连接: SELECT p.productName,pd.dirName FROM product p INNER JOIN productdir pd ON p.dir_id = pd.id<br>显示内连接: SELECT p.productName,pd.dirName FROM product p JOIN productdir pd ON p.dir_id = pd.id</p><p>在做等值连接的时候,若A表中和B表中的列名相同. 则可以简写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT&lt;selectList&gt;</span><br><span class="line">FROMA [INNER] JOIN B USING(同名的列)</span><br><span class="line">前提:在emp和dept表中都有deptno列. 并且是外键关系。</span><br><span class="line">如: SELECT * FROM emp JOIN dept USING (deptno)</span><br></pre></td></tr></table></figure></p><p>使用表名前缀在多个表中区分相同的列。<br>在不同表中具有相同列名的列可以用表的别名加以区分。<br>使用别名可以简化查询。<br>使用表名前缀可以提高执行效率。<br>如果使用了表的别名，则不能再使用表的真名</p><p>需求: 查询货品id，货品名称，货品所属分类名称<br>需求: 查询零售价大于200的无线鼠标<br>需求: 查询零售价大于200的无线鼠标(使用表的别名)<br>需求: 查询每个货品对应的分类以及对应的库存<br>需求: 如果库存货品都销售完成,按照利润从高到低查询货品名称,零售价,货品分类（三张表）.</p><p>外连接查询:<br>   A LEFT JOIN  B—-&gt; B RINGHT JOIN A<br>  左外连接:查询出JOIN左边表的全部数据查询出来,JOIN右边的表不匹配的数据使用NULL来填充数据.<br>  右外连接:查询出JOIN右边表的全部数据查询出来,JOIN左边的表不匹配的数据使用NULL来填充数据.</p><p>语法格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT&lt;selectList&gt;</span><br><span class="line">FROMA LEFT/RIGHT OUTER JOIN B</span><br><span class="line">  ON (A.column_name = B.column_name)];</span><br><span class="line">左连接:</span><br><span class="line">SELECT * FROM product p LEFT JOIN productdir pd ON p.dir_id = pd.id</span><br><span class="line">右连接:</span><br><span class="line">SELECT * FROM product p RIGHT JOIN productdir pd ON p.dir_id = pd.id</span><br></pre></td></tr></table></figure></p><p><img src="/images/64.png" style="width: 100%;height: 100%"></p><p><img src="/images/65.png" style="width: 100%;height: 100%"></p><p>自连接查询:把一张表看成两张来做查询.</p><p><img src="/images/66.png" style="width: 100%;height: 100%"></p><h2 id="操作数据-DML"><a href="#操作数据-DML" class="headerlink" title="操作数据(DML)"></a>操作数据(DML)</h2><p>DQL:查询语句,查询之后,会返回结果的临时表.<br>DML:增删改语句,操作之后,会返回一个结果,表示受影响的行数(删除3条数据,就返回3).</p><p>插入语句:一次插入操作只插入一行.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name (column1,column2,column3...)</span><br></pre></td></tr></table></figure></p><p>1.插入完整数据记录<br>2.插入数据记录一部分<br>3.插入多条数据记录（MySQL特有）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTOtable_name (column1,column2,column3...)</span><br><span class="line">  VALUES (value1,value2,value3...),</span><br><span class="line">         (value1,value2,value3...),</span><br><span class="line">         (value1,value2,value3...)..;</span><br></pre></td></tr></table></figure></p><p>4.插入查询结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTOtable_name (column1,column2,column3...)</span><br><span class="line">    SELECT (column1,column2,column3...)</span><br><span class="line">    FROM table_name </span><br><span class="line">INSERT INTO productdir (dirName,parent_id)</span><br><span class="line">  SELECT dirName,parent_id FROM productdir</span><br></pre></td></tr></table></figure></p><p>删除操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE  FROM table_name [WHERE condition];</span><br><span class="line">注意:如果省略了where子句，则全表的数据都会被删除.</span><br></pre></td></tr></table></figure><p>更新操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name SET columnName = value [, columnName = value] [WHEREcondition];</span><br></pre></td></tr></table></figure><p>如果省略了where子句，则全表的数据都会被修改。注意:没有FROM</p><p>需求:将零售价大于300的货品零售价上调0.2倍<br>需求:将零售价大于300的有线鼠标的货品零售价上调0.1倍</p><h2 id="数据备份和恢复"><a href="#数据备份和恢复" class="headerlink" title="数据备份和恢复"></a>数据备份和恢复</h2><p>备份:很重要,修改之前,都先做备份.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MySQL自身的数据库维护：</span><br><span class="line">通过cmd命令进入dos窗口：</span><br><span class="line">1.导出：mysqldump -u账户 -p密码 数据库名称&gt;脚本文件存储地址</span><br><span class="line"></span><br><span class="line">   mysqldump -uroot -padmin jdbcdemo&gt; C:/shop_bak.sql</span><br><span class="line"></span><br><span class="line">2.导入：mysql -u账户 -p密码 数据库名称&lt; 脚本文件存储地址</span><br><span class="line">   mysql -uroot -padmin jdbcdemo&lt; C:/shop_bak.sql</span><br><span class="line"></span><br><span class="line">Navicat工具的导入和导出：</span><br></pre></td></tr></table></figure></p><p><img src="/images/67.png" style="width: 100%;height: 100%"></p><p><img src="/images/68.png" style="width: 100%;height: 100%"></p><p>1 、 部门表：DEPT<br>No. 字段名称 类型 描述<br>1 DEPTNO BIGINT 部门编号，由两位数字所组成( 主键)<br>2 DNAME VARCHAR(20) 部门名称，由 14 位字符所组成<br>3 LOC VARCHAR(20) 部门位置</p><p>2 、 雇员表：EMP<br>No. 字段名称 类型 描述<br>1 EMPNO BIGINT 雇员编号，由四位数字所组成( 主键)<br>2 ENAME VARCHAR(20) 雇员姓名<br>3 JOB VARCHAR(20) 职位<br>4 MGR BIGINT 一个雇员对应的领导编号（雇员编号）<br>5 HIREDATE DATE 雇员的雇佣日期<br>6 SAL DOUBLE(7,2) 基本工资，由两位小数和五位整数所组成<br>7 COMM DOUBLE(7,2) 奖金/奖金<br>8 DEPTNO BIGINT 一个雇员所在的部门编号，与 dept 表的对应</p><p>DEPT 表数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `DEPT` VALUES (10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos;);</span><br><span class="line">INSERT INTO `DEPT` VALUES (20, &apos;RESEARCH&apos;, &apos;DALLAS&apos;);</span><br><span class="line">INSERT INTO `DEPT` VALUES (30, &apos;SALES&apos;, &apos;CHICAGO&apos;);</span><br><span class="line">INSERT INTO `DEPT` VALUES (40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos;);</span><br></pre></td></tr></table></figure></p><p>EMP 表数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `EMP` VALUES (7369, &apos;SMITH&apos;, &apos;CLERK&apos;, 7902, &apos;1980-12-17&apos;, 800, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7499, &apos;ALLEN&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-02-20&apos;, 1600, 300, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7521, &apos;WARD&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-02-22&apos;, 1250, 500, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7566, &apos;JONES&apos;, &apos;MANAGER&apos;, 7839, &apos;1981-04-02&apos;, 2975, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7654, &apos;MARTIN&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-09-28&apos;, 1250, 1400, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7698, &apos;BLAKE&apos;, &apos;MANAGER&apos;, 7839, &apos;1981-05-01&apos;, 2850, NULL, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7782, &apos;CLARK&apos;, &apos;MANAGER&apos;, 7839, &apos;1981-06-09&apos;, 2450, NULL, 10);</span><br><span class="line">INSERT INTO `EMP` VALUES (7788, &apos;SCOTT&apos;, &apos;ANALYST&apos;, 7566, &apos;1987-04-19&apos;, 3000, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7839, &apos;KING&apos;, &apos;PRESIDENT&apos;, NULL, &apos;1981-11-17&apos;, 5000, NULL, 10);</span><br><span class="line">INSERT INTO `EMP` VALUES (7844, &apos;TURNER&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-09-08&apos;, 1500, 0, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7876, &apos;ADAMS&apos;, &apos;CLERK&apos;, 7788, &apos;1987-05-23&apos;, 1100, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7900, &apos;JAMES&apos;, &apos;CLERK&apos;, 7698, &apos;1981-12-03&apos;, 950, NULL, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7902, &apos;FORD&apos;, &apos;ANALYST&apos;, 7566, &apos;1981-12-03&apos;, 3000, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7934, &apos;MILLER&apos;, &apos;CLERK&apos;, 7782, &apos;1982-01-23&apos;, 1300, NULL, 10);</span><br></pre></td></tr></table></figure></p><h2 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h2><p>01.查询每个雇员的编号、姓名、职位。</p><p>02.查询每个雇员的职位，职位。</p><p>03.查询每个雇员的职位，使用 T DISTINCT 消除掉显示的重复 行记录。</p><p>04.计算出每个雇员的基本年薪，同时查询出雇员的编号、姓名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">05.每个雇员每个月公司会补贴饭食 200 元，交通补助 300 元，计算年薪（年薪=(工资+奖金)*12）。</span><br></pre></td></tr></table></figure><p>06.查询基本工资高于 2000 的全部雇员信息。</p><p>07.查询出 smith 的信息。</p><p>08.查询出所有不是 CLERK 的详细信息。</p><p>09.查询出所有销售人员(SALESMAN)的基本信息，并且要求销售人员的工资高于 1300。</p><p>10.查询出工资范围在 1500~3000 之间的全部雇员信息（包含 1500 和 3000）。</p><p>11.查询出所有经理或者是销售人员的信息，并且要求这些人的基本工资高于 1500。</p><p>12.要求查询出所有在 1981 年雇佣的雇员信息。</p><p>13.查询所有领取奖金的雇员信息（comm 不为空）。</p><p>14.查询所有领取奖金高于 100 的雇员信息。</p><p>15.查询出雇员编号是 7369、7566、9999 的雇员信息。</p><p>16.查询出所有雇员姓名是以 A 开头的全部雇员信息。</p><p>17.查询出雇员姓名第二个字母是 M 的全部雇员信息。</p><p>18.查询出雇员姓名任意位置上包含字母 A 的全部雇员信息。</p><p>19.查询出所有雇员的信息，要求按照工资排序。</p><p>20.要求查询所有雇员的信息，按照雇佣日期由先后排序。</p><p>21.查询全部雇员信息，按照工资由高到低排序，如果工资相同，则按照雇佣日期由先后排序。</p><p>22.查询部门 30 中的所有员工。</p><p>23.查询出所有办事员（CLERK）的姓名，编号和部门编号。</p><p>24.查询出奖金高于薪金的员工。</p><p>25.查询出奖金高于薪金的 60%的员工。</p><p>26.查询出部门 10 中所有经理（MANAGER）和部门 20 中所有办事员（CLERK）的详细资料。</p><p>27.查询出部门 10 中所有经理，部门 20 中所有办事员，既不是经理又不是办事员但其薪金大于或等于 2000<br>的所有员工的信息。</p><p>28.查询出收取奖金的员工的不同工作。</p><p>29.查询出不收取奖金或收取的奖金低于 100 的员工。</p><p>30.查询出不带有“R”的员工的姓名。</p><p>31.查询出每个雇员的姓名、职位、领导姓名。</p><p>32.查询出所有员工的编号、姓名及其直接上级的编号、姓名，显示的结果按领导年工资的降序排列。</p><p>33.查询出在销售部（SALES）工作的员工姓名、基本工资、雇佣日期、部门名称。（不知道销售部编号）。</p><p>34.查询出所有员工的姓名、部门名称和工资。</p><p>35.查询出所有员工的年工资，所在部门名称，按年薪从低到高排序。</p><p>36.查询出某个员工的上级主管及所在部门名称，并要求出这些主管中的薪水超过 3000。</p><p>37.查询出公司的最高和最低工资。</p><p>38.查询出每个部门的人数、平均工资，只显示部门编号。</p><p>39.查询出每种职位的最高和最低工资。</p><p>40.查询平均工资高于 2000 的职位信息，以及从事此职位的雇员人数、平均工资。</p><p>41 查询出至少有一个员工的所有部门编号、名称，并统计出这些部门的平均工资、最低工资、最高工资。</p><p>42.查询出部门名称和这些部门的员工信息（数量、平均工资），同时列出那些没有员工的部门。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Android开发教程</title>
    <link href="https://huangguangda.github.io/2018/05/04/1/"/>
    <id>https://huangguangda.github.io/2018/05/04/1/</id>
    <published>2018-05-04T15:50:24.000Z</published>
    <updated>2018-06-14T11:59:23.629Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/41.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>老罗Android开发视频教程</p><h2 id="Android系统介绍"><a href="#Android系统介绍" class="headerlink" title="Android系统介绍"></a>Android系统介绍</h2><p>Android是基于Linux内核的操作系统，是Google公司在2007年11月5日公布的手机操作系统。早期由原名为“Android”的公司开发，谷歌在2005年收购”Android.Inc“后，继续进行对Android系统开发运营，它采用了软件堆层的架构，主要分为三部分，底层Linux内核只提供基本功能，其他的应用软件则由各公司自行开发，部分程序以Java编写。</p><p>2011年初数据显示，仅正式上市两年的操作系统Android已经跃居全球最受欢迎的智能手机平台。现在，Android系统不但应用于智能手机，也在平板电脑市场急速扩张。</p><h2 id="Android平台五大优势特色"><a href="#Android平台五大优势特色" class="headerlink" title="Android平台五大优势特色"></a>Android平台五大优势特色</h2><p>开放性</p><p>Android平台首先就是其开放性，开发的平台允许任何移动终端厂商加入到Android联盟中来。</p><p>挣脱运营商的束缚</p><p>在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。自从Android上市，用户可以更加方便地链接网络，运营商的制约减少。随着2G至3G移动网络的逐步过渡和提升，手机随意接入网络。</p><p>丰富的硬件选择</p><p>这一点还是与Android平台的开发性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步，甚至软件的兼容。</p><p>不受任何限制的开发商</p><p>Android平台提供给第三方开发商一个十分宽泛，自由的环境。因此不会受到各种条条框框的阻挠。</p><p>无缝结合Google应用</p><p>Google服务如地图，邮件，搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。</p><h2 id="Android学习路线图介绍"><a href="#Android学习路线图介绍" class="headerlink" title="Android学习路线图介绍"></a>Android学习路线图介绍</h2><p>Java语言编程基础 面向对象基础 Java常用设计模式 Java数据结构和算法</p><p>关系型数据库 JDBC数据库编程 HTML和Javascript编程 Java动态网页编程</p><h3 id="Java以及Web应用开发项目"><a href="#Java以及Web应用开发项目" class="headerlink" title="Java以及Web应用开发项目"></a>Java以及Web应用开发项目</h3><p>UI界面设计 Android数据库编程 Android服务的应用 Android内容提供者</p><p>Android网络编程 Android多媒体编程 Android异步任务加载 Android传感器编程</p><p>Android谷歌地图开发 Android蓝牙开发 Android Wifi编程 Android与Webservice</p><p>Android与HTML开发 JQueryMobile编程 PhoneGap应用开发 Widget套件使用</p><p>Android与工作流引擎结合 Android报表制作 Android高速描绘 Android企业框架介绍</p><h3 id="Android应用项目实战开发"><a href="#Android应用项目实战开发" class="headerlink" title="Android应用项目实战开发"></a>Android应用项目实战开发</h3><p>2D图形编程 图片处理 碰撞检测 物理引擎介绍</p><p>Cocoa 2D引擎介绍 OpenGLES 游戏资源调度 游戏实战项目</p><h3 id="Android游戏应用开发"><a href="#Android游戏应用开发" class="headerlink" title="Android游戏应用开发"></a>Android游戏应用开发</h3><h2 id="第二集：android系统框架的介绍"><a href="#第二集：android系统框架的介绍" class="headerlink" title="第二集：android系统框架的介绍"></a>第二集：android系统框架的介绍</h2><p>src目录：主要是完成java代码的编写<br>assets目录：资源目录<br>res目录：存在图片，布局文件和字符串，菜单等文件<br>bin目录：输出文件夹，如生成的APK文件<br>project.properties工程属性文件配置<br>gen目录：系统自动生成的源代码目录<br>这个R.java文件时系统自动生成的文件，非常的重要。这个R.java默认有attr,drawable,layout,string 4个静态内部类，每个类对应一种资源。例如我们在工程中添加一副图片，那么工程就会在此类的drawable内部类中添加一条数据，如果删除了此图片，工程则会自动删除此条数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/41.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Android工程师初级知识点</title>
    <link href="https://huangguangda.github.io/2018/05/03/1/"/>
    <id>https://huangguangda.github.io/2018/05/03/1/</id>
    <published>2018-05-03T04:33:40.000Z</published>
    <updated>2018-05-29T06:29:28.380Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/40.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><h2 id="提示框，菜单，数据存储，组件篇"><a href="#提示框，菜单，数据存储，组件篇" class="headerlink" title="提示框，菜单，数据存储，组件篇"></a>提示框，菜单，数据存储，组件篇</h2><h2 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h2><blockquote><p>Toast.makeText(context, text, 时间).show();</p></blockquote><p>setDuration();//设置时间<br>setGravity();//位置</p><p>获取：</p><p>添加toast.getView();<br>imageView添加到toast中，addView();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater inflater = LayoutInflater.from(this);</span><br><span class="line">View toast_view=inflater.inflate(R.id.,null);</span><br><span class="line">Toast.</span><br><span class="line">Toast.setView(toast_view);</span><br></pre></td></tr></table></figure><h2 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h2><p>AlertDialog.Builder </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTitle();</span><br><span class="line">setIcon();</span><br><span class="line">setView();</span><br><span class="line">setItems();</span><br><span class="line"></span><br><span class="line">setMultiChoiceItems(); 复选</span><br><span class="line">setSingleChoiceItems(); 单选</span><br><span class="line">setNeutralButton();</span><br><span class="line"></span><br><span class="line">setPositiveButton();</span><br><span class="line">setNegativeButton();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog dialog = builder.create(); .show();</span><br><span class="line"></span><br><span class="line">消失</span><br><span class="line">dialog.dismiss();</span><br></pre></td></tr></table></figure><p>Notification通知栏，如接收短信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">属性</span><br><span class="line">Notification </span><br><span class="line">setTicker();//手机状态栏的提示</span><br><span class="line">setWhen();//设置时间</span><br><span class="line">setContentTitle();</span><br><span class="line">setContentText();</span><br><span class="line">setContentIntent();</span><br><span class="line"></span><br><span class="line">Notification notification = builder.build();</span><br></pre></td></tr></table></figure><h2 id="OptionsMenu"><a href="#OptionsMenu" class="headerlink" title="OptionsMenu"></a>OptionsMenu</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onCreateOptionsMenu();</span><br><span class="line">动态：menu.add();</span><br><span class="line">监听：onOptionsItemSelected();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean onCreateOptionsMenu(Menu menu)&#123;</span><br><span class="line">getMenuInflater().inflate(R.menu.main,menu);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听：onOptionsItemSelected<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean onOptionsItemSelected(MenuItem item)&#123;</span><br><span class="line">switch(item.getItemId())&#123;</span><br><span class="line">case R.id..:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ContextMenu上下文菜单"><a href="#ContextMenu上下文菜单" class="headerlink" title="ContextMenu上下文菜单"></a>ContextMenu上下文菜单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean onCreateItemSelected(MenuItem item)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)&#123;</span><br><span class="line">super.onCreateContextMenu(menu, v, menuIfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SubMenu-子菜单"><a href="#SubMenu-子菜单" class="headerlink" title="SubMenu 子菜单"></a>SubMenu 子菜单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean onCreateOptionsMenu(Menu menu)&#123;</span><br><span class="line">getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">return true;</span><br><span class="line">//return super.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu ...&gt;</span><br><span class="line"> &lt;item</span><br><span class="line">  android:showAsAction=&quot;never&quot;</span><br><span class="line">  android:title=&quot;文件&quot;&gt;</span><br><span class="line">  &lt;menu&gt;</span><br><span class="line">   &lt;item</span><br><span class="line">    android:id=&quot;@+id/..&quot;</span><br><span class="line">    android:showAsAction=&quot;never&quot;</span><br><span class="line">    android:title=&quot;打开&quot;/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MenuInflater inflater = getMenuInflater();</span><br><span class="line">inflater.inflate(R.menu.main, menu);</span><br></pre></td></tr></table></figure><h2 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h2><p>四种：</p><ol><li>SharedPreferences</li><li>SQLite</li><li>Content Provider</li><li>File </li></ol><p>SharedPreferences是一种比较轻型的数据存储，基于xml的键值对存储，存储一些简单的信息。</p><p>SharedPreferences只能获取数据不能存储和修改，但能通过Editor实现存储修改。</p><p>步骤：</p><ol><li>获取SharedPreferences对象</li><li>SharedPreferences.Editor </li><li>Editor的putXXX的方法</li><li>Editor.commit() </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(MainActivity.this);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPreferences = getSharedPreferences(&quot;sharedPreferences&quot;, MODE_PRIVATE);</span><br><span class="line">Editor editor = sharedPreferences.edit();</span><br><span class="line">editor.putXXX();</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><p>用户名和密码的存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharedPreferences = getSharedPreferences(&quot;UserInfo&quot;, MODE_PRIVATE);</span><br><span class="line">Editor editor = sharedPreferences.editor();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">登录</span><br><span class="line">String name = etName.getText().toString().trim();</span><br><span class="line">String pass = etPass.getText().toString().trim();</span><br></pre></td></tr></table></figure><p>SQLite的形式，以单个文件的存储，存储2T内存，以B-Tree形式。</p><p>SQLite的数据类型，null,integer,real,text,blob。</p><ol><li>SQLiteDatabase</li><li>SQLiteOpenHelper</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = openOrCreateDatabase(&quot;table.db&quot;, MODE_PRIVATE, null);</span><br></pre></td></tr></table></figure><p>SQLiteOpenHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DBOpenHelper helper = new DBOpenHelper(MainActivity.this, &quot;user.db&quot;);</span><br><span class="line">SQLiteDatabase db = helper.getWritableDatabase();</span><br><span class="line">Cursor c = db.rawQuery(&quot;select * from user&quot;, null);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public DBOpenHelper(Context context, String name, CursorFactory factory, int version)&#123;</span><br><span class="line">super(context, name, factory, version);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onCreate(SQLiteDatabase db)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = this.getFilesDir();</span><br><span class="line">File file = this.getCacheDir();//重要文件就不要放在这里</span><br></pre></td></tr></table></figure><p>MODE_PRIVATE</p><p>默认操作</p><p>MODE_APPEND</p><p>文件是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void WriteFiles(String content)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">FileOutputStream fileOutputStream = openFileOutput(&quot;super.txt&quot;, MODE_PRIVATE);</span><br><span class="line">fileOutputStream.write(content.getBytes());</span><br><span class="line">fileOutputStream.close();</span><br><span class="line">&#125;catch()&#123;</span><br><span class="line"></span><br><span class="line">&#125;catch()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContentProvider</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line"> android:name=&quot;&quot;</span><br><span class="line"> android:authorities=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyContentProvider extends ContentProvider&#123;</span><br><span class="line">public int delete(Uri uri,String selection, String[] selectionArgs)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Uri 通用资源标志符</p><p>Broadcast广播</p><p>BroadcastReceiver 广播接收器</p><p>使用：需要Intent对象，sendBroadcast(),sendOrderBroadcast(),sendStickyBroadcast()。</p><p>Service</p><p>注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void onClick(View v)&#123;</span><br><span class="line">switch(v.getId())&#123;</span><br><span class="line">case R.id.:</span><br><span class="line">Intent intent = new Intent(MainActivity.this, MyService.class);</span><br><span class="line">startService(intent);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Service&#123;</span><br><span class="line">public void onCreate()&#123;</span><br><span class="line">super.onCreate();</span><br><span class="line">&#125;</span><br><span class="line">public int onStartCommand(Intent intent,int flags,int startId)&#123;</span><br><span class="line">return super.onStartCommand(intent,flags,startId);</span><br><span class="line">&#125;</span><br><span class="line">public void onDestroy()&#123;</span><br><span class="line">super.onDestroy();</span><br><span class="line">&#125;</span><br><span class="line">public IBinder onBind(Intent intent)&#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void onCreate()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public IBinder onBind(Intent intent)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void unbindService(ServiceConnection conn)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServiceConnection conn = new ServiceConnection()&#123;</span><br><span class="line">public void onServiceDisconnected(ComponentName name)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void onServiceConnected(ComponentName name, IBinder binder)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统服务</p><p>MountService,ClipboardService,getSystemService().</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getSystemService(String name)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POWER_SERVICE,PowerManger电源服务<br>ALARM_SERVICE,AlarmManager闹钟服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater inflater = MainActivity.this.getSystemService(LAYOUT_INFLATER_SERVICE);</span><br><span class="line">View view = inflater.inflate(R.layout. , null);</span><br><span class="line">setContentView(view);</span><br></pre></td></tr></table></figure><p>getSystemService</p><p>GestureDetector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MotionEvent,GestureDetector,onGestureListener.</span><br></pre></td></tr></table></figure><p>GestureOverlayView</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Android:eventsInterceptionEnabled</span><br><span class="line">Android:fadeDuration</span><br><span class="line">Android:fadeEnabled</span><br><span class="line">Android:gestureColor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.gesture.GestureOverlayView </span><br><span class="line"> android:id=&quot;&quot;</span><br><span class="line"> android:layout_width=&quot;&quot;</span><br><span class="line"> android:layout_height=&quot;&quot;&gt;</span><br><span class="line"> &lt;ImageView</span><br><span class="line">  android:id=&quot;&quot;</span><br><span class="line">  android:layout_width=&quot;&quot;</span><br><span class="line">  android:layout_height=&quot;&quot;</span><br><span class="line">&lt;/android.gesture.GestureOverlayView&gt;</span><br></pre></td></tr></table></figure><p>完结！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/40.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android开发工程师文集" scheme="https://huangguangda.github.io/categories/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E9%9B%86/"/>
    
    
      <category term="Android开发工程师文集" scheme="https://huangguangda.github.io/tags/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E9%9B%86/"/>
    
  </entry>
  
</feed>
