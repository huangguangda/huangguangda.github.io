<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>达叔小生</title>
  
  <subtitle>分享 Android&amp;Java 知识点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huangguangda.github.io/"/>
  <updated>2018-10-19T01:43:27.027Z</updated>
  <id>https://huangguangda.github.io/</id>
  
  <author>
    <name>达叔小生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>腾讯智慧校园开发平台</title>
    <link href="https://huangguangda.github.io/2018/10/19/1/"/>
    <id>https://huangguangda.github.io/2018/10/19/1/</id>
    <published>2018-10-19T01:42:25.000Z</published>
    <updated>2018-10-19T01:43:27.027Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯智慧校园开发平台</p><a id="more"></a><h2 id="腾讯智慧校园开发平台"><a href="#腾讯智慧校园开发平台" class="headerlink" title="腾讯智慧校园开发平台"></a>腾讯智慧校园开发平台</h2><p><strong>优势:</strong></p><ol><li>智慧校园联合登录</li><li>身份角色同一</li><li>消息推送</li></ol><p><strong>智慧校园接入流程:</strong></p><ol><li>创建应用: 填写网站名称,简介和图标,官网地址等信息</li><li>开发应用:</li><li>提交审核:</li><li>审核通过上线:</li></ol><h2 id="第三方应用使用指引"><a href="#第三方应用使用指引" class="headerlink" title="第三方应用使用指引"></a>第三方应用使用指引</h2><p><strong>第三方应用？</strong></p><ol><li>在“应用管理”-&gt; “本校应用”中看到。</li><li>在“应用管理”-&gt; “第三方应用”-&gt;“应用市场”中找到</li></ol><p><strong>安装后如何使用第三方应用？</strong></p><p>使用其PC管理功能，及移动端功能。</p><ol><li>使用PC管理功能<br>点击图标 -&gt; 进入应用PC管理页面</li><li>使用移动端功能<br>(1) 独立应用<br>可直接进入使用<br>(2) 普通应用<br>配置方法：登录学校后台 -&gt; 左侧菜单“应用管理” -&gt; 在“本校应用”或“第三方应用”下找到应用图标 -&gt; 点击图标右上角小齿轮 -&gt; 进入“应用基本信息”页 -&gt; 找到“移动端配置”</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><strong>OpenAPI调用相关问题</strong></p><blockquote><p>请完整的阅读每篇文档，特别注意必传字段及字段格式和说明</p></blockquote><ol><li>使用开放平台后台”API测试工具”</li><li>对照文档中的代码Demo</li></ol><p><strong>反馈时提供信息</strong></p><ol><li>完整的请求url，包括get参数。</li><li>post的数据。</li><li>返回的code与msg。</li><li>sign签名所用的密钥key。</li><li>提供bug的发生时间，至少要以小时为单位（年-月-日-小时），当然越具体越容易查明问题。</li></ol><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul><li>应用接入指引【重要】</li><li>开放API说明【重要】</li></ul><p><strong>使用哪种方式调用API？</strong> ?–&gt;</p><p>1) 使用开发者方式<br>2) 使用应用（openAppID）方式</p><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p>1) 使用开发者方式<br>1.1) 学校或上级单位自己开发：<br>1.2) 以开发者身份，替学校/上级单位开发：<br>调用方式为devCode+devType+keyId，<br>其中keyId和密钥key需要找学校/上级单位创建者索要</p><h2 id="【开发流程】"><a href="#【开发流程】" class="headerlink" title="【开发流程】"></a>【开发流程】</h2><p>获取devCode、devType、密钥key，用于生成后续的sign签名</p><p>开发者类型:学校/上级单位/合作伙伴/开发者，通过创建应用开发</p><p>调用API时，开发者信息、sign签名密钥获取方式：<br>调用方式:</p><p>openAppID<br>开放平台后台==》应用管理==》查看详情==》AppID、AppSecret</p><h2 id="签名生成的步骤"><a href="#签名生成的步骤" class="headerlink" title="签名生成的步骤"></a>签名生成的步骤</h2><p>第一步：</p><p>设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA。<br>特别注意以下重要规则：</p><p>参数名按ASCII码从小到大排序（字典序）；<br>如果参数的值为空不参与传参和签名；<br>参数名区分大小写；<br>get 和 post 参数均参与签名（注意：签名时不要对 get 和 post 的参数进行urlencode）；<br>sign 参数不参与签名；<br>根据HTTP协议要求，传递参数的值中如果存在特殊字符（如：&amp;、@等），那么该值需要做URL Encoding，这样请求接收方才能接收到正确的参数值。这种情况下，待签名数据应该是原始值而不是encoding之后的值。例如：调用某接口需要对请求参数email进行数字签名，那么待签名数据应该是<a href="mailto:email=test@msn.com" target="_blank" rel="noopener">email=test@msn.com</a>，而不是email=test%40msn.com。</p><p>第二步</p><p>在stringA最后拼接上“&amp;key=AppSecret”得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值。</p><p>第三步：</p><p>拼接sign签名，得到最终请求字符串。</p><h2 id="签名算法示例"><a href="#签名算法示例" class="headerlink" title="签名算法示例"></a>签名算法示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;openAppID&quot;:&quot;597882146416&quot;,</span><br><span class="line">    &quot;objectid&quot;:1,</span><br><span class="line">    &quot;objType&quot;:2,</span><br><span class="line">    &quot;userid&quot;:1661,</span><br><span class="line">    &quot;timestamp&quot;:1442401156,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;id&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;张三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对参数按照key=value的格式，并按照参数名ASCII字典序排序如下：</span><br><span class="line">$stringA=&quot;data[id]=1&amp;data[name]=张三&amp;objType=2&amp;objectid=1&amp;openAppID=597882146416&amp;timestamp=1442401156&amp;userid=YmvhAU762R0done&quot;;</span><br></pre></td></tr></table></figure></p><p>第二步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拼接API密钥，md5加密并转成大写，生成sign：</span><br><span class="line">$stringSignTemp=&quot;stringA&amp;key=testtoken123456&quot;</span><br><span class="line">$sign = strtoupper(md5($stringSignTemp));</span><br><span class="line">即$sign为：&quot;5F9F67A5635592A132BA935D44B25D40&quot;</span><br></pre></td></tr></table></figure></p><p>第三步：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对请求的数据拼接sign签名：</span><br><span class="line">$param = $stringA . &apos;&amp;sign=5F9F67A5635592A132BA935D44B25D40;</span><br></pre></td></tr></table></figure></p><p>最终请求如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://open.campus.qq.com/api/OpenApi/getUserInfo?timestamp=1442401156&amp;data[id]=1&amp;data[name]=张三&amp;objType=2&amp;objectid=1&amp;openAppID=597882146416&amp;userid=1661&amp;</span><br><span class="line">sign=5F9F67A5635592A132BA935D44B25D40</span><br></pre></td></tr></table></figure></p><p>最终请求如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://open.campus.qq.com/api/OpenApi/getUserInfo?timestamp=1442401156&amp;data[id]=1&amp;data[name]=张三&amp;objType=2&amp;objectid=1&amp;openAppID=597882146416&amp;userid=1661&amp;</span><br><span class="line">sign=5F9F67A5635592A132BA935D44B25D40</span><br></pre></td></tr></table></figure></p><blockquote><p>【注意】</p></blockquote><p>密钥key仅作加密使用，为了保证数据安全请不要在请求参数中传递，并对密钥key进行保密。</p><h2 id="校验签名正确性"><a href="#校验签名正确性" class="headerlink" title="校验签名正确性"></a>校验签名正确性</h2><p>签名校验工具：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=20_1</span><br></pre></td></tr></table></figure></p><p>校验方式：选择“deeplink”或“自定义参数”<br>PS.校验不通过那个提示不用管，只要对比自己代码生成的sign签名，与工具所生成的sign签名是否一致即可</p><h3 id="【开发流程】-1"><a href="#【开发流程】-1" class="headerlink" title="【开发流程】"></a>【开发流程】</h3><p>获取devCode、devType、密钥key，用于生成后续的sign签名，详见签名参数sign生成说明</p><p>==》获取objectid、objType、userid<br>测试id详见开放平台后台-&gt;测试工具-&gt;沙盒测试环境-&gt;沙盒学校objectid</p><p>正式id详见签名参数sign生成说明、应用管理后台接入、应用H5前台接入</p><p>==》查看公共参数文档，详见API公共参数说明</p><p>==》查看API接口文档</p><p>==》根据接口参数，生成和拼接sign签名，详见签名参数sign生成说明</p><p>==》调用接口</p><p>==》调试接口<br>若接口报错，请参照以下顺序排查：<br>仔细阅读接口文档，特别是必传参数及参数格式<br>使用开放平台后台“API测试工具”，进行排查<br>对照文档中的Demo代码<br>若报签名错误，对照签名参数sign生成说明文档和文档中的“签名校验工具”</p><p>2) 使用应用（需创建应用，openAppID）</p><p>【开发流程】</p><p>登录到开放平台后台（open.campus.qq.com）</p><p>==》创建应用</p><p>==》查看应用详情，获取AppID、AppSecret、H5Secret，用于生成后续的sign签名</p><p>==》获取objectid、objType、userid<br>应用上线前，只能使用测试id，获取方式为：开放平台后台-&gt;测试工具-&gt;沙盒测试环境-&gt;沙盒学校objectid</p><p>应用上线后，正式id的获取方式，详见签名参数sign生成说明、应用管理后台接入、应用H5前台接入</p><p>==》查看公共参数文档，详见API公共参数说明</p><p>==》查看API接口文档</p><p>==》根据接口参数，生成和拼接sign签名，详见签名参数sign生成说明</p><p>==》调用接口</p><p>==》调试接口</p><p>==》沙盒测试环境，测试应用</p><p>==》测试应用无误后，申请上线</p><p>==》一般情况下，腾讯智慧校园会在3个工作日内，审核应用</p><p>==》应用审核通过后，学校/上级单位在PC后台-&gt;应用管理-&gt;第三方应用中，安装应用</p><p>==》学校/上级单位，在PC或移动端使用应用时，会将objectid、objType、userid等参数，以url参数追加的形式传递到第三方应用的url中</p><h2 id="【公共参数及签名密钥相关】"><a href="#【公共参数及签名密钥相关】" class="headerlink" title="【公共参数及签名密钥相关】"></a>【公共参数及签名密钥相关】</h2><ol><li>都有哪些公共参数？</li></ol><p>详见文档：开放API调用说明==》API公共参数说明</p><ol start="2"><li>什么是objectid、objType、userid，如何获取它们？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="3"><li>什么是openAppID、AppSecret、H5Secret，如何获取它们？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="4"><li>什么是devCode、devType、授权密钥、授权密钥ID，如何获取它们？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="5"><li>如何生成和校验sign签名？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明，以及文档中的“签名校验工具”</p><h2 id="【OpenAPI调用方式相关】"><a href="#【OpenAPI调用方式相关】" class="headerlink" title="【OpenAPI调用方式相关】"></a>【OpenAPI调用方式相关】</h2><ol><li>API调用说明？</li></ol><p>详见文档：开放API调用说明==》API调用说明</p><ol start="2"><li>post请求参数demo？</li></ol><p>详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="3"><li>OpenAPI调用代码demo？</li></ol><p>详见文档：开放API调用说明==》Demo下载</p><h2 id="【OpenAPI调用出错相关】"><a href="#【OpenAPI调用出错相关】" class="headerlink" title="【OpenAPI调用出错相关】"></a>【OpenAPI调用出错相关】</h2><ol><li>业务错误码及说明</li></ol><p>详见文档：开放API调用说明==》业务错误码</p><ol start="2"><li>接口返回“1018 密钥不存在“或”1010 AppID或密钥不正确”</li></ol><p>请核对devCode、devType、密钥是否匹配，获取方式详见文档：开放API调用说明==》签名参数sign生成说明</p><ol start="3"><li>接口返回“1011 参数错误，请检查必传参数及类型”</li></ol><p>请核对是否传了公共参数，并确认post格式是正确的，注意post数据为数组格式</p><p>详见文档：</p><p>开放API调用说明==》API调用说明</p><p>开放API调用说明==》签名参数sign生成说明</p><p>开放API调用说明==》API公共参数说明</p><p>开放API调用说明==》Demo下载</p><ol start="4"><li>接口返回“1002 签名错误”</li></ol><p>详见文档：</p><p>开放API调用说明==》签名参数sign生成说明，以及文档中的“签名校验工具”</p><p>请仔细对照工具中的每个步骤，看看是哪一步不一致。</p><ol start="5"><li>调用发消息接口时，接口返回“1013 该学校/上级单位尚未安装此AppID应用”</li></ol><p>只有学校/上级单位创建者，在PC后台==》应用管理==》第三方应用中，安装了开发者提供的第三方应用，才能调用发消息接口，进行发消息。</p><h2 id="应用接入流程"><a href="#应用接入流程" class="headerlink" title="应用接入流程"></a>应用接入流程</h2><ol><li>简要介绍</li></ol><p>腾讯智慧校园通过开放平台来满足学校/上级单位的定制化开发需求。 学校/上级单位/合作伙伴可在开放平台创建应用、开发调试、提交审核。应用上线后，学校/上级单位可安装使用。</p><p>第三方开发者也可通过智慧校园开放平台创建并提交第三方应用，供所有学校/上级单位使用。</p><ol start="2"><li>应用类型</li></ol><p>腾讯智慧校园开放平台期待各种富于创新、安全稳定，符合校园5大使用场景的应用，包括：</p><p>（1）校内管理类应用</p><p>（2）学生学习类应用</p><p>（3）家校互动类应用</p><p>（4）移动办公类应用</p><p>（5）校园生活类应用</p><ol start="3"><li>如何创建应用</li></ol><p>（1）学校/上级单位：已加入腾讯智慧校园的学校/上级单位，将自动为其开通开放平台权限。学校超级管理员可直接登录到开放平台，创建并申请应用上线</p><p>（2）合作伙伴：签约的合作伙伴，将自动为其开通开放平台权限。合作伙伴管理员可直接登录到开放平台，创建并申请应用上线</p><p>（3）第三方公司/组织单位：需要先申请开发者资质，资质审核通过后，可登录开放平台，创建并申请应用上线。</p><ol start="4"><li>如何开发调试</li></ol><p>（1）应用程序开发</p><p>开发者可以在本地机器上进行应用程序的开发，实现业务逻辑。同时腾讯智慧校园开放平台开放了许多API，建议开发者先阅读API文档，了解不同场景下有哪些API可以调用。</p><p>（2）测试和联调</p><p>腾讯智慧校园开放平台提供的测试工具包含：沙盒学校测试环境、OpenAPI联调工具。详细信息请登录开放平台后查看“测试工具”。</p><ol start="5"><li>如何部署应用</li></ol><p>需要将应用部署在开发者自己的服务器上，因此需要自己准备服务器、域名等，并进行应用部署和测试。腾讯智慧校园暂不为该过程提供技术支持。</p><ol start="6"><li>上线规范</li></ol><p>为确保接入腾讯智慧校园开放平台应用的质量、提高后续运营服务的稳定性，上线前，请开发者按照接入规范对应用进行仔细检查及测试，对于不符合规范项进行修改。详见应用接入规范</p><ol start="7"><li>应用审核</li></ol><p>应用提交后，腾讯智慧校园将在5个工作日内对应用进行审核。审核中无法修改应用信息。审核通过后，应用将自动上线。</p><ol start="8"><li>应用管理</li></ol><p>开发者登录到腾讯智慧校园开放平台后，可以进入到管理中心统一管理应用，管理中心功能主要：</p><p>（1）服务所有开发者；</p><p>（2）服务于应用全生命周期；</p><p>（3）提供依据用户权限的功能；</p><p>（4）具备足够的帮助指引，可以由开发者自助使用。</p><p>详见管理中心使用说明</p><ol start="9"><li>应用安装及使用</li></ol><p>应用上线后，学校/上级单位可按如下步骤安装应用：</p><p>登录学校管理后台 -&gt; 点击“应用管理”右侧的设置按钮 -&gt; 选择“全部应用” -&gt; 点击要安装的应用icon -&gt; 进入安装页面，安装指引进行安装</p><p>安装成功后，使用方式如下：</p><p>若为独立应用：安装成功后应用将自动出现在菜单栏。可在学校管理后台访问其PC管理后台页面，可在微信企业号内使用其移动端功能。<br>若为普通应用：安装成功后需手动配置其移动端地址。可在“应用管理-&gt;我的应用”中访问其PC管理后台页面，可在配置的应用菜单处使用其移动端功能。</p><h2 id="开发api说明"><a href="#开发api说明" class="headerlink" title="开发api说明"></a>开发api说明</h2><ol><li>PC管理后台、H5前台登录态打通</li></ol><p>学校在管理后台【应用市场】安装了开发者的应用后，可以在学校后台【我的应用】==》【应用管理】中，对应用进行管理。</p><p>同时，学校可以将开发者所提供的H5 url粘贴到企业号应用菜单，或应用的H5页面中。</p><p>关于“PC管理后台应用管理登录态打通方案”，请参见“应用管理后台接入”小节。</p><p>关于“H5页面登录态打通方案”，请参见“应用H5前台接入”小节。</p><ol start="2"><li>通过“API列表”中的接口，获取学校/上级单位信息</li></ol><p>在获取登录态的同时，可以获取到学校ID/上级单位ID、用户ID等信息。</p><p>当开发者获取到学校ID、用户ID后，可以调用“API接口列表”中的接口，进一步获取学校/上级单位信息。</p><p>哪些学校和用户可以使用该应用，由【应用详情】中的“使用范围”和“适用人群”决定。开发者只能获取这部分人的信息。</p><h2 id="API调用说明"><a href="#API调用说明" class="headerlink" title="API调用说明"></a>API调用说明</h2><p>1.开发者调用腾讯智慧校园API时，需使用Https协议、UTF8编码，访问域名为<a href="https://open.campus.qq.com" target="_blank" rel="noopener">https://open.campus.qq.com</a> 数据包不需要加密。<br>注：原有域名<a href="https://m.campus.qq.com" target="_blank" rel="noopener">https://m.campus.qq.com</a> 仍可正常使用，但不会再进行功能的升级和维护，并将于2018年底下线。</p><p>2.请求接口的数据为数组格式。</p><p>3.接口返回的数据为json格式。其中GET接口可以通过传入callback参数，兼容jsonp格式。</p><p>4.接口安全校验采用sign签名的方式，sign由密钥key生成（key为第三方应用AppSecret），sign参数的生成算法详见“签名参数sign生成说明”小节。</p><p>5.合作伙伴、第三方开发者通过在开放平台建立第三方应用的方式，使用openAppID（第三方应用ID）+AppSecret（第三方应用密钥）进行开发。</p><p>openAppID、AppSecret的获取方式：开放平台后台：应用管理==》应用详情，openAppID对应AppID</p><p>注意：应用AppSecret仅作加密生成sign签名使用，为了保证数据安全请不要在请求参数中传递，并对应用AppSecret进行严格保密。因自行泄漏密钥导致的数据安全问题，需要自行承担。</p><p>6.在每次调用智慧校园接口时都需要带上openAppID、objectid、objType、timestamp、sign参数。各参数具体含义及获取方式，详见“API公共参数说明”小节</p><p>7.在开发者调用API接口时，腾讯智慧校园会对签名和时间戳进行验证： 腾讯智慧校园会使用同样的sign签名算法判断接收到的sign与计算的签名是否一致，来验证请求来源的合法性；另外，接收到请求时会判断当前时间戳与接收到的timestamp参数是否在一个合理的范围，相差5分钟内才合法，以防止重放攻击。</p><h2 id="API公共参数说明"><a href="#API公共参数说明" class="headerlink" title="API公共参数说明"></a>API公共参数说明</h2><p>“API接口列表”中有一些请求参数是通用的，在此做以下统一说明：</p><p>数据id，如objectid、userid、departid等，最大长度为50位</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;腾讯智慧校园开发平台&lt;/p&gt;
    
    </summary>
    
      <category term="腾讯智慧校园开发平台" scheme="https://huangguangda.github.io/categories/%E8%85%BE%E8%AE%AF%E6%99%BA%E6%85%A7%E6%A0%A1%E5%9B%AD%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
    
      <category term="腾讯智慧校园开发平台" scheme="https://huangguangda.github.io/tags/%E8%85%BE%E8%AE%AF%E6%99%BA%E6%85%A7%E6%A0%A1%E5%9B%AD%E5%BC%80%E5%8F%91%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发</title>
    <link href="https://huangguangda.github.io/2018/10/18/1/"/>
    <id>https://huangguangda.github.io/2018/10/18/1/</id>
    <published>2018-10-18T01:45:49.000Z</published>
    <updated>2018-10-18T01:47:06.467Z</updated>
    
    <content type="html"><![CDATA[<p>微信公众号开发</p><a id="more"></a><h1 id="微信公众号开发"><a href="#微信公众号开发" class="headerlink" title="微信公众号开发"></a>微信公众号开发</h1><hr><p>request用于网络请求,它是对原生的http request的封装.</p><p>微信的数据包装方式是xml,所以我们要借助ejs这个模板库,把数据作为变量替换到xml字符汇中</p><p>还有一些工具模板:</p><p>lodash是一些常用的方法集,做数组拆分,类型判断等等.Heredoc是一个黑科技,把函数体里面的多行的注解作为字符串提取出来主要用来降低拼接字符串的成本</p><p>raw-body用来获取一个http请求返回的可读流的内容实体.</p><p>sha1进行加密.</p><p>微信服务器返回的数据是xml格式,无法用js函数直接使用,所以要xml2js这个模块把xml数据解析为js对象,方便我们使用.</p><p>微信公众号开发:配置接入流程,加密认证环节,票据access_token.</p><p>利用nodejs开发一些网页或者爬虫工具,来对nodejs api和它的技术特点有一些基本的认知.</p><p>有一些其他的后端经验,php,java,ruby,主要弄明白一个网络http请求从开发到结束中间所经过的环节.</p><p>nodejs和javascript</p><p>进击node.js教程</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>针对微信常用接口进行一个一个单独讲解和实现,并且有许多小案例演示.</p><p>开发电影公众号的网站项目.</p><p>了解一:本地代理环节的搭建以及最入门的加密认证.</p><p>1.域名服务器环境的配置<br>2.利用qq浏览器代理调式端口</p><p>重点:加密认证逻辑</p><h2 id="微信公众号-企业号-订阅号-服务号"><a href="#微信公众号-企业号-订阅号-服务号" class="headerlink" title="微信公众号:企业号,订阅号,服务号"></a>微信公众号:企业号,订阅号,服务号</h2><p>订阅号:个人,小团队,只要是信息的传播,管理用户以及用户的互动. 如消息定制</p><p>服务,企业和组织,提供业务服务与用户管理能力.比如支付,智能接口.</p><p>企业号,管理全学校所有学院等,各个部门上班人员的考勤,活动进程等.</p><p>服务号,管理全学校的水果商店或者打印店,可以直接支持送货上门,以及推送一些特价水果.</p><p>订阅号,管理一个班级,一个学院的信息订阅,通知和互动.</p><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>认证和非认证</p><p>认证:一般需要你有个开户过的企业大家可以法人身份去折腾下开一个小公司.</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>订阅号:认证和非认证账号的区别就是,认证账号别可以直接在添加好友里搜索关键词就能找到你.</p><h2 id="订阅号和服务号三点不同"><a href="#订阅号和服务号三点不同" class="headerlink" title="订阅号和服务号三点不同"></a>订阅号和服务号三点不同</h2><p>出现位置不同.<br>单月发送消息的数量,订阅号一天一篇,服务号一个月最多4篇.<br>订阅号没有9大接口和支付功能.</p><h2 id="服务号9大接口"><a href="#服务号9大接口" class="headerlink" title="服务号9大接口"></a>服务号9大接口</h2><p>1.语音识别<br>2.客服接口<br>3.OAuth 2.0网页的授权:这个授权接口,可以请求用户授权,从而拿到更多用户的信息.</p><p>4.生成带参数二维码:<br>公众号可以获取一系列携带不同参数的二维码,在用户扫描关注公众号后.<br>公众号可以根据参数分析各二维码的效果.这些参数可以自己定制,从而可以实现更多分析结果,比如用户从哪里来的.</p><p>5.获取用户的地理位置:公众号能够获得用户进入公众号会话时的地理位置.可以做微信导航.</p><p>6.获取用户基本信息:公众号可以根据加密后的用户OpenID,通过一系列的参数交互,最终拿到用户基础信息,包括头像,名称,性别,地区.</p><p>7.获取关注者的列表:通过这个接口,可以拿到所有关注者的OpenID,就知道有多少人关注你,是谁在关注你.<br>8.用户分组接口:通过分组接口,可以在后台为用户移动,创建,修改分组,比如把你们班级你们团队分成,男生一组,女生一组<br>9.上传下载多媒体文件</p><h2 id="订阅号"><a href="#订阅号" class="headerlink" title="订阅号"></a>订阅号</h2><p>1.会话界面的自定义菜单<br>2.多客服接口<br>3.获取用户地址位置<br>4.高级群发接口<br>5.用户分组接口</p><h2 id="域名-服务器以及ngrok环境"><a href="#域名-服务器以及ngrok环境" class="headerlink" title="域名,服务器以及ngrok环境"></a>域名,服务器以及ngrok环境</h2><p>微信<->服务器<->域名<->应用服务器<->微信</-></-></-></-></p><p>./ngork</p><blockquote><p><a href="http://www.tunnel.mobl" target="_blank" rel="noopener">www.tunnel.mobl</a></p></blockquote><p>使用:<br>下载配置文件ngrok.cfg</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngrok -config ngrok.cfg - subdomain example 8080</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd</span><br><span class="line">cd text</span><br><span class="line">ls</span><br><span class="line">// 写一个简单的服务器</span><br><span class="line">python m SimpleHTTPServer 3100</span><br><span class="line">python -m SimpleHTTPServer 3100</span><br><span class="line">-config ngrok.cfg subdomain imooc-wechat 3100</span><br></pre></td></tr></table></figure><p>子域名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://imooc-wechat.tunnel.mobi</span><br></pre></td></tr></table></figure><p>使用nodejs的localtunnel服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g localtunnel</span><br><span class="line">lt --port 3100</span><br></pre></td></tr></table></figure><blockquote><p>PageKite 花生壳</p></blockquote><h2 id="配置-接入微信公众号"><a href="#配置-接入微信公众号" class="headerlink" title="配置,接入微信公众号"></a>配置,接入微信公众号</h2><p>点击开发者工具:接口测试申请</p><p>获取:<br>url<br>token</p><p>接入公众号:</p><p>一:配置微信公众号后台<br>二:验证公众号</p><p>配置服务器的url</p><h2 id="验证公众号"><a href="#验证公众号" class="headerlink" title="验证公众号"></a>验证公众号</h2><p>token,timestamp,nonce<br>字典排序,sha1加密<br>r===signature</p><p>一:将token,timestamp,nonce三个参数进行字典序排序<br>二:将三个参数字符串拼接成一个字符串进行sha1加密.<br>三:将加密后的字符串与signature对比,如果相同,表示这个请求来源于微信,我们直接原因返回echostr参数内容,接入验证就成功了.</p><h2 id="实现加密认证逻辑"><a href="#实现加密认证逻辑" class="headerlink" title="实现加密认证逻辑"></a>实现加密认证逻辑</h2><blockquote><p>使用koa,不用express</p></blockquote><p>使用Koa框架,代码可以更加精简,更加易懂,对于反反复复的异步交互更适合用这个框架实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scott/wechat &gt;&gt;</span><br><span class="line"></span><br><span class="line">npm install koa sha1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">node --harmony app.js</span><br><span class="line"></span><br><span class="line">&gt;&gt; ./ngrok -config ngrok.cfg -subdomain scott_wechat 1234</span><br><span class="line"></span><br><span class="line">ls --port 1234</span><br><span class="line">// 把生成的地址配置到接口配置信息中url里面去</span><br><span class="line"></span><br><span class="line">node --harmony app</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084</span><br></pre></td></tr></table></figure><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><ol><li>填写服务器配置</li><li>验证服务器地址的有效性</li><li>根据接口文档实现业务逻辑</li></ol><p>我们在手机上给微信公众号发送一个消息，这就相当于一个request请求，然后这个request到达微信服务器，紧接着微信服务器对这个request做出解析，然后开始响应一个response给你，这样你就收到了相应的回复。</p><p>当我们进行微信公众号的开发之后，用户的请求就不再有微信服务器去做处理了，而是由我们自己的服务做处理，然后把消息传给微信服务器，微信服务器再将消息返回给我们的用户。</p><p>在这个过程中，微信服务器起了一个中间商的作用，所以经过这样的分析，微信公众号开发要把握的一点就是，你只要返回给微信服务器正确的数据，微信服务器就能帮你做正确的事情。</p><p>所以作为微信公众号开发的第一步就是接入，你需要将自己的服务器和微信服务器做接通，只有接通之后，用户发送的请求到达微信服务器之后，微信服务器才知道该将这个请求转发给哪个服务器来处理。</p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>这个url是用来接收微信服务器发送过来的请求的，要对请求做处理？想一想，request？处理？该怎么做呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class OneServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">       super.doGet(req, resp);</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line"></span><br><span class="line">   protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">       super.doPost(req, resp);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="需要"><a href="#需要" class="headerlink" title="需要"></a>需要</h2><p>服务器<br>公众号</p><p>申请测试号<br>这里是申请地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</span><br></pre></td></tr></table></figure><p>appID 和appsecret </p><p>通过他们我们能得到很重要的一个数值就access_token<br>access_token是公众号的全局唯一接口调用凭据</p><p>公众号调用各接口时都需使用access_token</p><h2 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access_token"></a>获取access_token</h2><p>官方技术文档中已经说了，公众号调用接口都需要使用到access_token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// https请求方式: GET</span><br><span class="line">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant_type是获取access_token填写client_credential</span><br><span class="line">appid是第三方用户唯一凭证</span><br><span class="line">secret是第三方用户唯一凭证密钥，即appsecret</span><br></pre></td></tr></table></figure><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>这个接口正确调用会返回什么数据呢？</p><p>正常情况下会返回下述JSON数据包给公众号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125;</span><br></pre></td></tr></table></figure><p>那么这里又包含如下参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">access_token获取到的凭证</span><br><span class="line">expires_in凭证有效时间，单位：秒</span><br></pre></td></tr></table></figure></p><p>使用Postman这个工具简单演示一下发起get请求获取access_token 。</p><p>然后把响应的参数填写即可，这里的grant_type 就写默认的即可，剩下的appid和secret就填写你公众号的appID 和appsecret。</p><p>这个时候你就会发现，一个完整的get请求就拼接好了，接下来点击send即可，然后就会看到返回的数据</p><p>这样就得到我们需要的access_token 。</p><p>微信服务器会往我们填写的这个URL上面发送一个get请求，通过这个get请求能够得到微信服务器发送过来的一些消息，然后对消息做响应的处理来与微信服务器对接。</p><p>很显然，这个URL需要填写一个servlet，微信服务区器将消息发送过来之后需要对这个请求做处理，所以这里选择使用servlet对请求做处理。</p><h2 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h2><p>关于如何验证，文档中给了一个PHP的例子，那么Java中该如何验证呢？</p><p>首先创建一个maven项目，然后创建一个CoreServlet用来接收微信服务器发送过来的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CoreServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        super.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        super.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成servlet之后就需要将这个servlet进行注册了，这个是在web.xml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">           xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</span><br><span class="line">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">           version=&quot;3.0&quot;&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;coreServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;</span><br><span class="line">            com.ithuanqging.wechat.CoreServlet</span><br><span class="line">        &lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!-- url-pattern中配置的/coreServlet用于指定该Servlet的访问路径 --&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;coreServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/coreservlet&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>填写服务器地址（URL）、Token和EncodingAESKey，其中URL是开发者用来接收微信消息和事件的接口URL。Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥。</p><p>开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。</p><h2 id="第二步：验证消息的确来自微信服务器"><a href="#第二步：验证消息的确来自微信服务器" class="headerlink" title="第二步：验证消息的确来自微信服务器"></a>第二步：验证消息的确来自微信服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signature微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</span><br><span class="line">timestamp时间戳</span><br><span class="line">nonce随机数</span><br><span class="line">echostr随机字符串</span><br></pre></td></tr></table></figure><p>1）将token、timestamp、nonce三个参数进行字典序排序 2）将三个参数字符串拼接成一个字符串进行sha1加密 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</p><p>检验signature的PHP示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private function checkSignature()</span><br><span class="line">&#123;</span><br><span class="line">    _GET[&quot;signature&quot;];</span><br><span class="line">    _GET[&quot;timestamp&quot;];</span><br><span class="line">    _GET[&quot;nonce&quot;];</span><br><span class="line"></span><br><span class="line">tmpArr = array(timestamp, $nonce);</span><br><span class="line">sort($tmpArr, SORT_STRING);</span><br><span class="line">$tmpStr = implode( $tmpArr );</span><br><span class="line">$tmpStr = sha1( $tmpStr );</span><br><span class="line"></span><br><span class="line">if( signature )&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">      // 微信加密签名</span><br><span class="line">      String signature = req.getParameter(&quot;signature&quot;);</span><br><span class="line">      // 时间戳</span><br><span class="line">      String timestamp = req.getParameter(&quot;timestamp&quot;);</span><br><span class="line">      // 随机数</span><br><span class="line">      String nonce = req.getParameter(&quot;nonce&quot;);</span><br><span class="line">      // 随机字符串</span><br><span class="line">      String echostr = req.getParameter(&quot;echostr&quot;);</span><br><span class="line"></span><br><span class="line">      PrintWriter out = resp.getWriter();</span><br><span class="line"></span><br><span class="line">      // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败</span><br><span class="line">      if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">          out.print(echostr);</span><br><span class="line">      &#125;</span><br><span class="line">      out.close();</span><br><span class="line">      out = null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>##<br>微信测试公众号基本配置URL和Token的验证-JAVA</p><p>我们填写的URL和Token，微信那边会根据你填的来验证是否正确，URL必须有域名的，Token自己定义的。</p><p>微信调用我们服务器，会通过GET请求，请求带有signature、timestamp、nonce、echostr参数。服务端返回echostr参数，则表示token验证成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">       @GET</span><br><span class="line">@Path(&quot;/tokenVarify&quot;)</span><br><span class="line">@Produces(MediaType.APPLICATION_JSON)</span><br><span class="line">@Consumes(MediaType.APPLICATION_JSON)</span><br><span class="line">@ApiOperation(value = &quot;Vatify wc token&quot;, position = 1)</span><br><span class="line">public void tokenVarify(@Context HttpServletRequest request,</span><br><span class="line">@Context HttpServletResponse response) &#123;</span><br><span class="line">boolean isGet = request.getMethod().toLowerCase().equals(&quot;get&quot;);</span><br><span class="line">PrintWriter print;</span><br><span class="line">if (isGet) &#123;</span><br><span class="line">           // 微信加密签名</span><br><span class="line">           String signature = request.getParameter(&quot;signature&quot;);</span><br><span class="line">           // 时间戳</span><br><span class="line">           String timestamp = request.getParameter(&quot;timestamp&quot;);</span><br><span class="line">           // 随机数</span><br><span class="line">           String nonce = request.getParameter(&quot;nonce&quot;);</span><br><span class="line">           // 随机字符串</span><br><span class="line">           String echostr = request.getParameter(&quot;echostr&quot;);</span><br><span class="line">           // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败</span><br><span class="line">           if (signature != null &amp;&amp; CheckoutUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   print = response.getWriter();</span><br><span class="line">                   print.write(echostr);</span><br><span class="line">                   print.flush();</span><br><span class="line">               &#125; catch (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CheckoutUtil.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import java.security.MessageDigest;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line"> </span><br><span class="line">public class CheckoutUtil &#123;</span><br><span class="line">// 与接口配置信息中的Token要一致</span><br><span class="line">    private static String token = &quot;bryant.zhang.test&quot;;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 验证签名</span><br><span class="line">     * </span><br><span class="line">     * @param signature</span><br><span class="line">     * @param timestamp</span><br><span class="line">     * @param nonce</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean checkSignature(String signature, String timestamp, String nonce) &#123;</span><br><span class="line">        String[] arr = new String[] &#123; token, timestamp, nonce &#125;;</span><br><span class="line">        // 将token、timestamp、nonce三个参数进行字典序排序</span><br><span class="line">        // Arrays.sort(arr);</span><br><span class="line">        sort(arr);</span><br><span class="line">        StringBuilder content = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            content.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageDigest md = null;</span><br><span class="line">        String tmpStr = null;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            md = MessageDigest.getInstance(&quot;SHA-1&quot;);</span><br><span class="line">            // 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line">            byte[] digest = md.digest(content.toString().getBytes());</span><br><span class="line">            tmpStr = byteToStr(digest);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        content = null;</span><br><span class="line">        // 将sha1加密后的字符串可与signature对比，标识该请求来源于微信</span><br><span class="line">        return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 将字节数组转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param byteArray</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static String byteToStr(byte[] byteArray) &#123;</span><br><span class="line">        String strDigest = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; byteArray.length; i++) &#123;</span><br><span class="line">            strDigest += byteToHexStr(byteArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return strDigest;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 将字节转换为十六进制字符串</span><br><span class="line">     * </span><br><span class="line">     * @param mByte</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static String byteToHexStr(byte mByte) &#123;</span><br><span class="line">        char[] Digit = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos; &#125;;</span><br><span class="line">        char[] tempArr = new char[2];</span><br><span class="line">        tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F];</span><br><span class="line">        tempArr[1] = Digit[mByte &amp; 0X0F];</span><br><span class="line">        String s = new String(tempArr);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sort(String a[]) &#123;</span><br><span class="line">        for (int i = 0; i &lt; a.length - 1; i++) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; a.length; j++) &#123;</span><br><span class="line">                if (a[j].compareTo(a[i]) &lt; 0) &#123;</span><br><span class="line">                    String temp = a[i];</span><br><span class="line">                    a[i] = a[j];</span><br><span class="line">                    a[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="qi文档中说的真的很清楚了，包括如何验证等表述的都很清楚，下面我们直接编码"><a href="#qi文档中说的真的很清楚了，包括如何验证等表述的都很清楚，下面我们直接编码" class="headerlink" title="qi文档中说的真的很清楚了，包括如何验证等表述的都很清楚，下面我们直接编码"></a>qi文档中说的真的很清楚了，包括如何验证等表述的都很清楚，下面我们直接编码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">      // 微信加密签名</span><br><span class="line">      String signature = req.getParameter(&quot;signature&quot;);</span><br><span class="line">      // 时间戳</span><br><span class="line">      String timestamp = req.getParameter(&quot;timestamp&quot;);</span><br><span class="line">      // 随机数</span><br><span class="line">      String nonce = req.getParameter(&quot;nonce&quot;);</span><br><span class="line">      // 随机字符串</span><br><span class="line">      String echostr = req.getParameter(&quot;echostr&quot;);</span><br><span class="line"></span><br><span class="line">      PrintWriter out = resp.getWriter();</span><br><span class="line"></span><br><span class="line">      // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败</span><br><span class="line">      if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">          out.print(echostr);</span><br><span class="line">      &#125;</span><br><span class="line">      out.close();</span><br><span class="line">      out = null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上是从request请求中拿到传过来的参数，接下来就是需要创建一个工具类按照文档中说的方法去进行验证了，这里我已经写好了这个工具类SignUtil</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class SignUtil &#123;</span><br><span class="line">    // 与接口配置信息中的Token要一致</span><br><span class="line">    private static String token = &quot;mytoken&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 验证签名</span><br><span class="line">     */</span><br><span class="line">    public static boolean checkSignature(String signature, String timestamp,String nonce) &#123;</span><br><span class="line">        // 1.将token、timestamp、nonce三个参数进行字典序排序</span><br><span class="line">        String[] arr = new String[] &#123; token, timestamp, nonce &#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        // 2. 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line">        StringBuilder content = new StringBuilder();</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            content.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageDigest md = null;</span><br><span class="line">        String tmpStr = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            md = MessageDigest.getInstance(&quot;SHA-1&quot;);</span><br><span class="line">            // 将三个参数字符串拼接成一个字符串进行sha1加密</span><br><span class="line">            byte[] digest = md.digest(content.toString().getBytes());</span><br><span class="line">            tmpStr = byteToStr(digest);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        content = null;</span><br><span class="line">        // 3.将sha1加密后的字符串可与signature对比，标识该请求来源于微信</span><br><span class="line">        return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将字节数组转换为十六进制字符串</span><br><span class="line">     */</span><br><span class="line">    private static String byteToStr(byte[] byteArray) &#123;</span><br><span class="line">        String strDigest = &quot;&quot;;</span><br><span class="line">        for (int i = 0; i &lt; byteArray.length; i++) &#123;</span><br><span class="line">            strDigest += byteToHexStr(byteArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return strDigest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将字节转换为十六进制字符串</span><br><span class="line">     */</span><br><span class="line">    private static String byteToHexStr(byte mByte) &#123;</span><br><span class="line">        char[] Digit = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;,&apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos; &#125;;</span><br><span class="line">        char[] tempArr = new char[2];</span><br><span class="line">        tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F];</span><br><span class="line">        tempArr[1] = Digit[mByte &amp; 0X0F];</span><br><span class="line">        String s = new String(tempArr);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>以上这个工具类你可以直接拿来使用。</p><p>这个时候就要回到我们的测试公众号后台了，去填写我们的配置，也就是接口配置信息，但是现在你写的程序还在本地，微信即使发送请求也发不到你这啊，所以这个时候需要将的项目打包传到你的服务器上</p><p>首先将你的项目通过maven打包成war</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G:\JavaCodeDemo\wechattest:mvn package</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wechattest &gt; target &gt;</span><br><span class="line">classes</span><br><span class="line">generated-sources</span><br><span class="line">maven-archiver</span><br><span class="line">maven-status</span><br><span class="line">wechattest</span><br><span class="line">wechattest.war</span><br></pre></td></tr></table></figure><p>接下来将这个war包上传到你的服务器上，我这里使用的是FileZilla这个工具</p><p>找到刚才生成的war包，远程站点必须是tomcat下的webapps目录下。</p><p>服务器配置的知识涉及到在服务器中安装JDK和tomcat！</p><p>现在只要告诉微信服务器你的这个项目中的CoreServlet的正确路径，就能接收微信服务器发动的消息了，现在回到测试公众号的后台。</p><p>接口配置信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器公网IP地址</span><br><span class="line">coreservlet的路径</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://139.199.98.152/wechattest/coreservlet</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信公众号开发&lt;/p&gt;
    
    </summary>
    
      <category term="微信公众号开发" scheme="https://huangguangda.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微信公众号开发" scheme="https://huangguangda.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>HTML入门教材</title>
    <link href="https://huangguangda.github.io/2018/05/17/1/"/>
    <id>https://huangguangda.github.io/2018/05/17/1/</id>
    <published>2018-05-17T03:48:02.000Z</published>
    <updated>2018-07-29T16:28:00.185Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><h2 id="HTML-基本结构及实体"><a href="#HTML-基本结构及实体" class="headerlink" title="HTML 基本结构及实体"></a>HTML 基本结构及实体</h2><ul><li>了解 HTML 文档的基本结构</li><li>掌握 HTML 结构标签<html><head><title><body></body></title></head></html></li><li>掌握 HTML 字符实体</li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h4 id="HTML-文件是什么？"><a href="#HTML-文件是什么？" class="headerlink" title="HTML 文件是什么？"></a>HTML 文件是什么？</h4><p>HTML 表示超文本标记语言（Hyper Text Markup Language）。<br>HTML 文件是一个包含标记的文本文件。<br>这些标记保证浏览器怎样显示这个页面。<br>HTML 文件必须有 htm 或者 html 扩展名。<br>HTML 文件可以用一个简单的文本编辑器创建。</p><h4 id="想不想尝试一下？"><a href="#想不想尝试一下？" class="headerlink" title="想不想尝试一下？"></a>想不想尝试一下？</h4><p>假如你运行的是 windows 系统，打开记事本，在其中输入以下文本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Title of page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is my first homepage.</span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>将此文件保存为“mypage.htm”。</p><h4 id="例子解释"><a href="#例子解释" class="headerlink" title="例子解释:"></a>例子解释:</h4><p>HTML 文档中，第一个标签是<html>。</html></p><p>这个标签告诉浏览器这是 HTML 文档的开始。</p><p>HTML</p><p>文档的最后一个标签是，这个标签告诉浏览器这是 HTML 文档的终止。</p><p>在<head>和</head>标签之间文本的是头信息。</p><p>在浏览器窗口中，头信息是不被显示的 。</p><p>在<title>和</title>标签之间的文本是文档标题，它被显示在浏览器窗口的标题栏 。</p><p>在<body>和</body>标签之间的文本是正文，会被显示在浏览器中。</p><p>在<b>和</b>标签之间的文本会以加粗字体显示。</p><h4 id="关于-HTML-编辑器："><a href="#关于-HTML-编辑器：" class="headerlink" title="关于 HTML 编辑器："></a>关于 HTML 编辑器：</h4><p>用一些所见即所得的编辑器，比如 frontpage，dreamwaver，你可以很容易创建一个<br>页面，而不需要在纯文本中编写代码。</p><p>但是假如你想成为一名熟练的网络开发者，我们强烈推荐你用纯文本编辑器编写代码 ，<br>这有助于学习 HTML 基础。</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题:"></a>常见问题:</h4><p>问：我编写完了 HTML 文件，但是不能在浏览器中看见结果，为什么？</p><p>答 ： 请确 认 你 保 存了 文 件 ， 并且 使 用 了 正确 的 文 件 名和 扩 展 名 ，例 如 ：<br>“c:\mypage.htm”，并且确认你用浏览器打开时使用同样的文件名。</p><p>问：我编辑了 HTML 文件，但是修改结果并没有在浏览器中显示，为什么？</p><p>答：浏览器缓存了你的页面，所以它不需要两次读取同样的页面。你修改了这个页面 ，<br>浏览器并不知道。请使用“刷新/重载”按钮来强迫浏览器读取编辑过的页面。</p><h4 id="HTML-元素："><a href="#HTML-元素：" class="headerlink" title="HTML 元素："></a>HTML 元素：</h4><p>HTML 文档是由 HTML 元素组成的文本文件。</p><p>HTML 元素是预定义的正在使用的 HTML 标签。</p><h5 id="HTML-标签："><a href="#HTML-标签：" class="headerlink" title="HTML 标签："></a>HTML 标签：</h5><p>HTML 标签用来组成 HTML 元素。</p><p>HTML 标签两端有两个包括字符：“&lt;”和“&gt;”,这两个包括字符被称为角括号。</p><p>HTML 标签通常成对出现，比如<b>和</b>。</p><p>一对标签的前面一个是开始标签，第二个是结束标签,在开始和结束标签之间的文本是元素内容。</p><p>HTML 标签是大小写无关的，<b>跟<b>表示的意思是一样的。</b></b></p><h5 id="HTML-元素：-1"><a href="#HTML-元素：-1" class="headerlink" title="HTML 元素："></a>HTML 元素：</h5><p>回忆一下上面的 HTML 例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Title of page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">This is my first homepage.</span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>下面是一个 HTML 元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br></pre></td></tr></table></figure></p><p>此 HTML 元素以开始标签<b>起始， 内容是：This text is bold，以结束标签</b>中止 。</p><p><b>标签的目的是定义一个需要被显示成粗体的 HTML 元素。</b></p><p>下面也是一个 HTML 元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">This is my first homepage.</span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>此 HTML 标签以开始标签<body>起始，终止于结束标签</body>。</p><p><body>标签的目的</body></p><p>是定义一个 HTML 元素，使其包含 HTML 文档的主体。</p><p>为什么使用小写标签？</p><p>我们刚说过，HTML 标签是大小写无关的：</p><p><b>跟<b>含义相同。</b></b></p><p>当你上网的时候，你会注意到多数教程在示例中使用大写的 HTML 标签，我们总是使用小写标签。</p><p>为什么？</p><p>假如你想投入到下一代 HTML 中，你应该开始使用小写标签。</p><p>W3C 在他们的 HTML4建议中提倡使用小写标签，XHTML（下一代 HTML）也需要小写标签。</p><h5 id="标签属性："><a href="#标签属性：" class="headerlink" title="标签属性："></a>标签属性：</h5><p>标签可以拥有属性。</p><p>属性能够为页面上的 HTML 元素提供附加信息。</p><p>标签<body>定义了 HTML 页面的主体元素。</body></p><p>使用一个附加的 bgcolor 属性，你可以告诉浏览器：你页面的背景色是红色的，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body bgcolor=&quot;red&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>标签<table>定义了一个 HTML 表格。</table></p><p>使用一个附加的 border 属性，你可以告诉浏览器：这个表格是没有边框的，代码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;0&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>属性通常由属性名和值成对出现，就像这样：name=”value”。</p><p>属性通常是附加给 HTML元素的开始标签的。</p><h4 id="引号样式："><a href="#引号样式：" class="headerlink" title="引号样式："></a>引号样式：</h4><p>属性值应该被包含在引号中。<br>双引号是最常用的，但是单引号也可以使用。</p><p>在很少情况下，比如说属性值本身包含引号，使用单引号就很必要了。</p><blockquote><p>比如：name=’John “ShotGun” Nelson’。</p></blockquote><p>注意：中文引号跟英文引号是不一样的。<br>上面所指的引号都是英文状态下的引号。</p><h4 id="HTML-实体"><a href="#HTML-实体" class="headerlink" title="HTML  实体"></a>HTML  实体</h4><p>有些字符，比如说“&lt;”字符，在 HTML 中有特殊的含义，因此不能在文本中使用。<br>想要在 HTML 中显示一个小于号“&lt;”，需要用到字符实体。</p><h5 id="字符实体："><a href="#字符实体：" class="headerlink" title="字符实体："></a>字符实体：</h5><p>在 HTML 中，有些字符拥有特殊含义，比如小于号“&lt;”定义为一个 HTML 标签的开始 。</p><p>假如我们想要浏览器显示这些字符的话，必须在 HTML 代码中插入字符实体。</p><p>一个字符实体拥有三个部分：<br>一个 and 符号（&amp;），<br>一个实体名或者一个实体号，<br>最后是一个分号（;）</p><p>想要在 HTML 文档中显示一个小于号，我们必须这样写：&lt;或者&#60;</p><p>使用名字相对于使用数字的优点是容易记忆，缺点是并非所有的浏览器都支持最新的实体名，但是几乎所有的浏览器都能很好地支持实体号。</p><p>注意：实体名是大小写敏感的。</p><p>下面这个例子能够让你针对 HTML 实体实践一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;This is a character entity: &amp;#123;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h4 id="不可拆分的空格"><a href="#不可拆分的空格" class="headerlink" title="不可拆分的空格"></a>不可拆分的空格</h4><p>在 HTML 中，最常见的字符实体就是不可拆分空格。</p><p>通常，HTML 会合并你文档中的空格。<br>假如在你的 HTML 文本中连续写了 10 个空格 ，其中 9 个会被去掉。<br>想要在 HTML 中插入空格，可以使用实体：&nbsp;</p><h2 id="HTML-基本元素的运用"><a href="#HTML-基本元素的运用" class="headerlink" title="HTML  基本元素的运用"></a>HTML  基本元素的运用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">段落相关标签&lt;p&gt;&lt;br&gt;&lt;hr&gt;</span><br><span class="line">格式化相关标签&lt;small&gt;&lt;sub&gt;&lt;sup&gt;&lt;pre&gt;</span><br><span class="line">列表相关标签&lt;ol&gt;&lt;ul&gt;&lt;li&gt;</span><br><span class="line">图片相关标签&lt;img&gt;</span><br><span class="line">超链相关标签&lt;a&gt;</span><br></pre></td></tr></table></figure><h3 id="段落-相关-标签"><a href="#段落-相关-标签" class="headerlink" title="段落 相关 标签"></a>段落 相关 标签</h3><p>标题元素：<br>标题元素由标签</p><h1>到<h6>定义。<h1>定义了最大的标题元素，<h6>定义了最小的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;This is a heading&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;This is a heading&lt;/h2&gt;</span><br><span class="line">&lt;h3&gt;This is a heading&lt;/h3&gt;</span><br><span class="line">&lt;h4&gt;This is a heading&lt;/h4&gt;</span><br><span class="line">&lt;h5&gt;This is a heading&lt;/h5&gt;</span><br><span class="line">&lt;h6&gt;This is a heading&lt;/h6&gt;</span><br></pre></td></tr></table></figure></h6></h1></h6></h1><p></p><blockquote><p>HTML 自动在一个标题元素前后各添加一个空行。</p></blockquote><h4 id="段落："><a href="#段落：" class="headerlink" title="段落："></a>段落：</h4><p>段落是用</p><p>标签定义的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is another paragraph&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>HTML 自动在一个段落前后各添加一个空行。</p></blockquote><h4 id="换行："><a href="#换行：" class="headerlink" title="换行："></a>换行：</h4><p>当需要结束一行，并且不想开始新段落时，使用<br>标签。<br>标签不管放在什么位置，都能够强制换行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This &lt;br&gt; is a para&lt;br&gt;graph with line breaks&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p><br>标签是一个空标签，它没有结束标记。</p></blockquote><h4 id="格式化-相关-标签"><a href="#格式化-相关-标签" class="headerlink" title="格式化 相关 标签"></a>格式化 相关 标签</h4><p>格式化文字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;b&gt;This text is bold&lt;/b&gt;&lt;br&gt;</span><br><span class="line">&lt;strong&gt;</span><br><span class="line">This text is strong</span><br><span class="line">&lt;/strong&gt;&lt;br&gt;</span><br><span class="line">&lt;big&gt;</span><br><span class="line">This text is big</span><br><span class="line">&lt;/big&gt;&lt;br&gt;</span><br><span class="line">&lt;em&gt;</span><br><span class="line">This text is emphasized</span><br><span class="line">&lt;/em&gt;&lt;br&gt;</span><br><span class="line">&lt;i&gt;</span><br><span class="line">This text is italic</span><br><span class="line">&lt;/i&gt;&lt;br&gt;</span><br><span class="line">&lt;small&gt;</span><br><span class="line">This text is small</span><br><span class="line">&lt;/small&gt;&lt;br&gt;</span><br><span class="line">This text contains</span><br><span class="line">&lt;sub&gt;</span><br><span class="line">subscript</span><br><span class="line">&lt;/sub&gt;&lt;br&gt;</span><br><span class="line">This text contains</span><br><span class="line">&lt;sup&gt;</span><br><span class="line">superscript</span><br><span class="line">&lt;/sup&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="列表相关标签"><a href="#列表相关标签" class="headerlink" title="列表相关标签"></a>列表相关标签</h3><h4 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h4><p>无序列表是一个项目的序列。各项目前加有标记（通常是黑色的实心小圆圈）。</p><p>无序列表以<ul>标签开始。每个列表项目以<li>开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;Coffee&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Milk&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li></ul></p><p>无序列表的项目中可以加入段落、换行、图像，链接，其他的列表等等。</p><h4 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h4><p>有序列表也是一个项目的序列。各项目前加有数字作标记。</p><p>有序列表以<ol>标签开始。每个列表项目以<li>开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">Web程序开发基础</span><br><span class="line">12</span><br><span class="line">&lt;li&gt;Coffee&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Milk&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure></li></ol></p><h2 id="不同类型："><a href="#不同类型：" class="headerlink" title="不同类型："></a>不同类型：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol type=&quot;A&quot;&gt;</span><br><span class="line">&lt;ol type=&quot;a&quot;&gt;</span><br><span class="line">&lt;ol type=&quot;I&quot;&gt;</span><br><span class="line">&lt;ol type=&quot;i&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul type=&quot;disc&quot;&gt;</span><br><span class="line">&lt;ul type=&quot;circle&quot;&gt;</span><br><span class="line">&lt;ul type=&quot;square&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="图片相关标签"><a href="#图片相关标签" class="headerlink" title="图片相关标签"></a>图片相关标签</h2><h4 id="Img-标签和-src属性："><a href="#Img-标签和-src属性：" class="headerlink" title="Img 标签和 src属性："></a>Img 标签和 src属性：</h4><p>在 HTML 里面，图像是由<img>标签定义的。</p><p><img>是空标签，意思是说，它只拥有属性，而没有结束标签。</p><p>想要在页面上显示一个图像，需要使用 src属性。<br>“src”表示“源”的意思。“src”属性的值是所要显示图像的 URL。</p><h5 id="插入图像的语法："><a href="#插入图像的语法：" class="headerlink" title="插入图像的语法："></a>插入图像的语法：</h5><p>URL 指向图像存储的地址。</p><p>alt 属性：</p><p>alt 属性用来给图像显示一个“交互文本”。<br>alt 属性的值是由用户定义的。</p><p>“alt”属性在浏览器装载图像失败的时候告诉用户所丢失的信息，此时，浏览器显示这个“交互文本”来代替图像。给页面上的图像都加上 alt 属性是一个好习惯，它有助于更好地显示信息，而且，对纯文本浏览器很有用。</p><h5 id="基本注意点——有用的技巧"><a href="#基本注意点——有用的技巧" class="headerlink" title="基本注意点——有用的技巧:"></a>基本注意点——有用的技巧:</h5><p>如果一个 HTML 文档包含 10 个图像，那么为了正确显示这个页面，需要加载 11 个文件 。<br>加载图像是需要时间的，所以请谨慎使用图像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;./images/hackanm.gif&quot; width=&quot;20&quot; height=&quot;20&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;body background=&quot;./images/background.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;back.htm&quot;&gt;</span><br><span class="line">&lt;img border=&quot;0&quot; src=&quot;./images/next.gif&quot;&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="超链相关标签"><a href="#超链相关标签" class="headerlink" title="超链相关标签"></a>超链相关标签</h2><h3 id="锚标签和-href-属性："><a href="#锚标签和-href-属性：" class="headerlink" title="锚标签和 href 属性："></a>锚标签和 href 属性：</h3><p>HTML 使用锚标签（<a>）来创建一个连接到其他文件的链接。<br>锚可以指向网络上的任何资源：HTML 页面，图像，声音，影片等等。</a></p><p>标签<a>被用来创建一个链接指向的锚，href 属性用来指定连接到的地址，在锚的起始标签<a>和结束标签</a>中间的部分将被显示为超级链接。</a></p><h4 id="target-属性："><a href="#target-属性：" class="headerlink" title="target 属性："></a>target 属性：</h4><p>使用 target 属性，你可以定义从什么地方打开链接地址。</p><h4 id="锚标签和-name-属性"><a href="#锚标签和-name-属性" class="headerlink" title="锚标签和 name 属性"></a>锚标签和 name 属性</h4><p>name 属性用来创建一个命名的锚。使用命名锚以后，可以让链接直接跳转到一个页面的某一章节，而不用用户打开那一页，再从上到下慢慢找。</p><p>下面是命名锚的语法：</p><p>你可以为锚随意指定名字，只要你愿意。</p><h4 id="基本注意点——有用的技巧："><a href="#基本注意点——有用的技巧：" class="headerlink" title="基本注意点——有用的技巧："></a>基本注意点——有用的技巧：</h4><p>命名锚通常用来在大型文档的开头创建章节表。这个页面的每个章节被加上一个命名锚，到这些锚的链接被放在页面的顶端。</p><p>如果浏览器无法找到指定的命名锚，它将转到这个页面的顶部，而不显示任何错误提示。</p><h4 id="更多示例："><a href="#更多示例：" class="headerlink" title="更多示例："></a>更多示例：</h4><p>在新浏览器窗口中打开链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=&quot;lastpage.htm&quot; target=&quot;_blank&quot;&gt;Last Page&lt;/a&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">If you set the target attribute of a link to &quot;_blank&quot;,</span><br><span class="line">the link will open in a new window.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="用-HTML-创建表格"><a href="#用-HTML-创建表格" class="headerlink" title="用 HTML  创建表格"></a>用 HTML  创建表格</h2><ul><li><p>了解掌握表格的基本结构<table><tr><th></th><td></td></tr></table></p></li><li><p>掌握跨行、跨列属性 colspan rowspan</p></li><li><p>掌 握 表 格 相 关 修 饰 属 性 border width height bgcolor</p></li><li><p>background height cellpadding cellspacing</p></li></ul><h2 id="HTML-表格"><a href="#HTML-表格" class="headerlink" title="HTML  表格"></a>HTML  表格</h2><p>表格 :</p><p>表格是用<table>标签定义的。</table></p><p>表格被划分为行（使用<tr>标签），每行又被划分为数据单</tr></p><p>元格（使用<td>标签）。td 表示“表格数据”（ Table Data），即数据单元格的内容。</td></p><h4 id="数据单元格可以包含文本，图像，列表，段落，表单，水平线，表格等等。想不想尝试一下？"><a href="#数据单元格可以包含文本，图像，列表，段落，表单，水平线，表格等等。想不想尝试一下？" class="headerlink" title="数据单元格可以包含文本，图像，列表，段落，表单，水平线，表格等等。想不想尝试一下？"></a>数据单元格可以包含文本，图像，列表，段落，表单，水平线，表格等等。想不想尝试一下？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;td&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;caption&gt;table title and/or explanatory text&lt;/caption&gt;</span><br><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;header&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;data&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;table border=&quot;1&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;th colspan=&quot;&quot; rowspan=&quot;&quot; headers=&quot;&quot; scope=&quot;&quot;&gt;&lt;/th&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;td&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/td&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;td&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">  &lt;td&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><h2 id="基本注意点——有用的技巧-1"><a href="#基本注意点——有用的技巧-1" class="headerlink" title="基本注意点——有用的技巧"></a>基本注意点——有用的技巧</h2><p>通常很少使用<thead>，<tbody>，<tfoot>标签，因为浏览器对它们的支持不好。希望这<br>个在 XHTML 的未来版本中得到改变。</tfoot></tbody></thead></p><blockquote><p>cellpadding 属性在表格内容和边框之间留出更多空白<br>cellspacing 属性来增加单元格间距<br>使用“align”属性来设置单元格的对齐方式</p></blockquote><h2 id="HTML-表单页面的运用"><a href="#HTML-表单页面的运用" class="headerlink" title="HTML  表单页面的运用"></a>HTML  表单页面的运用</h2><p>掌握表单基本结构<form><br>掌握各种表单元素<br>能理解 post 和 get 两种提交方式的区别</form></p><h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML  表单"></a>HTML  表单</h2><p>表单：<br>表单是一个能够包含表单元素的区域。</p><p>表单元素是能够让用户在表单中输入信息的元素（比如文本框，密码框，下拉菜单，单<br>选框，复选框等等）。</p><h2 id="Input："><a href="#Input：" class="headerlink" title="Input："></a>Input：</h2><p>最常用的表单标签是<input>标签。Input 的类型用 type属性指定。最常用的 input 类型解释如下：</p><p>文本框：在表单中，文本框用来让用户输入字母、数字等等。</p><p>表单的 action 属性和提交按钮：<br>当用户点击提交按钮的时候，表单的内容会被提交到其他文件。</p><p>表单的 action 属性定义了所要提交到的目的文件，该目的文件收到信息后通常进行相关的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form name=&quot;input&quot; action=&quot;xxxx&quot; method=&quot;get&quot;&gt;</span><br><span class="line"> &lt;input type=&quot;&quot; name=&quot;&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>简单的下拉列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;select name=&quot;cars&quot;&gt;</span><br><span class="line">&lt;option value=&quot;volvo&quot;&gt;Volvo</span><br><span class="line">&lt;option value=&quot;saab&quot;&gt;Saab</span><br><span class="line">&lt;option value=&quot;fiat&quot;&gt;Fiat</span><br><span class="line">&lt;option value=&quot;audi&quot;&gt;Audi</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>创建一个含有预先选定元素的下拉列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">文本域：</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line"> This example demonstrates a text-area.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;textarea rows=&quot;10&quot; cols=&quot;30&quot;&gt;</span><br><span class="line"> The cat was playing in the garden.</span><br><span class="line">&lt;/textarea&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;Hello world!&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;fieldset&gt;</span><br><span class="line">&lt;legend&gt;</span><br><span class="line"> Health information:</span><br><span class="line">&lt;/legend&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">     Height&lt;input type=&quot;text&quot; size=&quot;3&quot;&gt;</span><br><span class="line"> Weight&lt;input type=&quot;text&quot; size=&quot;3&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line"> If there is no border around the input form, your browser is too old.</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;x&quot; method=&quot;post&quot;</span><br><span class="line">enctype=&quot;text/plain&quot;&gt;</span><br><span class="line">&lt;h3&gt;xxxxxxxxxxx&lt;/h3&gt;</span><br><span class="line"> Name:&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;yourname&quot; size=&quot;20&quot;&gt;</span><br><span class="line"> &lt;br&gt;</span><br><span class="line"> Mail:&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;mail&quot; value=&quot;yourmail&quot; size=&quot;20&quot;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"> Comment:&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;comment&quot; value=&quot;yourcomment&quot; size=&quot;40&quot;&gt;</span><br><span class="line"> &lt;br&gt;&lt;br&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;Send&quot;&gt;</span><br><span class="line">&lt;input type=&quot;reset&quot; value=&quot;Reset&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="使用样式表美化页面-1-1"><a href="#使用样式表美化页面-1-1" class="headerlink" title="使用样式表美化页面 1 1"></a>使用样式表美化页面 1 1</h2><p>掌握在网页中使用 CSS 的方法<br>熟悉 CSS 的不同选择器的使用方法<br>熟悉字体属性：font-family，font-size，font-style，<br>font-weight<br>熟悉文本属性：text-align，text-indent，text-decoration，<br>text-transform，vertical-align，word-spacing，<br>letter-spacing</p><h2 id="CSS-的工作原理"><a href="#CSS-的工作原理" class="headerlink" title="CSS  的工作原理"></a>CSS  的工作原理</h2><p>在这一节，你将学习如何制作自己的第一个样式表。</p><p>你将了解基本的 CSS 模型，以及在HTML 文档里使用 CSS 所必需的代码。</p><p>级联样式表（CSS）里用到的许多 CSS 属性都与 HTML 属性相似，所以，假如你熟悉<br>采用 HTML 进行布局的话，那么这里的许多代码你都不会感到陌生。我们先来看一个具<br>体的例子。</p><h2 id="基本的-CSS-语法："><a href="#基本的-CSS-语法：" class="headerlink" title="基本的 CSS 语法："></a>基本的 CSS 语法：</h2><p>比方说，我们要用红色作为网页的背景色：<br>用  L HTML 的话，我们可以这样：<br>用  CSS的话，我们可以这样获得同样的效果：</p><h4 id="为一个-HTML-文档应用-CSS："><a href="#为一个-HTML-文档应用-CSS：" class="headerlink" title="为一个 HTML 文档应用 CSS："></a>为一个 HTML 文档应用 CSS：</h4><p>为 HTML 文档应用 CSS，有三种方法可供选择。</p><p>下面对这三种方法进行了概括。我们建议你对第三种方法（即外部样式表）予以关注。</p><p>方法 1：行内样式表（style 属性）</p><p>方法 2：内部样式表（style 元素）</p><p>方法 3：外部样式表（引用一个样式表文件）</p><h2 id="元素的分类与标识（-class-和-和-id-）"><a href="#元素的分类与标识（-class-和-和-id-）" class="headerlink" title="元素的分类与标识（ class  和 和  id ）"></a>元素的分类与标识（ class  和 和  id ）</h2><p>有时，你希望对特定元素或者特定一组元素应用特殊的样式。<br>在这一节，我们将深入学习如何利用 class 和 id 来为所选元素指定属性。</p><p>如何实现为网站上许多标题中的某一个单独应用颜色？<br>如何实现把网站上的链接分为不同的类，并对各类链接分别应用不同的样式？<br>这只是本节将解决的诸多问题中的最具代表性的两个问题。</p><h2 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h2><p>这一节，你将学习字体以及如何用 CSS 来设置字体。我们还会考虑如何解决“网站所选<br>的字体仅当访问者的 PC 上安装有该字体时才会被显示”这一难题。本节将对下列 CSS<br>属性进行讲解：</p><p>• font-family<br>• font-style<br>• font-variant<br>• font-weight<br>• font-size<br>• font</p><h4 id="字体族-font-family-："><a href="#字体族-font-family-：" class="headerlink" title="字体族[font-family]："></a>字体族[font-family]：</h4><p>CSS 属性 font-family 的作用是设置一组按优先级排序的字体列表，如果该列表中的<br>第一个字体未在访问者计算机上安装，那么就尝试列表中的下一个字体，依此类推，直<br>到列表中的某个字体是已安装的。</p><p>有两种类型的名称可用于分类字体：字体族名称（family-name）和族类名称（generic<br>family）。下面来解释这两个术语。</p><p>字体族名称（family-name）：</p><p>字体族名称（就是我们通常所说的“字体”）的例子包括<br>“Arial”、“Times New Roman” 、“宋体”、“黑体”等等。</p><p>字体样式[font-style]：<br>CSS 属性 font-style 定义所选字体的显示样式： normal （正常）、 c italic （斜体）或  oblique<br>（倾斜）。</p><p>字体变化[font-variant]：<br>CSS 属性 font-variant 的值可以是： normal（正常）或  s small-caps（小体大写字母） 。<br>small-caps 字体是一种以小尺寸显示的大写字母来代替小写字母的字体。</p><p>字体浓淡[font-weight]：<br>CSS 属性 font-weight 指定字体显示的浓淡程度。其值可以是  l normal（正常）或  bold<br>（加粗）。</p><p>字体大小[font-size]：<br>字体的大小用 CSS 属性 font-size 来设置。字体大小可通过多种不同单位（比如像素或百分比等）来设置。</p><h2 id="文本-属性"><a href="#文本-属性" class="headerlink" title="文本 属性"></a>文本 属性</h2><p>文本的显示格式与式样对于网页设计师来说是一个重要问题。<br>这一节将向你介绍 CSS 在文本布局方面令人激动的特性。本节将对下列 CSS 属性进行讲解：</p><p>• text-indent<br>• text-align<br>• text-decoration<br>• letter-spacing<br>• text-transform</p><p>文本缩进[text-indent]：<br>CSS 属性 text-indent 用于为段落设置首行缩进，以令其具有美观的格式。</p><p>文本对齐[text-align]：<br>CSS 属性 text-align 与 HTML 属性 align 的功能相同。该属性的值可以是：<br>left（左对齐）、 right（右对齐）或者  center（居中）。</p><p>文本装饰[text-decoration]：<br>CSS 属性 text-decoration 令我们可以为文本增添不同的“装饰”或“效果”。</p><p>字符间距[letter-spacing]：<br>CSS 属性 letter-spacing 用于设置文本的水平字间距。</p><p>文本转换[text-transform]：<br>CSS 属性 text-transform 用于控制文本的大小写。<br>无论字母本来的大小写，你可以通过该属性令它<br>首字母大写（capitalize）、全部大写（uppercase）或者全部小写（lowercase）。</p><h2 id="使用样式表美化页面"><a href="#使用样式表美化页面" class="headerlink" title="使用样式表美化页面"></a>使用样式表美化页面</h2><p>熟悉显示属性：display<br>熟悉边框属性：Border , border-style 等<br>熟悉定位属性：top , Width , Height , Left</p><h4 id="显示-属性"><a href="#显示-属性" class="headerlink" title="显示 属性"></a>显示 属性</h4><p>显示属性允许使用四个值中的一个来定义一个元素：<br>block ：在元素的前和后都会有换行<br>inline ：在元素的前和后都不会有换行<br>list-item ：与 block 相同，但增加了目录项标记<br>none ：没有显示</p><h2 id="边框-属性"><a href="#边框-属性" class="headerlink" title="边框 属性"></a>边框 属性</h2><p>边框（border）可以有多种用途，比如作为装饰元素或者作为划分两物的分界线。在设<br>置边框方面，CSS 为你提供了无尽选择。</p><p>• border-width<br>• border-color<br>• border-style</p><h2 id="边框宽度-border-width-："><a href="#边框宽度-border-width-：" class="headerlink" title="边框宽度[border-width]："></a>边框宽度[border-width]：</h2><p>边框宽度由 CSS 属性 border-width 定义，其值可以是“thin”（薄）、“medium”（普通 ）<br>或“thick”（厚）等，也可以是像素值。</p><h2 id="边框颜色-border-color-："><a href="#边框颜色-border-color-：" class="headerlink" title="边框颜色[border-color]："></a>边框颜色[border-color]：</h2><p>CSS 属性 border-color 用于定义边框的颜色。其值就是正常的颜色值，例如：“#123456”、<br>“rgb(123,123,123)”、“yellow”等。</p><h2 id="边框样式-border-style-："><a href="#边框样式-border-style-：" class="headerlink" title="边框样式[border-style]："></a>边框样式[border-style]：</h2><p>边框样式有多种可供选择。</p><h2 id="缩写-border-："><a href="#缩写-border-：" class="headerlink" title="缩写[border]："></a>缩写[border]：</h2><p>跟许多其他属性一样，你也可以将有关边框的 CSS 属性缩写为一个 border 属性。</p><h2 id="相对定位："><a href="#相对定位：" class="headerlink" title="相对定位："></a>相对定位：</h2><p>要对元素进行相对定位，应将 position 属性的值设为relative。<br>绝对定位与相对定位的区别在于计算位置的方式。</p><p>采用相对定位的元素，其位置是相对于它在文档中的原始位置计算而来的。<br>这意味着 ，相对定位是通过将元素从原来的位置向右、向左、向上或向下移动来定位的。<br>采用相对定位的元素会获得相应的空间。</p><h2 id="HTML-中框架、层的运用"><a href="#HTML-中框架、层的运用" class="headerlink" title="HTML  中框架、层的运用"></a>HTML  中框架、层的运用</h2><p>掌握框架结构<frameset><frame><iframe><br>掌握组织元素：span 和 div</iframe></frameset></p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>使用框架，可以在一个浏览器窗口中显示不止一个 HTML 文档。<br>这样的 HTML 文档被称为框架页面，它们是相互独立的。：</p><p>使用框架的不利因素有：</p><p>• 网站开发者需要关心更多 HTML 文档的情况。<br>• 打印整个页面变得困难。</p><p>frameset 标签：</p><p>• <frameset>标签定义了如何将窗口拆分成框架。<br>• 每个 frameset 标签定义了一组行和列。<br>• 行/列的值指明了每个行/列在屏幕上所占的大小</frameset></p><p>frame标签：</p><p>• <frame>标签定义了每个框架中放入什么文件。</p><p>基本注意点——有用的技巧：</p><p>假如一个框架有可见边框，用户可以拖动边框来改变它的大小。<br>如果不想让用户改变大小，可以在<frame>标签中加入：noresize=”noresize”。<br>给不支持框架的浏览器写上<noframes>标签。</noframes></p><h2 id="内联框架："><a href="#内联框架：" class="headerlink" title="内联框架："></a>内联框架：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;iframe src=&quot;intro.htm&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;p&gt;Some older browsers don&apos;t support iframes.&lt;/p&gt;</span><br><span class="line">&lt;p&gt;If they don&apos;t, the iframe will not be visible.&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="组织元素-：-span-和-和-div"><a href="#组织元素-：-span-和-和-div" class="headerlink" title="组织元素 ： span  和 和  div"></a>组织元素 ： span  和 和  div</h2><p>span 和 div 元素用于组织和结构化文档，并经常联合 class 和 id 属性一起使用。</p><p>用 span 组织元素：</p><p>span 元素可以说是一种中性元素，因为它不对文档本身添加任何东西。<br>但是与 CSS 结合使用的话，span 可以对文档中的部分文本增添视觉效果。</p><h2 id="XML-基本知识"><a href="#XML-基本知识" class="headerlink" title="XML  基本知识"></a>XML  基本知识</h2><p>XML  的应用范围<br>人类一直在不断地尝试改进自己的发明，其中也包括人类最伟大的发明——文字的构成。<br>第一个文本处理系统是用纸笔记录文字。现在，计算机文本处理器已经取代了手工处理，它不仅包含原始文档，还负责设置格式、出版和管理。在这些方便的功能整合到字处理之前，是由排字工人遵循书面标记说明来完成所有格式编排的。<br>正是利益于这种实践，人们将“标记”这个词加入到 HTML 和 XML。顾名思义，标记是指加上记号。<br>文本处理环境（如 XML）中使用了相同的标记过程。</p><p>使用脚本语言或 DHTML 能够以各种方式显示信息。<br>这就要求必须为相同的输出编写不同的代码以供不同的浏览器使用，因为这些语言不能跨浏览器兼容。</p><p>XML（eXtensible Markup Language，可扩展标记语言）克服了这些缺点。<br>顾名思义，XM L是可扩展的，即开发人员可以定义自己的一组标签，并使其他的人或程序能够理解这些标签。</p><p>HTML 是单标记语言，为特定应用设计，而 XML 则是一系列的标记语言。<br>因此 ，XML 比 HTML 灵活得多。</p><p>实际上，由于 XML 标签表示了数据的逻辑结构，不同的应用可以通过不同的方式来解释和使用这些标签。<br>Web 上的数据大多是继承的，XML 继承了 SGML 和 HTML 的优点。<br>也就是说，它不仅继承了 SGML 的特色，还结合了 HTM L的特色。</p><p>它采用了 SGML 的主要框架，有时，人们也将 XML 称为 SGML 的子集。<br>因此 ，HTML 是 SGML 的应用，而 XML 是 SGML 的子集。</p><p>使用标签对文档进行标记以提供有关内容的信息，不仅能加快搜索速度，而且还能降低网络流量。<br>XML 是由 SGML 修整并改造而来，它是一种元语言，用于描述其他语言。</p><p>我们可以使用 XML 为特定目的创建自己的标记语言（如化学标记语言）。</p><p>XML 是基于文本的格式，允许开发人员描述结构化数据并在各种应用之间发送和交换这些数据，这样客户端就可以显示并自定义数据。</p><p>XML 还有助于在服务器之间传输结构化数据。</p><p>有许多信息是分布在不同的和不匹配的数据库中。</p><p>如有必要，XML 允许通过使用自定义格式来标识、交换和处理这些数据库可以理解的数据。</p><p>XML 和 HTML 有许多相同点和不同点。XML描述数据，如城市名称、温度和气压；HTML定义描述数据显示方式的标签，如使用项目符号列表或表格。</p><p>但 XML 允许开发人员定义任意数量的标签集，使用开发人员有很大的灵活性来决定要使用哪些数据，并确定数据的适用标准或自定义标签。</p><h2 id="L-XML-的-文档-结构"><a href="#L-XML-的-文档-结构" class="headerlink" title="L XML  的 文档 结构"></a>L XML  的 文档 结构</h2><p>XML 文档是由一组使用唯一名称标识的实体组成。</p><p>所有文档都以根或文档实体开始，而且所有实体都是可选的。</p><p>实体可以被视为更复杂功能的别名。单个实体名称可以代替许多文本。</p><p>在别名方案中，每当需要引用某个文本时，只需要使用别名，处理器会展开别名的内容。</p><p>XML 文档也有一种逻辑结构。</p><p>ok,完</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HTML" scheme="https://huangguangda.github.io/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://huangguangda.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>必背面试题</title>
    <link href="https://huangguangda.github.io/2018/05/16/1/"/>
    <id>https://huangguangda.github.io/2018/05/16/1/</id>
    <published>2018-05-16T00:57:24.000Z</published>
    <updated>2018-07-23T18:37:59.919Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>1 抽象类和接口的区别?</p><p>抽象类：</p><p>1）抽象方法，只有行为的概念，没有具体的行为实现。使用abstract关键字修饰，没有方法体。子类必须重写这些抽象方法。<br>2）包含抽象方法的类，一定是抽象类。<br>3）抽象类只能被继承，一个类只能继承一个抽象类。</p><p>接口：</p><p>1）全部的方法都是抽象方法，属型都是常量<br>2）不能实例化，可以定义变量。<br>3）接口变量可以引用具体实现类的实例<br>4）接口只能被实现，一个具体类实现接口，必须实现全部的抽象方法<br>5）接口之间可以多实现<br>6）一个具体类可以实现多个接口，实现多继承现象</p><h2 id="列举你所知道的线程同步的方法"><a href="#列举你所知道的线程同步的方法" class="headerlink" title="列举你所知道的线程同步的方法"></a>列举你所知道的线程同步的方法</h2><p>wait():让线程等待。将线程存储到一个线程池中。</p><p>notify()：唤醒被等待的线程。通常都唤醒线程池中的第一个。让被唤醒的线程处于临时阻塞状态。</p><p>notifyAll(): 唤醒所有的等待线程。将线程池中的所有线程都唤醒。</p><h2 id="简述String和StringBuffer、ArrayList和LinkedList、HashMap和HashTable的特点及区别。"><a href="#简述String和StringBuffer、ArrayList和LinkedList、HashMap和HashTable的特点及区别。" class="headerlink" title="简述String和StringBuffer、ArrayList和LinkedList、HashMap和HashTable的特点及区别。"></a>简述String和StringBuffer、ArrayList和LinkedList、HashMap和HashTable的特点及区别。</h2><p>答:</p><p>String 对象的长度一旦定义就固定就不可以改变，</p><p>对于已经存在的String对象的修改都是创建一个新的对象，</p><p>然后把新的值存进去,</p><p>String类不能被继承。</p><p>StringBuffer是一个可变对象，</p><p>当对它进行修改的时候不会像String那样重新建立对象。</p><p>它只能通过构造函数来建立对象。</p><p>另外StringBuffer还是一个线程安全的类。</p><p>ArrayList是实现了基于动态数组的数据结构用于，LinkedList基于连表的数据结构，</p><p>二者都可以存储对象的引用。</p><p>对于随机访问get和set，ArrayList优于LinkedList，</p><p>因为LinkedList要移动指针。</p><p>对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p><p>HashMap是Hashtable的轻量级实现（非线程安全的实现），</p><p>他们都完成了Map接口，</p><p>主要区别在于HashMap允许空（null）键值（key）,</p><p>由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。</p><p>HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p><p>HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。</p><p>因为contains方法容易让人引起误解。</p><p>Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</p><p>最大的不同是，</p><p>Hashtable的方法是Synchronize的，而HashMap不是，</p><p>在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</p><p>Hashtable和HashMap</p><p>采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</p><p>就HashMap与HashTable主要从三方面来说。</p><p>一. 历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现<br>二. 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的<br>三. 值：只有HashMap可以让你将空值作为一个表的条目的key或value</p><h2 id="什么是java序列化，如何事件java序列化"><a href="#什么是java序列化，如何事件java序列化" class="headerlink" title="什么是java序列化，如何事件java序列化"></a>什么是java序列化，如何事件java序列化</h2><p>序列化就是一种用来处理对象流的机制，<br>所谓对象流也就是将对象的内容进行流化。</p><p>可以对流化后的对象进行读写操作，<br>也可将流化后的对象传输于网络之间。</p><p>序列化是为了解决在对对象流进行读写操作时所引发的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Cat implements Serializable ｛｝</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">Try&#123;</span><br><span class="line">   FileOutputStream fos = new FileOutputStream(&quot;catDemo.out&quot;);</span><br><span class="line">   ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class="line">   System.out.println(&quot; 1&gt; &quot; + cat.getName());</span><br><span class="line">   cat.setName(&quot;My Cat&quot;);                        </span><br><span class="line">   oos.writeObject(cat);</span><br><span class="line">   oos.close();        </span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="多线程有几种实现方式，同步有几种实现方式，stop-和suspend-方法为什么不推荐使用"><a href="#多线程有几种实现方式，同步有几种实现方式，stop-和suspend-方法为什么不推荐使用" class="headerlink" title="多线程有几种实现方式，同步有几种实现方式，stop()和suspend()方法为什么不推荐使用"></a>多线程有几种实现方式，同步有几种实现方式，stop()和suspend()方法为什么不推荐使用</h2><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 </p><p>同步的实现方面有两种，分别是synchronized,wait与notify”</p><p>反对使用stop()，是因为它不安全。</p><p>它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。</p><p>结果很难检查出真正的问题所在。</p><p>suspend()方法容易发生死锁。 </p><p>调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。</p><p>此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。</p><p>对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。</p><p>所以不应该使用suspend()，而应在自己的 Thread类中置入一个标志，</p><h2 id="简述你对java反射机制的理解"><a href="#简述你对java反射机制的理解" class="headerlink" title="简述你对java反射机制的理解"></a>简述你对java反射机制的理解</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</p><p>对于任意一个对象，都能够调用它的任意一个方法和属性</p><h2 id="写下你对多线程的理解，怎么创建一个线程以及线程同步的方法。"><a href="#写下你对多线程的理解，怎么创建一个线程以及线程同步的方法。" class="headerlink" title="写下你对多线程的理解，怎么创建一个线程以及线程同步的方法。"></a>写下你对多线程的理解，怎么创建一个线程以及线程同步的方法。</h2><p>1.多线程是操作系统的重要部分，可以提高应用程序的效率，将耗时操作放进工作线程，可以有效提高用户体验。</p><p>2.new Thread().start，在方法中重写run方法；新建类实现Runable接口，重写其抽象方法</p><p>3.public static synchronized void test() {  }<br>  public void test2() { synchronized(lock){  }}</p><h2 id="从操作系统角度请阐述一下线程与进程的区别"><a href="#从操作系统角度请阐述一下线程与进程的区别" class="headerlink" title="从操作系统角度请阐述一下线程与进程的区别"></a>从操作系统角度请阐述一下线程与进程的区别</h2><p>答：</p><p>进程是系统进行资源分配和调度的一个独立单位，线程是CPU调度和分派的基本单位</p><p>进程和线程的关系：</p><p>（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</p><p>（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。</p><p>（3）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p>（5）线程是指进程内的一个执行单元，也是进程内的可调度实体。</p><p>线程与进程的区别：</p><p>（1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。</p><p>（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。</p><p>（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p><p>（4）系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。</p><h2 id="Android系统的架构，采用了分层的架构，从高层到底层分别是："><a href="#Android系统的架构，采用了分层的架构，从高层到底层分别是：" class="headerlink" title="Android系统的架构，采用了分层的架构，从高层到底层分别是："></a>Android系统的架构，采用了分层的架构，从高层到底层分别是：</h2><p>1.Android系统架构之应用程序</p><p>Android会同一系列核心应用程序包一起发布，该应用程序包包括email客户端，SMS短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA语言编写的。</p><p>2.Android系统架构之应用程序框架</p><p>开发人员可以完全访问核心应用程序所使用的API框架（android.jar）。该应用程序的架构设计简化了组件的重用;任何一个应用程序都可以发布它的功能块并且任何其它的应用程序都可以使用其所发布的功能块。</p><p>3.Android系统架构之系统运行库</p><p>1)程序库<br>Android 包含一些C/C++库，这些库能被Android系统中不同的组件使用。它们通过 Android 应用程序框架为开发者提供服务。</p><p>4.Android系统架构之Linux 内核</p><p>Android 的核心系统服务依赖于 Linux 2.6 内核，如安全性，内存管理，进程管理， 网络协议栈和驱动模型。 Linux 内核也同时作为硬件和软件栈之间的抽象层。</p><h2 id="消息推送的方式有哪几种，每种方式的优缺点是什么？"><a href="#消息推送的方式有哪几种，每种方式的优缺点是什么？" class="headerlink" title="消息推送的方式有哪几种，每种方式的优缺点是什么？"></a>消息推送的方式有哪几种，每种方式的优缺点是什么？</h2><p>前Android上主要的推送实现方案有以下几种：</p><p>方案1、使用极光和友盟推送。</p><p>方案2、使用XMPP协议（Openfire + Spark + Smack）</p><p>简介：基于XML协议的通讯协议，前身是Jabber，目前已由IETF国际标准化组织完成了标准化工作。</p><p>优点：协议成熟、强大、可扩展性强、目前主要应用于许多聊天系统中，且已有开源的Java版的开发实例androidpn。</p><p>缺点：协议较复杂、冗余（基于XML）、费流量、费电，部署硬件成本高。</p><p>方案3、使用MQTT协议（更多信息见：<a href="http://mqtt.org/）" target="_blank" rel="noopener">http://mqtt.org/）</a></p><p>简介：轻量级的、基于代理的“发布/订阅”模式的消息传输协议。</p><p>优点：协议简洁、小巧、可扩展性强、省流量、省电，目前已经应用到企业领域（参考：<a href="http://mqtt.org/software），且已有C++版的服务端组件rsmb。" target="_blank" rel="noopener">http://mqtt.org/software），且已有C++版的服务端组件rsmb。</a></p><p>缺点：不够成熟、实现较复杂、服务端组件rsmb不开源，部署硬件成本较高。</p><p>方案4、使用HTTP轮循方式</p><p>简介：定时向HTTP服务端接口（Web Service API）获取最新消息。</p><p>优点：实现简单、可控性强，部署硬件成本低。</p><p>缺点：实时性差。</p><h2 id="android的数据存储的方式"><a href="#android的数据存储的方式" class="headerlink" title="android的数据存储的方式?"></a>android的数据存储的方式?</h2><p>答：</p><p>Android提供了5种方式存储数据：</p><p>（1）使用SharedPreferences存储数据；</p><p>它是Android提供的用来存储一些简单配置信息的一种机制，采用了XML格式将数据存储到设备中。只能在同一个包内使用，不能在不同的包之间使用。</p><p>（2）文件存储数据；</p><p>文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。</p><p>（3）SQLite数据库存储数据；</p><p>SQLite是Android所带的一个标准的数据库，它支持SQL语句，它是一个轻量级的嵌入式数据库。</p><p>（4）使用ContentProvider存储数据；</p><p>主要用于应用程序之间进行数据交换，从而能够让其他的应用保存或读取此Content Provider的各种数据类型。</p><p>（5）网络存储数据；</p><p>通过网络上提供给我们的存储空间来上传(存储)和下载(获取)我们存储在网络空间中的数据信息。</p><h2 id="横竖屏切换时候activity的生命周期"><a href="#横竖屏切换时候activity的生命周期" class="headerlink" title="横竖屏切换时候activity的生命周期?"></a>横竖屏切换时候activity的生命周期?</h2><p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新 调用各个生命周期，只会执行onConfigurationChanged方法</p><h2 id="Android中动画分为哪几类-他们的特点和区分有那些"><a href="#Android中动画分为哪几类-他们的特点和区分有那些" class="headerlink" title="Android中动画分为哪几类?他们的特点和区分有那些?"></a>Android中动画分为哪几类?他们的特点和区分有那些?</h2><p>一种是tweened animation(补间动画) </p><p>一种是frame by frame(逐帧动画) </p><p>特点：</p><p>补间动画是通过改变view的大小、旋转的角度、透明度、位置来产生动画，可以控制动画的播放快慢以及加速度。</p><p>逐帧动画是用一组图片轮流绘制，产生动画的感觉。类似于gif图片。</p><p>区别：</p><p>补间动画的所有操作是通过矩阵变换对同一个物体（绘制的一个view或者图片）进行操作产生动画。</p><p>而逐帧动画是多个物体（多张图片）进行绘制，可以说这多张图片是不相关的（从播放的角度来看只能说是内容相关）。</p><h2 id="请解释下在单线程模式中Message-Handler-MessageQueue-Looper之间的关系解释下"><a href="#请解释下在单线程模式中Message-Handler-MessageQueue-Looper之间的关系解释下" class="headerlink" title="请解释下在单线程模式中Message,Handler,MessageQueue,Looper之间的关系解释下."></a>请解释下在单线程模式中Message,Handler,MessageQueue,Looper之间的关系解释下.</h2><p>Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理. </p><p>Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列. </p><p>Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息. </p><p>Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。 </p><p>Looper也把消息队列里的消息广播给所有的Handler：Handler接受到消息后调用handleMessage进行处理.</p><h2 id="说说mvc模式的原理-它在android中的运用"><a href="#说说mvc模式的原理-它在android中的运用" class="headerlink" title="说说mvc模式的原理,它在android中的运用"></a>说说mvc模式的原理,它在android中的运用</h2><p>答：</p><p>android的官方建议应用程序的开发采用mvc模式。何谓mvc？</p><p>mvc是model,view,controller的缩写，mvc包含三个部分：</p><p>l模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。</p><p>2视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。</p><p>3控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，想用用户出发的相关事件，交给m哦得了处理。</p><p>在android中mvc的具体体现如下：</p><p>  1)视图层（view）：</p><p>一般采用xml文件进行界面的描述，</p><p>使用的时候可以非常方便的引入，当然，如何你对android了解的比较的多了话，就一定 可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通 信，幸运的是，android提供了它们之间非常方便的通信实现。</p><p>　2)控制层（controller）：</p><p>android的控制层的重 任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理， 这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。</p><p>　3)模型层（model）：</p><p>对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p><h2 id="请描述下Activity的生命周期"><a href="#请描述下Activity的生命周期" class="headerlink" title="请描述下Activity的生命周期."></a>请描述下Activity的生命周期.</h2><p>onCreate(Bundle savedInstanceState)：创建activity时调用。</p><p>设置在该方法中，还以Bundle的形式提供对以前储存的任何状态的访问！</p><p>onStart()：activity变为在屏幕上对用户可见时调用。</p><p>onResume()：activity开始与用户交互时调用（无论是启动还是重新启动一个活动，该方法总是被调用的）。 </p><p>onPause()：activity被暂停或收回cpu和其他资源时调用，该方法用于保存活动状态的，也是保护现场，压栈吧！</p><p>onStop()：activity被停止并转为不可见阶段及后续的生命周期事件时调用。</p><p>onRestart()：重新启动activity时调用。该活动仍在栈中，而不是启动新的活动。</p><p>OnDestroy()：activity被完全从系统内存中移除时调用该方法</p><h2 id="Android中4大组件有哪些-他们的作用是什么"><a href="#Android中4大组件有哪些-他们的作用是什么" class="headerlink" title="Android中4大组件有哪些?他们的作用是什么?"></a>Android中4大组件有哪些?他们的作用是什么?</h2><p>Activity：</p><p>Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑。 </p><p>service：</p><p>后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事务，定义好需要接受的Intent提供同步和异步的接口。 </p><p>Content Provider：</p><p>是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的接口模型，大大简化上层应用，对数据的整合提 供了更方便的途径。 </p><p>BroadCast Receiver：</p><p>接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型。 </p><h2 id="Activity有哪4种启动模式-有哪些特点"><a href="#Activity有哪4种启动模式-有哪些特点" class="headerlink" title="Activity有哪4种启动模式?有哪些特点?"></a>Activity有哪4种启动模式?有哪些特点?</h2><p>standard 默认模式 ——— 来了intent，每次都创建新的实例。</p><p>singleTop ——– 来了intent, 每次都创建新的实例，仅一个例外：当栈顶的activity恰恰就是该activity的实例（即需要创建的实例)时，不再创建新实例。</p><p>这解决了栈顶复用问题，想一想，你按两次back键，退出的都是同一个activity，这感觉肯定不爽。</p><p>singleTask ———- 来了intent后，检查栈中是否存在该activity的实例，如果存在就把intent发送给它，否则就创建一个新的该activity的实例，栈中只能有它一个该activity实例，但允许其他activity加入该栈。解决了在一 个task中共享一个activity。</p><p>singleInstance ———– 肯定位于一个task的栈底,并且是该栈唯一的activity。解决了多个task共享一个activity。</p><h2 id="注册广播有几种方式-这些方式有何特点"><a href="#注册广播有几种方式-这些方式有何特点" class="headerlink" title="注册广播有几种方式,这些方式有何特点?"></a>注册广播有几种方式,这些方式有何特点?</h2><p>1)动态代码注册不是常驻型广播，也就是说广播跟随程序的生命周期。</p><p>2)清单文件注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p><h2 id="谈谈对android内存优化的方法-方案-规则及对内存泄漏如何避免"><a href="#谈谈对android内存优化的方法-方案-规则及对内存泄漏如何避免" class="headerlink" title="谈谈对android内存优化的方法,方案,规则及对内存泄漏如何避免"></a>谈谈对android内存优化的方法,方案,规则及对内存泄漏如何避免</h2><p>OOM即Out Of Memory,一般是由程序编写者对内存使用不当，如对该释放的内存资源没有释放，导致其一直不能被再次使用而使内存被耗尽的现象。根本的解决办法是对代码进行优化:在内存引用上做些处理，使用软引用、虚引用、和弱引用；在内存中加载图片时直接在内存中做处理，如边界压缩等；建立动态回收内存机制；优化Dalvik虚拟机的堆内存分配；自定义堆内存大小等。</p><p>一般而言，android中常见的原因主要有以下几个：</p><p>1.数据库的cursor没有关闭。<br>2.构造adapter没有使用缓存contentview。<br>3.调用registerReceiver()后未调用unregisterReceiver().<br>4.未关闭InputStream/OutputStream。<br>5.Bitmap使用后未调用recycle()。<br>6.Context泄漏。<br>7.static关键字等。</p><h2 id="启动service有几种方式，说出他们之间的主要区别"><a href="#启动service有几种方式，说出他们之间的主要区别" class="headerlink" title="启动service有几种方式，说出他们之间的主要区别"></a>启动service有几种方式，说出他们之间的主要区别</h2><p>答：</p><p>调用startService()：通过此种方法启动的service会一直运行在后台直到stopService()或stopSelf()方法被调用。</p><p>调用bindService()：通过此种方法启动的service会与调用者绑定，如果这个service还没有被启动，那么service启动时将不会调用onStart()，只调用onCreate()和onBind()，调用者被销毁时，service也被销毁</p><h2 id="intent-putExtra时，如果传递的不是基本类型，而是一个”Object”，那么对这个对象有什么要求？还是说任何对象都可以进行传递？"><a href="#intent-putExtra时，如果传递的不是基本类型，而是一个”Object”，那么对这个对象有什么要求？还是说任何对象都可以进行传递？" class="headerlink" title="intent.putExtra时，如果传递的不是基本类型，而是一个”Object”，那么对这个对象有什么要求？还是说任何对象都可以进行传递？"></a>intent.putExtra时，如果传递的不是基本类型，而是一个”Object”，那么对这个对象有什么要求？还是说任何对象都可以进行传递？</h2><p>答：</p><p>必须实现Serializable接口，或者实现Parcelable接口的对象才可以进行传递。  </p><h2 id="当调用startActivityForResult时，如何获取并处理返回的结构"><a href="#当调用startActivityForResult时，如何获取并处理返回的结构" class="headerlink" title="当调用startActivityForResult时，如何获取并处理返回的结构"></a>当调用startActivityForResult时，如何获取并处理返回的结构</h2><p>答：</p><p>通过onActivityResult(int requestCode, int resultCode, Intent data)处理返回的数据<br>requestCode：调用startActivityForResult(Intent intent, int requestCode)时传递过去的请求码。</p><p>resultCode：被调用的Activity执行setResult(int resultCode, Intent intent)时传递的结果码，一般有RESULT_CANCELED，RESULT_OK等，用于区分被调用的Activity传回的不同结果</p><p>data：被调用的Activity传回来的数据，可以用data.getExtras()得到数据，用Bundle类型的变量来接收，调用get…(String key)来获取对应的值</p><h2 id="使用startService（）和bindService（）启一个Service，这个Sercice的生命周期会有哪里不同？"><a href="#使用startService（）和bindService（）启一个Service，这个Sercice的生命周期会有哪里不同？" class="headerlink" title="使用startService（）和bindService（）启一个Service，这个Sercice的生命周期会有哪里不同？"></a>使用startService（）和bindService（）启一个Service，这个Sercice的生命周期会有哪里不同？</h2><p>  答:</p><p>   1.Context.startService()方式的生命周期： </p><p>   启动时，startService –&gt; onCreate() –&gt; onStart()停止时，stopService –&gt; onDestroy()</p><p>   如果调用者直接退出而没有停止Service，则Service 会一直在后台运行</p><p>   Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，</p><p>   接着调用onStart()方法。</p><p>   如果调用startService()方法前服务已经被创建，</p><p>   多次调用startService()方法并不会导致多次创建服务，</p><p>   但会导致多次调用onStart()方法。</p><p>   采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法附代码</p><p>2.Context.bindService()方式启动：</p><p>①Context.bindService()方式的生命周期： </p><p>绑定时,bindService -&gt; onCreate() –&gt; onBind()调用者退出了，</p><p>即解绑定时,Srevice就会unbindService –&gt;onUnbind() –&gt; onDestory()</p><p>Context.bindService()方式启动 </p><p>Service的方法：</p><p>绑定Service需要三个参数：bindService(intent, conn, Service.BIND_AUTO_CREATE);</p><p>第一个：Intent对象</p><p>第二个：ServiceConnection对象，</p><p>创建该对象要实现它的onServiceConnected()和 onServiceDisconnected()来判断连接成功或者是断开连接</p><p>第三个：如何创建Service，一般指定绑定的时候自动创建。</p><h2 id="Android中什么是ANR-如何应对或者如何避免它？"><a href="#Android中什么是ANR-如何应对或者如何避免它？" class="headerlink" title="Android中什么是ANR,如何应对或者如何避免它？"></a>Android中什么是ANR,如何应对或者如何避免它？</h2><p>答:  ANR 就是application not responding<br>    在android中Activity的最长执行时间是5秒.</p><p>BroadcastReceiver的最长执行时间则是10秒.</p><p>超出执行时间就会产生ANR.</p><p>解决方法: </p><ol><li>运行在主线程里的任何方法都尽可能少做事情。</li></ol><p>特别是，Activity应该在它的关键生命周期方法 （如onCreate()和onResume()）里尽可能少的去做创建操作。<br>（可以采用重新开启子线程的方式，然后使用Handler+Message 的方式做一些操作，比如更新主线程中的ui等）</p><ol start="2"><li>应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。</li></ol><p>但不再是在子线程里做这些任务（因为 BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个 Service。</p><h2 id="AIDL-的全称是什么？如何工作？能处理哪些类型的数据？"><a href="#AIDL-的全称是什么？如何工作？能处理哪些类型的数据？" class="headerlink" title="AIDL 的全称是什么？如何工作？能处理哪些类型的数据？"></a>AIDL 的全称是什么？如何工作？能处理哪些类型的数据？</h2><p> 答:  AIDL: (Android Interface Definition Language)跨进程通信传输语言</p><p>   如何工作:AIDL文件由自己定义,在被绑定的Service中和绑定的客户端中都要部署</p><p>1.创建AIDL文件, 在这个文件里面定义接口, 该接口定义了可供客户端访问的方法和属性。<br>2、编译AIDL文件, 用Ant的话, 可能需要手动, 使用Eclipse plugin的话,可以根据adil文件自动生产java文件并编译, 不需要人为介入.<br>3、在Java文件中, 实现 AIDL中定义的接口. 编译器会根据AIDL接口, 产生一个JAVA接口。这个接口有一个名为Stub的内部抽象类，它继承扩展  了接口并实现了远程调 用需要的几个方法(是Binder的子类)。</p><p>接下来就需   要自己去实现自定义的几个接口了.</p><p>4.第一个程序的Service:因为跨进程传递时利用Binder对象来实现的,所以我们要在Service端构建Binder对象,又因为我们定义的接口AIDL文件在编译转成.java时的内部类Sub实现了Binder,所以我们构建Binder对象时构建实例内部类直接继承Sub内部类,在类中我们可以调用Service中的方法,此类的对象也就是Binder对象.</p><p>5.第二个程序的Activity:在Activity中我们利用bindService方法启动一个绑定的Service的同时需要传入连接对象,所以我们先在Activity中构建Service的连接对象,在该对象的匿名内部类中重写获得Binder对象的方法,参数含有Binder对象,将此对象强制转换成我们在Service中继承Sub的类的对象,强转后我们可以利用该对象调用Service中的方法,从而实现跨进程通信,控制Service.</p><h2 id="请简单介绍一下NDK。"><a href="#请简单介绍一下NDK。" class="headerlink" title="请简单介绍一下NDK。"></a>请简单介绍一下NDK。</h2><p>NDK全称：Native Development Kit。</p><p>1、NDK是一系列工具的集合。</p><ul><li>NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。</li></ul><h2 id="你后台的Activity被系统回收怎么办："><a href="#你后台的Activity被系统回收怎么办：" class="headerlink" title="你后台的Activity被系统回收怎么办："></a>你后台的Activity被系统回收怎么办：</h2><p>当你的程序中某一个Activity A 在运行时中，主动或被动地运行另一个新的Activity B 这个时候A会执行<br>Java代码</p><p>public<br>void onSaveInstanceState(Bundle outState) {<br>super.onSaveInstanceState(outState);<br>outState.putLong(“id”, 1234567890);<br>}<br>public void<br>onSaveInstanceState(Bundle outState) {</p><p>B 完成以后又会来找A, 这个时候就有两种情况，一种是A被回收，一种是没有被回收，被回 收的A就要重新调用onCreate()方法，不同于直接启动的是这回 onCreate()里是带上参数 savedInstanceState，没被收回的就还是onResume就好了。</p><p>savedInstanceState是一个Bundle对象，你基本上可以把他理解为系统帮你维护的一个Map对象。在onCreate()里你可能会用到它，如果正常启动onCreate就不会有它，所以用的时候要判断一下是否为空。</p><p>Java代码<br>if(savedInstanceState !=null){<br>long id =savedInstanceState.getLong(“id”);<br>}<br>if(savedInstanceState !=null){<br>就像官方的Notepad教程里的情况，你正在编辑某一个note，突然被中断，那么就把这个note的id记住，再起来的时候就可以根据这个id去把那个note取出来。</p><h2 id="怎么优化listview"><a href="#怎么优化listview" class="headerlink" title="怎么优化listview"></a>怎么优化listview</h2><p>1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。<br>2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。<br>3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。<br>4、设置listview的监听器，如果listview是飞快滑动状态则不更新view</p><h2 id="根据自己的理解描述下Android数字签名。"><a href="#根据自己的理解描述下Android数字签名。" class="headerlink" title="根据自己的理解描述下Android数字签名。"></a>根据自己的理解描述下Android数字签名。</h2><p>(1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序</p><p>(2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证</p><p>(3)如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名。</p><p>(4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。</p><h2 id="简述Android-root机制"><a href="#简述Android-root机制" class="headerlink" title="简述Android root机制"></a>简述Android root机制</h2><p>答:</p><p>root指的是你有权限可以再系统上对所有档案有 “读” “写” “执行”的权力。root机器不是真正能让你的应用程序具有root权限。它原理就跟linux下的像sudo这样的命令。在系统的bin目录下放个su程序并属主是root并有suid权限。则通过su执行的命令都具有Android root权限。当然使用临时用户权限想把su拷贝的/system/bin目录并改属性并不是一件容易的事情。这里用到2个工具跟2个命令。把busybox拷贝到你有权限访问的目录然后给他赋予4755权限，你就可以用它做很多事了。</p><h2 id="进程间通信机制，传统IPC-和-Binder"><a href="#进程间通信机制，传统IPC-和-Binder" class="headerlink" title="进程间通信机制，传统IPC 和 Binder"></a>进程间通信机制，传统IPC 和 Binder</h2><p>答:</p><p>传统的进程间通信机制IPC 有管道（Pipe）、信号（Signal）和跟踪（Trace），这三项通信手段只能用于父进程和子进程之间，或者兄弟进程之间；后来又增加了命令管道（Named Pipe）,使得进程间通信不再局限于父子进程或兄弟进程之间。后来又出现了报文队列（Message）、共享内存（Share Memeory）和信号量（Semaphore）。Android系统没有采用上述提到的各种进程间通信机制，而是采用Binder机制，它是基于OpenBinder来实现的。<br>它提供了远程过程调用（RPC）功能，在Android系统的Binder机制中，有一系列组件组成包括 Client、Server、ServiceManager和Binder驱动程序。</p><h2 id="Serializable和Parcelable的特点及比较"><a href="#Serializable和Parcelable的特点及比较" class="headerlink" title="Serializable和Parcelable的特点及比较"></a>Serializable和Parcelable的特点及比较</h2><p>答:</p><p>Serializable和Parcelable二者都是实现序列化的接口。Parcelable,定义了将数据写入Parcel，和从Parcel中读出的接口。一个实体（用类来表示），如果需要封装到消息中去，就必须实现这一接口，实现了这一接口，该实体就成为“可打包的”了。</p><p>一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才是可序列化的。</p><p>因此如果要序列化某些类的对象，这些类就必须实现Serializable接口。而实际上，Serializable是一个空接口，没有什么具体内容，它的目的只是简单的标识一个类的对象可以被序列化。Serializable的实现，只需要implements Serializable即可，这只是给对象打了一个标记，系统会自动将其序列化。</p><p>Parcelable的实现，需要在类中添加一个静态成员变量CREATOR，这个变量需要继承Parcelable.Creator接口。</p><p>比较:</p><p>Serializable是Java.io中的，不可被activity中的内部类被继承，否则出错；Parcelable是Android特有的，比Serializable节省内存，可以传递Bundle对象，当我们有boolean型的变量可以现存在Bundle中。</p><h2 id="View、surfaceView、GLSurfaceView有什么区别"><a href="#View、surfaceView、GLSurfaceView有什么区别" class="headerlink" title="View、surfaceView、GLSurfaceView有什么区别"></a>View、surfaceView、GLSurfaceView有什么区别</h2><p>View：</p><p>显示视图，<br>内置画布，<br>提供图形绘制函数、<br>触屏事件、<br>按键事件函数等，<br>必须在UI主线程内更新画面，速度较慢</p><p>SurfaceView：</p><p>基于view视图进行拓展的视图类，<br>更适合2D游戏的开发，<br>是view的子类，<br>类似使用双缓机制，<br>在新的线程中更新画面所以刷新界面速度比view快</p><p>GLSurfaceView：</p><p>基于SurfaceView视图再次进行拓展的视图类，<br>专用于3D游戏开发的视图，<br>是surfaceView的子类，<br>openGL专用</p><h2 id="你曾经用到的android手机访问服务端的方式有哪些？"><a href="#你曾经用到的android手机访问服务端的方式有哪些？" class="headerlink" title="你曾经用到的android手机访问服务端的方式有哪些？"></a>你曾经用到的android手机访问服务端的方式有哪些？</h2><p>Android手机访问服务端的方式有两种，分别是：通过socket访问和通过Http协议发送Post和Get请求。</p><p>   Socket是长连接，服务端和客户端之间通过Socket建立连接，首先ServerSocket将在服务端监听某个端口，当发现客户端有Socket来试图连接它时，它会接受该Socket的连接请求，同时在服务端建立一个对应的Socket与之进行通信。这样就有两个Socket了，客户端和服务端各一个。</p><p>   发送get和post协议，通过HTTP协议建立短连接。客户端发送请求（Request），服务器端收到后根据请求的类型返回相应的响应（response）。</p><h2 id="什么是TCP和IP，它们位于网络模型的哪层？"><a href="#什么是TCP和IP，它们位于网络模型的哪层？" class="headerlink" title="什么是TCP和IP，它们位于网络模型的哪层？"></a>什么是TCP和IP，它们位于网络模型的哪层？</h2><p>TCP是传输控制协议，<br>IP是internet协议，</p><p>TCP在网络模型中与UDP一样同属于第二层(传输层)，</p><p>IP属于三层(网络层)，</p><p>IP用于确定主机在网络中的位置，而TCP与UDP用于标示不同的服务，即应用程序。</p><h2 id="Xml和json的区别"><a href="#Xml和json的区别" class="headerlink" title="Xml和json的区别"></a>Xml和json的区别</h2><p>1．可读性　　<br>JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。</p><p>2可扩展性　　<br>XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。</p><p>3.编码难度　　<br>XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。</p><p>4．解码难度　　<br>XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。</p><p>5.流行度　　<br>XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。</p><h2 id="SAX-、DOM4J-、PULL解析的区别"><a href="#SAX-、DOM4J-、PULL解析的区别" class="headerlink" title="SAX 、DOM4J  、PULL解析的区别"></a>SAX 、DOM4J  、PULL解析的区别</h2><p>Sax特点</p><pre><code>1. 解析效率高，占用内存少2.可以随时停止解析3.不能载入整个文档到内存4.不能写入xml5.SAX解析xml文件采用的是事件驱动</code></pre><p>pull与sax的不同之处</p><pre><code>1.pull读取xml文件后触发相应的事件调用方法返回的是数字。2.pull可以在程序中控制，想解析到哪里就可以停止到哪里</code></pre><p>3.Android中更推荐使用pull解析</p><p>DOM的特点<br>         &gt;优点<br>                  1.整个文档树在内存中，便于操作；支持删除、修改、重新排列等多种功能<br>                  2.通过树形结构存取xml文档<br>                  3.可以在树的某个节点上向前或向后移动<br>         &gt;缺点<br>                  1.将整个文档调入内存（包括无用的节点），浪费时间和空间<br>         &gt;适用场合<br>                  一旦解析了文档还需多次访问这些数据；硬件资源充足（内存，cpu）</p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题总结</title>
    <link href="https://huangguangda.github.io/2018/05/15/1/"/>
    <id>https://huangguangda.github.io/2018/05/15/1/</id>
    <published>2018-05-15T00:42:00.000Z</published>
    <updated>2018-07-04T00:51:54.435Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>Android面试题总结</p><p>1.简述Activity的生命周期？</p><p>1）Activity的生命周期通过7个生命周期方法<br>onCreate(),<br>onRestart(),<br>onStart(),<br>onResume(),<br>onPause(),<br>onStop(),<br>onDestroy()<br>来体现。</p><p>2）其中6个生命周期方法是<br>成对对应起来的,<br>哪里创建的对象，一般应该在其对应的方法中销毁。</p><p>onCreate() – onDestroy()<br>onStart() – onStop()<br>onResume() – onPause()</p><p>3）当程序启动之后，<br>第一个Activity经过的生命周期方法是：<br>onCreate() →onStart() → onResume()方法,</p><p>当第一个Activity<br>A启动第二个Activity B的时候</p><p>(备注:第二个Activity完全遮盖住第一个Activity，并且这个过程中没有出现点击Home键，或者第一个Activity被杀死等异常情况，并且两个Activity的启动模式是标准模式)，</p><p>这两个Activity经历的生命周期方法是：</p><p>A onPause() → B onCreate() → B onStart() → B onResume() → A onStop() → (此时Activity A已经在回退栈的最低端， Activity B已经在Activity A的上面，在回退栈的最顶端)</p><p>当通过点击后退键退出Activity B的时候：</p><p>(此时Activity B 弹出回退栈) → B onPause() → A onRestart() → A onStart() → A onResume() → B onStop() → B onDestroy() 此时B<br>被销毁</p><p>简述Service的生命周期？</p><p>1).如果在Activity中通过调用</p><p>startService()</p><p>方法启动一个Service的话，<br>那么生命周期是：</p><p>onCreate() → onStartCommand() → 运行中 → (如果自己或者客户端(如Activity)调用了stop Service的方法的话) → onDestroy()</p><p>2).如果在Activity中通过调用</p><p>bindService()</p><p>方法启动一个Service的话，<br>那么生命周期是：</p><p>onCreate() → onBind() → 运行中 → (如果有客户端(Activity)调用了unBindService()方法与Service解除绑定时) → onUnbind() → onDestroy()</p><p>有几种控件布局的方式？</p><p>1）RelativeLayout:相对布局，<br>可以根据相对位置来调整控件的位置。推荐使用相对布局，更利于屏幕的自适应。</p><p>2）LinearLayout:线性布局，<br>控件之间的水平排列或者垂直排列。但是如果要想构建复杂布局，要进行多层的LinearLayout布局嵌套，但是这样会运行布局载入效率。</p><p>3）FrameLayout:帧布局，<br>控件与控件之间处于上下叠加的状态。</p><p>备注：还有两个已经不怎么用的布局：<br>TableLayout：表格布局 AbsoluteLayout 绝对布局。</p><p>布局实现方式有两种：xml文件静态实现，代码动态实现。</p><p>一般xml文件中可以实现布局控制的话，就不建议放在代码中实现布局控制，因为在xml文件中实现布局控制，可以做到布局与代码分离。</p><p>4.有几种数据存储方式，分别是什么？</p><p>1）SQLite数据库存储结构化数据。</p><p>2）文件存储：分为内部存储和外部存储(SD卡)两种存储方式。</p><p>3）SharedPreferences共享参数，键值对形式存储。</p><p>4）网络存储。</p><p>5.IntentService与Service有什么区别？</p><p>IntentService是Service的子类</p><p>1）Service如果要处理异步请求(如耗时操作)的话，</p><p>需要自己启动一个worker thread,</p><p>如果启动多个worker thread来处理相关事务的话，各线程之间无法很好的控制。</p><p>而IntentService可以将多个异步请求的Intent放入队列中，封装了一个开启worker thread的onHandleIntent()方法，来依次处理放入队列中的Intent，只有一个worker thread在运行，同一时刻只有一个Intent被处理，当一个Intent处理完了之后才会处理另外一个Intent。</p><p>2）Service可以通过startService()或者bindService()方法来启动，</p><p>而IntentService则是通过startService()方法来启动。</p><p>3）Service适合多线程处理异步请求。</p><p>而IntentService则适合处理需要排队的请求。</p><p>6.StartService与bindService之间的区别？</p><p>1）StartService启动了Service之后无法与Activity之间进行通信，与现有的Activity分离，即使Activity被杀掉了之后，Service还可以运行，同时通过设置Service的粘性，还可以让Service被杀掉之后，可以自启动。而bindService启动Service之后，与绑定的Activity之间有关系，可以依据Server/Client模式来进行通信(binder客户端主动请求模式，或者通过信使)，但是无法设置Serrvice的粘性。</p><p>2) StartService启动的Service,Activity中可以调用stopService()方法来结束一个Service，或者通过Service自己调用stopSelf()方法来结束Service。而bindService只能通过Activity()来调用unbindService()方法来结束Service，Service会调用onUnBind()方法，以及onDestroy()方法。</p><p>7.ArrayAdapter BaseAdapter CursorAdapter的区别？</p><p>ArrayAdpter CursorAdapter都是BaseAdapter的子类。<br>都是用来填充那些含有item的控件。</p><p>1）主要区别是数据来源不同。</p><p>ArrayAdapter数据来源是Object数组，<br>CursorAdapter数据来源是数据库的Cursor,<br>而BaseAdapter适合创建复杂自定义的item内容，</p><p>通过继承BaseAdapter类，重写相关方法来实现。</p><p>8.Handler与Looper之间的关系?</p><p>1) Handler和Looper的关系就好比，坐地铁过安检时候：每一个人可以理解为一个Handler，一个人的一个或者多个东西看做Message而循环滚动的检查台装置可以看做是Looper，而要检查的东西排成队列可以理解为MessageQueue消息队列。</p><p>2)Looper是Handler和MessageQuene之间的桥梁，Looper将Handler发送过的消息放入MessageQueue,同时Looper也将MessageQueue中的Message发送给Handler来处理。</p><p>9.res文件夹与assets文件夹有什么区别?</p><p>1)res文件夹中的资源在会在R.java文件中生成ID，<br>代码中可以直接通过R.id的形式来访问。</p><p>而assets文件夹中的资源不会在R.java文件中生成ID,</p><p>需要通过AssetsManager通过IO流的方式来访问。</p><p>2)res文件夹中的文件会被压缩，</p><p>而assets文件中的文件不会被压缩。</p><p>3)Res不能自定义目录名，不支持多层目录。</p><p>而assets支持自定义目录名，支持多层目录。</p><p>10.广播接收器有几种注册方式，分别是什么？</p><p>1)动态注册：在代码中注册，创建一个IntentFilter(意图过滤器)对象，设置想要就收的广播，在onCreate()方法中通过调用registerReceiver()方法来注册广播接收器，在onDestroy()方法中通过调用unregisterReceiver()方法来注销广播接收器。</p><p>2)静态注册：在AndroidManifest.xml文件中注册，<receiver>标签注册类，通过<intentfilter>标签中的<action>来过滤意图。静态注册的好处是，当程序关闭或者没有打开的时候，同样可以接收相关的广播。比如实现开机启动。</action></intentfilter></receiver></p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Java就业面试题大全</title>
    <link href="https://huangguangda.github.io/2018/05/14/1/"/>
    <id>https://huangguangda.github.io/2018/05/14/1/</id>
    <published>2018-05-14T13:40:52.000Z</published>
    <updated>2018-07-02T15:41:26.139Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>仅供学习</p><p>1、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？<br>可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。</p><p>2、Java有没有goto?<br>java中的保留字，现在没有在java中使用。</p><p>3、说说&amp;和&amp;&amp;的区别。<br>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。</p><p>&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式</p><p>4、在JAVA中如何跳出当前的多重嵌套循环？ </p><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。</p><p>5、switch语句能否作用在byte上，能否作用在long上，能否作用在String上? </p><p>由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 </p><p>6、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? </p><p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。<br>对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 </p><p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。<br>对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p><p>7、char型变量中能不能存贮一个中文汉字?为什么? </p><p>char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。</p><p>8、用最有效率的方法算出2乘以8等於几? </p><p>2 &lt;&lt; 3，<br>因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 &lt;&lt; 3。</p><p>使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ </p><p>使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于如下语句：</span><br><span class="line"> final StringBuffer a=new StringBuffer(&quot;immutable&quot;);</span><br><span class="line">执行如下语句将报告编译期错误：</span><br><span class="line">a=new StringBuffer(&quot;&quot;);</span><br><span class="line">但是，执行如下语句则可以通过编译：</span><br><span class="line">a.append(&quot; broken!&quot;);</span><br></pre></td></tr></table></figure></p><p>有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void method(final  StringBuffer  param)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：<br>        param.append(“a”);</p><p>“==”和equals方法究竟有什么区别？<br>==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。</p><p>equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。</p><p>静态变量和实例变量的区别？<br>在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。</p><p>在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p><p>是否可以从一个static方法内部发出对非static方法的调用？ </p><p>不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。</p><p>Integer与int的区别</p><p>int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。</p><p>下面的代码有什么不妥之处?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. if(username.equals(“zxx”)&#123;&#125;</span><br><span class="line">2.int  x = 1;</span><br><span class="line">return x==1?true:false;</span><br></pre></td></tr></table></figure></p><p>abstract class和interface有什么区别? </p><p>含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</p><p>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。</p><p>下面比较一下两者的语法区别：<br>1.抽象类可以有构造方法，接口中不能有构造方法。<br>2.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p><ol start="4"><li>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然<br>eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</li><li>抽象类中可以包含静态方法，接口中不能包含静态方法</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li></ol><p>什么是内部类？Static Nested Class 和 Inner Class的不同。</p><p>内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中.</p><p>jdk中哪些类是不能继承的？<br>不能继承的是类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中System,String,StringBuffer等都是基本类型。</p><p>String是最基本的数据类型吗?<br>基本数据类型包括byte、int、char、long、float、double、boolean和short。<br>java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 </p><p>是否可以继承String类?<br>String类是final类故不可以继承。 </p><p>String 和StringBuffer的区别</p><p>JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。String类表示内容不可改变的字符串。而StringBuffer类表示内容可以被修改的字符串。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。</p><p>StringBuffer与StringBuilder的区别</p><p>StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。</p><p>如何把一段逗号分割的字符串转换成一个数组?<br>如果不查jdk api，我很难写出来！我可以说说我的思路：<br>1.用正则表达式，代码大概为：String [] result = orgStr.split(“,”);<br>2.用 StingTokenizer ,代码为：StringTokenizer  tokener = StringTokenizer(orgStr,”,”);<br>String [] result = new String[tokener .countTokens()];<br>Int i=0;<br>while(tokener.hasNext(){result[i++]=toker.nextToken();}</p><p>数组有没有length()这个方法? String有没有length()这个方法？<br>数组没有length()这个方法，有length的属性。String有有length()这个方法。</p><p>final, finally, finalize的区别。<br>　　final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br>内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码……</p><p>finally是异常处理语句结构的一部分，表示总是执行。</p><p>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用</p><p>运行时异常与一般异常有何异同？<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p><p>error和exception有什么区别?<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 </p><p>java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？ </p><p>java5以前，有如下两种：</p><p>第一种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Thread()&#123;&#125;.start();这表示调用Thread子类对象的run方法，new Thread()&#123;&#125;表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：</span><br><span class="line">new Thread()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第二种：</span><br><span class="line">new Thread(new Runnable()&#123;&#125;).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable()&#123;&#125;表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：</span><br><span class="line">new Thread(new Runnable()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><p>sleep() 和 wait() 有什么区别? </p><p>（网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。） </p><p>sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class MultiThread &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">new Thread(new Thread1()).start();</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">new Thread(new Thread2()).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static class Thread1 implements Runnable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">//由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。</span><br><span class="line"></span><br><span class="line">synchronized (MultiThread.class) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;enter thread1...&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread1 is waiting&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">//释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。</span><br><span class="line"></span><br><span class="line">MultiThread.class.wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread1 is going on...&quot;);</span><br><span class="line">System.out.println(&quot;thread1 is being over!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static class Thread2 implements Runnable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">synchronized (MultiThread.class) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;enter thread2...&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread2 notify other thread can release wait status..&quot;);</span><br><span class="line">//由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。</span><br><span class="line"></span><br><span class="line">MultiThread.class.notify();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread2 is sleeping ten millisecond...&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;thread2 is going on...&quot;);</span><br><span class="line">System.out.println(&quot;thread2 is being over!&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步和异步有何异同，在什么情况下分别使用他们？举例说明。 </p><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。<br>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 </p><p>多线程有几种实现方法?同步有几种实现方法? </p><p>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口<br>同步的实现方面有两种，分别是synchronized,wait与notify<br>wait():使一个线程处于等待状态，并且释放所持有的对象的lock。<br>sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。<br>notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。<br>Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</p><p>启动一个线程是用run()还是start()?<br>启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。 </p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>MVC的各个部分都有那些技术来实现?如何实现? </p><p>答:MVC是Model－View－Controller的简写。Model 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， View 是应用的表示面（由JSP页面产生），Controller 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。 </p><p>数据库部分<br>1、用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。<br>employee:<br>     eid,ename,salary,deptid;<br> select * from employee order by deptid desc,salary</p><p>j2ee常用的设计模式？说明工厂模式。<br>总共23种，分为三大类：创建型，结构型，行为型<br>我只记得其中常用的6、7种，分别是：<br>创建型（工厂、工厂方法、抽象工厂、单例）<br>结构型（包装、适配器，组合，代理）<br>行为（观察者，模版，策略）<br>然后再针对你熟悉的模式谈谈你的理解即可。  </p><p>Java中的23种设计模式：<br>Factory（工厂模式），      Builder（建造模式），       Factory Method（工厂方法模式），<br>Prototype（原始模型模式），Singleton（单例模式），    Facade（门面模式），<br>Adapter（适配器模式），    Bridge（桥梁模式），        Composite（合成模式），<br>Decorator（装饰模式），    Flyweight（享元模式），     Proxy（代理模式），<br>Command（命令模式），      Interpreter（解释器模式）， Visitor（访问者模式），<br>Iterator（迭代子模式），   Mediator（调停者模式），    Memento（备忘录模式），<br>Observer（观察者模式），   State（状态模式），         Strategy（策略模式），<br>Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式） </p><p>J2EE是什么？<br>答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。</p><p>一个另类的回答：j2ee就是增删改查。 </p><p>J2EE是技术还是平台还是框架？ 什么是J2EE<br>   J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。<br>   J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。</p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>四级考试听力场景词汇大全</title>
    <link href="https://huangguangda.github.io/2018/05/13/1/"/>
    <id>https://huangguangda.github.io/2018/05/13/1/</id>
    <published>2018-05-13T05:34:14.000Z</published>
    <updated>2018-07-01T06:10:34.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>仅供学习</p><p>你永远也无法找到一个比这个更全更准的听力复习资料</p><p>一、机场、飞机上、客轮</p><p>常考思路：<br>　　1) 票已售完<br>　　2) 接人(飞机)晚点<br>　　3) 送人伤感 see somebody off<br>　　常见线索词：<br>　　departure 离港<br>　　sect belt 安全带<br>　　arrival 进港<br>　　pick up 接机<br>airplane, flight 航班, direct flight直航，transfer转机，<br>first class头等舱， economy class经济舱，<br>circle 盘旋<br>　　wing: a.建筑物的附属楼 b.飞机的翅膀 c.鸡翅<br>　　terminal: a.终端(机房里面 Should I use this terminal?)<br>　　b. =final station公交站最后一站<br>　　c.候机大厅<br>　　domestic terminal国内候机大厅，international terminal国际候机大厅</p><p>1.机场地点­<br>    Terminal (航站楼)­  Check-in counter (换票柜台)　　Customs (海关)­</p><ol start="2"><li>机场人物­<br>　　Airhostess/stewardess (空姐)　 steward (空哥、空少)　 flight attendant (飞机乘务员)­</li><li>飞机动作­<br>　　Take off/land (起飞、降落)　　 ascend/descend(上升、下降)­<br>wait for further notice等候进一步通知<br> minor mechanical errors轻微的机械故障 terminal候机大厅<br> clear up天晴起来 　　　　　　swing不稳定,极端<br> weather forecast天气预报 　   freezing非常冷 　<br>coupled with strong wind伴有强风</li></ol><p>二、餐厅　<br>　　1)cafeteria学校饭堂：meal card/ticket饭卡/饭票，helping一人份<br>　　2)restaurant: fancy高档的, menu菜谱, order, manager经理, waiter<br>　　book/reserve预订 ，make a reservation预定<br>　　上菜顺序：soup汤——&gt; main course主菜——&gt; salad沙拉(chef salad招牌沙拉)——&gt; dessert甜点 (pudding布丁, cheese , fruit)</p><p>赞美人家做菜好吃：<br>　　1) Even my mother’s can’t match this.即使我妈妈做的也比不上这个好吃。<br>　　2) I took the last one and it was out of the world.(太好吃了以至于)我把最后一块也吃掉了。<br>　　3) You wouldn’t have to force me to help another one. 你不用叫我吃，我自己也会拿来吃的。<br>1.点菜：­ French Fries (薯条)­</p><ol start="2"><li>买单：­Check the bill please!(买单！) Treat (请客)　 split the bill (分开付)­</li></ol><p>三、图书馆　<br>　　1.书籍：journal 学术类刊物　(08-6)­<br>　　volume 卷　 current/back issue 现/过刊　 periodical　 期刊­<br>2.人物：librarian 图书管理员­</p><p>四、Campus life　校园生活­</p><ol><li>课程分类<br>　　Optional course 选修课<br>　　Required course 必修课<br>Literature 文学<br>09-12出现的一些新课程名称：­<br>advanced physics (高级物理)<br>data processing (数据处理)­<br>　　computer programming (计算机程序)­<br>be through with sth　结束，完成(两次考到)­<br>　due　到期<br>　have sb’s hands full with sth　忙于做某事(07-12)­<br>apply for申请<br>business degree商学院学位<br>pay your own way自己支付各种费用</li></ol><p>2.　课程形式词汇：­<br>　　Seminar(06-6、07年6月词汇，研讨会)　　<br>　　presentation (展示或演示课，多次考到)­<br>biology生物学<br>    class permit听课证<br>informative信息量大</p><p>senior(大四)(05年考点)­<br>graduate(毕业生)<br>undergraduate (在校生，本科生)<br>postgraduate (研究生)­<br>tutor(导师)<br>graduate school　(研究生院)­<br>Position/post　(职位。多次考到)　　<br>recruit (招聘。连续考到)<br>　　resign　(退休，多次考到)­<br>benefit (package)　(福利，两次考到)<br>paid vacation　 (带薪假期)­<br>social security (美国的社会保险)<br>phased retirement (08-12 阶段性退休)<br>be laid off (解雇 09-12考点)­<br>hotel consultant (08-6 酒店咨询)<br>sales manager(08-12 销售经理)­<br>　　Administrative work (08-12 行政工作)­<br>　　promotion(升职，09-6/12连续考到)­</p><p>4.抱怨的作业：<br>　　1)paper a.论文 b.=newspaper 报纸 c. document文件 d.纸张<br>　　写论文的步骤：<br>　　a. choose a topic选题<br>　　area: The area is too board for me. 题目的范围太广了<br>　　narrow the topic down 把题目范围缩小<br>　　b. do some research 做调查 (去图书馆library 做调查)<br>　　c. type it out打印<br>　　typewriter打字机，computer, lap top手提电脑， printer打印机， laser printer激光打印机， ribbon色带<br>　　2) presentation口头演讲——oral form = speech = report = address<br>　　a.时间性 20分钟，一般演讲18-19分钟，留下几分钟时间别人发问<br>　　b.正式着装——formal clothes<br>　　change(穿的衣服不合适就要换)<br>　　You can’t go like that. You need a change.你这样穿不行，要换一套衣服。<br>　　c.内心感受——nervous (演讲前心里很害怕)<br>　　3) Reading assignment / list 阅读作业/清单<br>　　Do you think the reading list is enormous? 你觉不觉要读的书太多了?<br>　　4) Research<br>　　Financial Aid经济资助<br>　　a. Tuition wavier学费减免<br>　　b. RA——Researching Assistant助研<br>　　TA——Teaching Assistant 助教<br>　　Fellowship奖学金<br>5.缺课<br>　　缺课原因：<br>　　1) get ill 由于生病而缺课<br>　　2) oversleep睡过头了<br>　　3)traffic jam交通堵塞/ (car)break down车抛锚</p><p>.考试<br>middle exam 期中考试<br>　　make up 补考<br>　　test测验<br>　　pop test 事先没有说好的测验<br>　　quiz 测验<br>　　oral test 口试<br>be through with结束，完成<br>release发布（分数）</p><p>　　考试临近<br>　　draw on 、 in sight of 、 draw nearly<br>　　<br>考试延期或取消<br>　 defer / hold up / postpone / put off / suspend</p><p>酒店、宾馆与约会　　</p><p> make a reservation 预订房间<br>　　confirm a reservation 确认预订<br>　　cancel a reservation 取消预订<br>　　fully booked / full up / full 客满<br>　　porter 行旅员<br>　　reception 前台<br>　　check in 登记入住<br>　　single room 单人房<br>　　suite 套房<br>　　room service 客房服务 (四级听力中的客房服务一般只有考一种——送餐)<br>　　lobby 大堂<br>salon 美容厅<br>　　night club 夜总会<br>　　check out 退房<br>　　饭店<br>    hotel clerk (07年6月词汇，等于receptionist)<br>eat out 出去吃<br>　　take away 外带<br>appetizer 开胃菜<br>　　main course 主食<br>　　dessert 餐后甜点<br>　　keep the change 不用找零了<br>move on to继续<br>　　the next item下一议题个<br>    come in one’s place代表某人来<br>on behalf of代表</p><p>罚款 fine<br>　　校内：library里面，书过期<br>　　校外： break the traffic rules违反交通规则，go speeding超速<br>　　各种费用：<br>　　fare交通费(车费，船费)， fee杂费， tuition学费， tuition and fee学杂费，rent 房租， utilities水电费，rate 按比例收取的费用， post rate=postage邮资</p><p>1．交通<br>　　常考思路：<br>　　1) 交通堵塞 traffic jam<br>　　back up: a.作业堆积如山 b. 车辆很多 c. back somebody up支持某人<br>　　2) 交通违章——&gt;fine罚款<br>　　break the traffic rule违反交通规则, go speeding超速<br>　　3) 晚点 behind schedule<br>　　parking lot停车场 　　　　maintain保养<br>    break down抛锚 　　　　　garage修车场<br>    scratches刮蹭 　　　　　　highway高速公路<br>    single lane单行道 　　　　 No-parking sign禁止停车标志<br>   sleeper卧铺 　　　be supposed to应该</p><p>打电话<br>　　常考思路：<br>　　1) 约人约不到<br>　　2) 约会去不了<br>　　sth comes up/ I’d like to reschedule/ Could you fit me in (the doctor’s schedule)?<br>　　3) 电话打不通(包括打错电话)<br>　　线索词：<br>　　run out of coins(在公共电话亭里)没钱了<br>   cut off被迫断线，hang up主动挂断电话，<br>   receiver听筒，slot 电话上的小投币口　</p><p>   九、医院<br>　　常考思路：<br>　　1) 医生难找<br>　　2) 病情如何(getting better/worse)<br>　　3) 有病耽误课miss the class<br>　　线索词：<br>　　treat治疗(表过程)， cure治疗,治愈(表结果)<br>　　infirmary / students’ help center学校的医院<br>prescribe开药方，prescription处方<br>　　Send him to Ward Three. 把他送去3号病房。 Send him toward three.把他送到东方去。(因为时钟三点指向东(上北下南左西右东) )<br>　　fill the prescription按方抓药， refill the prescription继续按方抓药，<br>dizzy头晕<br>    a fever发烧<br>    have the ankle twisted扭到脚踝<br>    blood vessel血管</p><p>(四)买东西<br>　　<br>1．采购衣服<br>size型号 　　　come in all sizes号全<br>2．采购电器<br>model款<br>latest technology最新的科技 </p><ol start="3"><li>1) supermarket超级市场: supplies生活用品，price tag价格签，<br>special offer/ on sale打折，cart手推车，vender售货员，cashier收银员<br>2)  appliance家用电器, costume服装, floor 层,<br>men’s 男装区,<br>for sale 热卖中,待售中,<br>70% off 三折, </li></ol><p>十一、 阅读与写作　<br>intensively精细地<br>reading assignment阅读任务 　　　　selectively有选择地<br>chapter by chapter一章一章地 　　　theory理论<br>read through从头到尾地读 　　　　　cover a few chapters涉及了几个章节<br>revise修订<br>quality paper好纸 　　　　　       get it published出版<br>proofread[pru:fri:d]校对 　　</p><p>十二、.求职与工作　　<br>常考思路:<br>　　1) 找到工作高兴<br>　　2) 失去工作伤心 a.被解雇 b.离开旧工作<br>　　3) 拒绝工作令人感到奇怪<br>　　线索词<br>　　找工作的过程:<br>　　1) 信息<br>　　a. classified ads分类广告<br>　　help and wanted section供求关系栏<br>　　b. bulletin board公告栏<br>　　c. flyer传单<br>　　2) make a phone call<br>　　Is the position still available? 工作职位还仍然空缺吗?<br>　　3) resume个人简历<br>　　certification 学历证, ID身份证,<br>qualification资历,<br>　　recommendation letter推荐信<br>　　fill out= fill in = fill up填表格</p><p>interview面试<br>　　 interview　面试　　　　　　finance金融<br>    suit西装 　　　　　　　　 accounting会计<br>    tie领带 　　　　　　　　　brush up on温习，复习<br>    travel出差                annual vacation年假<br>job vacancy 有空缺职位<br>　　academic background 教育背景<br>　　offer 聘用信<br>　　ask for a raise 加钱<br>　　salary 日薪<br>　　bonus奖金<br>　　allowance 津贴<br>　　promotion 升职　　</p><p>十三. 租房子<br>　　常考思路<br>　　live on campus 住校<br>　　live off campus 住校外<br>　　for sale 可销售的房子<br>　　for rent / lease 可出租的房子<br>　　to let 同上<br>　　utilities 公用事业费<br>　　suburb / downtown 市郊 / 市中心<br>　　leaking 漏水<br>　　blackout 断电<br>　　transportation 交通<br>　　land lord 房东<br>　　land lady 房东太太<br>　　tenant 房客<br>　　roommate 室友<br>　　好的室友：neat 整洁的 considerate 体贴的，细心的<br>　　不好的室友：messy / untidy 脏乱的 noisy 吵闹的<br>　　apartment 公寓<br>　　dorm/dormitory 寝室<br>    for rent房子出租，rest-room厕所　</p><p>十四、 理发<br>　　线索词<br>　　cut大剪，trim小修剪，bang男生刘海儿，fringe女生刘海儿，parting分头(I want parting to the left.我想要左分头。)<br>　　plait 辫子　　</p><p>十五、医院场景<br>　　send for a doctor 让医生出诊<br>　　health center / clinic 卫生所 / 门诊部<br>　　physician 内科医生<br>　　surgeon 外科医生<br>　　make an appointment 预约<br>　　liquid 喝药水<br>　　injection =&gt; shot 注射<br>　　medical result 诊断结果</p><p>8.宾馆和约会场景<br>　　　　<br>　十六、邮局场景<br>　　rate 费率<br>　　overweight 超重<br>　　postage 邮资<br>　　forward the mail to把邮件转发给<br>　　cc(carbon copy) 抄送<br>　　bcc(blind carbon copy)秘密抄送<br>　　attach 附件</p><p>   log in登录</p><p>   log off登出<br>　　<br>十七、其他场景<br>　　be mad with对某人生气<br>　　干杯cheers<br>    the last man 最不愿意见的人<br>　　sell off 低价处理库存商品<br>　　selling machine 自动售货机<br>　　count for little 无足轻重<br>　　count for much 举足轻重<br>　　count down 倒计时<br>　　count up 相加<br>健忘 forgetful, absent-minded, slip one’s mind</p><p>　　count up to 共计</p><p>短对话考前嘱咐<br>　　1. 学习——基于学生的角度，一定是抱怨学习<br>　　2. 生活——poor,很穷。<br>　　Student ID 学生证 用于discount 打折， bargain 讨价还价<br>　　3. 学习vs 生活——忙，忙于学习</p><p>长对话十大类标志词<br>　　据研究有90%以上的考点都是由标志词引导活提示的，因此在语段听力中听到下列标志词时要引起高度的重视，集中注意力听清标志词前后的句子。<br>　　1.最高级标志词<br>　　形容词、副词最高级、most / chief / primary / main / leading / ……<br>　　2.唯一级标志輯div&gt; 　　only / unique / prefer / every / one / of all / perfect / ……<br>　　3.因果项标志词<br>　　cause / lead to / contribute to / thanks to / owing to / question / answer / why / reason / 其他形式的问句 / ……<br>　　4.转则项关键词<br>　　despite / in spite of / instead / while / from ~ to ~ / although ~ (yet)~ / not only ~ but also ~ / ……<br>　　5.序数项标志词<br>　　所有的序数词(first , second)/ another / the other / next / last / in addition / on the other hand / ……<br>　　6.时间项标志词<br>　　when / how / today / as / before / after / since / then / until / ……<br>　　7.解释项标志词<br>　　or / namely / in other words / that is / that is to say / ……<br>　　8.目的项标志词<br>　　to / for / ……<br>　　9.总结项标志词<br>　　all in all / in brief / to conclude / at last / in summary / in short / ……<br>　　10.强调项标志词<br>　　副词：especially / particularly / almost / always / usually / ……<br>　　动词：show / remember / note / notice / say / pronounce / ……</p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="英语" scheme="https://huangguangda.github.io/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="https://huangguangda.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Android面试常考题目</title>
    <link href="https://huangguangda.github.io/2018/05/12/1/"/>
    <id>https://huangguangda.github.io/2018/05/12/1/</id>
    <published>2018-05-12T04:04:50.000Z</published>
    <updated>2018-06-22T05:24:53.056Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>来源网络资料</p><p>1、 Android的四大组件是哪些，它们的作用？</p><p>答：</p><p>Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑，Activity：不可见，只是一种容器，view组件（UI控件，容器控件的基类）用来显示可以看到的东西。</p><p>service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事物，定义好需要接受的Intent提供同步和异步的接口</p><p>Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的接口模型，大大简化上层应用，对数据的整合提供了更方便的途径</p><p>BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型</p><p>2、 请介绍下Android中常用的五种布局。</p><p>常用五种布局方式，<br>分别是：<br>FrameLayout（框架布局），<br>LinearLayout （线性布局），<br>AbsoluteLayout（绝对布局），<br>RelativeLayout（相对布局），<br>TableLayout（表格布局）。</p><p>一、FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。</p><p>二、LinearLayout：线性布局，<br>每一个LinearLayout里面又可分为垂直布局（android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）。</p><p>当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。</p><p>三、AbsoluteLayout：绝对布局用X,Y坐标来指定元素的位置，</p><p>这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。</p><p>四、RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。</p><p>主要属性有：<br>相对于某一个元素<br>android:layout_below、 android:layout_toLeftOf<br>相对于父元素的地方<br>android:layout_alignParentLeft、android:layout_alignParentRigh；</p><p>五、TableLayout：表格布局，<br>每一个TableLayout里面有表格行TableRow，<br>TableRow里面可以具体定义每一个元素。<br>每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。</p><p>3、 android中的动画有哪几类，它们的特点和区别是什么</p><p>答：两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</p><p>4、 android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。</p><p>答：XML解析主要有三种方式，SAX、DOM、PULL。常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。</p><p>5、 ListView的优化方案</p><p>答：</p><p>1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。</p><p>2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。</p><p>3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。</p><p>6、 请介绍下Android的数据存储方式。</p><p>答：</p><p>使用SharedPreferences存储数据；文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据；</p><p>Preference，File， DataBase这三种方式分别对应的目录是/data/data/Package Name/Shared_Pref, /data/data/Package Name/files, /data/data/Package Name/database 。</p><p>一：使用SharedPreferences存储数据</p><p>首先说明SharedPreferences存储方式，它是 Android提供的用来存储一些简单配置信息的一种机制，</p><p>例如：登录用户的用户名与密码。</p><p>其采用了Map数据结构来存储数据，以键值的方式存储，可以简单的读取与写入，具体实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void ReadSharedPreferences()&#123;</span><br><span class="line"></span><br><span class="line">String strName,strPassword;</span><br><span class="line"></span><br><span class="line">SharedPreferences user = getSharedPreferences(“user_info”,0);</span><br><span class="line"></span><br><span class="line">strName = user.getString(“NAME”,””);</span><br><span class="line">strPassword = user getString(“PASSWORD”,””);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WriteSharedPreferences(String strName,String strPassword)&#123;</span><br><span class="line"></span><br><span class="line">SharedPreferences user = getSharedPreferences(“user_info”,0);</span><br><span class="line"></span><br><span class="line">uer.edit();</span><br><span class="line">user.putString(“NAME”, strName);</span><br><span class="line">user.putString(“PASSWORD” ,strPassword);</span><br><span class="line">user.commit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据读取与写入的方法都非常简单，只是在写入的时候有些区别：先调用edit()使其处于编辑状态，然后才能修改数据，最后使用commit()提交修改的数据。</p><p>实际上SharedPreferences是采用了XML格式将数据存储到设备中，在DDMS中的File Explorer中的/data/data//shares_prefs下。</p><p>使用SharedPreferences是有些限制的：只能在同一个包内使用，不能在不同的包之间使用。</p><p>二：文件存储数据</p><p>文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与 Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。具体实例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String fn = “moandroid.log”;</span><br><span class="line">FileInputStream fis = openFileInput(fn);</span><br><span class="line">FileOutputStream fos = openFileOutput(fn,Context.MODE_PRIVATE);</span><br></pre></td></tr></table></figure><p>三：网络存储数据</p><p>网络存储方式，需要与Android 网络数据包打交道，关于Android 网络数据包的详细说明，请阅读Android SDK引用了Java SDK的哪些package？。</p><p>四：ContentProvider</p><p>1、ContentProvider简介</p><p>当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。</p><p>2、Uri类简介</p><p>Uri代表了要操作的数据，Uri主要包含了两部分信息：</p><p>1.需要操作的ContentProvider ，<br>2.对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成：</p><p>1.scheme：ContentProvider（内容提供者）的scheme已经由Android所规定为：content://…<br>2.主机名（或Authority）：用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。</p><p>3.路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下：<br>要操作contact表中id为10的记录，可以构建这样的路径:/contact/10<br>要操作contact表中id为10的记录的name字段， contact/10/name<br>要操作contact表中的所有记录，可以构建这样的路径:/contact?<br>要操作的数据不一定来自数据库，也可以是文件等他存储方式，如下:<br>要操作xml文件中contact节点下的name节点，可以构建这样的路径：/contact/name<br>如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：<br>Uri uri = Uri.parse(“content://com.changcheng.provider.contactprovider/contact”)</p><p>3、UriMatcher、ContentUrist和ContentResolver简介</p><p>因为Uri代表了要操作的数据，所以我们很经常需要解析Uri，并从 Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher 和ContentUris 。掌握它们的使用，会便于我们的开发工作。</p><p>UriMatcher：用于匹配Uri，它的用法如下：</p><p>1.首先把你需要匹配Uri路径全部给注册上，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码(-1)。</span><br><span class="line">UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line">//如果match()方法匹配content://com.changcheng.sqlite.provider.contactprovider /contact路径，返回匹配码为1</span><br><span class="line">uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact”, 1);//添加需要匹配uri，如果匹配就会返回匹配码</span><br><span class="line">//如果match()方法匹配 content://com.changcheng.sqlite.provider.contactprovider/contact/230路径，返回匹配码为2</span><br><span class="line">uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact/#”, 2);//#号为通配符</span><br></pre></td></tr></table></figure><p>2.注册完需要匹配的Uri后，就可以使用uriMatcher.match(uri)</p><p>方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用 addURI()方法传入的第三个参数，假设匹配 content://com.changcheng.sqlite.provider.contactprovider/contact路径，返回的匹配码为1。<br>ContentUris：用于获取Uri路径后面的ID部分，它有两个比较实用的方法：<br>withAppendedId(uri, id)用于为路径加上ID部分<br>parseId(uri)方法用于从路径中获取ID部分<br>ContentResolver：当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用 ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver使用insert、delete、update、query方法，来操作数据。</p><p>7、 activity的启动模式有哪些？是什么含义？</p><p>答：</p><p>在android里，有4种activity的启动模式，分别为：</p><p>“standard” (默认)<br>“singleTop”<br>“singleTask”<br>“singleInstance”</p><p>它们主要有如下不同：</p><ol><li><p>如何决定所属task<br>“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。<br>如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。<br>“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。</p></li><li><p>是否允许多个实例<br>“standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例；<br>“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。</p></li><li><p>是否允许其它activity存在于本task内<br>“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。<br>而另外三种模式，则可以和其它activity共存。</p></li><li><p>是否每次都生成新实例<br>“standard”对于没一个启动Intent都会生成一个activity的新实例；<br>“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。</p></li></ol><p>比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。<br>如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D<br>如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。<br>“singleInstance”是其所在栈的唯一activity，它会每次都被重用。<br>“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。</p><p>当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。</p><p>8、 跟activity和Task 有关的 Intent启动方式有哪些？其含义？</p><p>核心的Intent Flag有：<br>FLAG_ACTIVITY_NEW_TASK<br>FLAG_ACTIVITY_CLEAR_TOP<br>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED<br>FLAG_ACTIVITY_SINGLE_TOP<br>FLAG_ACTIVITY_NEW_TASK</p><p>如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的 Activity）定义了用户可以迁移的Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。<br>这个标志一般用于呈现“启动”类型的行为：它们提供用户一系列可以单独完成的事情，与启动它们的Activity完全无关。</p><p>使用这个标志，如果正在启动的Activity的Task已经在运行的话，那么，新的Activity将不会启动；代替的，当前Task会简单的移入前台。参考FLAG_ACTIVITY_MULTIPLE_TASK标志，可以禁用这一行为。</p><p>这个标志不能用于调用方对已经启动的Activity请求结果。</p><p>FLAG_ACTIVITY_CLEAR_TOP</p><p>如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。</p><p>例如，假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。<br>上例中正在运行的Activity B既可以在onNewIntent()中接收到这个新的Intent，也可以把自己关闭然后重新启动来接收这个Intent。</p><p>如果它的启动模式声明为 “multiple”(默认值)，并且你没有在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，那么它将关闭然后重新创建；对于其它的启动模式，或者在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，都将把这个Intent投递到当前这个实例的onNewIntent()中。<br>这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。</p><p>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED</p><p>如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。</p><p>FLAG_ACTIVITY_SINGLE_TOP</p><p>如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的<br>FLAG_ACTIVITY_BROUGHT_TO_FRONT<br>这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。</p><p>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET</p><p>如果设置，这将在Task的Activity stack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。</p><p>这在你的程序有分割点的时候很有用。</p><p>例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个 Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。</p><p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</p><p>如果设置，新的Activity不会在最近启动的Activity的列表中保存。</p><p>FLAG_ACTIVITY_FORWARD_RESULT</p><p>如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的 Activity。</p><p>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY</p><p>这个标志一般不由应用程序代码设置，如果这个Activity是从历史记录里启动的（常按HOME键），那么，系统会帮你设定。</p><p>FLAG_ACTIVITY_MULTIPLE_TASK</p><p>不要使用这个标志，除非你自己实现了应用程序启动器。与FLAG_ACTIVITY_NEW_TASK结合起来使用，可以禁用把已存的Task送入前台的行为。当设置时，新的Task总是会启动来处理Intent，而不管这是是否已经有一个Task可以处理相同的事情。</p><p>由于默认的系统不包含图形Task管理功能，因此，你不应该使用这个标志，除非你提供给用户一种方式可以返回到已经启动的Task。</p><p>如果FLAG_ACTIVITY_NEW_TASK标志没有设置，这个标志被忽略。</p><p>FLAG_ACTIVITY_NO_ANIMATION</p><p>如果在Intent中设置，并传递给Context.startActivity()的话，这个标志将阻止系统进入下一个Activity时应用 Acitivity迁移动画。这并不意味着动画将永不运行——如果另一个Activity在启动显示之前，没有指定这个标志，那么，动画将被应用。这个标志可以很好的用于执行一连串的操作，而动画被看作是更高一级的事件的驱动。</p><p>FLAG_ACTIVITY_NO_HISTORY</p><p>如果设置，新的Activity将不再历史stack中保留。用户一离开它，这个Activity就关闭了。这也可以通过设置noHistory特性。</p><p>FLAG_ACTIVITY_NO_USER_ACTION</p><p>如果设置，作为新启动的Activity进入前台时，这个标志将在Activity暂停之前阻止从最前方的Activity回调的onUserLeaveHint()。</p><p>典型的，一个Activity可以依赖这个回调指明显式的用户动作引起的Activity移出后台。这个回调在Activity的生命周期中标记一个合适的点，并关闭一些Notification。</p><p>如果一个Activity通过非用户驱动的事件，如来电或闹钟，启动的，这个标志也应该传递给Context.startActivity，保证暂停的Activity不认为用户已经知晓其Notification。</p><p>FLAG_ACTIVITY_PREVIOUS_IS_TOP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If set and this intent is being used to launch a new activity from an existing one, the current activity will not be counted as the top activity for deciding whether the new intent should be delivered to the top instead of starting a new one. The previous activity will be used as the top, with the assumption being that the current activity will finish itself immediately.</span><br></pre></td></tr></table></figure><p>FLAG_ACTIVITY_REORDER_TO_FRONT</p><p>如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。</p><p>例如，假设一个Task由四个Activity组成：A,B,C,D。</p><p>如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。</p><p>9、 请描述下Activity的生命周期。</p><p>答：activity的生命周期方法有：onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()；</p><p>可见生命周期：从onStart()直到系统调用onStop()<br>前台生命周期：从onResume()直到系统调用onPause()</p><p>10、 activity在屏幕旋转时的生命周期</p><p>答：</p><p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p><p>11、 如何启用Service，如何停用Service。</p><p>服务的开发比较简单，如下：</p><p>第一步：继承Service类<br>public class SMSService extends Service {}</p><p>第二步：在AndroidManifest.xml文件中的节点里对服务进行配置:<br>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。</p><p>如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。</p><p>如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。</p><p>如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。</p><p>服务常用生命周期回调方法如下：</p><p>onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。</p><p>onDestroy()该方法在服务被终止时调用。</p><p>与采用Context.startService()方法启动服务有关的生命周期方法<br>onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。</p><p>多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。</p><p>与采用Context.bindService()方法启动服务有关的生命周期方法<br>onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。</p><p>onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。</p><p>该方法在调用者与服务解除绑定时被调用</p><p>12、 注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。</p><p>答：首先写一个类要继承BroadcastReceiver</p><p>第一种:在清单文件中声明,添加</p><p>第二种使用代码进行注册如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);</span><br><span class="line">IncomingSMSReceiver receiver = new IncomgSMSReceiver();</span><br><span class="line">registerReceiver(receiver.filter);</span><br></pre></td></tr></table></figure><p>两种注册类型的区别是：</p><p>1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。<br>2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p><p>13、 请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。</p><p>答：</p><p>简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理.</p><p>Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列</p><p>Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息</p><p>Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的</p><p>Handler：Handler接受到消息后调用handleMessage进行处理</p><p>Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理<br>在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。</p><p>下面将对它们进行分别介绍：</p><ol><li><p>Message<br>Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。</p></li><li><p>Handler<br>Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。</p></li><li><p>Message Queue<br>Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。<br>每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。</p></li><li><p>Looper<br>Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。</p></li></ol><p>对于子线程使用Looper，API Doc提供了正确的使用方法：这个Message机制的大概流程：</p><ol><li><p>在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。</p></li><li><p>一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。</p></li></ol><p>随后Looper取出了那个Message，则调用 该Message的target指向的Hander的dispatchMessage函数对Message进行处理。</p><p>在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：</p><p>1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；<br>2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；<br>3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。<br>由此可见，我们实现的handleMessage方法是优先级最低的！</p><ol start="3"><li><p>Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！<br>在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！</p></li><li><p>当Handler对象的构造函数的参数为空，则为当前所在线程的Looper；</p></li><li><p>Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。</p></li></ol><p>14、 简要解释一下activity、 intent 、intent<br>filter、service、Broadcase、BroadcaseReceiver</p><p>答：</p><p>一个activity呈现了一个用户可以操作的可视化用户界面；一个service不包含可见的用户界面，而是在后台运行，可以与一个activity绑定，通过绑定暴露出来接口并与其进行通信；一个broadcast receiver是一个接收广播消息并做出回应的component，broadcast receiver没有界面；一个intent是一个Intent对象，它保存了消息的内容。</p><p>对于activity和service来说，它指定了请求的操作名称和待操作数据的URI，Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。</p><p>但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。它是通过将Intent对象和目标的intent filter相比较来完成这一工作的；一个component的intent filter告诉android该component能处理的intent。</p><p>intent filter也是在manifest文件中声明的。</p><p>15、 说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？</p><p>mvc是model,view,controller的缩写，mvc包含三个部分：</p><p>　　模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。</p><p>　　视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。</p><p>　　控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。</p><p>　　android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：</p><p>　　1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。</p><p>　　2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。</p><p>　　3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p><p>16、 什么是ANR 如何避免它？</p><p>答：</p><p>ANR：Application Not Responding。在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作的在5s内应用程序没能做出反应，BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，这既是ANR。</p><p>避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成。主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。</p><p>17、 什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？</p><p>答：程序出现异常，比如nullpointer。</p><p>避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息</p><p>18、 描述一下android的系统架构</p><p>android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层。</p><p>linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。</p><p>libraries和 android runtime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit（引擎），该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。android的runtime负责解释和执行生成的dalvik格式的字节码。</p><p>　　applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。</p><p>　　applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。</p><p>　　上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。</p><p>android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个 applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。</p><p>19、 请介绍下ContentProvider是如何实现数据共享的。</p><p>一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。</p><p>要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。<br>如何通过一套标准及统一的接口获取其他应用程序暴露的数据？<br>Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。</p><p>20、 Service和Thread的区别？</p><p>答：</p><p>servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。</p><p>1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。</p><p>2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。</p><p>如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。</p><p>既然这样，那么我们为什么要用 Service 呢？</p><p>其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。</p><p>另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。</p><p>举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。</p><p>因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。</p><p>因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。</p><p>21、 Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？</p><p>答：</p><p>会，比如nullpointerException。我遇到过，比如textview.setText()时，textview没有初始化。会导致程序无法正常运行出现forceclose。打开控制台查看logcat信息找出异常信息并修改程序。</p><p>22、 IntentService有何优点?</p><p>答：</p><p>Acitivity的进程，当处理Intent的时候，会产生一个对应的Service； Android的进程处理器现在会尽可能的不kill掉你；非常容易使用</p><p>23、 </p><p>如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？</p><p>答：重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据</p><p>24、 如何将一个Activity设置成窗口的样式。</p><p>答：</p><p>中配置：android :theme=”@android:style/Theme.Dialog”<br>另外android:theme=”@android:style/Theme.Translucent” 是设置透明</p><p>25、 如何退出Activity？如何安全退出已调用多个Activity的Application？</p><p>答：</p><p>对于单一Activity的应用来说，退出很简单，直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。</p><p>对于多个activity，</p><p>1、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。</p><p>2、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。</p><p>3、递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。为了编程方便，最好定义一个Activity基类，处理这些共通问题。</p><p>在2.1之前，可以使用ActivityManager的restartPackage方法。</p><p>它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。<br>注意不要被它的名字迷惑。</p><p>可是，在2.2，这个方法失效了。在2.2添加了一个新的方法，killBackground Processes()，需要权限 android.permission.KILL_BACKGROUND_PROCESSES。可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。<br>另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。</p><p>它需要权限android.permission.FORCE_STOP_PACKAGES。</p><p>并且需要添加android:sharedUserId=”android.uid.system”属性。同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。</p><p>因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。</p><p>而Android.mk是用于在Android源码下编译程序用的。</p><p>从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。</p><p>现提供几个方法，供参考：</p><p>1、抛异常强制退出：<br>该方法通过抛异常，使程序Force Close。<br>验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。</p><p>2、记录打开的Activity：<br>每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。</p><p>3、发送特定广播：<br>在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。</p><p>4、递归退出<br>在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。</p><p>除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。</p><p>但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。</p><p>26、 AIDL的全称是什么？如何工作？能处理哪些类型的数据？</p><p>答：</p><p>全称是：Android Interface Define Language<br>在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢?</p><p>显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. </p><p>在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。</p><p>AIDL(AndRoid接口描述语言)是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.</p><p>AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。</p><p>它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: </p><ol><li><p>引入AIDL的相关类.; </p></li><li><p>调用aidl产生的class.</p></li></ol><p>AIDL的创建方法:</p><p>AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 </p><p>由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:</p><ol><li>不需要import声明的简单Java编程语言类型(int,boolean等)</li><li>String, CharSequence不需要特殊声明</li><li>List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.</li></ol><p>(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持)</p><p>27、 请解释下Android程序运行时权限与文件系统权限的区别。</p><p>答：运行时权限Dalvik( android授权)</p><p>文件系统 linux 内核授权</p><p>28、 系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。</p><p>通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性</p><p>29、 android系统的优势和不足</p><p>答：Android平台手机 5大优势：</p><p>一、开放性<br>在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。</p><p>二、挣脱运营商的束缚<br>在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市 ，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。</p><p>三、丰富的硬件选择<br>这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？</p><p>四、不受任何限制的开发商<br>Android平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、方面的程序和游戏如可控制正是留给Android难题之一。</p><p>五、无缝结合的Google应用<br>如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。</p><p>再说Android的5大不足：</p><p>一、安全和隐私<br>由于手机 与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。</p><p>二、首先开卖Android手机的不是最大运营商<br>众所周知，T-Mobile在23日，于美国纽约发布 了Android首款手机G1。但是在北美市场，最大的两家运营商乃AT&amp;T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！</p><p>三、运营商仍然能够影响到Android手机<br>在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。</p><p>四、同类机型用户减少<br>在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。</p><p>五、过分依赖开发商缺少标准配置<br>在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。但入手开始使用默认的程序同样可以应付多样的需要。在 Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐 播放器，全部依赖第三方开发，缺少了产品的统一性。</p><p>30、 Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念<br>答：DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。</p><p>31、 sim卡的EF文件是什么？有何作用<br>答：sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的</p><p>32、 嵌入式操作系统内存管理有哪几种， 各有何特性<br>　　页式，段式，段页，用到了MMU,虚拟空间等技术</p><p>33、 什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?</p><p>嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。</p><p>34、 一条最长的短信息约占多少byte?</p><p>　　中文70(包括标点)，英文160，160个字节。　　</p><p>35、 有一个一维整型数组int[]data保存的是一张宽为width，高为height的图片像素值信息。请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50% ###。</p><p>36、 如何将SQLite数据库(dictionary.db文件)与apk文件一起发布<br>解答：可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中</p><p>37、 如何将打开res aw目录中的数据库文件?</p><p>解答：在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。</p><p>复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。</p><p>在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。</p><p>38、 DDMS和TraceView的区别?</p><p>DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器 。</p><p>39、 java中如何引用本地语言</p><p>可以用JNI（java native interface java 本地接口）接口 。</p><p>40、 谈谈Android的IPC（进程间通信）机制</p><p>IPC是内部进程通信的简称， 是共享”命名管道”的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。</p><p>41、 NDK是什么</p><p>NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。<br>NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android课程体系</title>
    <link href="https://huangguangda.github.io/2018/05/11/1/"/>
    <id>https://huangguangda.github.io/2018/05/11/1/</id>
    <published>2018-05-11T02:59:53.000Z</published>
    <updated>2018-06-22T03:17:06.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>来源网络收集</p><p>第一阶段：Java se阶段</p><p>阶段    课程    课程内容    讲解知识点</p><p>Java语言基础    入门基础    </p><p>1.Java开发环境搭建<br>（第一天只能使用文本文档编写代码）    </p><p>1.Java语言发展史介绍<br>2.Java体系与特点<br>3.JVM与GC介绍<br>4.Java跨平台原理<br>5.JavaSE组成概念<br>6.JDK与JRE介绍<br>7.Java开发环境搭建<br>8.实现 HelloWorld 程序<br>9.HelloWorld程序编写与分析<br>10.Java中的三种注释<br>11.常见Java开发工具介绍<br>12.Wiki文档的使用技巧    </p><p>1.基本语法与命名规范<br>2.程序分支结构控制<br>3.数组及常用算法<br>（可以考虑使用Editplus编辑器）    </p><p>1.1    变量<br>1.2  数据类型<br>1.3  二进制以及进制间转换<br>1.4  标识符<br>1.5  类型转换<br>1.6  关键字<br>1.7  常量<br>1.8  转义字符<br>1.9  算术运算符<br>1.10  赋值运算符<br>1.11  关系运算符<br>1.12  逻辑运算符<br>1.13  位运算符<br>1.14  移位运算符<br>1.15  字符串连接运算符<br>1.16  三目运算符<br>1.17  运算符优先级</p><p>2.1   if条件语句<br>2.2   switch语句<br>2.3   for循环语句<br>2.4   while循环语句<br>2.5   do while循环语句</p><p>3.1数组四种声明方式以及特性<br>3.2数组插入、遍历等常用操作<br>3.3常用算法：最大、最小、平均值<br>3.4多维数组声明及原理<br>3.5多维数组的存储、遍历等操作    </p><p>面向对象</p><p>基础</p><p>1.面向过程与面向对象思想分析<br>2.封装性<br>3.String类<br>4.this关键字<br>5.static关键字<br>6.对象数组<br>7.JDK1.5新特性<br>8.代码块<br>9.内部类    1.1面向对象思想介绍<br>1.2面向过程与面向对象分析<br>1.3什么是类？什么是对象？<br>1.4类与对象之间的关系<br>1.5类的定义格式<br>1.6对象的定义格式<br>1.7创建对象时的内存分析<br>1.8调用类中的属性，调用方法<br>1.9方法的重载</p><p>2.1   封装性介绍<br>2.2   构造方法<br>2.3   构造方法的重载<br>2.4   匿名对象<br>2.5   如何设计一个类</p><p>3.1   String的两种赋值方式<br>3.2   String的比较<br>3.3   String两种赋值方式的区别<br>3.4   String的值不可改变<br>        （字符串常量池）<br>3.5   String类的常用操作方法<br>3.6   引用传递深入讲解<br>        （课件中三个范例）<br>3.6一对一关系讲解</p><p>4.1   this关键字<br>4.2   this调用类中的属性<br>4.3   this调用类中的方法<br>4.4   this表示当前对象<br>4.5   this接收本类引用<br>        （自定义对象的比较）</p><p>5.1   static关键字介绍<br>5.2   static特点<br>5.3   static访问限制<br>5.4   成员变量和类变量<br>5.5   static属性内存分析<br>5.6   应用案例- - 计数器<br>5.7   main方法讲解<br>5.8   设计模式—单例（懒汉、饿汉）</p><p>6.1   自定义对象定义数组<br>6.2   对象数组案例-商品管理系统</p><p>7.1   foreach输出<br>7.2   可变参数</p><p>8.1   普通代码块<br>8.2   构造块<br>8.3   静态代码块<br>8.4   三种代码块以及构造方法执行顺序</p><p>9.1内部类概念<br>9.2内部类的访问规则<br>9.3内部类的访问限制<br>9.4递归<br>9.5链表（添加、删除、输出）    </p><p>高级    </p><p>1.继承<br>2.super关键字<br>3.final关键字<br>4.抽象类<br>5.接口<br>6.多态性<br>7.instanceOf关键字<br>8.Object类<br>9.抽象类和接口的关系<br>10.接口应用<br>11.匿名内部类<br>12.包装类<br>13.包与访问修饰符<br>14.Eclipse介绍    </p><p>1.1继承的概念（定义）<br>1.2继承的格式<br>1.3继承的好处<br>1.4继承的限制<br>1.5子类的实例化过程<br>1.6访问修饰符讲解<br>1.7重载和重写的区别</p><p>2.1   super关键字<br>2.2   super调用父类中的属性<br>2.3   super调用父类中的方法</p><p>3.1   final关键字<br>3.2   final修饰类<br>3.3   final修饰方法<br>3.4   final修饰属性</p><p>4.1   抽象类概念、定义<br>4.2   抽象方法<br>4.3   抽象类特点<br>4.4   设计模式—模板方法<br>（大保健的例子）</p><p>5.1   接口的定义<br>5.2   接口的特点<br>5.3   接口多实现、不能实例化…<br>5.4   设计模式—策略模式<br>5.5   接口总结（接口中定义什么？）</p><p>6.1   多态概念<br>6.2   两种多态<br>6.3   向上、向下转型<br>6.4   多态的体现<br>6.5   多态的好处<br>6.6   多态的弊端<br>6.7   多态的前提</p><p>7.1   instanceOf关键字<br>7.2   抽象类的实际应用<br>7.3   接口的实际应用</p><p>8.1   Object类讲解<br>8.2   toString方法<br>8.3   equals方法<br>8.4   Object接收任意引用参数</p><p>9.1   （简单介绍即）</p><p>10.1  简单工厂设计模式<br>10.2  代理设计模式<br>（课件案例或潘金莲案例）<br>10.3  适配器模式（课件案例）<br>10.4  面向对象六大原则其中三个</p><p>12.1匿名内部类</p><p>12.1  包装类概念介绍<br>12.2  装箱、拆箱概念<br>12.3  JDK1.5新特性—<br>自动装箱、自动拆箱<br>12.4  转型操作<br>12.5  Integer—享元设计模式</p><p>13.1   包介绍<br>13.2  包的命名规则<br>13.3  访问修饰符的访问范围整理</p><p>14.1Eclipse接受<br>14.2发放Eclipse工具<br>14.3发放Eclipse配色、快捷键大全    </p><p>Java语言高级    异常处理    </p><p>1.认识并处理异常<br>2.异常的处理流程、<br>3.标准的异常处理格式<br>4.RuntimeException和<br>Exception的区别<br>5.自定义异常<br>6.Eclipse  Debug    </p><p>1.1演示算数异常的产生<br>1.2讲解异常结构图<br>1.3讲解Exception和Error的区别<br>1.4使用if语句先处理异常<br>1.5使用try catch处理异常<br>1.6演示数组下标越界异常<br>1.7处理数组下标越界异常</p><p>2.1   讲解异常捕获的流程<br>2.2   异常的统一出口finally<br>2.3   面试题：在try块中有return</p><p>语句并且正常执行，问Finally语句块中的内容是否会执行</p><p>2.4   throws关键字<br>2.5   throw关键字</p><p>3.1   演示标准的异常处理格式<br>3.2   添加多个catch语句块<br>3.3   多个catch块继承关系的顺序<br>3.4   JDK1.7多个catch的新支持<br>4.1   讲解RuntimeException<br>4.2   讲解 Exception<br>4.3   总结区别</p><p>5.1   自定义异常<br>5.2   使用自定义异常</p><p>6.1   讲解Eclipse Debug使用    </p><p>常用类库    </p><p>1.深入StringBuffer类及其操作方法<br>2.国际化程序的实现<br>3.日期操作，Date、DateFormat、SimpleDateFormat等<br>4.比较器的实现及原来二分查找、二叉树、以及对象的克隆    </p><p>1.1由String特性引出<br>1.2介绍StringBuffer特性<br>1.3StringBuffer实现原理：<br>A.默认缓冲区大小<br>B.缓冲区扩充算法<br>1.4StringBuilder介绍<br>1.5面试题：Builder与Buffer区别？</p><p>2.1   介绍国际化程序<br>2.2   Locale类介绍<br>2.3   ResourceBundle类介绍<br>2.2   实现国际化程序<br>2.5   处理动态文本</p><p>3.1   Math类介绍及常用方法演示<br>3.2   Random介绍及演示<br>3.3   Arrays类介绍及演示<br>3.4   演示Arrays类中的binarySearch方法<br>3.5   二分查找法（折半查找）<br>3.6   Date类介绍<br>3.7   Calendar类介绍<br>3.8   使用Calendar实现中国式时间<br>3.9   使用SimpleDateFormat格式化时间</p><p>4.1   Arrays的sort方法引出<br>4.2   Comparable接口讲解<br>4.3   排序规则的讲解<br>4.4   二叉树算法（添加、输出）<br>4.5   Comparator接口讲解<br>4.6   Cloneable接口讲解<br>4.7   对象的克隆实现</p><p>IO操作    </p><p>1.File类的使用及利用递归实现文件搜索器<br>2.字节操作流，InputStream、OutputStream、FileInputStream、ByteArrayInputStream等等<br>3.字符操作流，缓冲流、管道流、合并流<br>4.对象序列化及对象序列化原理，源码解析<br>5.装饰者设计模式    1.1File类的介绍<br>1.2 创建文件<br>1.3 删除文件<br>1.4 判断文件类型<br>1.5 列出目录中的文件<br>1.6 递归遍历文件</p><p>2.1    FileOutputStream<br>2.2    FileInputStream<br>2.3    一次读取一个字节示例<br>2.4    一次读取整个文件示例<br>2.5    定义缓冲区读取文件<br>2.6    文件复制习题</p><p>3.1    字节流读取中文引出乱码<br>3.2    字符流处理中文讲解<br>3.3    示例：使用字节流字符流分别写入文件<br>3.4    引出缓冲区概念，讲解字节流字符流区别<br>3.5    位字节流添加缓冲功能BufferedOutputStream<br>3.6    字节字符转换流OutputStreamWriter</p><p>InputStreamReader</p><p>3.7    使用字符流向文件输出‘97’<br>3.8    引出PrintStream打印流<br>3.9    文件分割、合并练习</p><p>4.1    对象序列化概念介绍<br>4.2    Serializable接口介绍<br>4.2    序列化：ObjectOutputStream<br>4.3    反序列化：ObjectInputStream<br>4.4    序列化一组对象<br>4.5    transient关键字作用<br>4.6    内存操作流ByteArrayInputStream<br>         ByteArrayOutputStream<br>4.7    缓冲区读取：BufferedReader类<br>4.7    数据流DataOutputStream<br>         DataInputStream<br>4.8    将管理系统序列化存储<br>4.9    字符编码介绍<br>4.10  IO体系结构梳理</p><p>5.1    装饰者设计模式讲解    </p><p>集合    </p><p>1.集合与数组的区别，缓存的管理，Collection 、List、Set接口的作用及相关的子类<br>2.Map集合与Conllection的区别，Map的好处及用法HashMap、HashTable、Properties等<br>3.Object 类中的方法及Object类存在的意义泛型的作用、枚举与泛型、泛型的好处<br>4.常用集合工具类Collections<br>5.哈希算法实现原来剖析    </p><p>1.1类集引出<br>1.2集合结构图讲解<br>1.3Collection接口讲解<br>1.4List接口讲解<br>1.5ArrayList实现原理及使用<br>1.6Vector实现原理及使用<br>1.7ArrayList和Vector区别<br>1.8LinkedList实现原理及使用<br>1.9LinkedList当做队列、堆栈使用<br>1.10Set接口讲解<br>1.11HashSet实现原理及使用<br>1.12TreeSet实现原理及使用<br>1.13平衡二叉树介绍<br>1.14集合输出Iterator接口<br>1.15双向输出ListIterator接口<br>1.16介绍废弃的接口Enumeration<br>1.17Foreach输出集合</p><p>2.1Map接口介绍<br>2.2HashMap实现原理及使用<br>2.3Object类中的hashCode方法<br>2.4哈希算法的存储实现原理<br>2.5哈希表的重新散列<br>2.6HashTable实现原理及使用<br>2.7HashMap和HashTable区别<br>2.8TreeMap实现原理 及使用<br>2.9Map集合的输出讲解</p><p>3.1一对多关系讲解<br>3.2多对多关系讲解</p><p>4.1Collections和Collection区别</p><p>5.1   分析hashCode、equals和内存泄露    </p><p>多线程    </p><p>1.进程和线程关系及区别<br>2.Thread与Runnable底层原理及使用作用原理<br>3.线程的优先级、线程池<br>4.线程的同步与死锁线程的并发处理    </p><p>1.1进程的概念<br>1.2线程的概念<br>1.3多线程概念介绍<br>1.4线程的两种实现方式<br>2<br>2.1两种实现方式的区别<br>2.2线程的操作状态<br>2.3线程的常用操作方法<br>2.4线程的强制执行<br>2.5线程的休眠<br>2.6线程的中断原理<br>3<br>3.1线程的优先级介绍<br>3.2线程池介绍及使用<br>4<br>4.1买票例子引出线程同步问题<br>4.2同步方法与同步代码块解决问题<br>4.3JDK1.5 新的加锁方式Lock<br>4.4模拟线程死锁<br>4.5生产者消费者案例讲解<br>4.6线程的生命周期    通过本章学习，可以掌握Java中线程的两种实现方式，熟练使用Java中的多线程，要求掌握Java中线程的同步并且避免Java中线程的死锁问题。理解并熟练使用线程池。    2<br>    网络编程    1.TCP、UDP程序的实现<br>2.ServerSocket  和Scoket 类的使用<br>3.URLConnection的使用    1.1计算机网络介绍<br>1.2网络通信协议介绍<br>1.3网络通信接口介绍<br>1.4CS/BS程序介绍<br>1.5TCP/IP协议介绍<br>1.6三次握手原理讲解<br>2<br>2.1使用Socket、和ServerSocket<br>编写服务器端程序<br>2.2使用Socket写客户端程序<br>2.3为服务器端加入ECHO<br>2.4为服务器端加入多线程<br>2.5UDP协议介绍<br>2.6使用DatagramPacket、<br>DatagramSocket实现UDP程序</p><p>3.1   URL介绍<br>3.2   URLConnection介绍<br>3.3   连网下载图片案例讲解    </p><p>GUI编程    </p><p>1.常用组件了解<br>2.事件与监听器<br>3.观察者设计模式    1.1GUI介绍<br>1.2AWT组成结构介绍<br>1.3Component类介绍<br>1.4Frame类介绍<br>1.5Panel讲解<br>1.6实现我们的第一个窗体<br>1.7Toolkit介绍<br>1.8使用Toolkit设置初始化位置<br>1.9布局介绍<br>1.10四种布局讲解</p><p>2.1实现事件处理的步骤<br>2.23种事件处理方式</p><p>3.1观察者设计模式实现<br>3.2使用JDK提供的观察者<br>3.3Swing介绍<br>3.4使用swing画登录窗体    </p><p>反射内省    1.Java Reflection API的作用、检查运行时的对象、动态更新字段、调用方法</p><p>2.反射主要的类 Class 、Method 、Field 、Constructor<br>3.内省机制的使用    </p><p>1.1什么是反射<br>1.2Class类讲解<br>1.3Class类的三种实例化方式<br>1.4使用Class类实例化对象<br>1.5反射调用无参构造方法<br>1.6反射调用有参构造方法<br>1.7反射类所在的包<br>1.8反射获取类中的属性（公有）<br>1.9反射获取类中的私有属性<br>1.10反射调用类中的私有方法</p><p>2.1Constructor类介绍<br>2.2Method类介绍<br>2.3Field类介绍</p><p>3.1内省概念介绍<br>3.2JavaBean介绍<br>3.3标准的get/set介绍<br>3.4使用trospector模拟框架底层</p><p>XML    </p><p>1.XML基础简介<br>2.XML的解析方式<br>3.深入XML两种解析思想DOM与SAX<br>4.DOM4J与JDOM    </p><p>1.1XML介绍<br>1.2XML用途</p><p>2.1XML的两种解析原理<br>2.2DOM原理讲解<br>2.3DOM解析示例<br>2.4SAX原理讲解<br>2.5SAX解析示例</p><p>3.1JDOM解析示例<br>3.2DOM4J解析示例<br>3.3通过对象生成XML文件<br>3.4各种解析方法分析比较    </p><p>XML文件可以用作数据的存储，数据传输，配置文件。</p><p>第二阶段：Java Web（2周/10天共60课时）</p><p>数据库应用    MySQL    </p><p>1.Mysql安装、基础语法、DDL、DML、DCL语法的操作、事务管理、数据库设计范式等    </p><p>JDBC    </p><p>1.JDBC实现对Mysql实现CURD操作<br>2.Sql注入问题及解决方案<br>3.批处理与事务控制<br>4.DAO设计模式</p><p>Java Web<br>前台与服务器端应用    </p><p>1.HTML标签<br>2.Web服务器环境搭建与配置<br>3.Web三大组件，Servlet<br>4.使用httpwatch解析Http协议原理<br>5.Web程序设计及MVC设计模式<br>6.Html5与JavaScript    </p><p>第三阶段：Android阶段</p><p>Android基础<br>Android入门    </p><p>1.Android简史<br>2.Android体系结构<br>3.DVM与JVM<br>4.SDK的获取(搭环境)<br>5.SDK目录结构<br>6.创建模拟器启动<br>7.运行HelloWord<br>8.项目目录结构<br>9.应用打包安装过程<br>10.DDMS使用<br>11.Logcat的使用</p><p>Android基础UI    </p><p>1.常用基本控件<br>2.Toast<br>3.常用响应事件<br>4.Menu<br>5.Dialog<br>6.常用布局</p><p>掌握Android<br>常用Menu 与 各种Dialog, 以及Android的五种布局    </p><p>Android文件读写<br>1.内部存储与外部存   储概念<br>2.内部存储读写文件<br>3.使用路径API在内部存储中读写文件<br>4.文件访问权限<br>5.外部存储读写文件<br>6.导入Setting源码<br>7.获取SD卡剩余容量<br>8.SharedPreference的使用    </p><p>掌握</p><p>SharedPreference的使用方式    </p><p>生成XML文件,Android单元测试与数据库操作    </p><p>1.Xml生成与解析 并通过debug 查看解析过程<br>2.Android中的单元测试<br>3.SQLite数据库简介<br>4.创建数据库<br>5.增删改查<br>6.SQLite事物<br>7.数据展示</p><p>Android单元测试</p><p>SQLite数据库的使用;<br>    AdapterView    </p><p>1.ListView 预览<br>2.Adapter简介<br>3.ListView的使用<br>4.ArrayAdapter ,SimpleAdapter ,CursorAdapter , SimpleCursorAdapter 等adapter的使用<br>5.BaseAdapter的使用(自定义Adapter)<br>6.Spinner选择列表的使用<br>7.GridView网格视图的使用<br>8.ListView , Spinner , GridView与BaseAdapter结合;<br>9.ListView , Spinner , GridView缓存原理与BaseAdapter优化    </p><p>Android进阶    Activity与 Intent    </p><p>1.Activity使用<br>2.Activity四大加载模式<br>2.Activity 生命周期<br>3.Activity 启动与关闭<br>4.Activity 横竖屏<br>5.Intent属性与使用<br>6.Activity 显式 隐式 带返回值跳转<br>7.IntentFilter(过滤器)<br>8.Activity回退栈原理</p><p>多线程与Android网络编程    </p><p>1.Android进程与线程<br>2.UI线程模型<br>3.Handler机制<br>4.使用消息队列刷新UI<br>5.AsyncTask的使用<br>6.进程通信<br>7.Android网络编程简介<br>8.获取网络状态<br>9.Get Post提交数据<br>10.Http协议<br>11.下载数据并建立本地缓存<br>12.JSON生成与解析 , Gson.jar包使用</p><p>1.服务介绍<br>2.启动Service与生命周期<br>3.绑定Service与生命周期<br>4.混合启动Service与声明周期<br>5.启动远程服务</p><ol start="6"><li>AIDL的使用</li></ol><p>Android四大组件之广播    </p><p>1.Android广播机制与概念<br>2.定义广播接收者<br>3.无序广播与有序广播<br>4.短信拦截系统<br>5.内存卡状态监听<br>6.监控应用状态<br>7.发送无序广播与有序广播<br>8.发送系统级广播</p><p>Android四大组件之内容提供者    </p><p>1.内容提供者简介<br>2.增删改差<br>3.URL匹配器<br>4.备份系统短信<br>5.插入系统短信<br>6.备份通讯录<br>7.插入联系人</p><p>Android多媒体编程    </p><p>1.摄像头的使用<br>2.图片处理<br>3.画板<br>4.音乐播放<br>5.视频播放    </p><p>Android动画    </p><p>1.动画简介<br>2.逐帧动画<br>3.补间动画<br>4.XML与JAVA代码形式实现<br>5.混合使用补间动画    </p><p>Android高级    </p><p>高级UI组件<br>与<br>常用开源组件</p><p>1.widget 桌面控件<br>2.XlistView 上拉刷新, 下拉加载更多<br>3.Drawerlayout抽屉效果<br>4.PopupWindow 定点弹窗<br>5.ExpandableListView 二级展开列表<br>6.ViewPager 滑动<br>7.WebView 网页加载    </p><p>Android碎片化之Fragment    </p><p>1.Android碎片化介绍<br>2.Fragment简介<br>3.FragmentManager使用<br>4.Fragment生命周期<br>5.Fragment使用方式<br>6.Fragment事物<br>7.Fragment 常见错误使用方式<br>8.Fragment与Viewpager结合使用    </p><p>开源框架之Volly    </p><p>1.Volly框架简介<br>2.创建请求队列<br>3.请求对象 StringRequest , JsonObjecyRequest,<br>JsonArrayRequest,<br>4.GET/POST请求<br>5.绑定Activity<br>6.二次回调封装<br>7.ImageRequest,<br>ImageLoader,<br>NetWorkImageView, 加载网络图片 并 监听<br>8.lruCache与ImageCache 本地缓存    </p><p>开源框架之Xutils    </p><p>1.Xutils四大模块简介<br>2.ViewUtils模块: 简化界面代码<br>3.DBUtils模块: 简化数据库操作<br>4.BitmapUtils模块: 优化图片加载<br>5.HttpUtils 模块: GET/POST请求网络    </p><p>开源框架之UniversalImageLoader    </p><p>1.图片加载器ImageLoader的单例模式简介<br>2.ImageLoaderConfiguration的作用<br>3.使用默认的ImageLoaderConfiguration给图片加载器ImageLoader配置加载参数<br>4.通过API方法自行创建ImageLoaderConfiguration对象设置加载参数<br>5.通过displayImage()异步加载图片<br>6.通过loadImage()异步加载图片<br>7.PauseOnScrollListener监听器的使用    </p><p>开源框架之Glide    </p><p>1.Glide简介<br>2.Glide中Gif动图与视频的解码方式介绍,<br>3.使用Glide加载gif图<br>4.使用Glide加载缩略图    </p><p>开源框架之Cropper    </p><p>1.Cropper简介<br>2.使用Cropper剪裁图片<br>3.使用Cropper实现图片旋转等    </p><p>LSB应用    百度地图</p><p>1.百度地图API简介<br>2.注册百度开发者以及地图访问密钥<br>3.集成百度地图SDK并成功调用出地图页面<br>5.设置地图显示类型<br>6.百度地图图层概念介绍<br>7.添加实时交通状况图层、添加热力图图层、添加标注点图层、添加弹出窗图层<br>8.使用百度地图实现定位<br>9.使用百度地图实现路径规划（步行、公共交通、驾车）<br>10.使用百度地图实现POI检索（附近检索、全程检索、详情检索</p><p>Android6.0新特性</p><p>Android M特点及Android Studio    </p><p>1.Android Studio下载与安装<br>2.Studio项目结构与运行HelloWord<br>3.常用功能介绍<br>4.常用快捷键介绍<br>5.导出导入Eclipse项目<br>6.APK打包签名设置<br>7.Gradle Plugin 中 buildTypes 、 productFlavors<br>8.Android6.0与新特性<br>9.Gradle自动化项目构建工具    </p><p>高级应用    </p><p>项目构建工具、项目版本管理、Android测试与发布、阿里云服务器    </p><p>1.Gradle项目构建工具<br>2.Git项目版本控制<br>3.JUnit单元测试<br>4.Android应用发布流程<br>5.阿里云服务器搭建及使用技巧    </p><p>编辑 ：达叔</p><p>定位：分享 Android&amp;Java 知识点</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android技术面试整理附有详细答案(包括百度、新浪、中科软等多家公司笔试面试题)</title>
    <link href="https://huangguangda.github.io/2018/05/10/1/"/>
    <id>https://huangguangda.github.io/2018/05/10/1/</id>
    <published>2018-05-10T02:30:45.000Z</published>
    <updated>2018-06-22T02:34:47.684Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>1、Android的四大组件是哪些，它们的作用？</p><p>答：</p><p>Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑</p><p>service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的食物，定义好需要接受的Intent提供同步和异步的接口</p><p>Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的借口模型，大大简化上层应用，对数据的整合提供了更方便的途径</p><p>BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型</p><p>2、请介绍下Android中常用的五种布局。</p><p>常用五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。</p><p>一、</p><p>FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。</p><p>二、</p><p>LinearLayout：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）。</p><p>当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。</p><p>三、</p><p>AbsoluteLayout：绝对布局，用X,Y坐标来指定元素的位置，这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。</p><p>四、</p><p>RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。</p><p>主要属性有：</p><p>相对于某一个元素<br>android:layout_below、android:layout_toLeftOf</p><p>相对于父元素的地方<br>android:layout_alignParentLeft、android:layout_alignParentRigh；</p><p>五、</p><p>TableLayout：表格布局，每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素。每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。</p><p>3、android中的动画有哪几类，它们的特点和区别是什么  </p><p>答：</p><p>两种，</p><p>一种是Tween动画、还有一种是Frame动画。</p><p>Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;</p><p>另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。</p><p>4、android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。</p><p>答：</p><p>XML解析主要有三种方式，SAX、DOM、PULL。</p><p>常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。</p><p>而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。</p><p>SAX和PULL使用</p><p>Pull解析器的运行方式与 SAX 解析器相似</p><pre><code>区别为：SAX解析器的工作方式是自动将事件推入事件处理器进行处理，因此你不能控制事件的处理主动结束；而Pull解析器的工作方式为允许你的应用程序代码主动从解析器中获取事件，正因为是主动获取事件，因此可以在满足了需要的条件后不再获取事件，结束解析。你随便找个sax和pull的例子比较一下就可以发现，pull是一个while循环，随时可以跳出，而sax不是，sax是只要解析了，就必须解析完成。</code></pre><p>5、ListView的优化方案</p><p>答：</p><p>1、</p><p>如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。</p><p>2、</p><p>给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。</p><p>3、</p><p>如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。</p><p>6、请介绍下Android的数据存储方式。</p><p>答：</p><p>使用SharedPreferences存储数据；<br>文件存储数据；<br>SQLite数据库存储数据；<br>使用ContentProvider存储数据；<br>网络存储数据；</p><p>Preference，File， DataBase这三种方式</p><p>分别对应的目录是</p><p>/data/data/Package Name/Shared_Pref, </p><p>/data/data/Package Name/files, </p><p>/data/data/Package Name/database 。</p><p>一：使用SharedPreferences存储数据</p><p>首先说明SharedPreferences存储方式，它是 Android提供的用来存储一些简单配置信息的一种机制，例如：登录用户的用户名与密码。</p><p>其采用了Map数据结构来存储数据，以键值的方式存储，可以简单的读取与写入，具体实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void ReadSharedPreferences()&#123;</span><br><span class="line"></span><br><span class="line">String strName,strPassword;</span><br><span class="line"></span><br><span class="line">SharedPreferences user = getSharedPreferences(“user_info”,0);</span><br><span class="line"></span><br><span class="line">strName = user.getString(“NAME”,””);</span><br><span class="line">strPassword = user.getString(“PASSWORD”,””);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void WriteSharedPreferences(String strName,String strPassword)&#123;</span><br><span class="line"></span><br><span class="line">SharedPreferences user = getSharedPreferences(“user_info”,0);</span><br><span class="line"></span><br><span class="line">uer.edit();</span><br><span class="line">user.putString(“NAME”, strName);</span><br><span class="line">user.putString(“PASSWORD” ,strPassword);</span><br><span class="line">user.commit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据读取与写入的方法都非常简单，只是在写入的时候有些区别：先调用edit()使其处于编辑状态，然后才能修改数据，最后使用commit()提交修改的数据。</p><p>实际上SharedPreferences是采用了XML格式将数据存储到设备中，<br>在DDMS中的File Explorer中的/data/data/<package name="">/shares_prefs下。</package></p><p>使用SharedPreferences是有些限制的：只能在同一个包内使用，不能在不同的包之间使用。</p><p>二：文件存储数据</p><p>文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与 Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。具体实例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String fn = “moandroid.log”;</span><br><span class="line">FileInputStream fis = openFileInput(fn);</span><br><span class="line">FileOutputStream fos = openFileOutput(fn,Context.MODE_PRIVATE);</span><br></pre></td></tr></table></figure><p>三：网络存储数据</p><p>网络存储方式，需要与Android 网络数据包打交道，关于Android 网络数据包的详细说明，请阅读Android SDK引用了Java SDK的哪些package？。</p><p>四：ContentProvider</p><p>1、ContentProvider简介</p><p>当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。</p><p>2、Uri类简介</p><p>Uri代表了要操作的数据，Uri主要包含了两部分信息：</p><p>1.需要操作的ContentProvider ，</p><p>2.对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成：</p><p>1.scheme：ContentProvider（内容提供者）的scheme已经由Android所规定为：content://…<br>2.主机名（或Authority）：用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。<br>3.路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下：</p><p>要操作contact表中id为10的记录，可以构建这样的路径:/contact/10</p><p>要操作contact表中id为10的记录的name字段， contact/10/name</p><p>要操作contact表中的所有记录，可以构建这样的路径:/contact?</p><p>要操作的数据不一定来自数据库，也可以是文件等他存储方式，如下:</p><p>要操作xml文件中contact节点下的name节点，可以构建这样的路径：/contact/name<br>如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：<br>Uri uri = Uri.parse(“content://com.changcheng.provider.contactprovider/contact”)</p><p>3、UriMatcher、ContentUrist和ContentResolver简介</p><p>因为Uri代表了要操作的数据，所以我们很经常需要解析Uri，并从 Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher 和ContentUris 。掌握它们的使用，会便于我们的开发工作。<br>UriMatcher：用于匹配Uri，它的用法如下：</p><p>1.首先把你需要匹配Uri路径全部给注册上，如下：</p><p>//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码(-1)。<br>UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);</p><p>//如果match()方法匹配content://com.changcheng.sqlite.provider.contactprovider /contact路径，返回匹配码为1</p><p>uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact”, 1);//添加需要匹配uri，如果匹配就会返回匹配码</p><p>//如果match()方法匹配 content://com.changcheng.sqlite.provider.contactprovider/contact/230路径，返回匹配码为2</p><p>uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact/#”, 2);//#号为通配符</p><p>2.注册完需要匹配的Uri后，就可以使用uriMatcher.match(uri)</p><p>方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用 addURI()方法传入的第三个参数，假设匹配 content://com.changcheng.sqlite.provider.contactprovider/contact路径，返回的匹配码为1。</p><p>ContentUris：用于获取Uri路径后面的ID部分，它有两个比较实用的方法：</p><p>withAppendedId(uri, id)用于为路径加上ID部分<br>parseId(uri)方法用于从路径中获取ID部分<br>ContentResolver：当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用 ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver使用insert、delete、update、query方法，来操作数据。</p><p>7、activity的启动模式有哪些？是什么含义？</p><p>答：</p><p>在android里，有4种activity的启动模式，分别为：<br>“standard” (默认)<br>“singleTop”<br>“singleTask”<br>“singleInstance”</p><p>它们主要有如下不同：</p><ol><li>如何决定所属task </li></ol><p>“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。<br>如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。<br>“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。</p><ol start="2"><li>是否允许多个实例 </li></ol><p>“standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例； </p><p>“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 </p><p>singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。</p><ol start="3"><li>是否允许其它activity存在于本task内 </li></ol><p>“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。<br>而另外三种模式，则可以和其它activity共存。</p><ol start="4"><li>是否每次都生成新实例 </li></ol><p>“standard”对于没一个启动Intent都会生成一个activity的新实例；<br>“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。 </p><p>比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。 </p><p>如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D<br>如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。</p><p>“singleInstance”是其所在栈的唯一activity，它会每次都被重用。<br>“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。</p><p>当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。</p><p>8、跟activity和Task 有关的 Intent启动方式有哪些？其含义？</p><p>核心的Intent Flag有：<br>FLAG_ACTIVITY_NEW_TASK<br>FLAG_ACTIVITY_CLEAR_TOP<br>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED<br>FLAG_ACTIVITY_SINGLE_TOP<br>FLAG_ACTIVITY_NEW_TASK </p><p>  如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的 Activity）定义了用户可以迁移的Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。 </p><p>  这个标志一般用于呈现“启动”类型的行为：它们提供用户一系列可以单独完成的事情，与启动它们的Activity完全无关。 </p><p>  使用这个标志，如果正在启动的Activity的Task已经在运行的话，那么，新的Activity将不会启动；代替的，当前Task会简单的移入前台。参考FLAG_ACTIVITY_MULTIPLE_TASK标志，可以禁用这一行为。 </p><p>  这个标志不能用于调用方对已经启动的Activity请求结果。</p><p>FLAG_ACTIVITY_CLEAR_TOP </p><p>  如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。 </p><p>  例如，假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。 </p><p>  上例中正在运行的Activity B既可以在onNewIntent()中接收到这个新的Intent，也可以把自己关闭然后重新启动来接收这个Intent。如果它的启动模式声明为 “multiple”(默认值)，并且你没有在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，那么它将关闭然后重新创建；对于其它的启动模式，或者在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，都将把这个Intent投递到当前这个实例的onNewIntent()中。 </p><p>  这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。 </p><p>FLAG_ACTIVITY_RESET_TASK_IF_NEEDED </p><pre><code>如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。</code></pre><p>FLAG_ACTIVITY_SINGLE_TOP </p><p>  如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的<br>FLAG_ACTIVITY_BROUGHT_TO_FRONT<br>  这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。 </p><p>FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET </p><p>  如果设置，这将在Task的Activity stack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。 </p><p>  这在你的程序有分割点的时候很有用。例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个 Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。 </p><p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS </p><p>  如果设置，新的Activity不会在最近启动的Activity的列表中保存。<br>FLAG_ACTIVITY_FORWARD_RESULT<br>  如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的 Activity。<br>FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY<br>  这个标志一般不由应用程序代码设置，如果这个Activity是从历史记录里启动的（常按HOME键），那么，系统会帮你设定。 </p><p>FLAG_ACTIVITY_MULTIPLE_TASK </p><p>  不要使用这个标志，除非你自己实现了应用程序启动器。与FLAG_ACTIVITY_NEW_TASK结合起来使用，可以禁用把已存的Task送入前台的行为。当设置时，新的Task总是会启动来处理Intent，而不管这是是否已经有一个Task可以处理相同的事情。 </p><p>  由于默认的系统不包含图形Task管理功能，因此，你不应该使用这个标志，除非你提供给用户一种方式可以返回到已经启动的Task。 </p><p>  如果FLAG_ACTIVITY_NEW_TASK标志没有设置，这个标志被忽略。 </p><p>FLAG_ACTIVITY_NO_ANIMATION </p><p>  如果在Intent中设置，并传递给Context.startActivity()的话，这个标志将阻止系统进入下一个Activity时应用 Acitivity迁移动画。这并不意味着动画将永不运行——如果另一个Activity在启动显示之前，没有指定这个标志，那么，动画将被应用。这个标志可以很好的用于执行一连串的操作，而动画被看作是更高一级的事件的驱动。 </p><p>FLAG_ACTIVITY_NO_HISTORY </p><p>  如果设置，新的Activity将不再历史stack中保留。用户一离开它，这个Activity就关闭了。这也可以通过设置noHistory特性。 </p><p>FLAG_ACTIVITY_NO_USER_ACTION </p><p>  如果设置，作为新启动的Activity进入前台时，这个标志将在Activity暂停之前阻止从最前方的Activity回调的onUserLeaveHint()。 </p><p>  典型的，一个Activity可以依赖这个回调指明显式的用户动作引起的Activity移出后台。这个回调在Activity的生命周期中标记一个合适的点，并关闭一些Notification。 </p><p>  如果一个Activity通过非用户驱动的事件，如来电或闹钟，启动的，这个标志也应该传递给Context.startActivity，保证暂停的Activity不认为用户已经知晓其Notification。<br>FLAG_ACTIVITY_PREVIOUS_IS_TOP </p><p>  If set and this intent is being used to launch a new activity from an existing one, the current activity will not be counted as the top activity for deciding whether the new intent should be delivered to the top instead of starting a new one. The previous activity will be used as the top, with the assumption being that the current activity will finish itself immediately. </p><p>FLAG_ACTIVITY_REORDER_TO_FRONT </p><p>  如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。<br>  例如，假设一个Task由四个Activity组成：A,B,C,D。如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。 </p><p>9、请描述下Activity的生命周期。</p><p>答：</p><p>activity的生命周期方法有：</p><p>onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()；</p><p>可见生命周期：从onStart()直到系统调用onStop()</p><p>前台生命周期：从onResume()直到系统调用onPause()</p><p>10、activity在屏幕旋转时的生命周期</p><p>答：</p><p>不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法</p><p>11、如何启用Service，如何停用Service。</p><p>服务的开发比较简单，如下：</p><p>第一步：继承Service类</p><p>public class SMSService extends Service {}</p><p>第二步：在AndroidManifest.xml文件中的<application></application></p><p>节点里对服务进行配置:<service android:name=".SMSService"></service></p><p>服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。</p><p>这两个方法都可以启动Service，但是它们的使用场合有所不同。</p><p>使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。</p><p>使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。</p><p>如果打算采用Context.startService()</p><p>方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。</p><p>如果调用startService()<br>方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。</p><p>采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。</p><p>如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。</p><p>这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。</p><p>如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。</p><p>如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。</p><p>服务常用生命周期回调方法如下： </p><p>onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。</p><p>onDestroy()该方法在服务被终止时调用。</p><p>与采用Context.startService()方法启动服务有关的生命周期方法<br>onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。</p><p>该方法在服务开始运行时被调用。</p><p>多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。<br>与采用Context.bindService()方法启动服务有关的生命周期方法<br>onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。</p><p>该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。</p><p>onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。</p><p>该方法在调用者与服务解除绑定时被调用</p><p>12、注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。</p><p>答：</p><p>首先写一个类要继承BroadcastReceiver</p><p>第一种:在清单文件中声明,添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receive android:name=&quot;.IncomingSMSReceiver &quot; &gt;</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">   &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;)</span><br><span class="line">&lt;intent-filter&gt;</span><br><span class="line">&lt;receiver&gt;</span><br></pre></td></tr></table></figure><p>第二种使用代码进行注册如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);</span><br><span class="line">IncomingSMSReceiver receiver = new IncomgSMSReceiver();</span><br><span class="line">registerReceiver(receiver.filter);</span><br></pre></td></tr></table></figure><p>两种注册类型的区别是：</p><p>1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。<br>2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</p><p>13、请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。</p><p>答：</p><p>简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理.</p><p>Message Queue(消息队列)</p><p>：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列</p><p>Handler：</p><p>可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息</p><p>Looper：</p><p>是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的</p><p>Handler：</p><p>Handler接受到消息后调用handleMessage进行处理</p><p>Message：</p><p>消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理<br>在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。</p><p>下面将对它们进行分别介绍：</p><ol><li><p>Message<br> Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。</p></li><li><p>Handler<br> Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。</p></li><li><p>Message Queue<br> Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。<br> 每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。</p></li><li><p>Looper<br> Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。对于子线程使用Looper，API Doc提供了正确的使用方法：</p></li></ol><p>这个Message机制的大概流程：</p><ol><li><p>在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。</p></li><li><p>一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。</p></li></ol><p>随后Looper取出了那个Message，则调用 该Message的target指向的Hander的dispatchMessage函数对Message进行处理。在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低：</p><pre><code>1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。由此可见，我们实现的handleMessage方法是优先级最低的！</code></pre><ol start="3"><li>Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！</li></ol><p>在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！ </p><pre><code>1. 当Handler对象的构造函数的参数为空，则为当前所在线程的Looper； </code></pre><ol start="2"><li>Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。</li></ol><p>14、简要解释一下activity、 intent 、intent filter、service、Broadcase、BroadcaseReceiver</p><p>答：</p><p>一个activity呈现了一个用户可以操作的可视化用户界面；一个service不包含可见的用户界面，而是在后台运行，可以与一个activity绑定，通过绑定暴露出来接口并与其进行通信；一个broadcast receiver是一个接收广播消息并做出回应的component，broadcast receiver没有界面；一个intent是一个Intent对象，它保存了消息的内容。</p><p>对于activity和service来说，它指定了请求的操作名称和待操作数据的URI，Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。它是通过将Intent对象和目标的intent filter相比较来完成这一工作的；一个component的intent filter告诉android该component能处理的intent。intent filter也是在manifest文件中声明的。</p><p>15、说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？</p><p>mvc是model,view,controller的缩写，mvc包含三个部分：</p><p>　　模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。<br>　　视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。<br>　　控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。</p><p>　　android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下：</p><p>　　1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。</p><p>　　2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。</p><p>　　3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。</p><p>16、什么是ANR 如何避免它？</p><p>答：</p><p>ANR：Application Not Responding。在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作的在5s内应用程序没能做出反应，BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，这既是ANR。</p><p>避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成。主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。</p><p>17、什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？</p><p>答：程序出现异常，比如nullpointer。</p><p>避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息</p><p>18、描述一下android的系统架构</p><p>android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层。</p><p>linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。</p><p>libraries和 android runtime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit（引擎），该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。</p><p>android的runtime负责解释和执行生成的dalvik格式的字节码。</p><p>　　applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。</p><p>　　applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。</p><p>　　上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。</p><p>android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个 applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。</p><p>19、请介绍下ContentProvider是如何实现数据共享的。</p><p>一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。</p><p>要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。</p><p>如何通过一套标准及统一的接口获取其他应用程序暴露的数据？</p><p>Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。</p><p>20、Service和Thread的区别？</p><p>答：</p><p>servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。</p><p>1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。</p><p>2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。</p><p>既然这样，那么我们为什么要用 Service 呢？</p><p>其实这跟 android 的系统机制有关，我们先拿 Thread 来说。</p><p>Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。</p><p>因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。</p><p>另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。  </p><p>举个例子：</p><p>如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。  </p><p>因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。</p><p>21、Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？</p><p>答：</p><p>会，比如nullpointerException。我遇到过，比如textview.setText()时，textview没有初始化。会导致程序无法正常运行出现forceclose。打开控制台查看logcat信息找出异常信息并修改程序。</p><p>22、IntentService有何优点?</p><p>答：Acitivity的进程，当处理Intent的时候，会产生一个对应的Service； Android的进程处理器现在会尽可能的不kill掉你；非常容易使用</p><p>23、如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？</p><p>答：重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据</p><p>24、如何将一个Activity设置成窗口的样式。</p><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity&gt;中配置：android :theme=&quot;@android:style/Theme.Dialog&quot; </span><br><span class="line">另外android:theme=&quot;@android:style/Theme.Translucent&quot; 是设置透明</span><br></pre></td></tr></table></figure><p>25、如何退出Activity？如何安全退出已调用多个Activity的Application？</p><p>答：</p><p>对于单一Activity的应用来说，退出很简单，直接finish()即可。</p><p>当然，也可以用killProcess()和System.exit()这样的方法。</p><p>对于多个activity，</p><p>1、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。</p><p>2、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。</p><p>3、递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。</p><p>为了编程方便，最好定义一个Activity基类，处理这些共通问题。</p><p>在2.1之前，可以使用ActivityManager的restartPackage方法。</p><p>它可以直接结束整个应用。</p><p>在使用时需要权限android.permission.RESTART_PACKAGES。</p><p>注意不要被它的名字迷惑。</p><p>可是，在2.2，这个方法失效了。</p><p>在2.2添加了一个新的方法，killBackground Processes()，需要权限 android.permission.KILL_BACKGROUND_PROCESSES。</p><p>可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。</p><p>另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。</p><p>它需要权限android.permission.FORCE_STOP_PACKAGES。并且需要添加android:sharedUserId=”android.uid.system”属性。</p><p>同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。</p><p>因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。</p><p>而Android.mk是用于在Android源码下编译程序用的。</p><p>从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。<br>现提供几个方法，供参考：</p><p>1、抛异常强制退出：<br>该方法通过抛异常，使程序Force Close。<br>验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。</p><p>2、记录打开的Activity：<br>每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。</p><p>3、发送特定广播：<br>在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。</p><p>4、递归退出<br>在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。</p><p>除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。</p><p>但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。</p><p>26、AIDL的全称是什么？如何工作？能处理哪些类型的数据？</p><p>答：</p><p>全称是：Android Interface Define Language<br>在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢?</p><p>显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. 在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。</p><p>AIDL(AndRoid接口描述语言)是一种接口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象.</p><p>AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class.</p><p>AIDL的创建方法:</p><p>AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 </p><p>由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型:</p><ol><li>不需要import声明的简单Java编程语言类型(int,boolean等)</li><li>String, CharSequence不需要特殊声明</li><li>List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.<br>(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持)</li></ol><p>27、请解释下Android程序运行时权限与文件系统权限的区别。</p><p>答：</p><p>运行时权限Dalvik( android授权)<br>文件系统 linux 内核授权</p><p>28、</p><p>系统上安装了多种浏览器，能否指定某浏览器访问指定页面？</p><p>请说明原由。<br>通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性</p><p>29、android系统的优势和不足</p><p>答：Android平台手机 5大优势： </p><p>一、开放性 </p><p>在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。</p><p>二、挣脱运营商的束缚 </p><p>在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市 ，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。</p><p>三、丰富的硬件选择 </p><p>这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？</p><p>四、不受任何限制的开发商 </p><p>Android平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、情色方面的程序和游戏如可控制正是留给Android难题之一。</p><p>五、无缝结合的Google应用 </p><p>如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。<br>再说Android的5大不足：</p><p>一、安全和隐私 </p><p>由于手机 与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。</p><p>二、首先开卖Android手机的不是最大运营商 </p><p>众所周知，T-Mobile在23日，于美国纽约发布 了Android首款手机G1。</p><p>但是在北美市场，最大的两家运营商乃AT&amp;T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！</p><p>三、运营商仍然能够影响到Android手机 </p><p>在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。</p><p>Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。</p><p>四、同类机型用户减少 </p><p>在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。</p><p>举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。</p><p>五、过分依赖开发商缺少标准配置 </p><p>在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。</p><p>但入手开始使用默认的程序同样可以应付多样的需要。</p><p>在 Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐 播放器，全部依赖第三方开发，缺少了产品的统一性。</p><p>30、Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念 </p><p>答：</p><p>DVM指dalivk的虚拟机。</p><p>每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。</p><p>而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。</p><p>31、sim卡的EF文件是什么？有何作用</p><p>答：</p><p>sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的</p><p>32、嵌入式操作系统内存管理有哪几种， 各有何特性</p><p>　　页式，段式，段页，用到了MMU,虚拟空间等技术</p><p>33、什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?</p><p>嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。</p><p>主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。</p><p>34、一条最长的短信息约占多少byte?</p><p>　　中文70(包括标点)，英文160，160个字节。<br>　　<br>35、有一个一维整型数组int[]</p><p>data保存的是一张宽为width，高为height的图片像素值信息。</p><p>请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50%。</p><p>36、如何将SQLite数据库(dictionary.db文件)与apk文件一起发布</p><p>解答：</p><p>可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。</p><p>所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。</p><p>可以将dictionary.db文件复制到res aw目录中</p><p>37、如何将打开res aw目录中的数据库文件?</p><p>解答：</p><p>在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。</p><p>复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。</p><p>在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。</p><p>38、DDMS和TraceView的区别? </p><p>DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器 。</p><p>39、java中如何引用本地语言 </p><p>可以用JNI（java native interface  java 本地接口）接口 。</p><p>40、谈谈Android的IPC（进程间通信）机制 </p><p>IPC是内部进程通信的简称， 是共享”命名管道”的资源。</p><p>Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。</p><p>Servier端实现IPC接口，Client端调用IPC接口本地代理。</p><p>41、NDK是什么</p><p>NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。</p><p>NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so</p><p>编辑 ：达叔</p><p>定位：分享 Android&amp;Java 知识点</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>制作个人简历模板网页效果 | 码云端的开源项目</title>
    <link href="https://huangguangda.github.io/2018/05/09/1/"/>
    <id>https://huangguangda.github.io/2018/05/09/1/</id>
    <published>2018-05-09T13:58:37.000Z</published>
    <updated>2018-06-18T14:11:33.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="http://upload-images.jianshu.io/upload_images/11158618-21bb875427cf1436?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="达叔"></p><a id="more"></a><p>制作个人简历模板网页效果<br>文 / 达叔 原创</p><p><strong>制作个人简历模板网页效果</strong></p><p>PC 端</p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-d644e9636633a877?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p><p>移动端</p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-d163bfb23d1159b7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p><p>首先要注册并登陆码云的网站：<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-c7b4ce6fc98184a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p><p>然后学会用 Git，就可以了，如图所示给出了文档</p><p>程序员技术交流群<br>群号：711613774</p><p><strong>大概教程：</strong></p><p>就是下载源代码下来，然后更改 index.html 文件即可，再次用Git上传到自己的项目中，然后申请Pages模式，即可就可以在自己的网页中显示自己的简历。</p><p>在大学毕业季，需要找工作，还用什么纸质的吗？还用pdf文件吗？</p><p>跟HR说：可以上网看</p><h4 id="安装教程-使用说明"><a href="#安装教程-使用说明" class="headerlink" title="安装教程 - 使用说明"></a><strong>安装教程 - 使用说明</strong></h4><ol><li><p>Fork 此项⽬目</p></li><li><p>将项⽬目 Clone 到本地</p></li><li><p>更更改⾃自⼰己的信息并更更新到远程</p></li><li><p>发布到⾃自⼰己的 Pages</p></li></ol><h4 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a><strong>贡献</strong></h4><p>一个开源项⽬目提交贡献代码 项⽬目地址 <a href="https://gitee.com/itsay/resume" target="_blank" rel="noopener">https://gitee.com/itsay/resume</a></p><p><strong>须知</strong></p><p>码云可以支持 Pages 功能，跟 Github 一样了，用过 Github Pages 的朋友就会很快的上手的，跟 Github 一样，默认的根文件是 index.html ，</p><p>登陆码云创建新的项目 ，+ ，这个加创建项目</p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-c85d7d70a938e372?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>项目名称：自己看可以定义：例如：Pages</p><p>然后记得这个要打勾：使用 Readme 文件初始化这个项目，点击创建就好</p><p>创建好后，定义一个 index.html 文件即可，写一段简单代码，展示效果</p><p><img src="http://upload-images.jianshu.io/upload_images/11158618-c46ef16ad57bf964?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p><p>如图点击后，进入Gitee Pages 服务，点击部署分支为 master 即可，然后点击开启 Gitee Pages 服务，网站地址就会自动给你，这时你就可以看到了哦~</p><p>如果你没用过 Git ，可以去看文档，我已上传教程，很简单的</p><p>Git Bash here ，表示在这个目录中提交并使用；</p><p>这里我展示一下 Git 的过程，你可以参考一下，其他的你就 Google Chrome ，展示一下代码，其实这文档中也有展示的：</p><p>注意：git config –global user.name 中，是 –  ，两个 “-”；</p><h1 id="GitHub-手把手教你如何把本地项目或代码提交到Github托管"><a href="#GitHub-手把手教你如何把本地项目或代码提交到Github托管" class="headerlink" title="GitHub 手把手教你如何把本地项目或代码提交到Github托管"></a>GitHub 手把手教你如何把本地项目或代码提交到Github托管</h1><p><a href="https://blog.csdn.net/qq_36232611/article/details/78509671" target="_blank" rel="noopener">https://blog.csdn.net/qq_36232611/article/details/78509671</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的码云名字&quot;</span><br><span class="line"></span><br><span class="line">回车</span><br><span class="line"></span><br><span class="line">git config --global user.email &quot;你的登录邮箱&quot;</span><br><span class="line"></span><br><span class="line">回车</span><br><span class="line"></span><br><span class="line">git clone https://....git</span><br><span class="line"></span><br><span class="line">cd 到你的目录</span><br><span class="line"></span><br><span class="line">然后把你下载好的源代码改一下，然后复制到次目录中即可--1</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">表示添加所有代码git commit -m &quot;chance log &quot;</span><br><span class="line"></span><br><span class="line">表示你提交代码后，进行备注，这个步骤一定要的，否则会出错</span><br><span class="line"></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">表示进行提交</span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">大功告成</span><br><span class="line"></span><br><span class="line">如果提交后，要进行更改内容如：index.html 中的代码：</span><br><span class="line"></span><br><span class="line">这是后你是已经复制代码到目录中了--1</span><br><span class="line"></span><br><span class="line">更新：</span><br><span class="line"></span><br><span class="line">你所需代码：</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">即可看到你的更新代码</span><br><span class="line"></span><br><span class="line">git commit -m &quot;随便写的&quot;</span><br><span class="line"></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">表示再次提交的步骤，🆗，大功告成</span><br></pre></td></tr></table></figure><p>编辑 ：达叔</p><p>信箱：<a href="mailto:2397923107@qq.com" target="_blank" rel="noopener">2397923107@qq.com</a></p><p>定位：分享 Android&amp;Java 知识点</p><p>我是简书的达叔小生。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/11158618-21bb875427cf1436?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;达叔&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://huangguangda.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://huangguangda.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>零基础入门Android语法与界面笔记</title>
    <link href="https://huangguangda.github.io/2018/05/08/1/"/>
    <id>https://huangguangda.github.io/2018/05/08/1/</id>
    <published>2018-05-08T12:08:15.000Z</published>
    <updated>2018-07-01T06:11:04.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/83.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>来源零基础入门Android语法与界面做笔记</p><p>面向对象</p><p>1、什么是对象<br>2、什么是面向对象<br>3、什么是类<br>4、什么是属性<br>5、什么是方法<br>6、类和对象的关系</p><p>什么是对象<br>•   万物皆对象、客观存在的事物<br>•   对象：用来描述客观事物的一个实体，由一组属性和方法构成</p><p>什么是面向对象<br>•   人关注对象<br>•   人关注事物信息</p><p>类<br>•   类是模子，确定对象将会拥有的特征（属性）和行为（方法）<br>•   类的特点<br>•   类是对象的类型<br>•   具有相同属性和方法的一组对象的集合</p><p>什么是对象的属性和方法<br>•   属性：对象具有的各种静态特征<br>•   “有什么”<br>•   方法：对象具有的各种动态行为<br>•   “能做什么”</p><p>类和对象的关系<br>•   类是抽象的概念，仅仅是模板<br>•   对象是一个你能够看得到、摸得着的具体实体<br>•   类是对象的类型<br>•   对象是特定类型的数据<br>•   具体开发过程中，先定义类再实例化对象</p><p>单一职责原则<br>•   单一职责原则，也称为单一功能原则<br>•   英文Single Responsibility Principle 缩写SRP<br>•   是面向对象设计中的一个重要原则<br>•   一个类，应该有且只有一个引起变化的原因<br>•   在程序设计中，尽量把不同的职责，放在不同的职责中，即把<br>不同的变化原因，封装到不同的类中。</p><p>对象实例化需要了解的</p><p>对象实例化<br>•   实例化对象的过程可以分为两部分：<br>–  声明对象   Cat one<br>–  实例化对象   new Cat();<br>–  Cat one=new Cat();</p><p>对象实例化<br>•   每次new对象会产生新的实例化对象<br>–  Cat one=new Cat();<br>–  Cat two=new Cat();</p><p>对象实例化<br>•   多个对象可以指向同一块实例化空间<br>–  Cat one=new Cat();<br>–  Cat two=one;</p><p>对象实例化<br>•   对象必须被实例化之后才能使用<br>•   对象间的引用传递，实际上传递的是堆内存空间的使用权</p><p>构造方法<br>1、构造方法与类同名且没有返回值<br>2、构造方法的语句格式<br>3、只能在对象实例化的时候调用</p><p>构造方法<br>4、当没有指定构造方法时，系统会自动添加无参的构造方法<br>5、当有指定构造方法，无论是有参、无参的构造方法，都不会自<br>动添加无参的构造方法<br>6、一个类中可以有多个构造方法</p><p>单一职责原则（SRP：Single responsibility principle）又称单一功能原<br>则，面向对象五个基本原则（SOLID：  SRP 单一责任原则、OCP  开放封闭原<br>则、LSP 里氏替换原则、DIP 依赖倒置原则、ISP  接口分离原则）之一。它规<br>定一个类应该只有一个发生变化的原因。该原则由罗伯特·C·马丁（Robert C.<br>Martin）于《敏捷软件开发：原则、模式和实践》一书中给出的。马丁表示此<br>原则是基于汤姆·狄马克(Tom DeMarco)和 Meilir Page-Jones  的著作中的内<br>聚性原则发展出的。</p><p>所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么<br>这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有<br>且只有一个改变的原因。</p><p>单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类<br>（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一<br>个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化<br>时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责<br>封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总<br>是同时发生改变则可将它们封装在同一类中。</p><p>之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：T<br>负责两个不同的职责：职责 P1，职责 P2。当由于职责 P1  需求发生改变而需要<br>修改类 T P2  功能发生故障。也就是说<br>职责 P1 和 P2<br>解决办法：遵守单一职责原则，将不同的职责封装到不同的类或模块中。<br>分别建立两个类 T1、T2，使 T1 完成职责 P1 功能，T2 完成职责 P2  功能。这<br>样，当修改类 T1 时，不会使职责 P2 发生故障风险；同理，当修改 T2  时，也<br>不会使职责 P1  发生故障风险。</p><p>关键字的用法</p><p>this 在类中就是代表当前对象，可以通过 this  关键字完成当前<br>对象的成员属性、成员方法和构造方法的调用。<br>那么何时用 this？<br>当在定义类中的方法时，如果需要调用该类对象，就可以用  this<br>来表示这个对象。也就是说，但凡在本类功能内部使用到了本类对象，<br>都用 this  表示。至于代表哪个对象，就看其所在功能被哪个对象调<br>用，这样就知道谁在参与运算。</p><p>封装<br>•   将类的某些信息隐藏在类内部，不允许外部程序直接访问<br>•   通过该类提供的方法来实现对隐藏信息的操作和访问<br>•   隐藏对象的信息<br>•   留出访问的接口</p><p>封装<br>特点：<br>1、只能通过规定的方法访问数据<br>2、隐藏类的实例细节，方便修改和实现</p><p>封装<br>设为private<br>修改属性的可见性<br>设为public<br>创建getter/setter方法<br>用于属性的读写<br>对属性值的合<br>法性进行判断<br>在getter/setter方法中加<br>入属性控制语句</p><p>包<br>作用：<br>1、管理Java文件<br>2、解决同名文件冲突</p><p>定义包<br>语法：<br>package 包名;<br>例：package com.imooc.animal;<br>注意：<br>1、必须放在Java源文件中的第一行<br>2、一个Java源文件中只能有一个package语句<br>3、包名全部英文小写<br>4、命名方式：域名倒序+模块+功能</p><p>导入包<br>语法：<br>import 包名.类名;<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导入包中全部类：</span><br><span class="line">import com.imooc.*;</span><br><span class="line">导入包中指定类：</span><br><span class="line">import com.imooc.animal.Cat;</span><br></pre></td></tr></table></figure></p><p>常用系统包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang   包含java语言基础的类</span><br><span class="line">java.util     包含java语言中各种工具类</span><br><span class="line">java.io       包含输入、输出相关功能的类</span><br></pre></td></tr></table></figure></p><p>static<br>1、static+属性—静态属性<br>2、static+方法—静态方法<br>3、static+类—不存在<br>4、static+方法内局部变量—不存在<br>静态成员随类加载产生，直至类销毁才回收</p><p>静态方法<br>1、可以直接调用同类中的静态成员<br>2、不可以直接调用同类中的非静态成员<br>3、可以通过实例化对象后，对象调用的方式完成非静态成员调用</p><p>代码块<br>1、通过{ }可以形成代码块<br>2、方法内的代码块称为：普通代码块<br>3、类内的代码块称为：构造代码块<br>4、构造代码块前+static：静态代码块</p><p>代码块执行顺序<br>1、无论实例产生多少对象，静态代码块只执行一次<br>2、构造代码块随实例化过程调用<br>3、普通代码块随方法调用执行</p><h2 id="kage-和-import-的使用"><a href="#kage-和-import-的使用" class="headerlink" title="kage 和 import 的使用"></a>kage 和 import 的使用</h2><p>1、打包–package<br>包名一般为小写，而类名的第一个字母一般为大写，这样在引用时，可以明显的分<br>辨出包名和类名。如果在类的定义之前没有使用package定义包名，那么该类就属于缺<br>省的包。</p><p>1.1、包的作用<br>可以更好的组织类，包与文件夹类似，文件夹可以将不同的文件放在同一个文件夹<br>中，而包也可以将不同的类文件放在同一包中。<br>减少类名的冲突问题，这也与文件夹类似，同一文件夹中的文件不能重名，不同文<br>件中的 文件可以重名，同一包中的类名不能重复，不同包中的类名可以重复。<br>对包中的类起了一定的保护作用，详见 Java  的访问控制（在后面的课程中会详细<br>讲解~~）。</p><p>1.2、包的使用<br>使用 package 关键字指明类所在的包。 package 语句必须在文件的最前面。 编译<br>时可使用 javac –d . Test.java 自动产生包需要目录。 可以使用 java testPackage.Test<br>来执行编译后的代码。</p><p>2、导入–import<br>使用了包机制后，如果在一个类中使用了其他包中的类，需要使用 import  来引入。</p><p>2.1 import的使用<br>直接引用指定的类，如 import java.util.Vector。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">引用一个包中的多个类，如 import java.awt.*。*号代替类名，但不能代替包名，如</span><br><span class="line">import java.awt.*，只引用 java.awt 下的类，而不引用 java.awt  下的子包里面的类。</span><br><span class="line">import java.awt.F*，这种使用方法是错误的。</span><br><span class="line">import 语句在所有类定义之前，在 package 定义之后。import  只告诉编译器及解</span><br><span class="line">释器哪里可以找到类、变量、方法的定义，而并没有将这些定义 引入代码中。</span><br><span class="line">2.2  包中类的使用</span><br><span class="line">如果要使用的类是属于 java.lang  包的，那么可以直接使用类名来引用指定的类，而</span><br><span class="line">不需要加上包名，因为包 java.lang 不用显示使用 import，它是缺省引入的。 如果要使</span><br><span class="line">用的类在其它包（java.lang 除外）中，那么可以通过包名加上类名来引用该类， 如</span><br><span class="line">java.awt.Font。</span><br><span class="line">对于经常要使用的类（该类在其它包中），那么最好使用 import  引用指定的包，如</span><br><span class="line">java.awt.*。</span><br><span class="line">如果 import  引入的不同的包中包含有相同的类名，那么这些类的使用必须加上包名。</span><br></pre></td></tr></table></figure><p>生活中的继承<br>•   孩子像爸妈<br>•   富二代<br>•   师徒关系</p><p>程序中的继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-表示私有</span><br><span class="line">Dog</span><br><span class="line">- name:String</span><br><span class="line">- month:int</span><br><span class="line">- species:String</span><br><span class="line">- sex:String</span><br><span class="line">- name:String</span><br><span class="line">- month:int</span><br><span class="line">- species:String</span><br><span class="line">- weight:double</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+表示公有</span><br><span class="line">+ eat():void</span><br><span class="line">+ eat():void</span><br><span class="line">+ getName():String</span><br><span class="line">+ getMonth ():int</span><br><span class="line">+ getSpecies ():String</span><br><span class="line">+ getSex():String</span><br><span class="line">+ sleep():void</span><br><span class="line">+ getName():String</span><br><span class="line">+ getMonth ():int</span><br><span class="line">+ getSpecies ():String</span><br><span class="line">+ getWeight():double</span><br><span class="line">+ run():void</span><br><span class="line">+ Dog()</span><br><span class="line">+ Cat()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">程序中的继承</span><br><span class="line">Cat</span><br><span class="line">Dog</span><br><span class="line">Animal</span><br><span class="line">- sex:String</span><br><span class="line">+ sleep():void</span><br><span class="line">+ Dog()</span><br><span class="line">- weight:double</span><br><span class="line">- name:String</span><br><span class="line">- month:int</span><br><span class="line">- species:String</span><br><span class="line">+ run():void</span><br><span class="line">+ Cat()</span><br><span class="line">+ eat():void</span><br><span class="line">+ getName():String</span><br><span class="line">+ getMonth ():int</span><br><span class="line">+ getSpecies ():String</span><br><span class="line">+ getWeight():double</span><br></pre></td></tr></table></figure><p>继承<br>特点：<br>1、利于代码复<br>2、缩短开发周期</p><p>继承<br>•  一种类与类之间的关系<br>•  使用已存在的类的定义作为基础建立新类<br>•  新类的定义可以增加新的数据或新的功能，也可以用父类的<br>功能，但不能选择性地继承父类<br>•父类 基类<br>•子类 派生类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">继承的关系</span><br><span class="line">• 满足“A is a B  ”的关系就可以形成继承关系</span><br><span class="line">如：</span><br><span class="line">猫、狗是动物==》猫，狗继承自动物</span><br><span class="line">学生、老师是人==》学生，老师继承自人</span><br><span class="line">小轿车、大卡车是汽车==》小轿车，大卡车继承自汽车</span><br></pre></td></tr></table></figure><p>实现继承<br>使用extends实现封装<br>–编写父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">//公共的属性和方法</span><br><span class="line">&#125;</span><br><span class="line">–编写子类，继承父类</span><br><span class="line">class Dog extends  Animal&#123;</span><br><span class="line">//子类特有的属性和方法</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends  Animal&#123;</span><br><span class="line">&#125;</span><br><span class="line">只能继承一个父类</span><br></pre></td></tr></table></figure></p><p>方法重写<br>语法规则：<br>•  返回值类型<br>•  方法名<br>•  参数类型、顺序、个数<br>都要与父类继承的方法相同</p><p>方法重写 PK  方法重载<br>•   方法重写：<br>•   方法重载：<br>–  在满足继承关系的子类中<br>–  在同一个类中<br>–  方法名相同<br>–  方法名、参数个数、顺序、类型与<br>父类、返回值相同<br>–  参数个数、顺序、类型不同<br>–  返回值类型、访问修饰符任意<br>–  访问修饰符的限定范围大于等于<br>父类方法</p><p>方法重写存在<br>属性重写不存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符</span><br><span class="line">•   公有的：public</span><br><span class="line">•   私有的：private</span><br><span class="line">•   受保护的 ：protected</span><br><span class="line">•   默认</span><br></pre></td></tr></table></figure><p>如何区分调用的是继承父类的方法<br>还是子类自己重写的方法？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">super</span><br><span class="line">•   子类访问父类成员</span><br><span class="line">–   访问父类成员方法</span><br><span class="line">super.print();</span><br><span class="line">super.name;</span><br><span class="line">–   访问父类属性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实例化顺序</span><br><span class="line">•继承后的初始化顺序</span><br><span class="line">父类静态成员</span><br><span class="line">子类静态成员</span><br><span class="line">父类对象构造</span><br><span class="line">（属性（赋值）、构造代码块、构造方法）</span><br><span class="line">子类对象构造</span><br><span class="line">（属性（赋值）、构造代码块、构造方法）</span><br></pre></td></tr></table></figure><p>子类对象实例化时，能否选择父类的构造<br>形式（调用指定的构造方法）？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">super</span><br><span class="line">•   子类访问父类成员</span><br><span class="line">–   访问父类成员方法</span><br><span class="line">super.print();</span><br><span class="line">super.name;</span><br><span class="line">super();</span><br><span class="line">–   访问父类属性</span><br><span class="line">–   访问父类构造方法</span><br></pre></td></tr></table></figure><p>super<br>•   子类的构造的过程中必须调用其父类的构造方法<br>•   如果子类的构造方法中没有显示调用父类的构造方法，则系统<br>系默认调用父类无参的构造方法<br>•   如果子类构造方法中既没有显式调用父类的构造方法，而父类<br>又没有无参的构造方法，则编译出错<br>•   使用super调用父类指定构造方法，必须在子类的构造方法的<br>第一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">super pk this</span><br><span class="line">•   this:  当前类对象的引用</span><br><span class="line">–   访问当前类的成员方法</span><br><span class="line">–   访问当前类的成员属性</span><br><span class="line">–   访问当前类的构造方法</span><br><span class="line">–   不能在静态方法中使用</span><br><span class="line">•   super:  父类对象的引用</span><br><span class="line">–   访问父类的成员方法</span><br><span class="line">–   访问父类的成员属性</span><br><span class="line">–   访问父类的构造方法</span><br><span class="line">–   不能在静态方法中使用</span><br><span class="line">•   构造方法调用时，super和this不能同时出现</span><br></pre></td></tr></table></figure><p>设计模式<br>•   设计模式（Design pattern）是一套被反复使用、多数人知晓的、<br>经过分类编目的、代码设计经验的总结。<br>•   设计模式是软件开发人员在软件开发过程中面临的一般问题的解决<br>方案。</p><p>设计模式<br>•   项目中合理的运用设计模式可以完美的解决很多问题<br>•   每种模式在现在中都有相应的原理来与之对应<br>•   每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题<br>的核心解决方案</p><p>设计模式<br>•   面向对象的设计模式很多，但大家认为这23个模式是其它模式的基础</p><p>单例模式（Singleton）<br>•   滚滚历史，朝代更迭，永恒定律：<br>–  一个朝代皇帝只有一个<br>–  军队的最高司令官只有一个<br>–  一山不容二虎<br>•   计算机系统：<br>–   驱动程序<br>–   打印机后台处理程序（Printer Spooler）<br>–   线程池<br>–   缓存<br>–   日志</p><p>单例模式（Singleton）<br>目的：<br>使得类的一个对象成为该类系统中的唯一实例<br>定义：<br>一个类有且仅有一个实例，并且自行实例化向整个系统提供</p><p>单例模式<br>要点：<br>1、某个类只能有一个实例<br>2、必须自行创建实例<br>3、必须自行向整个系统提供这个实例<br>实现：<br>1、只提供私有的构造方法<br>2、含有一个该类的静态私有对象<br>3、提供一个静态的公有方法用于创建、获取静态私有对象</p><p>单例模式<br>代码实现方案：<br>1、饿汉式<br>2、懒汉式</p><p>饿汉式 PK  懒汉式<br>1、饿汉式在类加载时就创建实例， 第一次加载速度快；<br>懒汉式第一次使用时才进行实例化，第一次加载速度慢<br>饿汉式：空间换时间<br>懒汉式：时间换空间<br>2、饿汉式线程安全；懒汉式存在线程风险<br>解决方案：<br>1、同步锁<br>3、静态内部类<br>4、枚举<br>2、双重校验锁</p><p>单例模式<br>优点：<br>1、在内存中只有一个对象，节省内存空间<br>2、避免频繁的创建销毁对象，提高性能<br>3、避免对共享资源的多重占用<br>缺点：<br>1、扩展比较困难<br>2、如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，<br>造成对象状态丢失</p><p>单例模式<br>适用场景：<br>1、创建对象时占用资源过多，但同时又需要用到该类对象<br>2、对系统内资源要求统一读写，如读写配置信息<br>3、当多个实例存在可能引起程序逻辑错误，如号码生成器</p><p>UML  中表示类与类的关系</p><p>UML(Unified Modeling Language), 又称统一建模语言或标准建模语言，它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，可用于多种类型软件系统开发建模的各个阶段。我们可以用 UML  图例来表示类与类之间的<br>各种关系。</p><p>类的层次结构代表类与类之间的关系，类的关系有很多种，包括泛化、依赖、关联、聚<br>合和组合。这些关系在大的类别上还可分为两种：横向关系和纵向关系，纵向关系就是泛化关系，而横向关系就是剩下的 4 种，</p><p>它们的强弱关系：依赖 &lt;  关联  &lt; 聚合  &lt;  组合。</p><p>理解这些类的关系，并应用于类的层次结构设计中，有助于优化代码组织结构。</p><p>接下来我们用 Enterprise Architect 12.0.1210 Corporate Edition  建模软件为大家演示这几种类与类关系的表示。</p><ol><li>泛化</li></ol><p>泛化关系就是继承，表示一般与特殊的关系，即“一般”元素是“特殊”元素的泛<br>化。在继承中，一般类就是父类，特殊类就是子类。</p><p>它们之间是“is a”的关系。</p><p>如：一个 Cat 类继承 Animal 类，也就是说 Cat is an Animal。在 UML类图设计中，继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父<br>接口。</p><ol start="2"><li>依赖</li></ol><p>表示一个元素以某种方式依赖于另一种元素。</p><p>依赖就是一个类 A 使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类 B  的变化会影响到类 A。</p><p>它们之间是“use a”的关系。</p><p>依赖的例子有：一个类把另一个类的对象作为参数，一个类访问另一个类的全局变<br>量，或者一个类调用另一个类的类操作。</p><p>比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码<br>层面，为类 B 作为参数被类 A 在某个 method 方法中使用。在 UML  类图设计中，依赖关系用由类 A 指向类 B  的带箭头虚线表示。</p><ol start="3"><li>关联</li></ol><p>关联体现的是两个类之间一种强依赖关系，这种关系比依赖更强、不存在依赖关系<br>的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。<br>关联可以是单向、双向的。</p><p>比如老师和学生是双向关联，老师有多名学生，学生也可能有多名老师。学生跟学<br>生学号之间是单向关联，一个学生只能对应一个唯一的学号。在 UML  类图设计中,  双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p><ol start="4"><li>聚合</li></ol><p>聚合关系是关联关系的一种，是强的关联关系，它体现的是整体与部分的关系  ，<br>且部分可以离开整体而单独存在；关联和聚合在语法上无法区分，必须考察具体的<br>逻辑关系。</p><p>它们之间是“use a”的关系。<br>此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多<br>个整体对象，也可以为多个整体对象共享。</p><p>在 UML  类图设计中，聚合关系以空心菱形加实线表示。如学校有很多老师。</p><ol start="5"><li>组合</li></ol><p>是整体与部分的关系，是比聚合关系还要强的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，如公司和部门是整体和部分的关系,  没有公司就不存在部门。</p><p>它体现的是一种“contains-a”的关系。<br>在 UML  类图设计中，组合关系以实心菱形加实线表示。</p><p>抽象类和抽象方法</p><p>一：知识梳理</p><p>1.基本概念：</p><p>在面向对象的概念中，所有的对象都是通过类来描述的，但并不是说所有的类都是用<br>来描述对象的，当一个类中没有包含足够的信息以描绘一个具体的对象时，这样的类<br>就是抽象类。</p><p>例：形状就是一个抽象的概念。不同的子类计算形状面积的方法是不一样的。可提供<br>抽象方法来被不同的子类所实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从例子中可看出，抽象类是用关键字 abstract   修饰的。抽象类中有一种特殊方法，即用 abstract 关键字来修饰的方法，称为“抽象方法”。</p><p>2.抽象类和抽象方法的声明格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract class &lt;类名&gt;&#123;</span><br><span class="line">成员变量;</span><br><span class="line">方法（）&#123;方法体&#125;;</span><br><span class="line">    abstract 方法（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.抽象类和抽象方法的特点：</p><p>（1）抽象方法不允许直接实例化，换句话说抽象类不能创建对象，它只能作为其他类的父类。  但可以通过向上转型，指向实例化。</p><p>（2）抽象方法只有声明，不能有实现，也就是仅有方法头，而没有方法体和操作实现。</p><p>如：abstract double area( );</p><p>4.定义抽象类的意义在于：</p><p>（1）为其子类提供一个公共的类型（父类引用指向子类对象）；<br>（2）封装子类中的重复内容（成员变量和方法）;<br>（3）将父类设计成抽象类后，既可借由父子继承关系限制子类的设计随意性，在一定程度上避免了无意义父类的实例化。</p><p>二．重点注意</p><p>含有抽象方法的类，只能被定义成抽象类。</p><p>如下面，不定义为抽象类时会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Shape&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正确的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape()&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象类不一定包含抽象方法。<br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">public void girth()&#123;</span><br><span class="line">System.out.println(&quot;图形周长为...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在抽象类中的成员方法可以包括一般方法和抽象方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">public void girth()&#123;</span><br><span class="line">System.out.println(&quot;图形周长为..&quot;);</span><br><span class="line">&#125;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象类不能被实例化，即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。<br>抽象类的构造方法主要是用于被其子类调用。</p><p>例子：<br>Shape  抽象类中不含抽象方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">public void girth()&#123;</span><br><span class="line">System.out.println(&quot;图形周长为..&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类中实例化 Shape,编译器会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape s=new Shape();</span><br></pre></td></tr></table></figure></p><p>一个类继承抽象类后，必须实现其所有抽象方法，否则也是抽象类，不同的子类对<br>父类的抽象方法可以有不同的实现。</p><p>如父类为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则其子类 Circle  有两种做法：</p><p>方案一：重写抽象方法 area( ),使方法得以实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Circle extends Shape&#123;</span><br><span class="line">public double r;</span><br><span class="line">public Circle(double r)&#123;</span><br><span class="line">this.r=r;</span><br><span class="line">&#125;</span><br><span class="line">public double area()&#123;</span><br><span class="line">return(double)(3.14*r*r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方案二：子类 Circle  类也定义为抽象类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Circle extends Shape&#123;</span><br><span class="line">public double r;</span><br><span class="line">public Circle(double r)&#123;</span><br><span class="line">this.r=r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使父类是具体的，但其子类也可以是抽象的。如  Object  是具体的，但可以创建<br>抽象子类。</p><p>abstract 方法不能用 static 和 private 修饰；对于类，不能同时用 final 和 abstract  修饰，因为 final 关键字使得类不可继承，而 abstract  修饰的类如果不可以继承将没有任何意义。两者放在一起，会起冲突</p><p>如以下用法都会引起编译器报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static abstract double area();</span><br><span class="line"></span><br><span class="line">private abstract double area();</span><br><span class="line"></span><br><span class="line">abstract final class Shape()&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三：一个完整准确的抽象类例子</p><p>声明一个抽象类 Shape,有抽象成员方法  area()。Shape 派生出两个子类圆  Circle  类和矩形 Rectangle  类。Shape 里声明了抽象方法area(),该方法分别在两个子类里得到实<br>现。</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Shape&#123;</span><br><span class="line">abstract double area();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shape&#123;</span><br><span class="line">public double r;</span><br><span class="line">Circle()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public Circle(double r)&#123;</span><br><span class="line">this.r=r;</span><br><span class="line">&#125;</span><br><span class="line">public double getR()&#123;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">public void setR(double r)&#123;</span><br><span class="line">this.r=r;</span><br><span class="line">&#125;</span><br><span class="line">public double area()&#123;</span><br><span class="line">return(double)(3.14*r*r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rectangle extends Shape&#123;</span><br><span class="line">public double lenghth;</span><br><span class="line">public double wide;</span><br><span class="line">Rectangle()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public Rectangle(double lenghth,double wide)&#123;</span><br><span class="line">this.lenghth=lenghth;</span><br><span class="line">this.wide=wide;</span><br><span class="line">&#125;</span><br><span class="line">public double getLenghth()&#123;</span><br><span class="line">return lenghth;</span><br><span class="line">&#125;</span><br><span class="line">public void setLenghth(double lenghth)&#123;</span><br><span class="line">this.lenghth = lenghth;</span><br><span class="line">&#125;</span><br><span class="line">public double getWide()&#123;</span><br><span class="line">return wide;</span><br><span class="line">&#125;</span><br><span class="line">public void setWide(double wide)&#123;</span><br><span class="line">this.wide=wide;</span><br><span class="line">&#125;</span><br><span class="line">public double area()&#123;</span><br><span class="line">return lenghth*wide;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(Stirng[] args)&#123;</span><br><span class="line">Circle c=new Circle(3.5);</span><br><span class="line">Rectangle re=new Rectangle(6,5);</span><br><span class="line">System.out.println(c.area());</span><br><span class="line">System.out.println(re.area());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中的内部类</p><p>我们在实际开发过程中，如果想要创建某些公共代码，使得它们可以被某个接口的所有<br>不同实现所共用，那么接口内部的嵌套类会显得很方便。</p><p>也就是说，在接口中可以含有内部类。</p><p>在这里，向大家展示接口中放置普通成员内部类和抽象成员内部类的情况。</p><p>首先创建接口，接口中定义了普通内部类 InnerClass 和抽象内部类  AbInnerClass</p><p>普通成员内部类的实例化</p><p>创建接口的实现类  ClassDemo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface IOuterInterface&#123;</span><br><span class="line">int TEMP=100;</span><br><span class="line">void abMethod();</span><br><span class="line">public default void deMethod()&#123;</span><br><span class="line">System.out.println(&quot;默认&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void stMethod()&#123;</span><br><span class="line">System.out.println(&quot;静态&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public class InnerClass&#123;</span><br><span class="line">public void show()&#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public abstract class AbInnerClass&#123;</span><br><span class="line">public abstract void abInfo();</span><br><span class="line">public void info()&#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通成员内部类的实例化<br>创建接口的实现类  ClassDemo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ClassDemo implements IOuterInterface&#123;</span><br><span class="line">public void abMethod()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public InnerClass getInner()&#123;</span><br><span class="line">return new InnerClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">IOuterInterface.InnerClass inner=new IOuterInterface.InnerClass();</span><br><span class="line">inner.show();</span><br><span class="line"></span><br><span class="line">ClassDemo demo=new ClassDemo();</span><br><span class="line">demo.getInner().show();</span><br><span class="line"></span><br><span class="line">InnerClass innerTwo = new InnerClass();</span><br><span class="line">innerTwo.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象成员内部类的实例化<br>创建接口的实现类  AbClassDemo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AbClassDemo implements IOuterInterface&#123;</span><br><span class="line">public void abMethod()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class AbDemo extends AbInnerClass&#123;</span><br><span class="line">public void abInfo()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TestOne&#123;</span><br><span class="line"> public static void main(String[] args)&#123;</span><br><span class="line"> IOuterInterface.AbInnerClass abInner=new IOuterInterface.AbInnerClass()&#123;</span><br><span class="line"> public void abInfo()&#123;</span><br><span class="line"> System.out.println();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> aabInner.abInfo();</span><br><span class="line"> abInner.info();</span><br><span class="line"> System.out.println();</span><br><span class="line"></span><br><span class="line"> IOuterInterface.AbInnerClass abInner=new AbClassDemo().new AbDemo();</span><br><span class="line"> abInnerOne.abInfo();</span><br><span class="line"> abInnerOne.info();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类详解</p><p>概  念</p><p>匿名内部类也就是没有名字的内部类正因为没有名字，所以匿名内部类只能使用一次，</p><p>它通常用来简化代码编写但使用匿名内部类还有个前提条件：</p><p>必须继承一个父类或实现一个接口</p><p>注意事项：</p><p>   编译后的文件命名：外部类$数字 . class<br>   无法使用 public、private、abstract、static  修饰，匿名内部类不能出现抽象方法<br>   无法编写构造方法，但可以添加构造代码块<br>   不能出现静态成员<br>   匿名内部类可实现接口也可以继承类，但是不可兼得<br>   匿名内部类不能是抽象的，它必须要实现继承的类或者实现接口的所有抽象方法</p><p>匿  名 内  部  类 初  始  化</p><p>我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造<br>器的，那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内<br>部类创建一个构造器的效果。<br>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class OutClass&#123;</span><br><span class="line">public InnerClass getInnerClass(final int age, final Stirng name)&#123;</span><br><span class="line">return new InnerClass()&#123;</span><br><span class="line">int age_;</span><br><span class="line">Stirng name_;</span><br><span class="line">&#123;</span><br><span class="line">if(0&lt;age&amp;&amp;age&lt;200)&#123;</span><br><span class="line">age_=age;</span><br><span class="line">nam_=name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public String getName()&#123;</span><br><span class="line">return name_;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge()&#123;</span><br><span class="line">return age_;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">OutClass out = new OutClass();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实  例<br>匿名内部类可以有不同的表现形式，下面用实例向大家展示一下：<br>继承式的匿名内部类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">abstract class Car&#123;</span><br><span class="line">public abstract void drive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Car car=new Car()&#123;</span><br><span class="line">public void drive()&#123;</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">car.drive();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Vehicle&#123;</span><br><span class="line">public void drive();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test&#123;</span><br><span class="line">public static void main(Stirng[] args)&#123;</span><br><span class="line">Vehicle v=new Vehicle()&#123;</span><br><span class="line">public void drive()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">v.drive();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abstract class Bar&#123;</span><br><span class="line">void doStuff(Foo f)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BarOne extends Bar&#123;</span><br><span class="line">void doStuff(Foo f)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Foo&#123;</span><br><span class="line">void foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test&#123;</span><br><span class="line">static void go()&#123;</span><br><span class="line">Bar b = new BarOne();</span><br><span class="line">b.doStuff(new Foo())&#123;</span><br><span class="line">public void foo()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread  类的匿名内部类实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Thread t = new Thread()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">for (int i=1;i&lt;=5;i++)&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable  接口的匿名内部类实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo&#123;</span><br><span class="line">public static void main(Stirng[] args)&#123;</span><br><span class="line">Runnable r=new Runnable()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">for(int i=1;i&lt;=5;i++)&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread t=new Thread(r);</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>向上转型和动态绑定机制</p><p>知  识 梳  理</p><ol><li>向上转型的概念：</li></ol><p>向上转型又叫自动转型、隐式转型。向上转型就是父类引用指向子类实例，也就是子类<br>的对象可以赋值给父类的对象。</p><p>如：Animal dog=new Dog( );   //Dog 类是 Animal  类的子类</p><p>注：向上转型是安全的，因为任何子类都继承并接受了父类的方法。从例子中也可以理<br>解，所有的狗狗都属于狗的父类——动物，这是可行的，但是向下转型则不行，若说所<br>有的动物都是狗狗就不成立了。（所以向下转型要通过强制类型转换，后续章节中会讲<br>解）</p><p>2、向上转型的应用</p><p>1）当一个子类对象向上转型父类类型以后，就被当成了父类的对象，所能调用的方法会<br>减少，只能调用子类重写了父类的方法以及父类派生的方法（如 set()、get()方法），<br>而不能调用子类独有的方法。<br>例如：</p><p>对象实例化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pen pc = new Pencil();</span><br></pre></td></tr></table></figure></p><p>此时，调用方法调用时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc.writing();</span><br><span class="line">pc.show();</span><br></pre></td></tr></table></figure><p>可以调用子类重写父类的方法 writing(),但调用子类独有的方法 show()时就是无效的</p><p>2）父类中的静态方法是不允许被子类重写的。</p><p>如父类 Pen 中含有静态方法 draw( )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void draw()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子类 Pencil 中也定义同名方法时，此时 draw( )算 Pencil  类自己独有的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void draw()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类中调用时：</p><p>返回结果为：</p><p>也就是实际上调用的是父类的静态方法 draw( )</p><p>知  识 扩  展</p><p>多态的实现可以通过向上转型和动态绑定机制来完成，向上转型实现了将子类对象向上<br>转型为父类类型，而动态绑定机制能识别出对象转型前的类型，从而自动调用该类的方法，<br>两者相辅相成。</p><p>动态绑定：</p><p>绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动<br>态绑定两种。</p><p>静态绑定：在程序运行之前进行绑定（由编译器和链接程序完成的），也叫做前期绑定。</p><p>动态绑定：在程序运行期间由 JVM  根据对象的类型自动的判断应该调用哪个方法，也叫做<br>后期绑定。</p><p>静态绑定的例子：</p><p>如有一类 Human,它派生出来三个子类 Chinese 类、American 类和 British  类，三个<br>子类中都重写了父类中的方法    speak(  )：void,在测试类中用静态绑定的方式调用方法<br>speak( )。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Chinese c = new Chinese();</span><br><span class="line">c.speak();</span><br><span class="line"></span><br><span class="line">American a=new American();</span><br><span class="line">a.speak();</span><br><span class="line"></span><br><span class="line">British b=new British();</span><br><span class="line">b.speak();</span><br></pre></td></tr></table></figure></p><p>这种调用方式是在代码里指定的，编译时编译器就知道 c 调用的是 Chinese 的 speak(  ),a调用的是 American 的 speak( )。</p><p>动态绑定的例子：</p><p>如果我们在测试类中做以下改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Human[] human = new Human[5];</span><br></pre></td></tr></table></figure><p>此时，Human 类中随机生成 Chinese 类、American 类和 British  类的对象，编译器不能<br>根据代码直接确定调用哪个类中的 speak(  )方法，直到运行时才能根据产生的随机数 n  的值来确定  human[i]到底代表哪一个子类的对象，这样才能最终确定调用的是哪个类中的<br>speak( )方法，这就是动态绑定。</p><p>向下转型和 instanceof  运算符的应用</p><p>知  识 梳  理</p><p>一：向下转型</p><ol><li>向下转型</li></ol><p>向下转型是与向上转型相对的概念，它是用子类引用指向父类实例。</p><p>如：下图，在进行转换是会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a = new Dog();</span><br><span class="line">Dog d=a;</span><br></pre></td></tr></table></figure><p>这时就告诉我们向下转型不能自动转换，我们需要强转，所以向下转型又叫做强制类型<br>转换。</p><p>正确的转换语句为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a=new Dog();</span><br><span class="line">Dog d=(Dog)a;</span><br></pre></td></tr></table></figure><ol start="2"><li>向下转型后，可以调用子类自己独有的方法。<br>例如：（承接上一文档例子）</li></ol><p>测试类中通过强制类型转换后，可调用 Pencil 类中独有的方法 show( )了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pen pc = new Pencil();</span><br><span class="line">Pencil p = (Pencil)pc;</span><br><span class="line">p.show();</span><br></pre></td></tr></table></figure></p><ol start="3"><li>兄弟类之间不能进行强制类型转换。</li></ol><p>如：父类 Pen 类派生出另一个子类 Brush。</p><p>将指向 Brush 对象的父类引用 b 强制转换为 Brush 的兄弟类 Pencil  的对象，此时编译<br>器并没有报错，但在运行时会报出如下错误：</p><p>二：instanceof  运算符</p><p>1． 基本概念<br>instanceof  运算符用来判断对象是否可满足某个特定类型实例特征。返回值为<br>true/false。一般用于 if  语句中。</p><p>表示方法为：<br>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean result;</span><br><span class="line">Pen pc=new Pencil();</span><br><span class="line">result=pc instanceof Pencil;</span><br></pre></td></tr></table></figure><p>如果左边对象是右边类的实例则返回 true,否则返回 false。</p><p>2.instanceof  运算符的应用</p><p>1）用  instanceof  运算符用来判断对象是否可满足某个特定类型实例特征<br>例子：</p><p>父类 Parents 类，Father 类和 Mother  类分别为它的两个子类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parents f=new Father();</span><br><span class="line">Parents m=new Mother();</span><br></pre></td></tr></table></figure></p><p>运行结果为：<br>注：java 中所有类都直接或间接继承于 Object  类。</p><h2 id="Four"><a href="#Four" class="headerlink" title="Four"></a>Four</h2><p>依赖与关联关系</p><p>依赖关系<br>依赖关系(Dependency)  是一种使用关系，特定事物的改变有可能会影响到使用<br>该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。如人要过河<br>时要使用到船，人与船之间就是依赖关系；我用锤子在墙上锤了一下，我和锤子之间就<br>是依赖关系；装修工人安装灯具时需要使用工具，装修工人和工具之间就是依赖关系。<br>大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。<br>依赖关系有下列三种情况：</p><p>A 类是 B  类中（某种方法的）局部变量<br>A 类是 B  类方法当中的一个参数<br>A 类向 B 类发送消息，从而影响 B  类发生变化</p><p>我们这里就依赖关系最常出现的情况—在某个类的方法使用另一个类的对象作为参数<br>进行举例说明：<br>课程表与课程之间就是依赖关系，<br>UML  图表示为：<br>对应的 java  代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CourseTable&#123;</span><br><span class="line">public void addCourse(Course course)&#123;</span><br><span class="line">course.show();</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public void reCourse(Course course)&#123;</span><br><span class="line">course.show();</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">public class Course&#123;</span><br><span class="line">public void show()&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>课程表类中用课程的对象作为参数，进行增加课程和删除课程的功能。课程的变化<br>会引起课程表的实时变更，这就是一种“use a”的关系，也就是课程表依赖于课程。</p><p>关联关系</p><p>关联关系是类与类之间最常用的一种关系，它是一种结构化关系，代表类的对象之<br>间的一组连接。如客户与订单、老师与学生、公司与职员，人体与大脑，这些关系不是<br>是使用时才有的，而是一种长期且稳定的关系。<br>关联关系可以分为双向关联、单向关联、自关联。</p><p>a)<br>双向关联：<br>指双方都知道对方的存在，都可以调用对方的公共属性和方法。默认情况下，关<br>联是双向的。如供货商和顾客之间的关系，一家供货商可以向多个顾客供货，一个顾<br>客也可以向多家供货商进货</p><p>UML  图表示为：<br>对应的 java  代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Customer&#123;</span><br><span class="line">private Supplier[] supplier;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Supplier&#123;</span><br><span class="line">public Customer[] customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>b)<br>单向关联：<br>类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如：顾客<br>(Customer)拥有地址(Address)，则 Customer 类与 Address  类具有单向关联关系<br>UML  图表示为：</p><p>对应的 java  代码片段：<br>c)<br>自身关联（反身关联）：<br>在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称<br>为自关联。顾客自身需要用到自己对象时，自己引用自己，带着一个自己的引用。<br>UML  图表示为：</p><p>对应的 java  代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Customer&#123;</span><br><span class="line">private Address address;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Address&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充扩展：<br>重数性关联:  表示一个类的对象与另一个类的对象连接的个数。<br>在 UML  中多重性关系可以直接在关联直线上增加一个数字表示与之对应的另一个类<br>的对象的个数。在关联的两端可写上一个被称为重数的范围，表示该类有多少个对象可与<br>对方一个对象连接，重数的默认值为 1，重数的符号通常有：<br>表示方式</p><p>多重性说明<br>表示“1”，表示另一个类的一个对象只与一个该类对象有关系<br>表示“零或多”，表示另一个类的一个对象与零个或多个该类对象有关系<br>表示“1 或多”，表示另一个类的一个对象与一个或多个该类对象有关系<br>表示“零或 1”，表示另一个类的一个对象没有或只与一个该类对象有关系<br>表示另一个类的一个对象与最少 m、最多 n 个该类对象有关系 (m&lt;=n)</p><p>ok</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/83.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>毕向东Java基础视频教程光碟01笔记</title>
    <link href="https://huangguangda.github.io/2018/05/07/1/"/>
    <id>https://huangguangda.github.io/2018/05/07/1/</id>
    <published>2018-05-07T05:29:18.000Z</published>
    <updated>2018-06-11T05:37:02.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/82.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>学习笔记</p><p>本套视频共计33天。<br>第1天~第5天讲解Java基础知识，带着读者轻松掌握Java中的字词句如何使用。并实现Java版的计算器。<br>第6天~第11天讲解Java的对象细节：培养面向对象思想，掌握对象和类的关系，封装、继承、多态的细节。如何使用内部类简化代码，<br>第12天~第13天讲解Java中的异常和包的使用。<br>第14天~第16天讲解Java中的多线程，实现多生产多消费，解决人妖问题。eclipse使用。<br>第17天~第18天讲解String类和JDK5中的特性。<br>第19天~第21天讲解Java中的各种集合容器使用。实现学生信息管理。<br>第22天~第26天讲解Java中的IO操作，并且时间文件切合和合并。<br>第27天讲解Java中的图形界面使用，实现自己想要的各种心动界面。<br>第28天~第29天讲解Java中的网络编程，实现网络聊天，群聊，文件上传，自己的浏览器实现。<br>第30天讲解Java中的正则表达式和反射技术。<br>第31天讲解网页标签语言HTML<br>第32天讲解网页布局，以及JavaScript揭秘<br>第33天讲解Javascript和DOM技术结合，实现各种网页常见效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/82.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>小码哥的MySQL笔记</title>
    <link href="https://huangguangda.github.io/2018/05/06/1/"/>
    <id>https://huangguangda.github.io/2018/05/06/1/</id>
    <published>2018-05-06T02:10:09.000Z</published>
    <updated>2018-06-07T11:04:27.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/69.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>可联系删除，做复习用，看不懂可以问哦~</p><p>数据库(DataBase:DB)：数据库是一个按数据结构来存储和管理数据的计算机软件系统。<br>     存储和管理数据的仓库.</p><p>数据库管理系统（Database Management System:DBMS）：是专门用于管理数据库的计算机系统软件。数据库管理系统能够为数据库提供数据的定义、建立、维护、查询和统计等操作功能，并完成对数据完整性、安全性进行控制的功能。</p><p>我们一般说的数据库,就是指的DBMS:  数据库服务器</p><p>数据库应用系统（Database Application System）：使用数据库技术的系统； 数据库应用系统有很多，基本上所有的信息系统都是数据库应用系统。它通常由软件、数据库和数据管理员组成。</p><p>常见的数据库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Oracle     :   Oracle </span><br><span class="line">DB2        :   IBM</span><br><span class="line">SQLServer  :   MS</span><br><span class="line">MySQL      :   AB--&gt;SUN--&gt;Oracle</span><br></pre></td></tr></table></figure></p><h2 id="什么是表？"><a href="#什么是表？" class="headerlink" title="什么是表？"></a>什么是表？</h2><p>我们说MYSQL是一种关系型数据库。关系数据库最重要的概念就是表。<br>表具有固定的列数和任意的行数，在数学上称为“关系”。</p><p>二维表是同类实体的各种属性的集合，每个实体对应于表中的一行，在关系中称为元组，相当于通常的一条记录；<br>表中的列表示属性，称为Field，相当于通常记录中的一个数据项，也叫列、字段。</p><p><img src="/images/70.png" style="width: 100%;height: 100%"></p><p><img src="/images/71.png" style="width: 100%;height: 100%"></p><p>MySQL安装过程中:注意:</p><p>MySQL的常用存储引擎:<br>  InnoDB:支持外键关系,支持事务(Transaction).           性能低.<br>  MyISAM:不支持外键关系,不支持事务管理.   性能高.</p><p>一般的,开发中外键关系可以不要,但是事务必须得有.  InnoDB.</p><p>MySQL的默认端口是:3306.</p><p>注意1: 选择MySQL的存储引擎:</p><p>注意2:  选择数据库的编码:UTF8,以后在MySQL中创建的数据库和表都是UTF8.</p><p>密码:admin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装成功之后:要修改MySQL的配置.</span><br><span class="line">进入MySQL的安装路径:C:\Program Files\MySQL\MySQL Server 5.5\bin</span><br><span class="line">找到.MySQLInstanceConfig.exe</span><br></pre></td></tr></table></figure></p><p><img src="/images/72.png" style="width: 100%;height: 100%"></p><p><img src="/images/73.png" style="width: 100%;height: 100%"></p><p><img src="/images/74.png" style="width: 100%;height: 100%"></p><h2 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">MySQL常用命令:</span><br><span class="line">打开数据库连接之前:一定要保证MySQL服务已经开启了.</span><br><span class="line">net start 命令名字:开启一个服务</span><br><span class="line">net stop  命令名字:关闭一个服务器</span><br><span class="line">---------------------------------------</span><br><span class="line">1 连接MySQL数据库:</span><br><span class="line">  进入 mysql, 在命令行中输入: </span><br><span class="line">  格式:mysql -u账户 -p密码 -h数据库服务器安装的主机 -P数据库端口</span><br><span class="line">  mysql -uroot -padmin -h127.0.0.1 -P3306</span><br><span class="line">  若连接的是本机,端口也是3306:</span><br><span class="line">  简写: mysql -uroot -padmin</span><br><span class="line">---------------------------------------  </span><br><span class="line">2 查看 mysq 中有哪些数据库: </span><br><span class="line">   show databases;</span><br><span class="line">---------------------------------------</span><br><span class="line">3 指定使用哪一个数据库: </span><br><span class="line">   use 数据库名称; </span><br><span class="line">---------------------------------------</span><br><span class="line">4 查看指定的数据库中有哪些数据表: </span><br><span class="line">    show tables</span><br><span class="line">---------------------------------------</span><br><span class="line">5 查看表的结构：</span><br><span class="line"> desc 表名</span><br><span class="line">---------------------------------------</span><br><span class="line">新建一个数据库: </span><br><span class="line"> create database 数据库名</span><br><span class="line">---------------------------------------</span><br><span class="line">删除一个数据库：</span><br><span class="line">drop database 数据库名</span><br><span class="line">---------------------------------------</span><br><span class="line">创建一张表:</span><br><span class="line">  create table  表名(</span><br><span class="line">   ....</span><br><span class="line">  )</span><br><span class="line">---------------------------------------</span><br><span class="line">删除一张表:</span><br><span class="line"> drop table  表名</span><br></pre></td></tr></table></figure><p>和数据库建立连接:<br>三要素:<br>URL: 连接地址: IP/端口/[数据库名字]<br>账户: root<br>密码: admin</p><p><img src="/images/75.png" style="width: 100%;height: 100%"></p><p>开发的时候,每个系统都应该由一个数据库实例.<br>都要自己建立新的数据库.不要使用系统自带的.</p><h2 id="MySQL中常见的列的数据类型"><a href="#MySQL中常见的列的数据类型" class="headerlink" title="MySQL中常见的列的数据类型"></a>MySQL中常见的列的数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">数据库中不区分大小写.</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">数据类型                 说明</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">char(size)            定长字符，0 - 255字节,size指N个字符数</span><br><span class="line">                  name char(20):</span><br><span class="line">                  存储will这4个字符:  底层依然占了20个字符. 不足以空格占位.---&gt;&apos;will                &apos;</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">varchar(size)      变长字符，0 - 255字节</span><br><span class="line">                  name  varchar(20):</span><br><span class="line">                  存储will这4个字符:  底层只占了4个字符. &apos;will&apos;</span><br><span class="line"></span><br><span class="line">注意:在MySQL中,字符使用单引号引起来. 相当于Java中字符串(String,StringBuilder/StringBuffer);</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">date                         日期数据:年月日，MySQL用&apos;YYYY-MM-DD&apos;格式检索和显示DATE值 </span><br><span class="line">                  格式受国际化影响.在中国YYYY-MM-DD: 在美国: 月日年(英文)</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">datetime               日期数据:年月日时分秒，要比date数据更确切，包含时分秒。MySQL以&apos;YYYY-MM-DD HH:MM:SS&apos;格式检索和显示DATETIME值 </span><br><span class="line">注意:在MySQL中,日期使用单引号引起来</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">int(size)              整型数据(size是显示的宽度):int</span><br><span class="line">                  int类型中的size表示宽度,但是没有任何意义.</span><br><span class="line">                  int(1)或者int(2)...其实底层都是int(11);</span><br><span class="line">                  一般定义int类型不需要指定size位数.               age  int</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">bigint            大整型:                Java:long</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">double[(s,p)]      小数类型，可存放实型和整型 ,精度(p)和范围(s)</span><br><span class="line">                  money double(5,2): 整数和小数一共占5为.其中小数占2位.    MAX:999.99,/ MIN:-999.99</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">decimal           小数类型，BigDecimal</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">blob                        存放图形、声音和影像，二进制对象，0-4GB:</span><br><span class="line">                  开发中,我们一般存储二进制文件保存路径.</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">text                      存放大文本文件， 0-4GB : 变长  :相当于Java中字符串(String,StringBuilder/StringBuffer);</span><br><span class="line">-----------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="创建表和约束"><a href="#创建表和约束" class="headerlink" title="创建表和约束"></a>创建表和约束</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.先进入某一个数据库.</span><br><span class="line">2.输入建表的命令:</span><br><span class="line">--------------------------------------------</span><br><span class="line">CREATE TABLE 表名(</span><br><span class="line">   列名1    列的类型   [约束],</span><br><span class="line">   列名2    列的类型   [约束],</span><br><span class="line">   ....</span><br><span class="line">   列名N    列的类型   约束    </span><br><span class="line">);</span><br><span class="line">注意:最后一行没有逗号</span><br><span class="line">--------------------------------------------</span><br><span class="line">DROP TABLE IF EXISTS `student`;</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20) AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20),</span><br><span class="line">  `age` int(11),</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;</span><br><span class="line">等价于:</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20)  PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20),</span><br><span class="line">  `age` int(11)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;</span><br><span class="line">-------------------------------------------</span><br><span class="line">若在建表中使用到了数据库的关键字.</span><br><span class="line">比如新建一张订单表:(order),但是order是数据库中的关键字(排序使用).</span><br><span class="line">表名:t_order,若费用使用order这个单词.此时使用反撇(`)括起来,`order`.</span><br><span class="line">-------------------------------------------</span><br><span class="line">常见的约束(针对于某一列):</span><br><span class="line">1.非空约束: NOT NULL, 不允许某列的内容为空.</span><br><span class="line">2.唯一约束: UNIQUE  , 在该表中,该列的内容必须唯一.</span><br><span class="line">3.主键约束: PRIMARY KEY, 非空且唯一.</span><br><span class="line">4.主键自增长:AUTO_INCREMENT</span><br></pre></td></tr></table></figure><h2 id="SQL和数据库导入导出-备份"><a href="#SQL和数据库导入导出-备份" class="headerlink" title="SQL和数据库导入导出/备份"></a>SQL和数据库导入导出/备份</h2><p>DQl语句分类 :<br>Select查询语句<br>    SELECT</p><p>DML语句（数据操作语言）    INSERT / UPDATE / DELETE</p><p>DDL语句(数据定义语言)<br>    CREATE / DROP / ALTER</p><p>DCL语句（数据控制语言）<br>事务控制语句</p><p><img src="/images/76.png" style="width: 100%;height: 100%"></p><p>Sql语句的书写规则:<br>在mysql数据库中，Sql 语句大小写不敏感.<br>Sql语句可单行或多行书写.<br>在Sql语句中，关键字不能跨多行或缩写.<br>为了提高可读性，一般关键字大写，其他小写.<br>空格和缩进使程序易读.</p><p><img src="/images/77.png" style="width: 100%;height: 100%"></p><p><img src="/images/78.png" style="width: 100%;height: 100%"></p><h2 id="简单查询-单表"><a href="#简单查询-单表" class="headerlink" title="简单查询(单表)"></a>简单查询(单表)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">------------------------------------</span><br><span class="line">SELECT *</span><br><span class="line">FROM  表名</span><br><span class="line">如果为 * 和创建表时的顺序一致。</span><br><span class="line">可以自己调整顺序，在select后边加上要查询的列名。</span><br><span class="line">-------------------------------------------</span><br><span class="line">定义字段的别名:</span><br><span class="line">1、改变列的标题头</span><br><span class="line">2、用于表示计算结果的含义</span><br><span class="line">3、作为列的别名</span><br><span class="line">4、如果别名中使用特殊字符,或者是强制大小写敏感,或有空格时,都需加双引号,不建议使用引号.</span><br><span class="line">   定义别名起有意义的英文单词或单词短语.(不要出现空格)</span><br><span class="line">SELECT 列名1 [AS] 别名,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">------------------------------------------</span><br><span class="line">带有限制条件的查询:过滤</span><br><span class="line">SELECT 列名1,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">WHERE 条件1 AND/OR 条件2...</span><br><span class="line">注意:字符串和日期要用单引号扩起来</span><br><span class="line">执行顺序:</span><br><span class="line">1.先执行FROM,确定查哪一张表</span><br><span class="line">2.再执行WHERE,过滤</span><br><span class="line">3.接着执行SELECT,筛选哪一些列</span><br><span class="line">4.接着执行ORDER子句,对查询的结果排序</span><br><span class="line">5.再接着执行GROUP BY子句,分组查询</span><br><span class="line">6.再接着执行HAVING子句,对分组的结果再筛选</span><br><span class="line">----------------</span><br><span class="line">比较运算符:</span><br><span class="line">BETWEEN 最小值 AND 最大值:在两个值之间（闭区间）: &gt;= 最小值 AND &lt;=最大值</span><br><span class="line">IN                                              :包含在什么之间: 或者等于,或者等于</span><br><span class="line">LIKE                                          :像..:模糊查询,有两种占位符:</span><br><span class="line">%:可表示零或多个字符</span><br><span class="line">_:就只表示一个字符</span><br><span class="line">------------------------------------</span><br><span class="line">对查询结果排序:</span><br><span class="line">使用ORDER BY 子句将记录排序</span><br><span class="line">ASC: 升序,缺省</span><br><span class="line">DESC: 降序</span><br><span class="line">SELECT 列名1,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">WHERE 条件1 AND/OR 条件2...</span><br><span class="line">ORDER BY 列名1 ASC/DESC, 列表2 ASC/DESC;</span><br></pre></td></tr></table></figure><p><img src="/images/79.png" style="width: 100%;height: 100%"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">需求1:查询所有货品信息</span><br><span class="line">需求2:查询所有货品的id,productName,salePrice</span><br><span class="line">需求3:查询所有货品的id，名称和批发价(批发价=卖价*折扣)</span><br><span class="line">需求4:查询所有货品的id，名称，和各进50个的成本价(成本=costPirce)</span><br><span class="line">需求5:查询所有货品的id，名称，各进50个，并且每个运费1元的成本</span><br><span class="line">需求6:查询所有货品的id，名称，各进50个，并且每个运费1元的成本(使用别名)</span><br><span class="line">需求7:查询货品零售价为119的所有货品信息</span><br><span class="line">需求8: 查询货品名为罗技G9X的所有货品信息.</span><br><span class="line">需求9: 查询货品名 不 为罗技G9X的所有货品信息.</span><br><span class="line">不区分大小写的查询:</span><br><span class="line">区分大小写的查询:</span><br><span class="line">需求10:查询分类编号不等于2的货品信息</span><br><span class="line">需求11:查询货品名称,零售价小于等于200的货品</span><br><span class="line">需求12:查询id，货品名称，批发价大于350的货品  </span><br><span class="line">需求13:选择id，货品名称，批发价在300-400之间的货品</span><br><span class="line">需求14:选择id，货品名称，分类编号为2,4的所有货品</span><br><span class="line">需求15:查询id，货品名称，货品名称匹配&apos;%罗技M9_&apos;</span><br><span class="line">需求16:选择id，货品名称，批发价 不 在300-400之间的货品</span><br><span class="line">查询id,名称, 分类为2或者 名字不带有M并且零售价大于100的货品</span><br><span class="line">需求17:选择id，货品名称，分类编号,零售价并且按零售价降序排序</span><br><span class="line"></span><br><span class="line">需求18:选择id，货品名称，分类编号,零售价先按分类编号排序,再按零售价排序</span><br><span class="line"></span><br><span class="line">需求19:查询M系列并按照批发价排序(加上别名)</span><br><span class="line"></span><br><span class="line">需求20:查询分类为2并按照批发价排序(加上别名)</span><br></pre></td></tr></table></figure><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">分组函数:分组函数作用于一组数据，并对一组数据返回一个值。</span><br><span class="line">分组函数类型:</span><br><span class="line">--------------------------------------</span><br><span class="line">AVG(列名)：  平均值</span><br><span class="line">COUNT(列名)：总数  ,查询结果是bigint类型(long),不是int类型</span><br><span class="line">MAX(列名)：  最大值</span><br><span class="line">MIN(列名)：  最小值</span><br><span class="line">SUM(列名)：  求和</span><br><span class="line">--------------------------------------</span><br><span class="line">需求:查询所有商品平均零售价</span><br><span class="line">需求:查询商品总记录数</span><br><span class="line">需求:查询分类为2的商品总数</span><br><span class="line">需求:查询商品的最小零售价，最高零售价，以及所有商品零售价总和</span><br><span class="line"></span><br><span class="line">分组查询:</span><br><span class="line"></span><br><span class="line">SELECT 列名1,列名2,列名3...</span><br><span class="line">FROM  表名</span><br><span class="line">WHERE 条件1 AND/OR 条件2...</span><br><span class="line">GROUP BY 分组的列名</span><br><span class="line">ORDER BY 列名1 ASC/DESC, 列表2 ASC/DESC;</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">可以使用GROUP BY 子句将表中的数据分成若干组</span><br><span class="line">注意：在SELECT子句中所有未包含在组函数中的列都应该包含在 GROUP BY 子句中。</span><br><span class="line">包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</span><br><span class="line">--------------------------------------</span><br><span class="line">需求:查询每个商品分类编号和每个商品分类各自的平均零售价</span><br><span class="line">需求:查询每个商品分类编号和每个商品分类各自的商品总数。</span><br><span class="line">需求:查询每个商品分类编号和每个商品分类中零售价大于100的商品总数：</span><br><span class="line">注意:</span><br><span class="line">不能在 WHERE 子句中使用组函数（注意）。</span><br><span class="line">可以在 HAVING 子句中使用组函数。</span><br><span class="line">HAVING子句:</span><br><span class="line">  对分组之后的结果做筛选/过滤.</span><br><span class="line">需求:查询零售价总和大于1500的商品分类编号以及总零售价和：</span><br></pre></td></tr></table></figure><p><img src="/images/80.png" style="width: 100%;height: 100%"></p><p><img src="/images/81.png" style="width: 100%;height: 100%"></p><h2 id="MySQL的分页查询"><a href="#MySQL的分页查询" class="headerlink" title="MySQL的分页查询"></a>MySQL的分页查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MySQL分页查询: MySQL方言:</span><br><span class="line">语法:</span><br><span class="line">SELECTcolumn1, column2...</span><br><span class="line">FROMtable</span><br><span class="line">[WHEREcondition]</span><br><span class="line">LIMIT beginIndex,pageSize</span><br><span class="line">beginIndex:是开始索引(从0开始):第一条记录:0,第二条记录:1</span><br><span class="line">beginIndex = (当前页数 - 1) * pageSize</span><br><span class="line">---------------------------------</span><br><span class="line">每页最多3条记录: pageSize = 3:</span><br><span class="line">------------------------------------------</span><br><span class="line">第一页: SELECT * FROM `product` LIMIT 0, 3  :   0,1,2</span><br><span class="line">第二页: SELECT * FROM `product` LIMIT 3, 3  :   3,4,5</span><br><span class="line">第三页: SELECT * FROM `product` LIMIT 6, 3  :   6,7,8</span><br><span class="line">第四页: SELECT * FROM `product` LIMIT 9, 3</span><br><span class="line">第七页: SELECT * FROM `product` LIMIT 18,3  :   18,19,20</span><br><span class="line">第N页:  SELECT * FROM `product` LIMIT beginIndex,3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/69.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>小码哥JAVA大神班MySql</title>
    <link href="https://huangguangda.github.io/2018/05/05/1/"/>
    <id>https://huangguangda.github.io/2018/05/05/1/</id>
    <published>2018-05-04T23:00:49.000Z</published>
    <updated>2018-06-06T18:25:47.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><a id="more"></a><p>可联系删除，做复习用，看不懂可以问哦~</p><h2 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h2><p>数据库(DataBase:DB)：数据库是按照数据结构来组织、存储和管理数据的仓库。—-&gt;存储和管理数据的仓库.</p><p>数据库管理系统（Database Management System:DBMS）：是专门用于管理数据库的计算机系统软件。数据库管理系统能够为数据库提供数据的定义、建立、维护、查询和统计等操作功能，并完成对数据完整性、安全性进行控制的功能。</p><p>MIS:管理信息系统.<br>我们一般说的数据库,就是指的DBMS: 数据库服务器.</p><h2 id="数据库技术发展历程："><a href="#数据库技术发展历程：" class="headerlink" title="数据库技术发展历程："></a>数据库技术发展历程：</h2><ol><li>层次数据库和网状数据库技术阶段；<br> 使用指针来表示数据之间的联系。</li><li>关系数据库技术阶段；<br> 经典的里程碑阶段。代表DBMS:Oracle、DB2、MySQL、SQL Server、SyBase等。</li><li>后关系数据库技术阶段；<br> 关系型数据库存在数据模型，性能，拓展伸缩性的缺点，出现了：<br> ORDBMS：面向对象数据库技术。<br> NoSQL ：结构化数据库技术。</li></ol><p>随着大数据的不断发展，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速，出色的NoSQL数据库：</p><h3 id="常见的NoSQL数据库分为四大类："><a href="#常见的NoSQL数据库分为四大类：" class="headerlink" title="常见的NoSQL数据库分为四大类："></a>常见的NoSQL数据库分为四大类：</h3><p>1):键值存储数据库：Oracle BDB,Redis,BeansDB<br>2):列式储数数据库：HBase,Cassandra,Riak<br>3):文档型数据库：MongoDB,CouchDB<br>4):图形数据库：Neo4J,InfoGrid,Infinite Graph</p><p>常见的关系数据库:</p><h2 id="数据库系统-所属公司"><a href="#数据库系统-所属公司" class="headerlink" title="  数据库系统        所属公司"></a>  数据库系统        所属公司</h2><p>  Oracle            Oracle(甲骨文)<br>  DB2               IBM<br>  SQL Server        MS<br>  MySQL             AB–&gt;SUN–&gt;Oracle</p><p>Oracle:运行稳定，可移植性高，功能齐全，性能超群！适用于大型企业领域。</p><p>DB2：速度快、可靠性好，适于海量数据，恢复性极强。适用于大中型企业领域。</p><p>SQL Server:全面，效率高，界面友好，操作容易，但是不跨平台。适用于于中小型企业领域。</p><p>MySQL:开源，体积小，速度快。适用于中小型企业领域。</p><h2 id="SQL：结构化查询语言-Structured-Query-Language-。"><a href="#SQL：结构化查询语言-Structured-Query-Language-。" class="headerlink" title="SQL：结构化查询语言(Structured Query Language)。"></a>SQL：结构化查询语言(Structured Query Language)。</h2><p>是关系型数据库标准语言。<br>特点：简单，灵活，功能强大。</p><h3 id="SQL包含6个部分："><a href="#SQL包含6个部分：" class="headerlink" title="SQL包含6个部分："></a>SQL包含6个部分：</h3><p>一：数据查询语言（DQL）：<br>其语句，也称为“数据检索语句”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。</p><p>二：数据操作语言（DML）：<br>其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动作查询语言。</p><p>三：事务处理语言（TPL）：<br>它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。</p><p>四：数据控制语言（DCL）：<br>它的语句通过GRANT或REVOKE获得许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。</p><p>五：数据定义语言（DDL）：<br>其语句包括动词CREATE和DROP。在数据库中创建新表或删除表（CREAT TABLE 或 DROP TABLE）；为表加入索引等。DDL包括许多与人数据库目录中获得数据有关的保留字。它也是动作查询的一部分。</p><p>六：指针控制语言（CCL）：<br>它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。</p><h3 id="书写规则："><a href="#书写规则：" class="headerlink" title="书写规则："></a>书写规则：</h3><p>1.数据库中，SQL语句大小写不敏感<br>2.SQL语句可单行或多行书写<br>3.在SQL语句中，关键字不能跨多行或缩写<br>4.为了提高可读性，一般关键字大写，其他小写<br>5.空格和缩进使程序易读</p><h2 id="什么是表？"><a href="#什么是表？" class="headerlink" title="什么是表？"></a>什么是表？</h2><p>我们说MySQL是一种关系型数据库。关系数据库最重要的概念就是表。 </p><p>表:又称之为二维表.(有行和列)—-&gt;存储数据.<br>表具有固定的列数和任意的行数，在数学上称为“关系”。</p><p>二维表是同类实体的各种属性的集合，每个实体对应于表中的一行，在关系中称为元组，相当于通常的一条记录；</p><p>表中的列表示属性，称为Field，相当于通常记录中的一个数据项，也叫列、字段。</p><p><img src="/images/42.png" style="width: 100%;height: 100%"></p><p><img src="/images/43.png" style="width: 100%;height: 100%"></p><p><img src="/images/44.png" style="width: 100%;height: 100%"></p><p><img src="/images/45.png" style="width: 100%;height: 100%"></p><p><img src="/images/46.png" style="width: 100%;height: 100%"></p><p><img src="/images/47.png" style="width: 100%;height: 100%"></p><p><img src="/images/48.png" style="width: 100%;height: 100%"></p><p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供不同的功能和能力。<br>通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p><p>MyISAM：拥有较高的插入，查询速度，但不支持事务，不支持外键。<br>InnoDB：支持事务，支持外键，支持行级锁定，性能较低。<br>InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但对比MyISAM，处理效率差，且会占用更多的磁盘空间以保留数据和索引。</p><p><img src="/images/49.png" style="width: 100%;height: 100%"></p><p><img src="/images/50.png" style="width: 100%;height: 100%"></p><p>最常用的整数类型：<br>MySQL列类型               Java数据类型</p><p>INT:                       int/Integer<br>BIGINT:                    long/Long</p><p>MySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。</p><p>例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。</p><p>需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。一般不用指定位宽。</p><p><img src="/images/51.png" style="width: 100%;height: 100%"></p><p><img src="/images/52.png" style="width: 100%;height: 100%"></p><p><img src="/images/53.png" style="width: 100%;height: 100%"></p><h2 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h2><p>创建表:<br>1.先进入某一个数据库.<br>2.输入建表的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">   列名1    列的类型   [约束],</span><br><span class="line">   列名2    列的类型   [约束],</span><br><span class="line">   ....</span><br><span class="line">   列名N    列的类型   约束    </span><br><span class="line">);</span><br><span class="line">注意:最后一行没有逗号</span><br></pre></td></tr></table></figure></p><p>使用SQL的时候,不要使用SQL的关键字,如果使用到,怎么办.<br>建立一张表,表用来装订单的信息,订单叫做:ORDER.<br>此时,SQL出错,因为ORDER是SQL中的关键字.</p><p>   解决方案一:使用反引号(<code>)把自定义的标识符引起来:</code>order`.<br>   解决方案二:使用表名的前缀,一般的,习惯t_order.</p><p>需求:在jdbcdemo数据库中,创建一张学生表(包含了id,name,age).<br>第一步:进入jdbcdemo数据库.<br>  USE jdbcdemo;<br>第二步:输入建立表的语句.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20) DEFAULT NULL,</span><br><span class="line">  `name` varchar(20) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>删除表:<br>DROP TABLE  student;</p><p>查看表结构：<br>DESC table_name;<br>查看表的详细定义：<br>SHOW CREATE TABLE table_name; 其实现实的建立表的SQL语句.</p><p><img src="/images/54.png" style="width: 100%;height: 100%"></p><h2 id="表的约束"><a href="#表的约束" class="headerlink" title="表的约束"></a>表的约束</h2><p>表的约束(针对于某一列):<br>1.非空约束：NOT NULL，不允许某列的内容为空。<br>2.设置列的默认值：DEFAULT。<br>3.唯一约束：UNIQUE，在该表中，该列的内容必须唯一。<br>4.主键约束：PRIMARY KEY， 非空且唯一。<br>5.主键自增长：AUTO_INCREMENT，从1开始，步长为1。<br>6.外键约束：FOREIGN KEY. A表中的外键列的值必须参照于B表中的某一列(B表主键)-明天讲解。</p><p>主键设计：<br>1：单字段主键，单列作为主键，建议使用。<br>   复合主键，使用多列充当主键，不建议。<br>2：主键分为两种:<br>   1）.自然主键:使用有业务含义的列作为主键(不推荐使用);<br>   2）.代理主键:使用没有业务含义的列作为主键(推荐使用);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20) PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) UNIQUE ,</span><br><span class="line">  `age` int(11) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/images/55.png" style="width: 100%;height: 100%"></p><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><p><img src="/images/56.png" style="width: 100%;height: 100%"></p><p>简单查询:<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT&#123;*, column [alias],...&#125;</span><br><span class="line">FROM     table_name;</span><br></pre></td></tr></table></figure></p><p>说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT   选择查询列表</span><br><span class="line">FROM  提供数据源(表、视图或其他的数据源)</span><br></pre></td></tr></table></figure></p><p>如果为 * 和创建表时的顺序一致。<br>可以自己调整顺序，在select后边加上要查询的列名。</p><p>需求:查询所有货品信息<br>需求:查询所有货品的id,productName,salePrice</p><p>消除结果中重复的数据:<br>需求:查询商品的分类编号。<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 列名，...</span><br><span class="line"></span><br><span class="line">FROMtable_name;</span><br></pre></td></tr></table></figure></p><p>实现数学运算查询:<br>对NUMBER型数据可以使用算数操作符创建表达式（+  -  *  /）<br>对DATE型数据可以使用部分算数操作符创建表达式 （+  -）</p><h3 id="运算符优先级："><a href="#运算符优先级：" class="headerlink" title="运算符优先级："></a>运算符优先级：</h3><p>1、乘法和除法的优先级高于加法和减法<br>2、同级运算的顺序是从左到右<br>3、表达式中使用”括号”可强行改变优先级的运算顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">需求:查询所有货品的id，名称和批发价(批发价=卖价*折扣)</span><br><span class="line"></span><br><span class="line">需求:查询所有货品的id，名称，和各进50个的成本价(成本=costPirce)</span><br><span class="line"></span><br><span class="line">需求:查询所有货品的id，名称，各进50个，并且每个运费1元的成本</span><br></pre></td></tr></table></figure><p>设置列名的别名。<br>1、改变列的标题头；<br>2、用于表示计算结果的含义；<br>3、作为列的别名；<br>4、如果别名中使用特殊字符，或者是强制大小写敏感，或有空格时，都需加双引号；</p><p>需求:查询所有货品的id，名称，各进50个，并且每个运费1元的成本(使用别名)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,productName,(costPrice+1) * 50 AS pf FROM product</span><br><span class="line">SELECT id,productName,(costPrice+1) * 50 pf FROM product</span><br><span class="line">SELECT id,productName,(costPrice+1) * 50 &quot;p f&quot; FROM product</span><br></pre></td></tr></table></figure></p><h2 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h2><p>过滤查询:<br>使用WHERE子句限定返回的记录：<br>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT  &lt;selectList&gt; </span><br><span class="line">FROM      table_name</span><br><span class="line">WHERE  条件;</span><br></pre></td></tr></table></figure></p><p>注意：<br>WHERE子句在 FROM 子句后</p><p>比较运算符:<br>运算符               含义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=               等于</span><br><span class="line">&gt;               大于</span><br><span class="line">&gt;=               大于或等于</span><br><span class="line">&lt;               小于</span><br><span class="line">&lt;=               小于或等于</span><br><span class="line">!=(&lt;&gt;)           不等于</span><br></pre></td></tr></table></figure></p><p>需求: 查询货品零售价为119的所有货品信息.<br>需求: 查询货品名为罗技G9X的所有货品信息.<br>需求: 查询货品名 不为 罗技G9X的所有货品信息.<br>需求: 查询分类编号不等于2的货品信息<br>需求: 查询货品名称,零售价小于等于200的货品<br>需求: 查询id，货品名称，批发价大于350的货品<br>思考：使用where后面使用别名不行,总结select和where的执行顺序</p><p>注意：字符串和日期要用单引号扩起来.<br>要让MySQL查询区分大小写，可以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE BINARY productName=&apos;g9x&apos;</span><br><span class="line">SELECT * FROM table_name WHERE BINARY productName=&apos;G9X&apos;</span><br></pre></td></tr></table></figure></p><p>SQL中不同子句执行先后顺序:<br>1):首先执行FROM子句. 明确从哪一张表中做查询.<br>2):其次执行WHERE子句.筛选符合条件的数据.<br>3):接着执行SELECT子句.选择出要显示哪些列的数据.<br>4):最后执行ORDER BY子句.对查询筛选的结果再做排序.</p><p>逻辑运算符:<br>运算符                含义</p><p>AND(&amp;&amp;)            如果组合的条件都是TRUE,返回TRUE<br>OR(||)             如果组合的条件之一是TRUE,返回TRUE<br>NOT(!)             如果下面的条件是FALSE,返回TRUE.</p><p>需求: 选择id，货品名称，批发价在300-400之间的货品<br>需求: 选择id，货品名称，分类编号为2,4的所有货品<br>需求: 选择id，货品名词，分类编号不为2的所有商品<br>需求: 选择id，货品名称，分类编号的货品零售价大于等于250或者是成本大于等于200</p><p>运算符优先级规则:<br>优先级            运算符</p><p>1                所有比较运算符<br>2                NOT<br>3                AND<br>4                OR</p><p>范围查询:<br>使用BETWEEN运算符显示某一值域范围的记录，这个操作符最常见的使用在数字类型数据的范围上，但对于字符类型数据和日期类型数据同样可用。<br>格式：<br>SELECT * FROM 表名 WHERE 列名 BETWEEN minvalue AND maxvalue：闭区间。<br>需求: 选择id，货品名称，批发价在300-400之间的货品<br>需求: 选择id，货品名称，批发价不在300-400之间的货品</p><p>集合查询:<br>使用IN运算符，判断列的值是否在指定的集合中。<br>格式： WHERE 列名 IN (值1，值2….);<br>需求:选择id，货品名称，分类编号为2,4的所有货品<br>需求:选择id，货品名称，分类编号不为2,4的所有货品</p><p>空值判断:<br>IS NULL:判断列的值是否为空。<br>格式：WHERE  列名 IS NULL;<br>需求:查询商品名为NULL的所有商品信息。</p><p>模糊查询:</p><p>使用LIKE运算符执行通配查询，查询条件可包含文字字符或数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%:通配符：可表示零或多个字符。</span><br><span class="line">_:通配符：可表示一个字符。</span><br><span class="line">通配符：用来实现匹配部分值得特殊字符。</span><br></pre></td></tr></table></figure></p><p>需求: 查询id，货品名称，货品名称匹配’%罗技M9_’<br>需求: 查询id，货品名称，分类编号,零售价大于等于200并且货品名称匹配’%罗技M1__’<br>模糊查询不是搜索引擎. Lucene </p><h2 id="对查询结果排序"><a href="#对查询结果排序" class="headerlink" title="对查询结果排序"></a>对查询结果排序</h2><p>使用ORDER BY子句将记录排序</p><p>ASC : 升序，缺省。<br>DESC: 降序。<br>ORDER BY </p><p>子句出现在SELECT语句的最后。<br>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;selectList&gt; </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE 条件</span><br><span class="line">ORDER BY 列名1 [ASC/DESC],列名2 [ASC/DESC]...;</span><br></pre></td></tr></table></figure></p><p>按照某一列来排序:<br>需求:选择id，货品名称，分类编号,零售价并且按零售价降序排序<br>按多列排序:<br>需求: 选择id，货品名称，分类编号,零售价先按分类编号排序,再按零售价排序<br>列的别名排序:<br>需求:查询M系列并按照批发价排序(加上别名)<br>需求:查询分类为2并按照批发价排序(加上别名)<br>注意：不能对使用了引号的别名排序。</p><p>SELECT语句执行顺序：<br>先执行FROM—&gt;接着执行WHERE—&gt;再执行SELECT—&gt;最后执行ORDER BY</p><h2 id="MySQL的分页查询"><a href="#MySQL的分页查询" class="headerlink" title="MySQL的分页查询"></a>MySQL的分页查询</h2><p>分页设计:<br>    假分页/逻辑分页/内存  分页:<br>        一次性把数据全部查询出来,存放在内存中,翻页的时候,只需要从内存中去截取指定的条数即可.<br>        优缺点:缺点:若数据过多,可能造成内存溢出;优点:简单,翻页比较快.<br>    真分页/物理分页/数据库分页:<br>        每次翻页的时候,都从数据库中去截取指定条数的数据.<br>        优缺点:缺点:复杂,翻页比较慢;优点:不会造成内存溢出.</p><p>此时,我们讲解MySQL特有的分页方式(LIMIT,在Oracle12C中也提供该语法了).</p><p>此时设置每页最多显示3条数据:<br>Integer pageSize = 3;<br>语法:  LIMIT  ?,?;<br>第一个?:从哪一个索引位置开始截取数据(从0开始的). beginIndex<br>第二个?:每页显示最多的条数.                       pageSize<br>LIMIT  beginIndex, pageSize;<br>beiginIndex = (currentPage - 1) * pageSize;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一页: SELECT * FROM `product` LIMIT 0, 3</span><br><span class="line">第二页: SELECT * FROM `product` LIMIT 3, 3</span><br><span class="line">第三页: SELECT * FROM `product` LIMIT 6, 3</span><br><span class="line">第四页: SELECT * FROM `product` LIMIT 9, 3</span><br><span class="line">第N页:  SELECT * FROM `product` LIMIT (N-1)*3, 3</span><br></pre></td></tr></table></figure><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>什么是聚集函数(分组函数/统计函数)：<br>聚集函数作用于一组数据，并对一组数据返回一个值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COUNT：统计结果记录数  </span><br><span class="line">MAX：  统计计算最大值</span><br><span class="line">MIN：  统计计算最小值</span><br><span class="line">SUM：  统计计算求和</span><br><span class="line">AVG：  统计计算平均值</span><br></pre></td></tr></table></figure><p>需求:查询所有商品平均零售价<br>需求:查询商品总记录数(注意在Java中必须使用long接收)<br>需求:查询分类为2的商品总数<br>需求:查询商品的最小零售价，最高零售价，以及所有商品零售价总和</p><p><img src="/images/57.png" style="width: 100%;height: 100%"></p><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>单表查询:从一张表中查询数据</p><p>多表查询:从多张表中联合查询出数据</p><p>为什么需要多表查询:<br>简单说分别操作:类似于咱们Java中的分类.不同的事物使用不同的类型(类)来表示.<br>                每一张表存储该类型的事物的数据,不同事物咱们采取分表操作.</p><p>单表查询:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;selectList&gt;</span><br><span class="line"></span><br><span class="line">FROM  表名</span><br></pre></td></tr></table></figure></p><p>注意:没有连接条件的表关系返回的结果:<br>多表查询会产生笛卡尔积:<br>假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。<br>实际运行环境下，应避免使用全笛卡尔集(笛卡尔积的数据存在大量的不合理)。</p><p>消除笛卡尔积最简单最直接的方式:<br>  使用等值连接.<br>如果是N张表做连接查询,等值连接关系至少是N-1个.<br>需求:查询所有的货品信息+对应的货品分类信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT productName,dirName FROM product,productdir</span><br><span class="line">WHERE dir_id = productdir.id</span><br></pre></td></tr></table></figure></p><p><img src="/images/59.png" style="width: 100%;height: 100%"></p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>主键约束: PRIMARY KEY. 在表中主键列的值,非空且唯一.<br>外键约束：FOREIGN KEY. A表中的外键列的值必须参照于B表中的主键列,外键列允许为NULL.</p><p>在MySQL中,只有InnoDB存储引擎才只能事务和外键,MyISAM不支持事务不支持外键.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改表的存储引擎: ALTER TABLE product engine = &apos;InnoDB&apos;;</span><br></pre></td></tr></table></figure></p><p><img src="/images/60.png" style="width: 100%;height: 100%"></p><p><img src="/images/61.png" style="width: 100%;height: 100%"></p><p><img src="/images/62.png" style="width: 100%;height: 100%"></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select &lt;select_list&gt; from tablea a left join tableb b on a.key=b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a left join tableb b on a.key = b.key where b.key is null</span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a right join tableb b on a.key = b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a on a.key = b.key where a.key is null</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select &lt;select_list&gt; from tablea a inner join tableb b on a.key = b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a full outer join tableb b on a.key = b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a full outer join tableb b on a.key = b.key </span><br><span class="line"></span><br><span class="line">select &lt;select_list&gt; from tablea a full outer join table b on a.key = b.key where a.key is null or b.key is null</span><br></pre></td></tr></table></figure><p><img src="/images/63.png" style="width: 100%;height: 100%"></p><p>内连接查询:<br>   隐式内连接:<br>   显示内连接:<br>外连接查询:<br>   左外连接:<br>   右外连接:<br>   全外连接:<br>子查询:<br>字连接查询:</p><p>内连接查询：是相对于外连接。<br>内连接分为：隐式内连接、显示内连接，其查询效果相同,仅仅是语法不一样而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">隐式内连接：</span><br><span class="line">SELECT &lt;selectList&gt;</span><br><span class="line">FROM   A ,B  WHERE A.列 = B.列</span><br><span class="line"></span><br><span class="line">显示内连接(推荐写法)：</span><br><span class="line">SELECT &lt;selectList&gt;</span><br><span class="line">FROM  A [INNER] JOIN B ON A.列 = B.列</span><br></pre></td></tr></table></figure></p><p>需求:查询所有商品的名称和分类名称:<br>隐式内连接: SELECT p.productName,pd.dirName FROM product p,productdir pd WHERE p.dir_id = pd.id<br>显示内连接: SELECT p.productName,pd.dirName FROM product p INNER JOIN productdir pd ON p.dir_id = pd.id<br>显示内连接: SELECT p.productName,pd.dirName FROM product p JOIN productdir pd ON p.dir_id = pd.id</p><p>在做等值连接的时候,若A表中和B表中的列名相同. 则可以简写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT&lt;selectList&gt;</span><br><span class="line">FROMA [INNER] JOIN B USING(同名的列)</span><br><span class="line">前提:在emp和dept表中都有deptno列. 并且是外键关系。</span><br><span class="line">如: SELECT * FROM emp JOIN dept USING (deptno)</span><br></pre></td></tr></table></figure></p><p>使用表名前缀在多个表中区分相同的列。<br>在不同表中具有相同列名的列可以用表的别名加以区分。<br>使用别名可以简化查询。<br>使用表名前缀可以提高执行效率。<br>如果使用了表的别名，则不能再使用表的真名</p><p>需求: 查询货品id，货品名称，货品所属分类名称<br>需求: 查询零售价大于200的无线鼠标<br>需求: 查询零售价大于200的无线鼠标(使用表的别名)<br>需求: 查询每个货品对应的分类以及对应的库存<br>需求: 如果库存货品都销售完成,按照利润从高到低查询货品名称,零售价,货品分类（三张表）.</p><p>外连接查询:<br>   A LEFT JOIN  B—-&gt; B RINGHT JOIN A<br>  左外连接:查询出JOIN左边表的全部数据查询出来,JOIN右边的表不匹配的数据使用NULL来填充数据.<br>  右外连接:查询出JOIN右边表的全部数据查询出来,JOIN左边的表不匹配的数据使用NULL来填充数据.</p><p>语法格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT&lt;selectList&gt;</span><br><span class="line">FROMA LEFT/RIGHT OUTER JOIN B</span><br><span class="line">  ON (A.column_name = B.column_name)];</span><br><span class="line">左连接:</span><br><span class="line">SELECT * FROM product p LEFT JOIN productdir pd ON p.dir_id = pd.id</span><br><span class="line">右连接:</span><br><span class="line">SELECT * FROM product p RIGHT JOIN productdir pd ON p.dir_id = pd.id</span><br></pre></td></tr></table></figure></p><p><img src="/images/64.png" style="width: 100%;height: 100%"></p><p><img src="/images/65.png" style="width: 100%;height: 100%"></p><p>自连接查询:把一张表看成两张来做查询.</p><p><img src="/images/66.png" style="width: 100%;height: 100%"></p><h2 id="操作数据-DML"><a href="#操作数据-DML" class="headerlink" title="操作数据(DML)"></a>操作数据(DML)</h2><p>DQL:查询语句,查询之后,会返回结果的临时表.<br>DML:增删改语句,操作之后,会返回一个结果,表示受影响的行数(删除3条数据,就返回3).</p><p>插入语句:一次插入操作只插入一行.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name (column1,column2,column3...)</span><br></pre></td></tr></table></figure></p><p>1.插入完整数据记录<br>2.插入数据记录一部分<br>3.插入多条数据记录（MySQL特有）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTOtable_name (column1,column2,column3...)</span><br><span class="line">  VALUES (value1,value2,value3...),</span><br><span class="line">         (value1,value2,value3...),</span><br><span class="line">         (value1,value2,value3...)..;</span><br></pre></td></tr></table></figure></p><p>4.插入查询结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTOtable_name (column1,column2,column3...)</span><br><span class="line">    SELECT (column1,column2,column3...)</span><br><span class="line">    FROM table_name </span><br><span class="line">INSERT INTO productdir (dirName,parent_id)</span><br><span class="line">  SELECT dirName,parent_id FROM productdir</span><br></pre></td></tr></table></figure></p><p>删除操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE  FROM table_name [WHERE condition];</span><br><span class="line">注意:如果省略了where子句，则全表的数据都会被删除.</span><br></pre></td></tr></table></figure><p>更新操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name SET columnName = value [, columnName = value] [WHEREcondition];</span><br></pre></td></tr></table></figure><p>如果省略了where子句，则全表的数据都会被修改。注意:没有FROM</p><p>需求:将零售价大于300的货品零售价上调0.2倍<br>需求:将零售价大于300的有线鼠标的货品零售价上调0.1倍</p><h2 id="数据备份和恢复"><a href="#数据备份和恢复" class="headerlink" title="数据备份和恢复"></a>数据备份和恢复</h2><p>备份:很重要,修改之前,都先做备份.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MySQL自身的数据库维护：</span><br><span class="line">通过cmd命令进入dos窗口：</span><br><span class="line">1.导出：mysqldump -u账户 -p密码 数据库名称&gt;脚本文件存储地址</span><br><span class="line"></span><br><span class="line">   mysqldump -uroot -padmin jdbcdemo&gt; C:/shop_bak.sql</span><br><span class="line"></span><br><span class="line">2.导入：mysql -u账户 -p密码 数据库名称&lt; 脚本文件存储地址</span><br><span class="line">   mysql -uroot -padmin jdbcdemo&lt; C:/shop_bak.sql</span><br><span class="line"></span><br><span class="line">Navicat工具的导入和导出：</span><br></pre></td></tr></table></figure></p><p><img src="/images/67.png" style="width: 100%;height: 100%"></p><p><img src="/images/68.png" style="width: 100%;height: 100%"></p><p>1 、 部门表：DEPT<br>No. 字段名称 类型 描述<br>1 DEPTNO BIGINT 部门编号，由两位数字所组成( 主键)<br>2 DNAME VARCHAR(20) 部门名称，由 14 位字符所组成<br>3 LOC VARCHAR(20) 部门位置</p><p>2 、 雇员表：EMP<br>No. 字段名称 类型 描述<br>1 EMPNO BIGINT 雇员编号，由四位数字所组成( 主键)<br>2 ENAME VARCHAR(20) 雇员姓名<br>3 JOB VARCHAR(20) 职位<br>4 MGR BIGINT 一个雇员对应的领导编号（雇员编号）<br>5 HIREDATE DATE 雇员的雇佣日期<br>6 SAL DOUBLE(7,2) 基本工资，由两位小数和五位整数所组成<br>7 COMM DOUBLE(7,2) 奖金/奖金<br>8 DEPTNO BIGINT 一个雇员所在的部门编号，与 dept 表的对应</p><p>DEPT 表数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `DEPT` VALUES (10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos;);</span><br><span class="line">INSERT INTO `DEPT` VALUES (20, &apos;RESEARCH&apos;, &apos;DALLAS&apos;);</span><br><span class="line">INSERT INTO `DEPT` VALUES (30, &apos;SALES&apos;, &apos;CHICAGO&apos;);</span><br><span class="line">INSERT INTO `DEPT` VALUES (40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos;);</span><br></pre></td></tr></table></figure></p><p>EMP 表数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `EMP` VALUES (7369, &apos;SMITH&apos;, &apos;CLERK&apos;, 7902, &apos;1980-12-17&apos;, 800, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7499, &apos;ALLEN&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-02-20&apos;, 1600, 300, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7521, &apos;WARD&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-02-22&apos;, 1250, 500, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7566, &apos;JONES&apos;, &apos;MANAGER&apos;, 7839, &apos;1981-04-02&apos;, 2975, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7654, &apos;MARTIN&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-09-28&apos;, 1250, 1400, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7698, &apos;BLAKE&apos;, &apos;MANAGER&apos;, 7839, &apos;1981-05-01&apos;, 2850, NULL, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7782, &apos;CLARK&apos;, &apos;MANAGER&apos;, 7839, &apos;1981-06-09&apos;, 2450, NULL, 10);</span><br><span class="line">INSERT INTO `EMP` VALUES (7788, &apos;SCOTT&apos;, &apos;ANALYST&apos;, 7566, &apos;1987-04-19&apos;, 3000, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7839, &apos;KING&apos;, &apos;PRESIDENT&apos;, NULL, &apos;1981-11-17&apos;, 5000, NULL, 10);</span><br><span class="line">INSERT INTO `EMP` VALUES (7844, &apos;TURNER&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-09-08&apos;, 1500, 0, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7876, &apos;ADAMS&apos;, &apos;CLERK&apos;, 7788, &apos;1987-05-23&apos;, 1100, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7900, &apos;JAMES&apos;, &apos;CLERK&apos;, 7698, &apos;1981-12-03&apos;, 950, NULL, 30);</span><br><span class="line">INSERT INTO `EMP` VALUES (7902, &apos;FORD&apos;, &apos;ANALYST&apos;, 7566, &apos;1981-12-03&apos;, 3000, NULL, 20);</span><br><span class="line">INSERT INTO `EMP` VALUES (7934, &apos;MILLER&apos;, &apos;CLERK&apos;, 7782, &apos;1982-01-23&apos;, 1300, NULL, 10);</span><br></pre></td></tr></table></figure></p><h2 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h2><p>01.查询每个雇员的编号、姓名、职位。</p><p>02.查询每个雇员的职位，职位。</p><p>03.查询每个雇员的职位，使用 T DISTINCT 消除掉显示的重复 行记录。</p><p>04.计算出每个雇员的基本年薪，同时查询出雇员的编号、姓名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">05.每个雇员每个月公司会补贴饭食 200 元，交通补助 300 元，计算年薪（年薪=(工资+奖金)*12）。</span><br></pre></td></tr></table></figure><p>06.查询基本工资高于 2000 的全部雇员信息。</p><p>07.查询出 smith 的信息。</p><p>08.查询出所有不是 CLERK 的详细信息。</p><p>09.查询出所有销售人员(SALESMAN)的基本信息，并且要求销售人员的工资高于 1300。</p><p>10.查询出工资范围在 1500~3000 之间的全部雇员信息（包含 1500 和 3000）。</p><p>11.查询出所有经理或者是销售人员的信息，并且要求这些人的基本工资高于 1500。</p><p>12.要求查询出所有在 1981 年雇佣的雇员信息。</p><p>13.查询所有领取奖金的雇员信息（comm 不为空）。</p><p>14.查询所有领取奖金高于 100 的雇员信息。</p><p>15.查询出雇员编号是 7369、7566、9999 的雇员信息。</p><p>16.查询出所有雇员姓名是以 A 开头的全部雇员信息。</p><p>17.查询出雇员姓名第二个字母是 M 的全部雇员信息。</p><p>18.查询出雇员姓名任意位置上包含字母 A 的全部雇员信息。</p><p>19.查询出所有雇员的信息，要求按照工资排序。</p><p>20.要求查询所有雇员的信息，按照雇佣日期由先后排序。</p><p>21.查询全部雇员信息，按照工资由高到低排序，如果工资相同，则按照雇佣日期由先后排序。</p><p>22.查询部门 30 中的所有员工。</p><p>23.查询出所有办事员（CLERK）的姓名，编号和部门编号。</p><p>24.查询出奖金高于薪金的员工。</p><p>25.查询出奖金高于薪金的 60%的员工。</p><p>26.查询出部门 10 中所有经理（MANAGER）和部门 20 中所有办事员（CLERK）的详细资料。</p><p>27.查询出部门 10 中所有经理，部门 20 中所有办事员，既不是经理又不是办事员但其薪金大于或等于 2000<br>的所有员工的信息。</p><p>28.查询出收取奖金的员工的不同工作。</p><p>29.查询出不收取奖金或收取的奖金低于 100 的员工。</p><p>30.查询出不带有“R”的员工的姓名。</p><p>31.查询出每个雇员的姓名、职位、领导姓名。</p><p>32.查询出所有员工的编号、姓名及其直接上级的编号、姓名，显示的结果按领导年工资的降序排列。</p><p>33.查询出在销售部（SALES）工作的员工姓名、基本工资、雇佣日期、部门名称。（不知道销售部编号）。</p><p>34.查询出所有员工的姓名、部门名称和工资。</p><p>35.查询出所有员工的年工资，所在部门名称，按年薪从低到高排序。</p><p>36.查询出某个员工的上级主管及所在部门名称，并要求出这些主管中的薪水超过 3000。</p><p>37.查询出公司的最高和最低工资。</p><p>38.查询出每个部门的人数、平均工资，只显示部门编号。</p><p>39.查询出每种职位的最高和最低工资。</p><p>40.查询平均工资高于 2000 的职位信息，以及从事此职位的雇员人数、平均工资。</p><p>41 查询出至少有一个员工的所有部门编号、名称，并统计出这些部门的平均工资、最低工资、最高工资。</p><p>42.查询出部门名称和这些部门的员工信息（数量、平均工资），同时列出那些没有员工的部门。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Android开发教程</title>
    <link href="https://huangguangda.github.io/2018/05/04/1/"/>
    <id>https://huangguangda.github.io/2018/05/04/1/</id>
    <published>2018-05-04T15:50:24.000Z</published>
    <updated>2018-06-14T11:59:23.629Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/41.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>老罗Android开发视频教程</p><h2 id="Android系统介绍"><a href="#Android系统介绍" class="headerlink" title="Android系统介绍"></a>Android系统介绍</h2><p>Android是基于Linux内核的操作系统，是Google公司在2007年11月5日公布的手机操作系统。早期由原名为“Android”的公司开发，谷歌在2005年收购”Android.Inc“后，继续进行对Android系统开发运营，它采用了软件堆层的架构，主要分为三部分，底层Linux内核只提供基本功能，其他的应用软件则由各公司自行开发，部分程序以Java编写。</p><p>2011年初数据显示，仅正式上市两年的操作系统Android已经跃居全球最受欢迎的智能手机平台。现在，Android系统不但应用于智能手机，也在平板电脑市场急速扩张。</p><h2 id="Android平台五大优势特色"><a href="#Android平台五大优势特色" class="headerlink" title="Android平台五大优势特色"></a>Android平台五大优势特色</h2><p>开放性</p><p>Android平台首先就是其开放性，开发的平台允许任何移动终端厂商加入到Android联盟中来。</p><p>挣脱运营商的束缚</p><p>在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。自从Android上市，用户可以更加方便地链接网络，运营商的制约减少。随着2G至3G移动网络的逐步过渡和提升，手机随意接入网络。</p><p>丰富的硬件选择</p><p>这一点还是与Android平台的开发性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步，甚至软件的兼容。</p><p>不受任何限制的开发商</p><p>Android平台提供给第三方开发商一个十分宽泛，自由的环境。因此不会受到各种条条框框的阻挠。</p><p>无缝结合Google应用</p><p>Google服务如地图，邮件，搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。</p><h2 id="Android学习路线图介绍"><a href="#Android学习路线图介绍" class="headerlink" title="Android学习路线图介绍"></a>Android学习路线图介绍</h2><p>Java语言编程基础 面向对象基础 Java常用设计模式 Java数据结构和算法</p><p>关系型数据库 JDBC数据库编程 HTML和Javascript编程 Java动态网页编程</p><h3 id="Java以及Web应用开发项目"><a href="#Java以及Web应用开发项目" class="headerlink" title="Java以及Web应用开发项目"></a>Java以及Web应用开发项目</h3><p>UI界面设计 Android数据库编程 Android服务的应用 Android内容提供者</p><p>Android网络编程 Android多媒体编程 Android异步任务加载 Android传感器编程</p><p>Android谷歌地图开发 Android蓝牙开发 Android Wifi编程 Android与Webservice</p><p>Android与HTML开发 JQueryMobile编程 PhoneGap应用开发 Widget套件使用</p><p>Android与工作流引擎结合 Android报表制作 Android高速描绘 Android企业框架介绍</p><h3 id="Android应用项目实战开发"><a href="#Android应用项目实战开发" class="headerlink" title="Android应用项目实战开发"></a>Android应用项目实战开发</h3><p>2D图形编程 图片处理 碰撞检测 物理引擎介绍</p><p>Cocoa 2D引擎介绍 OpenGLES 游戏资源调度 游戏实战项目</p><h3 id="Android游戏应用开发"><a href="#Android游戏应用开发" class="headerlink" title="Android游戏应用开发"></a>Android游戏应用开发</h3><h2 id="第二集：android系统框架的介绍"><a href="#第二集：android系统框架的介绍" class="headerlink" title="第二集：android系统框架的介绍"></a>第二集：android系统框架的介绍</h2><p>src目录：主要是完成java代码的编写<br>assets目录：资源目录<br>res目录：存在图片，布局文件和字符串，菜单等文件<br>bin目录：输出文件夹，如生成的APK文件<br>project.properties工程属性文件配置<br>gen目录：系统自动生成的源代码目录<br>这个R.java文件时系统自动生成的文件，非常的重要。这个R.java默认有attr,drawable,layout,string 4个静态内部类，每个类对应一种资源。例如我们在工程中添加一副图片，那么工程就会在此类的drawable内部类中添加一条数据，如果删除了此图片，工程则会自动删除此条数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/41.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我的视频" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="我的视频" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Android工程师初级知识点</title>
    <link href="https://huangguangda.github.io/2018/05/03/1/"/>
    <id>https://huangguangda.github.io/2018/05/03/1/</id>
    <published>2018-05-03T04:33:40.000Z</published>
    <updated>2018-05-29T06:29:28.380Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/40.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><h2 id="提示框，菜单，数据存储，组件篇"><a href="#提示框，菜单，数据存储，组件篇" class="headerlink" title="提示框，菜单，数据存储，组件篇"></a>提示框，菜单，数据存储，组件篇</h2><h2 id="Toast"><a href="#Toast" class="headerlink" title="Toast"></a>Toast</h2><blockquote><p>Toast.makeText(context, text, 时间).show();</p></blockquote><p>setDuration();//设置时间<br>setGravity();//位置</p><p>获取：</p><p>添加toast.getView();<br>imageView添加到toast中，addView();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater inflater = LayoutInflater.from(this);</span><br><span class="line">View toast_view=inflater.inflate(R.id.,null);</span><br><span class="line">Toast.</span><br><span class="line">Toast.setView(toast_view);</span><br></pre></td></tr></table></figure><h2 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h2><p>AlertDialog.Builder </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTitle();</span><br><span class="line">setIcon();</span><br><span class="line">setView();</span><br><span class="line">setItems();</span><br><span class="line"></span><br><span class="line">setMultiChoiceItems(); 复选</span><br><span class="line">setSingleChoiceItems(); 单选</span><br><span class="line">setNeutralButton();</span><br><span class="line"></span><br><span class="line">setPositiveButton();</span><br><span class="line">setNegativeButton();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog dialog = builder.create(); .show();</span><br><span class="line"></span><br><span class="line">消失</span><br><span class="line">dialog.dismiss();</span><br></pre></td></tr></table></figure><p>Notification通知栏，如接收短信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">属性</span><br><span class="line">Notification </span><br><span class="line">setTicker();//手机状态栏的提示</span><br><span class="line">setWhen();//设置时间</span><br><span class="line">setContentTitle();</span><br><span class="line">setContentText();</span><br><span class="line">setContentIntent();</span><br><span class="line"></span><br><span class="line">Notification notification = builder.build();</span><br></pre></td></tr></table></figure><h2 id="OptionsMenu"><a href="#OptionsMenu" class="headerlink" title="OptionsMenu"></a>OptionsMenu</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onCreateOptionsMenu();</span><br><span class="line">动态：menu.add();</span><br><span class="line">监听：onOptionsItemSelected();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean onCreateOptionsMenu(Menu menu)&#123;</span><br><span class="line">getMenuInflater().inflate(R.menu.main,menu);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听：onOptionsItemSelected<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean onOptionsItemSelected(MenuItem item)&#123;</span><br><span class="line">switch(item.getItemId())&#123;</span><br><span class="line">case R.id..:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ContextMenu上下文菜单"><a href="#ContextMenu上下文菜单" class="headerlink" title="ContextMenu上下文菜单"></a>ContextMenu上下文菜单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean onCreateItemSelected(MenuItem item)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)&#123;</span><br><span class="line">super.onCreateContextMenu(menu, v, menuIfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SubMenu-子菜单"><a href="#SubMenu-子菜单" class="headerlink" title="SubMenu 子菜单"></a>SubMenu 子菜单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState)&#123;</span><br><span class="line">super.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean onCreateOptionsMenu(Menu menu)&#123;</span><br><span class="line">getMenuInflater().inflate(R.menu.main, menu);</span><br><span class="line">return true;</span><br><span class="line">//return super.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;menu ...&gt;</span><br><span class="line"> &lt;item</span><br><span class="line">  android:showAsAction=&quot;never&quot;</span><br><span class="line">  android:title=&quot;文件&quot;&gt;</span><br><span class="line">  &lt;menu&gt;</span><br><span class="line">   &lt;item</span><br><span class="line">    android:id=&quot;@+id/..&quot;</span><br><span class="line">    android:showAsAction=&quot;never&quot;</span><br><span class="line">    android:title=&quot;打开&quot;/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MenuInflater inflater = getMenuInflater();</span><br><span class="line">inflater.inflate(R.menu.main, menu);</span><br></pre></td></tr></table></figure><h2 id="数据存储方式"><a href="#数据存储方式" class="headerlink" title="数据存储方式"></a>数据存储方式</h2><p>四种：</p><ol><li>SharedPreferences</li><li>SQLite</li><li>Content Provider</li><li>File </li></ol><p>SharedPreferences是一种比较轻型的数据存储，基于xml的键值对存储，存储一些简单的信息。</p><p>SharedPreferences只能获取数据不能存储和修改，但能通过Editor实现存储修改。</p><p>步骤：</p><ol><li>获取SharedPreferences对象</li><li>SharedPreferences.Editor </li><li>Editor的putXXX的方法</li><li>Editor.commit() </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(MainActivity.this);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPreferences = getSharedPreferences(&quot;sharedPreferences&quot;, MODE_PRIVATE);</span><br><span class="line">Editor editor = sharedPreferences.edit();</span><br><span class="line">editor.putXXX();</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><p>用户名和密码的存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sharedPreferences = getSharedPreferences(&quot;UserInfo&quot;, MODE_PRIVATE);</span><br><span class="line">Editor editor = sharedPreferences.editor();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">登录</span><br><span class="line">String name = etName.getText().toString().trim();</span><br><span class="line">String pass = etPass.getText().toString().trim();</span><br></pre></td></tr></table></figure><p>SQLite的形式，以单个文件的存储，存储2T内存，以B-Tree形式。</p><p>SQLite的数据类型，null,integer,real,text,blob。</p><ol><li>SQLiteDatabase</li><li>SQLiteOpenHelper</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = openOrCreateDatabase(&quot;table.db&quot;, MODE_PRIVATE, null);</span><br></pre></td></tr></table></figure><p>SQLiteOpenHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DBOpenHelper helper = new DBOpenHelper(MainActivity.this, &quot;user.db&quot;);</span><br><span class="line">SQLiteDatabase db = helper.getWritableDatabase();</span><br><span class="line">Cursor c = db.rawQuery(&quot;select * from user&quot;, null);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public DBOpenHelper(Context context, String name, CursorFactory factory, int version)&#123;</span><br><span class="line">super(context, name, factory, version);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onCreate(SQLiteDatabase db)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = this.getFilesDir();</span><br><span class="line">File file = this.getCacheDir();//重要文件就不要放在这里</span><br></pre></td></tr></table></figure><p>MODE_PRIVATE</p><p>默认操作</p><p>MODE_APPEND</p><p>文件是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void WriteFiles(String content)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">FileOutputStream fileOutputStream = openFileOutput(&quot;super.txt&quot;, MODE_PRIVATE);</span><br><span class="line">fileOutputStream.write(content.getBytes());</span><br><span class="line">fileOutputStream.close();</span><br><span class="line">&#125;catch()&#123;</span><br><span class="line"></span><br><span class="line">&#125;catch()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContentProvider</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line"> android:name=&quot;&quot;</span><br><span class="line"> android:authorities=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyContentProvider extends ContentProvider&#123;</span><br><span class="line">public int delete(Uri uri,String selection, String[] selectionArgs)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Uri 通用资源标志符</p><p>Broadcast广播</p><p>BroadcastReceiver 广播接收器</p><p>使用：需要Intent对象，sendBroadcast(),sendOrderBroadcast(),sendStickyBroadcast()。</p><p>Service</p><p>注册：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void onClick(View v)&#123;</span><br><span class="line">switch(v.getId())&#123;</span><br><span class="line">case R.id.:</span><br><span class="line">Intent intent = new Intent(MainActivity.this, MyService.class);</span><br><span class="line">startService(intent);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Service&#123;</span><br><span class="line">public void onCreate()&#123;</span><br><span class="line">super.onCreate();</span><br><span class="line">&#125;</span><br><span class="line">public int onStartCommand(Intent intent,int flags,int startId)&#123;</span><br><span class="line">return super.onStartCommand(intent,flags,startId);</span><br><span class="line">&#125;</span><br><span class="line">public void onDestroy()&#123;</span><br><span class="line">super.onDestroy();</span><br><span class="line">&#125;</span><br><span class="line">public IBinder onBind(Intent intent)&#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void onCreate()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public IBinder onBind(Intent intent)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void unbindService(ServiceConnection conn)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ServiceConnection conn = new ServiceConnection()&#123;</span><br><span class="line">public void onServiceDisconnected(ComponentName name)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public void onServiceConnected(ComponentName name, IBinder binder)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>系统服务</p><p>MountService,ClipboardService,getSystemService().</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object getSystemService(String name)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POWER_SERVICE,PowerManger电源服务<br>ALARM_SERVICE,AlarmManager闹钟服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater inflater = MainActivity.this.getSystemService(LAYOUT_INFLATER_SERVICE);</span><br><span class="line">View view = inflater.inflate(R.layout. , null);</span><br><span class="line">setContentView(view);</span><br></pre></td></tr></table></figure><p>getSystemService</p><p>GestureDetector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MotionEvent,GestureDetector,onGestureListener.</span><br></pre></td></tr></table></figure><p>GestureOverlayView</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Android:eventsInterceptionEnabled</span><br><span class="line">Android:fadeDuration</span><br><span class="line">Android:fadeEnabled</span><br><span class="line">Android:gestureColor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.gesture.GestureOverlayView </span><br><span class="line"> android:id=&quot;&quot;</span><br><span class="line"> android:layout_width=&quot;&quot;</span><br><span class="line"> android:layout_height=&quot;&quot;&gt;</span><br><span class="line"> &lt;ImageView</span><br><span class="line">  android:id=&quot;&quot;</span><br><span class="line">  android:layout_width=&quot;&quot;</span><br><span class="line">  android:layout_height=&quot;&quot;</span><br><span class="line">&lt;/android.gesture.GestureOverlayView&gt;</span><br></pre></td></tr></table></figure><p>完结！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/40.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android开发工程师文集" scheme="https://huangguangda.github.io/categories/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E9%9B%86/"/>
    
    
      <category term="Android开发工程师文集" scheme="https://huangguangda.github.io/tags/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA语言-985大学</title>
    <link href="https://huangguangda.github.io/2018/05/02/1/"/>
    <id>https://huangguangda.github.io/2018/05/02/1/</id>
    <published>2018-05-02T15:32:04.000Z</published>
    <updated>2018-06-06T18:25:55.079Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/39.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>记录收藏，记录要点，来源各个大佬，部分内容也来源网络</p><h2 id="Java学习课程——基础篇"><a href="#Java学习课程——基础篇" class="headerlink" title="Java学习课程——基础篇"></a>Java学习课程——基础篇</h2><h2 id="第一篇-Java-入门导论"><a href="#第一篇-Java-入门导论" class="headerlink" title="第一篇  Java 入门导论"></a>第一篇  Java 入门导论</h2><ul><li>对Java的历史、Java平台、Java语言建立基本概念。并实际地导览读者到网络上去看Java所构筑的网络新世界。然后再开始学习几个简易的入门程序，开始建立Java程序的概念与印象。 </li></ul><h2 id="本篇包括："><a href="#本篇包括：" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第1章  Java 概说<br>第2章  Java的世界<br>第3章  先来一杯Java 吧 </p><h2 id="第二篇-面向对象程序设计（一）"><a href="#第二篇-面向对象程序设计（一）" class="headerlink" title="第二篇  面向对象程序设计（一）"></a>第二篇  面向对象程序设计（一）</h2><ul><li>在开始学习Java语言时，先针对其面向对象的特性，诸如对象、类、封装、继承等概念加以说明。避开语言上的枝节探讨，先将Java面向对象的概念点出，以免使读者落入程序语言的丛林里。然后再介绍Java 1.3API对象结构化的类库，认识其所提供包、类的功能概述。  </li></ul><h2 id="本篇包括：-1"><a href="#本篇包括：-1" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第4章  面向对象程序设计基本概念<br>第5章  Java 1.3 API 简介 </p><h2 id="第三篇-Java语言基础"><a href="#第三篇-Java语言基础" class="headerlink" title="第三篇  Java语言基础"></a>第三篇  Java语言基础</h2><ul><li>Java语言是由C/C++所演变，去芜存菁并重新设计的语言。采用Unicode编码，并有其特有的标识符与关键字。而数据的类型，也是有原生类型与参考类型之别。本篇各章主要根据Java Language Specification (Second Edition)，＜此规格书可由 <a href="http://www.java.sun.com" target="_blank" rel="noopener">www.java.sun.com</a> 自由下载 ＞，挑选最主要的三部分来作编写架构。 </li></ul><h2 id="本篇包括：-2"><a href="#本篇包括：-2" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第6章  语汇结构<br>第7章  类型、数值、变量<br>第8章  控制结构 </p><h2 id="第四篇-面向对象程序设计（二）"><a href="#第四篇-面向对象程序设计（二）" class="headerlink" title="第四篇  面向对象程序设计（二）"></a>第四篇  面向对象程序设计（二）</h2><ul><li>有了第二与第三篇的基础后，再来以实际的程序范例来看Java的面向对象，就会对Java的面向对象精神有清楚的认识。</li></ul><h2 id="本篇包括：-3"><a href="#本篇包括：-3" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第9章    类、接口、包<br>第10章  方法与异常处理 </p><h2 id="第五篇-Java图形用户界面程序"><a href="#第五篇-Java图形用户界面程序" class="headerlink" title="第五篇  Java图形用户界面程序"></a>第五篇  Java图形用户界面程序</h2><ul><li>图形用户界面的程序是现代程序设计的一大重点。而Java API所提供的图形界面包AWT及SWING，也是图形界面的一大进步，因为它们成功打破了各家操作系统图形界面的屏障，使程序设计师不必疲于修改要适用于各家平台的程序。而SWING更踏在AWT的肩膀上，进一步提供更强大、多元、弹性的功能。  </li></ul><h2 id="本篇包括：-4"><a href="#本篇包括：-4" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第11章  Java GUI概论<br>第12章  Java版面配置<br>第13章  事件处理<br>第14章  Applet与JApplet<br>第15章  Swing初级</p><h2 id="学习建议："><a href="#学习建议：" class="headerlink" title="学习建议："></a>学习建议：</h2><blockquote><p>对较无程序设计基础的初学者 </p></blockquote><p>可依照本书安排次序循序渐进学习。尤其对没碰过C或 C++的人，更需要摸清每章的各部分。若本书不够清楚，请再参考别的书籍作比照，这样才能打好基础。</p><blockquote><p>对有C/C++程序设计经验者 </p></blockquote><p>若您有C/C++的语法基础，可先略过第三篇Java语言基础部分。但可能您还不清楚Java的设计理念及其面向对象程序设计原理，所以还是建议您从第一篇开始（除了第三篇外）按部就班地学习。待有Java语言基础部分不懂之处，再去查看即可。</p><h2 id="第一篇-Java入门导论"><a href="#第一篇-Java入门导论" class="headerlink" title="第一篇  Java入门导论"></a>第一篇  Java入门导论</h2><p>第1章  Java 概说<br>第2章  Java的世界<br>第3章  先来一杯Java吧 </p><h2 id="第1章-Java-概说"><a href="#第1章-Java-概说" class="headerlink" title="第1章  Java 概说"></a>第1章  Java 概说</h2><blockquote><p>Java的发展历史 </p></blockquote><p>Java的发展历史，要从1990年开始追溯起。<br>当时Sun Microsystem公司为了发展消费性电子产品而进行了一个名为Green的项目计划。<br>这个计划的负责人是James Gosling。<br>起初他以C++来写一种内嵌式软件，可以放在烤面包机或PAD等小型电子消费设备里，使得机器更聪明，更具有人工智能。<br>但后来他发现C++并不适合这类的任务！因为C++常会有使系统失效的程序错误，尤其是内存管理，C++是采用直接参考（direct reference）的方式，需要程序设计师记录并管理内存资源。<br>这造成设计师们极大的负担，并可能产生许多bugs。<br>若是一台烤面包机上的程序有错误，可能会使烤面包机烧坏了，甚至更严重会有爆炸产生！ </p><p>所以为了解决所遇到的问题，Gosling最后决定要发展一种新的语言，来解决C++的潜在性危险问题，这个语言名叫Oak。<br>它保留了大部分与C++相似的语法，但却把些较具危险性的功能加以改进，像内存资源管理，便由语言本身来管理，以减少程序设计师的负担及错误的产生。<br>Oak是一种可移植性（portable）语言，也就是一种平台独立（platform-independent）的语言，能够在各种芯片上运行。<br>这样子各家厂商就可降低研发成本，直接把应用程序应用在自家的产品上。 </p><h2 id="Java与Internet"><a href="#Java与Internet" class="headerlink" title="Java与Internet"></a>Java与Internet</h2><p>时间到了1994年，Oak的技术已日趋成熟，这时刚好网络也正开始蓬勃发展。<br>而Oak研发小组发现Oak很适合作为一种网络程序语言。<br>因此发展了一个能与Oak相配合的浏览器——WebRunner，后更名为HotJava，它证明了Oak是一种能在网络上发展的程序语言。<br>后来，因为Oak这个商标已被注册走了，工程师们便想到以手中常享用的咖啡(Java)来重新命名，并于Sun World 95中被发表出来。<br>从此以后，Java就随着网络的快速发展，而成了一个程序语言的明日之星。</p><h2 id="Java平台"><a href="#Java平台" class="headerlink" title="Java平台"></a>Java平台</h2><p>“网络即计算机”，是Sun企业的格言。<br>所以在设计上，Java即是以网络为运作范畴，并且是架设在各种硬件环境上的一种纯软件平台(platform)。<br>它与一般与硬件有关的各式操作系统（Operating System，如Windows，MacOS）或称操作平台不同。<br>一般所谓的平台是指撰写程序时所依赖的API(Application Program Interface)，通常都预先定义在计算机中的操作系统上。<br>因此在Java之前，程序设计师就只能借助所在环境的API写单一操作系统的程序。<br>若要改成另一操作系统版本的程序，就需要花许多的转换功夫，或者根本不可能。<br>但Java平台，虽然不算是一种操作系统（不过现在已有JavaOS的出现），却提供了甚至比现今各操作系统更深、更广的API。<br>Java平台包括Java虚拟机器（Java Virtual Machine,JVM）以及Java API。</p><h2 id="Java平台的版本"><a href="#Java平台的版本" class="headerlink" title="Java平台的版本"></a>Java平台的版本</h2><p>目前Java平台有3种的版本，以因应各种需求：  </p><ul><li>JAVATM 2 PLATFORM,STANDARD EDITION（标准版）</li><li>JAVATM 2 PLATFORM,ENTERPRISE EDITION（企业版） </li><li>JavaTM 2 Platform, Micro Edition (J2METM) （小型家电版）  </li></ul><p>借助这些平台版本，使得Java程序能在各式大小型机器及操作系统上运行，达成所谓程序可移植性、跨平台的目标。<br>因着Java平台的这些特性，使微软倍感威胁。<br>微软现今所展的.Net，便是视Java平台为强力竞争对手之一。 </p><h2 id="Java平台运作原理"><a href="#Java平台运作原理" class="headerlink" title="Java平台运作原理"></a>Java平台运作原理</h2><p>Java平台是一种新的计算机计算运作方式，植基于网络的能力与程序能“撰写一次，到处运行”（write once,run anywhere）的技术。<br>借着Java技术，人们可以使用多种的上网工具来达到互相沟通的目的。<br>像现今流行的新一代手机、PDA、可视电话，智能卡（smart cart）等先进设备等，也都能彼此沟通。<br>而非仅限于台式计算机或笔记本电脑而已。<br>当然能达到这些目的，主要就是通过前面所说的Java API、Java VM 与Java语言等技术的配合。</p><h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h2><p>Java语言，是一个新一代的高级（high-level）、通用目的（general-purpose）、面向对象（objec-oriented）的程序语言。</p><p>其语法与C或C++类似，但在组织结构上却相当的不同。</p><p>它是一个完全面向对象的程序语言，程序的基本处理单位：类（class）及API的组织，均以对象的观点来处理及架构起来的。</p><p>不仅如此，它在被设计的时候也倾向于是一种具生产力的语言（production language）,而非只是研究性语言（research language）。</p><p>所以当我们学习运用Java语言的时候，便能很快地感受到它的便利与强大功能。</p><h2 id="Java语言的特性"><a href="#Java语言的特性" class="headerlink" title="Java语言的特性"></a>Java语言的特性</h2><p>面向对象程序语言<br>简单（simple）<br>强固（robust）<br>安全（security）<br>平台独立（platform-independent） </p><p>多任务线程（multithreading）<br>动态（dynamic）<br>分布式计算(distributed computing)<br>运行效率（performance）<br>内存管理与资源回收(garbage collection) </p><h2 id="Java-与C-C-的差异"><a href="#Java-与C-C-的差异" class="headerlink" title="Java 与C/C++的差异"></a>Java 与C/C++的差异</h2><p>C/C++<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream.h&gt;</span><br><span class="line">public :</span><br><span class="line">unsigned int aData=10;</span><br><span class="line">class PrintOut&#123;</span><br><span class="line">void printData()&#123;</span><br><span class="line">cout&lt;&lt;”Data:”+aData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">PrintOut po;</span><br><span class="line">po.printData();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public int aData=10;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">Test test=new Test();</span><br><span class="line">test.printData();</span><br><span class="line">&#125;</span><br><span class="line">void printData()&#123;</span><br><span class="line">System.out.println(&quot;Data:&quot;+this.aData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java-与C-C-的差异-1"><a href="#Java-与C-C-的差异-1" class="headerlink" title="Java 与C/C++的差异"></a>Java 与C/C++的差异</h2><p>舍去功能<br>新增功能<br>取代改进功能 </p><h2 id="Java-程序的种类"><a href="#Java-程序的种类" class="headerlink" title="Java 程序的种类"></a>Java 程序的种类</h2><p>Java是一种网络程序语言，它能写出包含前端(Applet)、本地（Application）及后端（Servlets）的程序。虽然这三者的结构不同，但基本的语法都一样，所以能彼此沟通，构造出一个所谓的平台。</p><p>现在又加上了JSP(Java Server Pages)作为服务器端的加强，使得开发网络程序更快速。Java平台也更完整。</p><h2 id="Applet"><a href="#Applet" class="headerlink" title="Applet"></a>Applet</h2><p>Applet是一种可嵌入于Web文件中的一种小型程序。</p><p>通常其程序因网络传输速度关系都很短小。</p><p>但在应用上却常常比Application有用，一般都是通过浏览器来观看Applet。<br>(数据来源：<a href="http://www.thejmaker.com" target="_blank" rel="noopener">www.thejmaker.com</a>) </p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>Application（应用程序）是在命令列环境运行的程序。</p><p>程序中由main()方法作为程序起点，运行顺序由程序本身来控制。但Applet却是由浏览器来控管。选择用Applet还是Application来写作，要视所欲表达内容及传输机制而定。</p><p>通常Applet较需图形用户界面（GUI,Graphical User Interface），而Application较不需要。但因GUI的便利，许多Application也都用GUI来增进用户的便利，右图便是一个连接数据库的应用程序。(数据来源：<a href="http://www.svcon.com" target="_blank" rel="noopener">www.svcon.com</a>) </p><h2 id="Servlets"><a href="#Servlets" class="headerlink" title="Servlets"></a>Servlets</h2><p>Servlets是应用在服务器端的应用程序，可提供各种服务器服务。例如数据查询或动态产生聊天室，月历等，右图是由一个网站流量统计的Servelets所产生的画面。<br>(数据来源：<a href="http://www.mycgiserver.com" target="_blank" rel="noopener">http://www.mycgiserver.com</a>) </p><h2 id="第一讲-JAVA语言概述"><a href="#第一讲-JAVA语言概述" class="headerlink" title="第一讲 JAVA语言概述"></a>第一讲 JAVA语言概述</h2><h2 id="本讲要点"><a href="#本讲要点" class="headerlink" title="本讲要点"></a>本讲要点</h2><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><p>什么是Java？<br>我们的学习目标<br>学习方法指导<br>学习资料推荐</p><h2 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h2><p>Java语言的特点<br>Java语言程序分类<br>Java程序开发过程<br>Java虚拟机</p><h2 id="什么是Java-？"><a href="#什么是Java-？" class="headerlink" title="什么是Java ？"></a>什么是Java ？</h2><p>一种编程语言</p><ul><li>面向对象的程序设计语言，提供了编译、运行、调试工具。</li><li>1991年Sun公司的 “绿色项目” Oak语言产生(Java) 项目失败，但Java活了下来(1995年发布第一个版本JDK1.0)。</li></ul><p>一种软件平台</p><ul><li>平台是程序运行的硬件或软件环境，Java平台与大多数其它平台不同，是基于其它软件或硬件的纯软件平台。</li><li>JVM：Java虚拟机，是Java平台的基础</li><li>Java API：Java应用程序接口，Java API是软件组件的集合，它们提供了很多有用的功能，如图形用户界面（GUI）。</li></ul><p>随着应用范围越来越广，Java演化出三个不同领域的应用平台</p><ul><li>J2SE：Java2 Platform， Standard Edition：标准版，桌面系统和低端服务</li><li>J2EE：Java2 Platform， Enterprise Edition：企业版，企业级应用</li><li>J2ME：Java2 Platform ，Micro Edition：小型版，嵌入式应用开发<br>与.net简单比较</li></ul><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><h2 id="最终目标：Java软件工程师"><a href="#最终目标：Java软件工程师" class="headerlink" title="最终目标：Java软件工程师"></a>最终目标：Java软件工程师</h2><p>Java语法、J2se平台基础、面向对象编程思想和方法（Java基础）<br>Java Web开发（简单应用）<br>J2ee企业开发（企业级应用）、J2me（嵌入式应用）<br>辅助技术：Struts设计模式、JavaScript、XML、SQL语言<br>开发工具：JDK、JCreater、Eclipes、JBuilder</p><h2 id="近期目标"><a href="#近期目标" class="headerlink" title="近期目标"></a>近期目标</h2><p>在校期间，掌握Java Web应用</p><h2 id="本学期目标"><a href="#本学期目标" class="headerlink" title="本学期目标"></a>本学期目标</h2><p>本学期， Java语法、J2se平台基础、面向对象编程思想和方法，培养自学能力。</p><h2 id="学习方法指导"><a href="#学习方法指导" class="headerlink" title="学习方法指导"></a>学习方法指导</h2><h2 id="奠定Java语法基础"><a href="#奠定Java语法基础" class="headerlink" title="奠定Java语法基础"></a>奠定Java语法基础</h2><p>学习Java的第一步是用Java语言来编写程序，学习Java语言的第一步，就是熟悉其语法的使用。</p><h2 id="注意思考和总结"><a href="#注意思考和总结" class="headerlink" title="注意思考和总结"></a>注意思考和总结</h2><p>在学习的过程中，最好能够了解Java的底层机制，而不是仅仅停留在表层，不是抄书上的例子运行出结果就可以。即便对一个简单的例子也要有耐心去琢磨、调试、改动。 </p><h2 id="动手写代码"><a href="#动手写代码" class="headerlink" title="动手写代码"></a>动手写代码</h2><p>在学习的过程中一定要动手做、写代码，而不是抱一本书看看就行。很多东西和体会必须自己动手才能真正属于自己。 </p><p>在学到一定阶段后，试用学过的东西做些什么。</p><h2 id="培养自学能力"><a href="#培养自学能力" class="headerlink" title="培养自学能力"></a>培养自学能力</h2><p>Java API文档</p><ul><li>英文地址：<a href="http://java.sun.com/j2se/1.5.0/docs/api/" target="_blank" rel="noopener">http://java.sun.com/j2se/1.5.0/docs/api/</a></li><li>中文：网上搜索下载</li></ul><p>充分利用网络学习资源</p><ul><li>使用搜索引擎</li><li>加入论坛参与讨论</li></ul><h2 id="学习资料推荐"><a href="#学习资料推荐" class="headerlink" title="学习资料推荐"></a>学习资料推荐</h2><h2 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h2><p>（1）《Java学习笔记》，良葛格著， 清华大学出版社，2006.8。</p><p>（2）《Java编程基础、应用与实例》，［韩］徐明浩 著 武传海译，人民邮电出版社，2005.10。</p><p>（3）《Java编程思想》第3版 ，（美）埃克尔（Eckel,B.） 著 陈昊鹏 等译, 机械工业出版社，2005.5。</p><p>（4）《Java就业培训教程》, 张孝祥 编著， 清华大学出版社,2003.9。</p><h2 id="网络学习资源"><a href="#网络学习资源" class="headerlink" title="网络学习资源"></a>网络学习资源</h2><p>（1）Java中国开发网–<a href="http://bbs.cjsdn.net/" target="_blank" rel="noopener">http://bbs.cjsdn.net/</a><br>（2）中文JAVA技术网–<a href="http://www.cn-java.com/" target="_blank" rel="noopener">http://www.cn-java.com/</a><br>（3）天新网 - 软件开发 - Java开发–<a href="http://dev.21tx.com/java/" target="_blank" rel="noopener">http://dev.21tx.com/java/</a><br>（4）视频教程《Java无难事视频教程》孙鑫<a href="http://www.enet.com.cn/eschool/zhuanti/java/" target="_blank" rel="noopener">http://www.enet.com.cn/eschool/zhuanti/java/</a><br>（5）ChinaJavaWorld.com技术论坛<a href="http://bbs.chinajavaworld.com/index.jspa" target="_blank" rel="noopener">http://bbs.chinajavaworld.com/index.jspa</a><br>（6）赛迪网技术社区 <a href="http://bbs.java.ccidnet.com/index.php" target="_blank" rel="noopener">http://bbs.java.ccidnet.com/index.php</a><br>（7）SUN中国技术社区 <a href="http://gceclub.sun.com.cn/" target="_blank" rel="noopener">http://gceclub.sun.com.cn/</a></p><h2 id="JAVA语言的特点"><a href="#JAVA语言的特点" class="headerlink" title="JAVA语言的特点"></a>JAVA语言的特点</h2><h2 id="简单、面向对象、与平台无关……"><a href="#简单、面向对象、与平台无关……" class="headerlink" title="简单、面向对象、与平台无关……"></a>简单、面向对象、与平台无关……</h2><ul><li><p>简单<br>风格类似于C++，易上手；<br>抛弃了C++中容易引发程序错误的一些特性，如指针、结构、枚举以及内存管理等；<br>Java提供了丰富的类库，可以帮助我们很方便的开发Java程序。</p></li><li><p>面向对象<br>面向对象可以说是Java最重要的特性，所以它支持继承、重载、多态等面向对象的特性。Java语言的设计是完全面向对象的，它不支持类似C语言那样的面向过程的程序设计技术。</p></li><li><p>分布式程序设计语言<br>面向网络的语言，编写网络应用程序</p></li><li><p>与平台无关、可移植性<br>“一次写入，到处运行”</p></li><li><p>健壮、安全、高性能、多线程、动态性等等</p></li></ul><h2 id="Java与C及C-的比较"><a href="#Java与C及C-的比较" class="headerlink" title="Java与C及C++的比较"></a>Java与C及C++的比较</h2><p>边学边比</p><h2 id="Java语言程序分类"><a href="#Java语言程序分类" class="headerlink" title="Java语言程序分类"></a>Java语言程序分类</h2><p>应用程序(Applicatiion)<br>可通过JVM独立运行的程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Hello</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println (&quot;hello world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小程序(Applet)<br>必须嵌入到网页，由支持JVM的浏览器解释运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.*;</span><br><span class="line">import java.applet.*;</span><br><span class="line">public class AppletHello extends Applet</span><br><span class="line">&#123;</span><br><span class="line">public void paint(Graphics g)</span><br><span class="line">&#123;</span><br><span class="line">g.drawString(&quot;hello,world!&quot;,20,20);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java程序开发过程"><a href="#Java程序开发过程" class="headerlink" title="Java程序开发过程"></a>Java程序开发过程</h2><h2 id="开发程序前，进行开发环境配置"><a href="#开发程序前，进行开发环境配置" class="headerlink" title="开发程序前，进行开发环境配置"></a>开发程序前，进行开发环境配置</h2><ul><li>安装JDK</li><li>选择安装开发工具<br>JDK＋记事本等文本编辑工具，可以直接使用JDK环境<br>JCreater、JBuilder、EClipes等集成开发环境</li></ul><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><p>编写程序源文件</p><ul><li>源文件类型名为.java</li></ul><p>编译生成字节码文件</p><ul><li>生成的字节码文件类型名为.class</li></ul><p>运行</p><ul><li>应用程序运行：通过Java虚拟机独立运行程序</li><li>小应用程序运行：嵌入浏览器中运行</li></ul><h2 id="下载安装JDK5-0-可以下载最新版"><a href="#下载安装JDK5-0-可以下载最新版" class="headerlink" title="下载安装JDK5.0(可以下载最新版)"></a>下载安装JDK5.0(可以下载最新版)</h2><p>JDK5.0 (J2SDK1.5)</p><ul><li>从SUN公司网站下载(jdk-1_5_0_11-windows-i586-p.exe)<br><a href="http://java.sun.com/javase/downloads/index_jdk5.jsp" target="_blank" rel="noopener">http://java.sun.com/javase/downloads/index_jdk5.jsp</a></li><li>安装:根据提示安装</li></ul><p>JDK安装目录结构简介</p><ul><li>bin<br>javac: Java编译器，用来将java程序编译成字节码文件.class。<br>java:   Java解释器，执行已经转换成字节码的java应用程序。<br>appletviewer : Java虚拟浏览器， 用来解释嵌到网页中的java小应用程序。</li><li>lib:Java类库</li><li>Jre\lib：Java核心类库</li></ul><h2 id="JDK环境下程序编译与运行"><a href="#JDK环境下程序编译与运行" class="headerlink" title="JDK环境下程序编译与运行"></a>JDK环境下程序编译与运行</h2><h2 id="编写Java应用程序源文件"><a href="#编写Java应用程序源文件" class="headerlink" title="编写Java应用程序源文件"></a>编写Java应用程序源文件</h2><p>在D盘创建工作目录exam1(不是必须的)<br>在工作目录下，使用记事体程序编写文件名为HelloWorld.java<br>输入程序代码</p><h2 id="准备编译和运行程序（环境配置）"><a href="#准备编译和运行程序（环境配置）" class="headerlink" title="准备编译和运行程序（环境配置）"></a>准备编译和运行程序（环境配置）</h2><p>开始运行(cmd)，打开命令窗口<br>输入set path=”c:\program files\java\jdk1.5.0_11\bin”并回车，设置Java命令的搜索路径<br>输入d:并回车，将当前盘转至D盘<br>输入cd exam1并回车，当前目录转至我们的工作目录</p><h2 id="编译成字节码文件"><a href="#编译成字节码文件" class="headerlink" title="编译成字节码文件"></a>编译成字节码文件</h2><p>输入javac HelloWorld.java并回车，将源文件编译成字节码文件</p><h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><p>输入java HelloWorld并回车，执行程序</p><h2 id="Applet程序的运行"><a href="#Applet程序的运行" class="headerlink" title="Applet程序的运行"></a>Applet程序的运行</h2><p>编写源程序AppletHello.java<br>内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.*;</span><br><span class="line">import java.applet.*;</span><br><span class="line">public class AppletHello extends Applet</span><br><span class="line">&#123;</span><br><span class="line">public void paint(Graphics g)</span><br><span class="line">&#123;</span><br><span class="line">g.drawString(&quot;hello,world!&quot;,20,20);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译为字节码文件AppletHello.class<br>运行<br>编写网页文件hello.html，其内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;applet code=&quot;AppletHello&quot; height=&quot;50&quot; width=&quot;200&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/applet&gt;</span><br></pre></td></tr></table></figure><p>用IE直接打开hello.html或者执行appletviewer  hello.html</p><h2 id="使用集成开发环境开发Java程序"><a href="#使用集成开发环境开发Java程序" class="headerlink" title="使用集成开发环境开发Java程序"></a>使用集成开发环境开发Java程序</h2><h2 id="集成开发工具简介"><a href="#集成开发工具简介" class="headerlink" title="集成开发工具简介"></a>集成开发工具简介</h2><ul><li>UltraEdit、EditPlus：文本编辑器，适用于初学者，只能编辑，编译和运行需要借助java命令。</li><li>Jcreater：功能较为强大，可以编辑、编译、调试运行。初学者使用的工具。</li><li>JBuilder：功能强大的集成开发工具，一般用于商业开发中，不适用于初学者。</li><li>Eclipes：功能强大的集成开发工具，免费，也常用于商业开发，不适用于初学者。</li></ul><h2 id="使用Jcreater编写Java应用程序"><a href="#使用Jcreater编写Java应用程序" class="headerlink" title="使用Jcreater编写Java应用程序"></a>使用Jcreater编写Java应用程序</h2><p>编辑<br>编译<br>运行</p><h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><h2 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM(Java Virtual Machine)"></a>JVM(Java Virtual Machine)</h2><ul><li>是一种利用软件方法来实现硬件功能的虚拟计算机。</li><li>是Java跨平台的保证</li><li>JVM的实现－Java运行时系统<br>嵌入Java运行时系统的应用程序，可以执行Java字节码文件</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>课程介绍<br>什么是Java?<br>学习目标与学习方法<br>Java语言简介<br>特点<br>程序分类<br>程序开发过程</p><h2 id="技能训练一-Java入门"><a href="#技能训练一-Java入门" class="headerlink" title="技能训练一 Java入门"></a>技能训练一 Java入门</h2><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>通过本次训练，使学生了解Java编程环境，掌握Java程序开发过程。</p><h2 id="训练内容"><a href="#训练内容" class="headerlink" title="训练内容"></a>训练内容</h2><p>1、编写一个简单的Java应用程序（源文件Hello.java），该程序在命令行窗口输出两行文字：“我叫XXX，来自XX班”、“我的爱好是XXX”。<br>2、写出在实训过程中涉及到的知识点及难点,遇到的问题和解决的办法，有哪些收获。<br>3、实验后的练习<br>（1）编译器如何提示丢失大括号的错误？<br>（2）编译器如何提示将System写成system的错误？<br>（3）编译器如何提示丢失行尾分号的错误？<br>（4）编译器如何提示程序文件名与类名不同的错误？</p><h2 id="技能训练二-熟悉Java语言开发过程"><a href="#技能训练二-熟悉Java语言开发过程" class="headerlink" title="技能训练二 熟悉Java语言开发过程"></a>技能训练二 熟悉Java语言开发过程</h2><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><ul><li>使学生掌握Java开发环境的安装与配置，学会下载安装JDK开发工具包，掌握使用JDK环境开发Java程序的过程，掌握集成开发工具软件下载、安装和使用。</li></ul><h2 id="训练内容-1"><a href="#训练内容-1" class="headerlink" title="训练内容"></a>训练内容</h2><p>1、操作</p><ul><li>从Sun公司网站下载JDK5.0的标准版，并安装</li><li>使用记事本编写Java应用程序、Java小程序</li><li>使用javac命令编译，并检查生成的字节码文件</li><li>运行Java应用程序</li><li>编写小程序的嵌入网页文件，并运行</li></ul><p>2、总结实训过程中涉及到的知识点及难点,遇到的问题和解决的办法，有哪些收获</p><h2 id="JAVA-程序设计"><a href="#JAVA-程序设计" class="headerlink" title="JAVA  程序设计"></a>JAVA  程序设计</h2><p>课程的性质、任务</p><p>本课程是软件、网络技术专业的一门专业基础课程，是该专业理论与实践紧密结合的一门必修课，课程的任务是使学生掌握Java程序设计语言，理解面向对象的程序设计的思路和方法。</p><p>培养学生的编程能力。本课程的主要知识点群包括面向对象技术、异常处理、多线程、输入输出流、图形用户界面（GUI）设计、Applet开发、网络通信以及数据库使用等。</p><h2 id="第1讲-基本要求"><a href="#第1讲-基本要求" class="headerlink" title="第1讲    基本要求"></a>第1讲    基本要求</h2><p>了解Java的发展历史及基本特点<br>掌握Java虚拟机的概念<br>掌握Java2 SDK的开发环境的建立<br>掌握 Java Applet, Java Application的Java应用种类及运行操作</p><h2 id="实验一-JDK开发工具"><a href="#实验一-JDK开发工具" class="headerlink" title="实验一  JDK开发工具"></a>实验一  JDK开发工具</h2><ul><li>内容：从网上下载JDK工具、帮助文档并安装，编写一个小程序 </li><li>要求：掌握从网上下载JDK工具、帮助文档并安装、会使用 JDK运行程序 </li></ul><h2 id="第1章-Java语言概述"><a href="#第1章-Java语言概述" class="headerlink" title="第1章  Java语言概述"></a>第1章  Java语言概述</h2><p>1.1  Java的发展历史<br>1.2  Java的特点<br>1.3  Java程序的开发过程与运行环境<br>实训一  安装与熟悉Java开发工具<br>习题一 </p><h2 id="1-1-Java的发展历史"><a href="#1-1-Java的发展历史" class="headerlink" title="1.1  Java的发展历史"></a>1.1  Java的发展历史</h2><p>Java的产生</p><p>1995年5月，Sun公司在“SunWorld95”大会上推出了Java语言。Java语言作为一种网络编程语言，随着国际互联网的飞速发展，很快得到了广泛的支持和实际的应用。</p><p>了解内容：Java语言最初并不是为互联网设计的，它来自于Sun公司的一个叫“Green”的项目，目的是为家用消费电子产品开发一个分布式代码系统，这样用户可以把E-mail发给电冰箱、电视机等家用电器，对它们进行控制和信息交流。该项目小组开始准备采用C++，但他们很快意识到C++太复杂，安全性差，最后基于C++开发了一种新的语言Oak(Java的前身)。</p><p>Oak是一种用于网络的精巧而安全的语言，Sun公司曾以此投标一个交互式电视项目，但败于SGI，使得Oak几乎夭折。</p><p>Mark Ardreesen开发的Mosaic和Netscape启发了Oak项目组成员，他们用Java编制了HotJava浏览器，得到了Sun公司首席执行官Scott McNealy的支持，Java得以进军互联网。</p><p>目前通常所说的Java有三层含义：<br>首先是指一种编程语言；<br>其次是一种开发环境；<br>再者是一种应用环境。</p><h2 id="Java的现状"><a href="#Java的现状" class="headerlink" title="Java的现状"></a>Java的现状</h2><p>Java作为新一代面向对象的程序设计语言，特别适合于Internet应用程序开发，它的平台无关性使Java作为软件开发的一种革命性技术地位已被确立。</p><p>计算机产业的许多大公司购买了Java的许可证，包括IBM、Microsoft、Apple、Oracle等。</p><p>Java开发工具软件日渐丰富，如Borland公司的JBuilder、Sun公司的JavaWorkshop、IBM的VisualAge、微软公司的Visual J++。</p><p>数据库厂商如Sybase、Versant、Oracle都在开发CGI接口，支持HTML和Java。</p><h2 id="按照Java的应用领域"><a href="#按照Java的应用领域" class="headerlink" title="按照Java的应用领域"></a>按照Java的应用领域</h2><p>Sun公司将Java分为三个版本：</p><p>(1)  J2SE(Java 2 Platform，Standard Edition)。<br>J2SE含有基本的Java2 SDK工具和运行时API，开发者可以用来编写、部署和运行Java应用程序以及Applet(在Web浏览器(如IE)中运行的Java小程序)。</p><p>(2)  J2EE(Java 2 Platform，Enterprise Edition)。J2EE建立在J2SE的基础上，它是JSP(Java Server Page)、Servlet、EJB、JTS(Java Transaction Service)、Java mail以及JMS(Java Message Service)等多项技术的混合体，主要用于开发分布式、服务器端多层结构的应用系统，如电子商务网站。</p><p>(3)  J2ME(Java 2 Platform，Micro Edition)。它主要用于开发电子产品，如移动电话、数字机顶盒、汽车导航系统等。</p><h2 id="Java-的-特-点"><a href="#Java-的-特-点" class="headerlink" title="Java 的 特 点"></a>Java 的 特 点</h2><p> Java语言从诞生到得到很广泛的应用，只经过了短短的几年，这与它的特点是分不开的。</p><p> Java作者写了一个非常有影响的“白皮书”，来解释设计目标和已取得的成果。“白皮书”是按下列11个特征来定义的：</p><p>●  简单的；<br>●  面向对象的；<br>●  分布式的；<br>●  健壮的(Robust)；<br>●  安全的；<br>●  中立结构的；<br>●  可移植的；<br>●  解释型的；<br>●  高效的；<br>●  多线程的；<br>●  动态的。</p><h2 id="结构中立"><a href="#结构中立" class="headerlink" title="结构中立"></a>结构中立</h2><p>Java语言编译器产生的二进制代码是一种与具体机器指令无关的指令集合，只要有Java运行时系统存在，编译后的代码便可在许多处理器上运行。</p><p>Java运行时系统被称为Java虚拟机(Java Virtual Machine，JVM)，Java编译器产生的代码由Java虚拟机解释执行，如图1.1所示。由此，Java语言实现了平台独立性，“一次编写，随处运行(Write once，Run anywhere)”。</p><p>Java编译器产生的二进制代码称为字节码(Byte Code)，字节码与任何具体计算机结构都无关。实际上，这并不是一个新想法，多年前的UCSD Pascal系统就在一个商业产品中做了同样的努力，不过，Java解决了这种技术存在的一个主要缺点，即与通常高级语言采用的编译为机器指令相比，采用这种方式程序执行效率相差很多。</p><p>同体系结构无关的特性使得Java应用程序可以在配备了Java虚拟机的任何计算机系统上运行，这成为Java应用软件便于移植的良好基础。</p><p>另外，Java系统的基本数据类型不依赖于具体实现，在任何硬件平台上均保持一致。而通常的高级语言数据类型是与平台相关的，如C语言在Windows 3.1中整数(int)为16位，在Windows 95中整数为32位，在DECAlpha中整数为64位，在Intel486中整数为32位。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象可以说是Java最重要的特性，Java语言的设计完全是面向对象的，它不支持类似C语言那样的面向过程的程序设计技术。Java支持静态和动态风格的代码继承及重用。。</p><p>Java语言程序的基本单位是类class，一个完整的Java语言程序一般由多个类构成。</p><p>Java语言运行环境还提供了功能强大的类库(或称为应用程序接口API)，可以帮助应用程序很容易地实现一些复杂的功能。</p><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><p>Java语言的简单性主要体现在以下三个方面：<br>(1)  Java的风格类似于C++，因而C++程序员是非常熟悉的。从某种意义上讲，Java语言是C及C++语言的一个变种，因此，C++程序员可以很快掌握Java编程技术。<br>(2)  Java摒弃了C++中容易引发程序错误的地方，如指针、内存管理、运算符重载等。<br>(3)  Java提供了丰富的类库</p><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>Java包括一个支持HTTP和FTP等基于TCP/IP协议的类库。</p><p>因此，Java应用程序访问网络上的对象很容易，其访问方式与访问本地文件系统几乎完全相同。为分布环境尤其是Internet提供动态内容无疑是一项非常宏伟的任务，但Java的语法特性却使得程序员可以很容易地实现这项目标。</p><h2 id="健壮"><a href="#健壮" class="headerlink" title="健壮"></a>健壮</h2><p>Java致力于检查程序在编译和运行时的错误。</p><p>类型检查帮助检查出许多开发早期出现的错误。Java自已操纵内存，减少了内存出错的可能性。Java还实现了真数组，避免了覆盖数据的可能。这些功能特征大大缩短了开发Java应用程序的周期。Java提供null指针检测、数组边界检测、异常出口和字节代码校验。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>Java的安全性可从两个方面得到保证：<br>一方面，在Java语言里，指针和释放内存等C++功能被删除，避免了非法内存操作；<br>另一方面，当用Java来创建浏览器时，语言功能和浏览器本身提供的功能会结合起来，使它更安全。</p><blockquote><p>Java语言程序在机器上执行前，要经过多次测试。它经过代码校验，检查代码段的格式，检测指针操作、对象操作是否错误等。</p></blockquote><blockquote><p>如果字节码通过代码校验后，没有返回错误，则表示代码没有堆栈上溢出和下溢出，所有操作代码参数类型都是正确的，没有发生非法数据转换，如将整数转换成指针，访问对象操作是合法的。</p></blockquote><p>通过校验的代码由类装载器(ClassLoader)装载执行。类装载器通过将本机类与网络资源类的名称分开来保持安全性。因为装入类时要经过检查，所以避免了特洛伊木马现象的出现。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Java提供的多线程功能使得在一个程序里可同时执行多个小任务。多线程带来的更大的好处是更好的交互性能和实时控制性能。</p><p>Java是第一个支持多线程的程序设计语言，而传统的程序设计语言要实现多线程必须调用操作系统提供的有关编程接口。当然，Java虚拟机本身并不实现多线程机制，多线程的实现最终还取决于系统本身(UNIX、Windows等).</p><h2 id="Java程序的开发过程与运行环境"><a href="#Java程序的开发过程与运行环境" class="headerlink" title="Java程序的开发过程与运行环境"></a>Java程序的开发过程与运行环境</h2><h2 id="Java程序的开发过程"><a href="#Java程序的开发过程" class="headerlink" title="Java程序的开发过程"></a>Java程序的开发过程</h2><p>Java程序的开发过程与其他高级语言相似。</p><blockquote><p>首先编写程序，然后采用文本编辑软件输入源程序，再使用Java语言编译器进行编译，生成字节码文件。</p></blockquote><p>Java虚拟机直接执行字节码文件，没有连接生成独立的可执行文件的过程，Java类库代码也不像C/C++的函数库或类库那样需要连接到执行文件中去。</p><blockquote><p>Java语言最基本的开发环境是由Sun公司免费提供的JDK(Java Development Kit)，它的开发环境比较简单，使用命令行编译源代码，编译调试程序都不是很方便。</p></blockquote><blockquote><p>Java语言的集成开发工具，集源代码的编辑、编译以及调试于一体，而且这些开发工具可以帮助程序员生成应用程序框架，减少程序员的重复劳动，提高软件开发的效率。常见的集成开发工具有Microsoft公司的Visual J++、Borland公司的Jbuilder、IBM公司的VisualAge for Java等。</p></blockquote><h2 id="Application与Applet"><a href="#Application与Applet" class="headerlink" title="Application与Applet"></a>Application与Applet</h2><p>Java程序主要有Java应用程序(Java Application)和Applet两种。下面首先给出两个最简单的Java程序，从中可以了解Java语言程序的基本结构。</p><p>【程序1.1】  最简单的Java应用程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* HelloWorldApp.java */</span><br><span class="line"> </span><br><span class="line">class HelloWorldApp &#123;</span><br><span class="line">  /**</span><br><span class="line">  * 传统的 &quot;Hello World!&quot; 程序</span><br><span class="line">  **/</span><br><span class="line">  public static void main (String args[]) &#123;</span><br><span class="line">    // 输出到标准输出设备</span><br><span class="line">    System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序1.1是一个Java Application，它的功能很简单，向标准输出设备输出字符串“Hello World!”，运行该程序后可以在显示器上看到该字符串。</p><p>从程序1.1中首先看到的是注释语句，Java语言的注释语句与C/C++语言中的注释语句类似，有两种基本形式：</p><p>(1) 以/<em>开始，以</em>/结束。其中的所有字符在编译时被忽略。<br>(2) 行注释。以//开始到本行结束。</p><p>程序1.1定义了一个类HelloWorldApp，其中定义了一个方法main，方法类似于C语言的函数。</p><p>main方法是程序的入口点，Java应用程序从main方法开始执行，main方法执行结束则该程序退出运行。因此，如果一个程序由多个类构成，只能有一个类有main方法。</p><p>程序1.1使用了Java API完成字符串的输出功能，System.out为标准输出流对象，相当于C语言中的标准输出文件，println为其方法成员。println方法的功能为输出括号中的字符串或其他类型的数据并换行。类似的还有方法print，它与println的区别是输出数据后不换行。</p><p>与C语言中标准输入文件对应，Java语言中也有标准输入流System.in，不过它的功能与C语言标准输入文件相比较弱，Java语言只提供了从标准输入设备读入字符的方法，而没有提供读入其他类型数据的方法。如果希望直接从键盘输入一个整数或实数，必须用程序将从键盘输入的字符串转换为所需的类型。</p><p>Java Applet的执行环境与Java应用程序不同，Applet不是独立的应用程序，它是嵌入在HTML文件中使用的，程序被放置在Web服务器上，下载到客户端后，由Web浏览器(如微软的Internet Explorer)执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【程序1.2】  最简单的Java Applet。</span><br><span class="line">import java.applet.Applet;</span><br><span class="line">import java.awt.Graphics;</span><br><span class="line">public class HelloWorld extends Applet&#123;</span><br><span class="line">public void paint(Graphics g)</span><br><span class="line">&#123;</span><br><span class="line">g.drawString (&quot;你好，Java世界！&quot;，2，20);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序1.2是一个最简单的Java Applet，下面是一个发布程序1.2的HTML文件的内容，请读者注意其中斜黑体的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;我的第一个Java Applet程序&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;p&gt;&lt;applet code=HelloWorld.class width=300 height=200&gt;&lt;/applet&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>将上述HTML文件和程序1.2编译得到的字节码文件HelloWorld.class放在Web服务器的同一个目录下，当使用Web浏览器浏览该HTML文件时，浏览器将下载HelloWorld.class，然后执行。</p><p>因为执行环境与Java Application不同，Applet的程序结构与Java Application也有所不同，当然它们有一点是共同的：都是由若干个类组成的。</p><blockquote><p>程序1.2的第1行相当于C语言中的#inlcude，表示该Applet程序需要引用Java的Applet类。</p></blockquote><p>不过，Java编译器的处理方法不同于C语言，它并不将该文件读入，而且它引用的是已经编译过的Java字节码文件。在编译阶段，Java编译器将从该字节码文件中读取有关Applet类的信息，检验程序中对Applet的使用是否正确。程序1.2编译生成的HelloWorld.class文件中也不包含Applet类的代码。</p><blockquote><p>第2行的作用与第1行类似，由于程序中用java.awt.Graphics类的功能来输出字符串，因此引入该类。</p></blockquote><blockquote><p>第3行开始定义HelloWorld类，注意后面的extends Applet，这是Java类继承语法。一个Applet程序可以由多个类构成，其中只有一个类继承于Applet类，这是Applet程序的入口。</p></blockquote><p>Applet的执行与Java Application不同，从程序中看不到像Application中main方法那样的一个明显的执行流程。</p><p>实际上这些都已经在Applet中实现了，Applet在执行时一直等待用户的输入或其他的一些事件(如关闭浏览器)，根据不同的事件执行不同的功能。</p><p>在编写Applet时需要做的就是提供各种事件的处理程序， 例如程序1.2类HelloWorld中定义了方法paint，该方法在Applet需要绘制界面时被调用。</p><p>Applet类中定义了paint方法的调用形式，它有一个Graphics类的对象作参数，通过它可以在Applet的界面上绘制图形和文字。程序1.2调用drawString方法来输出一个字符串：<br>g.drawString (“你好，Java世界！”，2，20);</p><p>drawString方法有三个参数：</p><ul><li>第一个是要输出的字符串；</li><li>第二、三个是输出位置，分别为x、y轴的值。</li></ul><p>图1.2是程序1.2在IE 6.0中执行的画面。</p><h2 id="JDK的安装与使用"><a href="#JDK的安装与使用" class="headerlink" title="JDK的安装与使用"></a>JDK的安装与使用</h2><p>JDK(Java Development Kit )是最基本的Java程序开发工具，可以从Java官方站点<br><a href="http://java.sun.com" target="_blank" rel="noopener">http://java.sun.com</a> 下载。目前该站点提供的正式版本是Java2 SDK 1.4.2，支持的平台有Windows、Linux、Solaris SPARC和Solaris x86，用户可选择合适的版本下载。</p><p>J2SE的下载页面为<a href="http://java.sun.com/j2se/1.4.2/download.html，" target="_blank" rel="noopener">http://java.sun.com/j2se/1.4.2/download.html，</a> 如图1.3所示，它提供了带集成开发环境和不带集成开发环境两种版本。</p><p>下面介绍Windows 98平台下不含集成开发环境的Java2 SDK 1.4.2的安装和使用。</p><p>1) 安装<br>运行下载的可执行文件，出现画面，选择“I accept the terms in the license agreement”，然后单击“Next”按钮，显示选择安装的项目。</p><p>如果不需安装演示程序和类库的源代码，可去掉安装项目中的“Demos”和“Source Code”。如果需要修改JDK安装的目录，点击“Change”按钮选择。最后单击“Next”按钮，进入画面，确定是否为系统当前已安装的Web浏览器安装了Java虚拟机插件。单击“Next”按钮开始复制文件和配置，最后画面，单击“Finish”按钮结束安装。</p><h2 id="JDK的使用"><a href="#JDK的使用" class="headerlink" title="JDK的使用"></a>JDK的使用</h2><p>JDK使用命令行方式进行编译。要调试Java程序，首先要使用文本编辑器输入保存Java源程序，然后编译执行。</p><h3 id="第一步：编辑源程序。"><a href="#第一步：编辑源程序。" class="headerlink" title="第一步：编辑源程序。"></a>第一步：编辑源程序。</h3><p>使用纯文本的编辑软件，如Windows 98的记事本(Notepad.exe)或MS-DOS的edit.exe。保存文件时注意文件名应与程序中的类名相同，程序1.1的文件名为HelloWorldApp.java(注意大小写)。</p><h3 id="第二步：编译源程序。"><a href="#第二步：编译源程序。" class="headerlink" title="第二步：编译源程序。"></a>第二步：编译源程序。</h3><p>在DOS命令提示符下执行(注意大小写)<br>javac HelloWorldApp.java </p><p>如果正常的话，将生成HelloWorldApp.class文件。</p><h3 id="第三步：运行程序。在DOS命令提示符下执行-注意大小写"><a href="#第三步：运行程序。在DOS命令提示符下执行-注意大小写" class="headerlink" title="第三步：运行程序。在DOS命令提示符下执行(注意大小写)"></a>第三步：运行程序。在DOS命令提示符下执行(注意大小写)</h3><p>java HelloWorldApp<br>注意不要输入文件的扩展名class。</p><h2 id="用JDK编译运行Java"><a href="#用JDK编译运行Java" class="headerlink" title="用JDK编译运行Java"></a>用JDK编译运行Java</h2><blockquote><p>Applet过程与编译运行Java应用程序类似，只是最后运行程序的方式不同。</p></blockquote><p>Java Applet可以在支持Java Applet的Web浏览器中运行，也可以使用JDK提供的appletviewer.exe。在DOS命令行中输入<br>appletviewer Page1.htm<br>这里，Page1.htm为程序1.2中的HTML文件。</p><h3 id="Visual-J-6-0的使用"><a href="#Visual-J-6-0的使用" class="headerlink" title="Visual J++ 6.0的使用"></a>Visual J++ 6.0的使用</h3><blockquote><p>Visual J++ 6.0是微软公司可视化集成开发环境Visual Studio 6.0的一个组成部分，Visual Studio是运行于Windows环境下的一个集成工具集，包括Visual C++、Visual J++和Visual InterDev等。</p></blockquote><p>Visual J++通过解决方案(Solution)和项目(Project)来组织程序。一个解决方案中可包含多个项目，每个项目相当于一个完整的程序，而解决方案相当于一个完整的应用系统。解决方案不可单独创建，在新建一个项目时会自动创建一个解决方案。图1.11是使用Visual J++调试程序1.2的画面，Visual J++创建了一个解决方案ch1-2，该解决方案包含一个项目ch1-2，而该项目由两个文件构成：HelloWorld.java和Page1.htm。</p><p>Visual J++ 6.0集成开发环境的功能很强大，限于篇幅，本书不详细介绍其使用方法，仅简单介绍如何使用Visual J++ 6.0调试Java应用程序和Java Applet。</p><p>1．用Visual J++调试Java应用程序</p><p>调试Java应用程序时，首先应为要调试的应用程序创建一个项目，在File菜单下选择“New Project”，弹出图1.12所示的对话框。在左边的树形列表中选择“Visual J++ Projects”→“Applications”，然后在右侧的列表中选择“Console Application”，在对话框下部的Name编辑框中输入项目名，在Location编辑框中输入项目文件存放的目录或单击“Browse”按钮选择一个目录。最后单击“打开”按钮，Visual J++将创建新项目。</p><p>对于Java应用程序，Visual J++自动创建了一个文件Class1.java，并给出了类的声明和main方法的声明，用户可在此基础上修改。</p><p>首先在解决方案窗口中展开该项目，然后在Class1.java文件名上单击鼠标右键，选择“Rename”，如图1.13所示，修改文件名。对于程序1.1应将文件名修改为HelloWorldApp.java，然后双击文件名打开源程序编辑窗口修改程序。</p><p>源程序输入完成后，选择Debug菜单的子功能即可执行程序。第一次执行可能会出现图1.14所示的对话框，原因是在创建该项目时，设定执行的类为Class1。单击“确定”按钮会出现图1.15所示的对话框，再单击“OK”按钮就可以，此时设定执行的类已改为HelloWorldApp。该窗口也可以通过“Project”菜单的子功能激活，然后修改要执行的类。</p><p>当然，如果源程序有错误，程序将不能正常编译执行，错误信息会显示在Task List窗口上。</p><p>选择File菜单的子功能Close All可以关闭当前打开的所有项目，Save All可保存当前项目的信息。Visual J++中解决方案保存的文件的扩展名为.sln，项目保存的文件的扩展名为.vjp，可以在以后再次打开。</p><p>用Visual J++调试Java Applet</p><p>用Visual J++调试Java Applet的步骤与调试Java应用程序基本相同，也需要先创建一个项目。在选择项目类型时，首先在左边的树形列表中选择Web Pages，然后在右边选择Applet on HTML。</p><p>Visual J++为新项目生成两个文件：Applet1.java和Page1.htm。Applet1.java提供了一个比较复杂的Applet程序的框架，对于程序1.2这样的Applet，可以将原来的代码删除。与Java应用程序类似，也应保持文件名与类名的一致。Page1.htm是Visual J++提供的一个HTML文档，用于在Web浏览器中调试Applet。</p><p>Visual J++提供了两种调试运行Applet的方法，可以在项目的Properties对话框中选择。选择运行HTML文件将使用Web浏览器，而选择运行Java类将使用微软公司提供的与appletviewer相似的WJView.exe。</p><h2 id="实训一-安装与熟悉Java开发工具"><a href="#实训一-安装与熟悉Java开发工具" class="headerlink" title="实训一  安装与熟悉Java开发工具"></a>实训一  安装与熟悉Java开发工具</h2><p>JDK开发工具</p><p>一、实训目的</p><ol><li>学习从网络下载JDK开发工具与帮助文档。</li><li>学习安装JDK开发工具及其文档。</li><li>掌握Java Appllcation程序的开发过程并编写一个Java Application程序。</li><li>掌握Java Applet程序的开发过程并编写一个Java Applet程序。</li><li>学习编写简单的HTML文件，配合Java Applet使用。</li><li>学习使用JDK的帮助文档。</li></ol><p>二、实训内容</p><p>1．从网络下载JDK开发工具与帮助文档。</p><p>(1)访问 <a href="http://java.sun.com，" target="_blank" rel="noopener">http://java.sun.com，</a> 浏览JDK下载页面,J2SE v 1.4.2的下载页面为 <a href="http://java.sun.com/j2se/1.4.2/download.html" target="_blank" rel="noopener">http://java.sun.com/j2se/1.4.2/download.html</a> 也可以通过访问其他国内外的免费FTP站点或从CD-ROM光盘中下载得到JDK开发工具。 </p><p>(2) 选择适合本地实验计算机平台的软件版本，运行Windows 95 / 98的计算机，应选择“Windows Installation”版本的JDK开发工具，即单击图1.18所示的链接。</p><p>单击此链接后，所示的网页，点击指定的链接。所示的页面中单击             按钮接受有关软件下载的协议，单击下载链接，如果采用Internet Explorer则出现所示保存文件的提示，单击            按钮，在所示的对话框中选择保存的目录。</p><p>(3) 按同样的方法下载JDK的帮助文档。</p><p>安装JDK开发工具与帮助文档。</p><p>(1) 运行下载的可执行文件，按照1.3节介绍的步骤安装JDK。<br>(2) 为方便运行Java编译器，设置环境变量Path。对于Windows 95/98，修改计算机的C:\AUTOEXEC.BAT文件时应在文件末增加一句：<br>set  Path=%Path%;C:\j2sdk1.4.2\bin<br>这里，C:\j2sdk1.4.2为JDK的安装目录。</p><blockquote><p>对于Windows XP及Windows 2000等平台，在控制面板中选择系统，在系统属性对话框中单击按钮。然后在“系统变量”列表中选择“Path”，然后单击按钮，在出现的对话框中仿照上面的set命令将C:\j2se1.4.2\bin加入到Path环境变量中。</p></blockquote><p>使用解压缩工具Winzip将JDK帮助文档j2sdk-1_4_2-doc.zip文件解压，该压缩文件包含一组以HTML文件形式组织的帮助文件，把它们保存在本地的一个目录下，例如保存在C:\j2sdk1.4.2\document\目录下。</p><h2 id="编写并运行一个Java-Application程序"><a href="#编写并运行一个Java-Application程序" class="headerlink" title="编写并运行一个Java Application程序"></a>编写并运行一个Java Application程序</h2><p>(1) 打开一个纯文本编辑器，例如Windows记事本NotePad.exe或DOS下的edit.exe。</p><p>(2) 键入1.2节中的程序1.1。</p><p>(3) 检查无误后(注意大小写准确)把文件保存起来，命名为HelloWorldApp.java，可以创建一个目录，如C:\Java\prog1_1，保存这个文件。</p><p>(4) 进入DOS命令行方式，用cd命令进入(3)中创建的目录，运行Java编译器：<br>javac HelloWorldApp.java</p><p>(5) 如果JDK安装正确、程序输入无误且保存的文件名正确，运行编译器没有任何输出；否则，会输出错误信息，一般的错误都是由于拼写失误引起的。运行dir命令查看是否已在相同目录下生成一个名为HelloWorldApp.class的文件。</p><p>(6) 利用Java解释器运行这个Java Application程序，并查看运行结果：java HelloWorldApp</p><h2 id="编写并编译一个Java-Applet程序。"><a href="#编写并编译一个Java-Applet程序。" class="headerlink" title="编写并编译一个Java Applet程序。"></a>编写并编译一个Java Applet程序。</h2><p>(1) 打开一个纯文本编辑器。<br>(2) 键入1.2节的程序1.2。<br>(3) 创建一个目录，保存文件，命名为HelloWorld.java。<br>(4) 进入DOS命令行方式，在保存有上述Java文件的目录下运行Java编译器：<br>javac HelloWorld.java<br>(5) 如果程序输入无误且保存的文件名正确，运行编译器将没有任何输出；否则，会输出错误信息。运行dir命令查看是否已在相同目录下生成—个名为HelloWorld.class的文件。</p><h2 id="编写配合Applet的HTML文件。"><a href="#编写配合Applet的HTML文件。" class="headerlink" title="编写配合Applet的HTML文件。"></a>编写配合Applet的HTML文件。</h2><p>(1) 打开一个纯文本编辑器。<br>(2) 键入如下的HTML程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;我的第一个Java Applet程序&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;p&gt;&lt;applet code=HelloWorld.class width=300 height=200&gt;&lt;/applet&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>(3) 检查无误后把文件命名为Page1.htm，保存在与文件HelloWorld.java同一目录下。<br>(4) 直接双击这个HTML文件的图标，或者打开Web浏览器(例如IE)，在地址栏中键入这个HTML文件的全路径名，查看Applet在浏览器中的运行结果。<br>(5) 利用模拟的Applet运行环境解释运行这个Java Applet程序并观察运行结果。进入DOS环境，在程序所在目录下运行下面的命令：<br>appletviewer Page1.htm</p><h2 id="使用JDK帮助文档。"><a href="#使用JDK帮助文档。" class="headerlink" title="使用JDK帮助文档。"></a>使用JDK帮助文档。</h2><p>在Windows中打开JDK文档目录，双击index.html文件，或者在Web浏览器的地址栏中输入这个文件的全路径名，打开这个文件对应的网页，查阅相关内容。<br>B．Visual J++ 6.0集成开发环境</p><p>一、实训目的</p><ol><li>学习安装Visual J++ 6.0集成开发环境。</li><li>掌握集成开发环境(IDE)的概念，了解并学习使用Visual J++开发环境的基本构成和功能。</li><li>了解“项目”的概念，掌握利用Visual J++开发并编译运行一个Java Application的过程。</li><li>了解“可视化开发”的概念，掌握利用Visual J++的向导开发一个Java Applet的过程。</li><li>给出Java Applet和Java Application例子，调试程序、修改程序功能。 </li></ol><p>二、实训内容<br>1．安装Visual J++ 6.0。<br>Visual J++ 6.0集成开发环境可以从CD-ROM光盘上安装，也可以从网络上利用共享目录安装，整个安装过程是自动完成的，用户只要给出安装到本机的目录、选择安装选件(通常选择“典型安装”)即可。</p><p>2．编写并运行第一个Java Application程序。<br>Visual J++是以“项目”(Project)来组织应用开发的。一个完整的应用通常由若干个源程序文件和辅助性文件构成，同时，为了保证开发的连续性，开发工具通常还会记录用户的桌面安排和其他种种设置。Visual J++中所有这些与一个应用开发任务相关的文件被放在一个目录中，称为一个Project。</p><p>(1) 新建—个空项目(Empty Project)。通过Windows 95/98“开始”菜单的“程序”选项选择“Microsoft Visual J++ 6.0”，打开Visual J++开发环境，出现“New Project”窗口(见图1.12)。<br>选中图标左边区域的“Visual J++ Projects”一项，右边的图标变成一个“Empty Project”，如图1.27所示，选中该图标。然后在对话框下方的“Location”一栏输入新建项目所在的目录，在“Name”一栏中输入新建项目的名称，然后单击“打开”按钮。系统将在指定目录中为这个项目生成一个指定名称的子目录，以保存这项目中的所有文件。</p><p>(2) 加入并编辑Java Application源程序。选中位于屏幕右上方的窗口“Project Explorer”，选中项目名，用鼠标右键单击项目名前的的图标，选择弹出菜单的“Add”菜单项的“Add Class”子菜单项所示的对话框。</p><p>第二个图标“ClassMain”，然后在“Name”栏中输入类名HelloWorldApp.java，点击“打开”按钮，系统将创建一个名为HelloWorldApp.java的源代码文件，将其加入当前项目并打开编辑这个源代码文件的窗口，其中包含系统自动生成的几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldApp</span><br><span class="line">              &#123;</span><br><span class="line">       public static void main(String[] args)</span><br><span class="line">            &#123;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p><p>按照程序1.1修改该文件，然后选择File菜单下的“Save HelloWorldApp”子菜单保存该文件。</p><p>(3) 编译并运行Java Application程序。选择“Build”菜单的“Build”选项编译该程序，屏幕最下方的状态条将显示“Solution update succeeded”，表示编译成功。选择“Debug”菜单的“start”选项即可运行此程序。程序第一次运行时，系统需要了解这个项目的有关属性。</p><p>由于程序是采用字符界面，因此以系统将打开一个字符界面的窗口，在其中运行该程序。这个字符界面的窗口将在程序运行完毕后自动关闭，读者可能来不及查看运行结果。为解决这个问题，可将光标定位到main方法结束的大括号处，然后选择“Debug”菜单的“Run to cursor”运行程序，程序运行到光标所在处后暂停，此时可切换到程序的字符界面窗口查看，然后再选择“Debug”菜单的“start”选项继续。</p><h2 id="编写并调试一个Java-Applet程序"><a href="#编写并调试一个Java-Applet程序" class="headerlink" title="编写并调试一个Java Applet程序"></a>编写并调试一个Java Applet程序</h2><p>(1) 新建Applet项目。按照1.3.4节介绍的步骤创建一个Applet项目。<br>(2) 编辑Applet源代码。按照程序1.2的清单修改Applet1.java文件。<br>(3) 修改Applet1.java文件名。 将文件名中的Applet1改为类名HelloWorld</p><p>修改HTML文档。在Project Explorer窗口中双击Page1.htm文件打开编辑窗口，用鼠标单击Applet显示区。然后，所示的Properties窗口中将code属性修改为HelloWorld.class，可同时修改height、width属性，调整Applet在浏览器中显示区域的大小。</p><p>HTML文档的编辑窗口有三页视图：第一页Design，可以利用屏幕左边Toolbox窗口中的HTML工具可视化地加入一些图形界面组件，如文本区域、按钮等(注意：这些组件是加入到HTML文件中，不是Applet中)；第二页Source，显示HTML的具体代码，其中蓝色的区域是HTML中所嵌入的Applet的显示效果；第三页QuickView，显示整个HTML在浏览器中的显示效果。</p><p>如果想以文本方式编辑HTML文档，可选择第二页视图，选中代表Applet的矩形区域，单击鼠标右键，在弹出的菜单中选择“Always View As Text”菜单项。</p><p>(5) 运行Applet程序。</p><h3 id="使用Visual-J-的调试功能。"><a href="#使用Visual-J-的调试功能。" class="headerlink" title="使用Visual J++的调试功能。"></a>使用Visual J++的调试功能。</h3><p>Visual J++的集成环境的调试功能很强大，开发人员启动调试功能后，可以介入程序的运行过程，能够分解、控制程序的运行或使程序在指定条件下运行，并随时查看运行的中间结果，极大地方便了开发人员，也提高了开发效率。</p><p>(1) 打开已有项目。选择File菜单的“Close All”菜单项关闭当前的项目及其中的所有文件，如果该项目修改后尚未保存，则系统将询问“是否保存当前项目中修改过的文件”，此时选择“Yes”。</p><p>选择File菜单的“Open Project”菜单项，打开“Open Project”对话框，找到HelloWorldApp应用程序所在的目录，选择所列出的文件(共列出两个文件，分别为 .sln文件和 .vjp文件，可选择其中任意一个)，点击“打开”按钮关闭对话框，系统打开前面创建的Java Application项目。</p><p>(2) 修改源代码。打开HelloWorldApp.java源程序编辑窗口，将程序修改为下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* HelloWorldApp.java */</span><br><span class="line">import java.lang.System;</span><br><span class="line"></span><br><span class="line">class HelloWorldApp &#123;</span><br><span class="line"> /**</span><br><span class="line"> * Traditional &quot;Hello World!&quot; program.</span><br><span class="line"> **/</span><br><span class="line"> public static void main (String args[]) &#123;</span><br><span class="line"> char c;</span><br><span class="line"> try&#123;</span><br><span class="line"> c = System.in.read();</span><br><span class="line">// 输出到标准输出设备</span><br><span class="line">System.out.println(&quot;Hello World!&quot;);</span><br><span class="line"> &#125;catch(IOException e)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>排除编译错误。选择Build菜单的Build选项，系统下方的状态条将提示“Solution failed”，表示出现了编译错误。错误内容显示在屏幕下方的TaskList窗口中。</p><p>该程序共有三个编译错误，双击第一行错误信息，光标将停留在源程序编辑窗口中发生该错误的那一行。产生这个错误是由于System.in.read方法的返回值为int类型，不能直接赋给char类型的变量c。将这行语句改为</p><p>c = (char)System.in.read();</p><p>从错误提示信息可以看出，第二个错误与第三个错误实际上都是由IOException这个标识符引起的。上面的程序使用了Java语言的异常处理机制，IOException是为Java类库提供的一个异常类，该程序中未引入该类，因此产生错误。在程序头部加上下面的语句即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br></pre></td></tr></table></figure></p><p>再次编译，系统显示“Solution update Succeeded”，表明错误已排除。</p><p>调试。排除了编译错误不等于程序就一定正确，如果程序里还包含了一些逻辑错误，则需要深入程序内部，动态地控制程序的运行过程，观察各种中间现象和中间结果。</p><p>调试一个程序所用的命令都在Debug菜单中，也可以使用专用的Debug工具条。选择View菜单的Toolbar菜单项，在打开的子菜单中选择Debug，系统将显示debug工具条.</p><p>在源代码编辑窗口中把光标移到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure></p><p>这一行，点击Debug工具条中的“运行到光标”(Run to cursor)按钮，程序将运行，输入一个字符换行后程序在指定行之前停止，源代码窗口中该指定行左边出现一个黄色的箭头。同时，系统将在屏幕下方打开观察程序内各变量取值的窗口和Watch窗口(如果未出现，可以点击Debug工具条上的对应按钮)，选择变量取值窗口的第二页Locals，可以观察到程序中局部变量的取值情况。</p><p>单步运行是调试的重要手段，单步运行时用户每发出一个单步命令，程序从当前位置开始运行一个语句。Debug菜单条中有三个单步运行按钮，它们是“Step Into”、  “Step Over”和“Step Out”，分别代表跟踪当前语句中的方法调用、不跟踪方法调用一次执行完当前语句和运行完当前循环并跳出。</p><p>Watch窗口用于在调试过程中观察指定变量的值，可在“Name”栏中输入变量名并回车，如果需要观察多个变量的值，可重复上述过程。</p><p>调试程序常用的另一种手段是设置断点，当程序运行到断点时，回到集成环境。可以观察变量的值，然后继续执行。</p><h2 id="习-题-一"><a href="#习-题-一" class="headerlink" title="习  题  一"></a>习  题  一</h2><h2 id="1．编译型语言与解释型语言是如何划分的"><a href="#1．编译型语言与解释型语言是如何划分的" class="headerlink" title="1．编译型语言与解释型语言是如何划分的?"></a>1．编译型语言与解释型语言是如何划分的?</h2><p>答：编译型语言在程序执行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序的时候，就不用再进行翻译了。</p><p> 解释型语言，是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。</p><p> C/C++ 等都是编译型语言，而Java，C#等都是解释型语言。</p><p> 虽然Java程序在运行之前也有一个编译过程，但是并不是将程序编译成机器语言，而是将它编译成字节码（可以理解为一个中间语言）。</p><p> 在运行的时候，由JVM将字节码再翻译成机器语言。</p><p> 注：脚本语言一般都有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。JAVASCRIPT,ASP,PHP,PERL,Nuva都是脚本语言。C/C++编译、链接后，可形成独立执行的exe文件。</p><p> 4.脚本语言是一种解释性的语言,例如vbscript,javascript,installshield script,ActionScript等等,它不象c\c++等可以编译成二进制代码,以可执行文件的形式存在.</p><p> 脚本语言不需要编译，可以直接用，由解释器来负责解释。 </p><p> 5.脚本语言一般都是以文本形式存在,类似于一种命令. </p><p> 举个例子说,如果你建立了一个程序,叫aaa.exe,可以打开.aa为扩展名的文件.<br> 你为.aa文件的编写指定了一套规则(语法),当别人编写了.aa文件后,你的程序用这种规则来理解编写人的意图,并作出回应.那么,这一套规则就是脚本语言</p><h3 id="百度来源答案："><a href="#百度来源答案：" class="headerlink" title="百度来源答案："></a>百度来源答案：</h3><p>编译型语言与解释型语言</p><p>计算机是不能理解高级语言的，更不能直接执行高级语言，它只能直接理解机器语言，所以使用任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言，也就是机器码。</p><p>而这种转换的方式有两种：</p><p>1）编译</p><p>2）解释</p><p>由此高级语言也分为编译型语言和解释型语言。</p><h3 id="编译型语言："><a href="#编译型语言：" class="headerlink" title="编译型语言："></a>编译型语言：</h3><p>使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。</p><p>特点：</p><p>在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。</p><p>总结：</p><p>1）一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</p><p>2）与特定平台相关，一般无法移植到其他平台；</p><p>3）现有的C、C++、Objective等都属于编译型语言。</p><h3 id="解释型语言："><a href="#解释型语言：" class="headerlink" title="解释型语言："></a>解释型语言：</h3><p>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。</p><p>特点：</p><p>解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。</p><p>总结：</p><p>1）解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</p><p>2）只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</p><p>3）Python等属于解释型语言。</p><h2 id="Java属于哪种类型语言"><a href="#Java属于哪种类型语言" class="headerlink" title="Java属于哪种类型语言?"></a>Java属于哪种类型语言?</h2><p>来源百度：</p><p>Java是一种计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。</p><p>Java不同于一般的编译语言和直译语言。它首先将源代码编译成字节码，然后依赖各种不同平台上的虚拟机来解释执行字节码，从而实现了“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。</p><h2 id="Java程序的编译和解释有何特点"><a href="#Java程序的编译和解释有何特点" class="headerlink" title="Java程序的编译和解释有何特点?"></a>Java程序的编译和解释有何特点?</h2><p>编译执行和解释执行是不同语言之间的特性，所有的java都是编译执行的。 如果不是编译执行，其实已经完全不用java的编译器。那么只是一个使用java语法的另一种语言而已。</p><p>编译执行是指把代码先编译成机器码。然后按顺序运行，如果编译中有任何异常，都无法继续运行。java的编译就是把java转换成class。<br>而解释执行则是运行到哪一行代码就执行哪一行代码。如果其他代码有错误但没有运行到，一般不会影响。 </p><p>比较起来，编译执行速度要快的多。而解释执行则在于比较灵活。可以动态修改。甚至可以在代码运行到指定语句之前，修改该代码。</p><p>1、java编译生成的字节码，在所有操作系统都是一样，故其有这样的特点：<br>write once, run anywhere.其意思：只需要一次编码，就可以在任何环境下运行。</p><p>2、不同的操作系统，其java虚拟机是不一样的。虚拟机将java字节代码转换对应操作系统的相关指令，保证其正常运行。</p><p>3、java 系统支持所有的硬件的平台，不存在你提及的问题，你可以放心使用。</p><p>4、解释器在java虚拟机中，编译器在JDK或JRE 中。</p><p>5、java虚拟机就是常说的java 运行环境，其缩写是 JRE，安装在操作系统下的一个目录中，这个目录在安装时可以由你自行指定，就像你安装其它应用软件一样。JDK中包含了JRE，还有开发环境，如编译器，帮助文档生成器，以及系统API的jar库文件等。</p><h2 id="这些特点对于Java成为Internet上的编程语言有什么影响"><a href="#这些特点对于Java成为Internet上的编程语言有什么影响" class="headerlink" title="这些特点对于Java成为Internet上的编程语言有什么影响?"></a>这些特点对于Java成为Internet上的编程语言有什么影响?</h2><p>Java编程语言并不是为Internet、www而设计的，它还可以用来编写独立的应用， Java编程是一种面向对象语言，Java语言类似于C++语言。Java程序需要编译，它被放置在Internet服务器上，当用户访问服务器时，Java程序被下载到本地的用户机上，由浏览器解释运行。实际上有两种Java程序：一种Java应用程序是一个完整的程序，如Web浏览器。另一种Java小应用程序是运行于Web浏览器中的一个程序。</p><p>Java程序和它的浏览器HotJava，提供了可让你的浏览器运行程序的方法。你能从你的浏览器里直接播放声音，你还能播放页面里的动画，Java还能告诉你的浏览器怎样处理新的类型文件。当我们能在2400 baud线上传输视频图象时，HotJava将能显示这些视频。</p><p>Java在电子商务方面的应用和特性</p><p>电子商务要求程序代码具有基本的要求：安全、可靠、同时要求能与运行于不同平台的机器的全世界客户开展业务。Java以</p><p>其强安全性、平台无关性、硬件结构无关性、语言简洁同时面向对象，在网络编程语言中占据无可比拟的优势，成为实现电子商务系统的首选语言。</p><p>在桌面应用上，尽管Java在桌面GUI方面尚有不尽如人意之处，但仍然有很多开发者用来开发运行在多种操作系统平台上的</p><p>桌面应用。具体应用在如下几个领域:</p><ol><li>行业和企业信息化</li></ol><p>由于Sun、IBM、Oracle、BEA等国际厂商相继推出各种基于Java技术的应用服务器以及各种应用软件，带动了Java在金融电信、制造等领域日益广泛的应用。如清华大学计算机系利用Java、XML和Web技术研制开发了多个软件平台，东方科技的Tong Web、金碟的Apusic、中创的Inforweb 等J2EE应用服务器及和佳ERP和宝信ERP等ERP产品，已在许多企业得到应用。</p><ol start="2"><li>电子政务及办公自动化</li></ol><p>东方科技、金碟、中创等开发的J2EE应用服务器在电子政务及办公自动化中也得到应用: 如金碟的Apusic在民政部、广东省市工商局应用; 东软电子政务架构EAP平台在社会保险、公检法、税务系统得到应用; 中创的Inforweb等Infor系列中间件产品在国家海事局、山东省政府及中国建设银行、民生银行等金融系统应用; 无锡永中科技基于Java平台开发的国产化集成办公软件Office”也已在一些省市政府部门得到应用。</p><ol start="3"><li>嵌入式设备及消费类电子产品</li></ol><p>无线手持设备、通信终端、医疗设备、信息家电(如数字电视、机顶盒、电冰箱)、汽车电子设备等是今年以来比较热门的Java应用领域。在这方面的应用有中国联通CDMA 1X网络中基于Java技术的无线数据增值服务——UniJa</p><p>来源：<a href="http://www.sohu.com/a/155169478_445013" target="_blank" rel="noopener">http://www.sohu.com/a/155169478_445013</a></p><h2 id="2．JDK的编译命令是什么"><a href="#2．JDK的编译命令是什么" class="headerlink" title="2．JDK的编译命令是什么?"></a>2．JDK的编译命令是什么?</h2><p>1、window+R 2、在窗口里输入 cmd 3、进入你放java的文件目录下 4、javac 文件名.java (这个是编译) 5、java 文件名 (执行)  前提是你装了JDK才能编译和执行！！！</p><h2 id="如果编译结果报告说找不到要编译的源代码，通常会是哪些错误"><a href="#如果编译结果报告说找不到要编译的源代码，通常会是哪些错误" class="headerlink" title="如果编译结果报告说找不到要编译的源代码，通常会是哪些错误?"></a>如果编译结果报告说找不到要编译的源代码，通常会是哪些错误?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=C:\Program Files\Java\jdk1.8.0_40</span><br><span class="line">PATH=%JAVA_HOME%\bin;</span><br><span class="line">CLASSPATH=.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre></td></tr></table></figure><h2 id="3．运行编译好的字节码文件使用什么命令-什么是JIT-什么是JVM"><a href="#3．运行编译好的字节码文件使用什么命令-什么是JIT-什么是JVM" class="headerlink" title="3．运行编译好的字节码文件使用什么命令? 什么是JIT? 什么是JVM?"></a>3．运行编译好的字节码文件使用什么命令? 什么是JIT? 什么是JVM?</h2><p>javac针对.java文件，编译源代码为字节码文件<br>java针对.class文件，JVM解释执行程序</p><h3 id="什么是JIT"><a href="#什么是JIT" class="headerlink" title="什么是JIT"></a>什么是JIT</h3><p>1、动态编译（dynamic compilation）指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫静态编译（static compilation）。</p><p>2、JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。JIT编译一词后来被泛化，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别。<br>3、自适应动态编译（adaptive dynamic compilation）也是一种动态编译，但它通常执行的时机比JIT编译迟，先让程序“以某种式”先运行起来，收集一些信息之后再做动态编译。这样的编译可以更加优化。</p><p>来源：<a href="https://blog.csdn.net/sunxianghuang/article/details/52094859" target="_blank" rel="noopener">https://blog.csdn.net/sunxianghuang/article/details/52094859</a></p><p>来源：<a href="https://baike.baidu.com/item/JVM/2902369?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/JVM/2902369?fr=aladdin</a></p><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>byte://1字节有符号整数的补码<br>short://2字节有符号整数的补码<br>int://4字节有符号整数的补码<br>long://8字节有符号整数的补码<br>float://4字节IEEE754单精度浮点数<br>double://8字节IEEE754双精度浮点数<br>char://2字节无符号Unicode字符</p><p>其它数据类型<br>object//对一个Javaobject（对象）的4字节引用<br>returnAddress//4字节，用于jsr/ret/jsr-w/ret-w指令</p><h3 id="JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是："><a href="#JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是：" class="headerlink" title="JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是："></a>JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是：</h3><p>JVM 指令系统<br>JVM 寄存器<br>JVM 栈结构<br>JVM 碎片回收堆<br>JVM 存储区</p><h3 id="JVM执行程序的过程-："><a href="#JVM执行程序的过程-：" class="headerlink" title="JVM执行程序的过程 ："></a>JVM执行程序的过程 ：</h3><p>I.加载.class文件<br>II.管理并分配内存<br>III.执行垃圾收集</p><p>JRE（java运行时环境）包含JVM的java程序的运行环境</p><p>JVM是Java程序运行的容器,但是他同时也是操作系统的一个进程,因此他也有他自己的运行的生命周期,也有自己的代码和数据空间。</p><p>JVM在整个jdk中处于最底层,负责与操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也叫虚拟计算机.</p><p>操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境。</p><p>1.创建JVM装载环境和配置<br>2.装载JVM.dll<br>3.初始化JVM.dll并挂接到JNIENV(JNI调用接口)实例<br>4.调用JNIEnv实例装载并处理class类。 </p><h2 id="4．Java程序分为哪两大类？它们之间有哪些差别"><a href="#4．Java程序分为哪两大类？它们之间有哪些差别" class="headerlink" title="4．Java程序分为哪两大类？它们之间有哪些差别?"></a>4．Java程序分为哪两大类？它们之间有哪些差别?</h2><p>Application和Applet是两个概念，前者指的是一个完整程序，后者指的是一个小程序，作为一个完整程序他具有一定的独立性，玩过手机游戏都知道一个手机游戏对应一个jar文件，这个jar文件就相当于一个Application，你运行游戏只需要选中它运行即可，不需要先启动另外一个程序后才能启动它。</p><p>而Applet则需要先启动浏览器后才能运行它。Applet因为小可以被看作一个软件组件，他可以作为一个动态网站的一个组成部分，Applet的主要用途是完成复杂的逻辑，这个是在JAVASCRIPT等脚本语言和JSP和ASP等动态网页技术还没出现时负责动态的显示数据的作用，类似微软的ActiveX组件。</p><h3 id="在JAVA领域有三个“let”："><a href="#在JAVA领域有三个“let”：" class="headerlink" title="在JAVA领域有三个“let”："></a>在JAVA领域有三个“let”：</h3><p>MIDlet：移动设备应用程序<br>Servlet:服务器程序<br>Applet:浏览器小程序</p><p>来源：<a href="https://zhidao.baidu.com/question/2265873673648119708.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/2265873673648119708.html</a></p><h2 id="5．Java程序中有哪几种注释方式？"><a href="#5．Java程序中有哪几种注释方式？" class="headerlink" title="5．Java程序中有哪几种注释方式？"></a>5．Java程序中有哪几种注释方式？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//…… 单行注释</span><br><span class="line">/*……*/ 多行注释</span><br><span class="line">/**......*/用来做文档的注释</span><br></pre></td></tr></table></figure><h2 id="6．分别编写Applet和Application，在屏幕上生成如下图案："><a href="#6．分别编写Applet和Application，在屏幕上生成如下图案：" class="headerlink" title="6．分别编写Applet和Application，在屏幕上生成如下图案："></a>6．分别编写Applet和Application，在屏幕上生成如下图案：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure><p>略</p><h2 id="第二章-结构化程序设计"><a href="#第二章-结构化程序设计" class="headerlink" title="第二章     结构化程序设计"></a>第二章     结构化程序设计</h2><h2 id="回顾—Java开发环境的建立"><a href="#回顾—Java开发环境的建立" class="headerlink" title="回顾—Java开发环境的建立"></a>回顾—Java开发环境的建立</h2><p>1)    下载J2SE安装程序<br>2)    运行J2SE安装程序，安装J2SE<br>3)    设置环境变量：<br>运行路径(path)<br>类路径(classpath)<br>4)下载J2SE的在线帮助文档</p><h2 id="回顾—Java程序设计步骤"><a href="#回顾—Java程序设计步骤" class="headerlink" title="回顾—Java程序设计步骤"></a>回顾—Java程序设计步骤</h2><p>打开文本编辑器<br>编辑Java应用程序<br>保存Java源程序<br>使用javac命令编译源程序<br>使用java命令运行Java程序</p><h2 id="回顾—Java应用程序"><a href="#回顾—Java应用程序" class="headerlink" title="回顾—Java应用程序"></a>回顾—Java应用程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldApp</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;      </span><br><span class="line">          System.out.println(“Hello World!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑存盘：文件名和公共类名(用public声明)要一致 HelloWorldApp.java<br>编译程序：javac HelloWorldApp.java<br>运行程序：java HelloWorldApp<br>运行结果：Hello World!</p><h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><h3 id="掌握Java中基本数据类型"><a href="#掌握Java中基本数据类型" class="headerlink" title="掌握Java中基本数据类型"></a>掌握Java中基本数据类型</h3><p>来源：<a href="https://blog.csdn.net/hs2201056/article/details/58680629" target="_blank" rel="noopener">https://blog.csdn.net/hs2201056/article/details/58680629</a></p><p>1.布尔型—–boolean，boolean 类型所占存储空间的大小没有明确指定，其取值为true或false,其默认值为false。</p><p>2.字节型—-byte，byte 类型所占存储空间大小为1个字节，其取值为-128——127，其默认值为0。</p><p>3.整型——int，int类型所占存储空间大小为4个字节，其取值为-2^31——2^31-1，其默认值为0。</p><p>4.短整型—–short，short类型所占存储空间大小为2个字节，其取值为-2^15——2^15-1，其默认值为0。</p><p>5.长整型—–long，long类型所占存储空间大小为8个字节，其取值为-2^63——2^63-1，其默认值为0。</p><p>6.字符型—–char，char类型所占存储空间大小为2个字节，其默认值为\u0000。</p><p>7.单精度浮点型—–float，float类型所占存储空间大小为4个字节，其取值为-2^128——2^128，其默认值为0.0F。</p><p>8.双精度浮点型—–double，double类型所占存储空间大小为8个字节，其取值为-2^1024——2^1024，其默认值为0.0D。</p><p>掌握Java中各种运算符的使用<br>掌握Java的控制结构<br>理解结构化程序设计方法</p><h2 id="教学重难点"><a href="#教学重难点" class="headerlink" title="教学重难点"></a>教学重难点</h2><p>重点<br>Java的基本数据类型<br>Java的控制结构</p><p>难点<br>Java程序控制结构</p><h2 id="Java的标示符和关键字"><a href="#Java的标示符和关键字" class="headerlink" title="Java的标示符和关键字"></a>Java的标示符和关键字</h2><h3 id="标识符可以用来标识变量名、类名、类中的方法名和文件名等"><a href="#标识符可以用来标识变量名、类名、类中的方法名和文件名等" class="headerlink" title="标识符可以用来标识变量名、类名、类中的方法名和文件名等."></a>标识符可以用来标识变量名、类名、类中的方法名和文件名等.</h3><ul><li>标识符组成: (1) 字母, (2)数字, (3)下划线“_” 和 (4)美元符号“$”; </li><li>首字符必须是(1) 字母, (2)下划线“_” 和 (3)美元符号“$”;</li><li>所有标识符是区分大小写的;</li><li>除去关键字、false、true和null;</li></ul><h3 id="具有特殊含义的字符序列"><a href="#具有特殊含义的字符序列" class="headerlink" title="具有特殊含义的字符序列"></a>具有特殊含义的字符序列</h3><p>例如： public、 static和class<br>具有特殊用途，不能作为变量名、方法名和类名</p><h2 id="Java的关键字"><a href="#Java的关键字" class="headerlink" title="Java的关键字"></a>Java的关键字</h2><p>abstract continue for new switch<br>assert default goto package synchronized<br>boolean do if private this<br>break double implements protected throw<br>byte else import public throws<br>case extends int short try<br>char final interface static void<br>class finally long strictfp volatile<br>const float native super while</p><h2 id="Java的数据类型"><a href="#Java的数据类型" class="headerlink" title="Java的数据类型"></a>Java的数据类型</h2><p>数据类型：</p><ol><li><p>基本数据类型：<br>布尔（boolean）:</p><p>数据类型：<br>定点类型：<br> 字符（char）<br> 字节（byte）<br> 短整数（short）<br> 整数（int）<br> 长整数（long）</p><p>浮点类型：<br> 单精度（float）<br> 双精度浮点数（double）</p></li><li><p>引用数据类型：<br>类或枚举或接口<br>数据</p></li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li><p>变量在计算机内部对应着一个存储单元，而且总是具有某种数据类型：基本数据类型或引用数据类型</p></li><li><p>变量总是具有与其数据类型相对应的值</p></li><li><p>每个变量均具有: 名字、类型、一定大小的存储单元以及值</p></li></ul><p>变量名对应内存的位置</p><h2 id="Java变量必须属于某种类型"><a href="#Java变量必须属于某种类型" class="headerlink" title="Java变量必须属于某种类型"></a>Java变量必须属于某种类型</h2><p>变量值也必须与变量类型相匹配<br>例如:<br>int studentNumber;       // 声明单个变量<br>double velocity, distance;     // 声明多个变量<br>studentNumber=30;    // 给变量赋以整数30<br>int studentNumber=30;// 声明变量，并赋初值</p><h2 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h2><p>int sum = 0;<br>String s = “Hello World!”;</p><h2 id="Java直接量（常量）"><a href="#Java直接量（常量）" class="headerlink" title="Java直接量（常量）"></a>Java直接量（常量）</h2><p>Java直接量包括基本数据类型直接量、字符串(String)直接量和null </p><p>布尔(boolean)直接量只有两个：true 和 false</p><p>‘c’,  ‘\u0061’, ‘\u0051’ 和 ‘\u005a’ 是char直接量.</p><p>34是int直接量</p><p>1.5, 45.6, 76.4E8和-32.0是double直接量</p><p>34L是long直接量. </p><p>1.5F, 45.6f, 76.4E8F和-32.0F是float直接量</p><p>“Hello World!”是String直接量</p><p>null是引用数据类型的直接量</p><p>任意引用数据类型的直接量(null)</p><h2 id="Java转义字符"><a href="#Java转义字符" class="headerlink" title="Java转义字符"></a>Java转义字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;\b&apos; (退格)</span><br><span class="line">&apos;\f&apos; (换页)</span><br><span class="line">&apos;\n&apos; (换行)</span><br><span class="line">&apos;\r&apos; (回车)</span><br><span class="line">&apos;\t&apos; (水平制表符(到下一个tab位置))</span><br><span class="line">&apos;\&apos; &apos; (单引号)</span><br><span class="line">&apos;\&quot; &apos; (双引号) </span><br><span class="line">&apos;\\&apos; (反斜杠)</span><br></pre></td></tr></table></figure><h2 id="Java运算符"><a href="#Java运算符" class="headerlink" title="Java运算符"></a>Java运算符</h2><p>算术运算符<br>关系运算符<br>布尔逻辑运算符<br>位运算符<br>赋值类运算符<br>条件运算符<br>其他运算符</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符包括：+, -, *, /, ++, –, %</p><ul><li>没有指数运算<br>  Math.pow(2.0, 3.0);  // 2.03.0</li><li>整数除法：截去余数<br>  7 / 5 结果为 1</li><li>取模：返回余数<br>  7 % 5 结果为 2</li></ul><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>六个关系运算符: &lt;、 &gt;、&lt;=、&gt;=、== 和 !=</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &gt; 2;                           // false</span><br><span class="line">3.5 != 1;                       // true </span><br><span class="line">51.5 &gt;= 23.0;    // true</span><br><span class="line">540 &lt;= 654;            // true</span><br><span class="line">24 == 3*8;                   // true</span><br><span class="line">boolean test1=(10 &lt; 10);       // test1= false;</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>六个布尔逻辑运算符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &amp; (逻辑 与 AND)</span><br><span class="line"> |   (逻辑 或 OR)</span><br><span class="line"> ^  (逻辑 异或 XOR )</span><br><span class="line"> ! (逻辑 非 NOT)</span><br><span class="line"></span><br><span class="line">单目运算符, 即只有一个操作数</span><br><span class="line"></span><br><span class="line"> &amp;&amp; (条件 与 AND) </span><br><span class="line"> || (条件 或 OR)</span><br></pre></td></tr></table></figure></p><h2 id="短路规则-amp-amp-和"><a href="#短路规则-amp-amp-和" class="headerlink" title="短路规则 ( &amp;&amp;和|| )"></a>短路规则 ( &amp;&amp;和|| )</h2><p>如果从第一个操作数可以推断出表达式结果，就不再计算第二个操作数<br>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((x == 2) &amp;&amp; (y != 2))</span><br><span class="line">System.out.println(&quot;两个条件都为 true.&quot;);</span><br></pre></td></tr></table></figure><h2 id="逻辑运算-amp-和"><a href="#逻辑运算-amp-和" class="headerlink" title="逻辑运算( &amp;和| )"></a>逻辑运算( &amp;和| )</h2><p>两个操作数均会被运算 (即不采用短路规则)<br>用不用短路规则，副作用不同<br>例如, </p><blockquote><p>(birthday == true) | (++age &gt;= 65)</p></blockquote><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符“? :”的表达式形式为“op1 ? op2 : op3”<br>op1:布尔表达式<br>例如:</p><blockquote><p>int k= ( (i&gt;=0) ? 1 : -1);</p></blockquote><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><ul><li><p>顺序结构<br>Java最基本的结构</p></li><li><p>选择结构<br>三种类型:  if、if/else和switch </p></li><li><p>循环结构<br>三种类型:  for、while和do/while</p></li></ul><h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><p>if-else语句的格式是:<br>if (布尔表达式)<br>    语句1或语句块1<br>else<br>    语句2或语句块2</p><p>例：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> if (grade&gt;60)</span><br><span class="line">System.out.println(&quot;Passed!&quot;);</span><br><span class="line"> else</span><br><span class="line">System.out.println(&quot;Failed!&quot;);</span><br></pre></td></tr></table></figure><h3 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h3><p>格式:<br>    for (表达式1;表达式2;表达式3)<br>    语句或语句块</p><h3 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h3><p>while循环语句格式为：</p><p>while (布尔表达式)<br>    语句或语句块</p><p>当条件(布尔表达式)为true ，则不断地执行语句或语句块</p><ul><li>“while” 循环中止条件是布尔表达式变为false</li><li>如果布尔表达式一开始就为false，则不执行循环体</li></ul><h2 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h2><p>1,从“最简单”的基本结构出发<br>2，任何一个矩形都能分解成两个顺行的矩形<br>3，任何一个矩形都可以用前的控制结构替换<br>4,2,3，可以不断地进行下去，直接完成程序设计</p><p>学习目的</p><p>主要讨论: 标识符数据类型运算符与表达式流程控制语句 </p><p>主要目的是对程序中所使用的各类符号及其使用规则有一个基本认识,建立程序设计的基本概念,初步掌握简单程序设计方法.</p><p>基本要求</p><p>掌握标识符的命名规则和常用关键字,运算符及注释符.<br>重点掌握常量,变量,数据类型的基本概念.<br>重点掌握各类运算符在复合表达式中的运算优先顺序.<br>掌握Java基本语法，能够编写简单的Java application和Java Applet程序.</p><h2 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h2><p>2.1  一个简单的例子<br>2.2  标识符<br>2.3  数据类型<br>2.4  运算符与表达式<br>2.5  流程控制语句 </p><p>实训二  结构化程序设计<br>习题二    </p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>Sun公司在开发Java语言时是以C/C++语言为基础进行的，因此，Java语言的基本语法，如变量声明、方法调用中的参数传递、运算符、流程控制结构等，都与C/C++语言非常相似。</p><p>下面首先给出一个简单的程序，通过该程序读者可以对Java语言的基本语法有一个大致的了解。</p><p>【程序2.1】  Fibonacci数列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Fibonacci &#123;</span><br><span class="line">//输出Fibonacci数列中值小于50的值</span><br><span class="line">public static void main(String []args) &#123;</span><br><span class="line">int lo = 1;</span><br><span class="line">int hi = 1;</span><br><span class="line">        System.out.println(lo);</span><br><span class="line">       while(hi &lt; 50)&#123;</span><br><span class="line">        System.out.println(hi);</span><br><span class="line">hi = lo + hi;</span><br><span class="line">lo = hi - lo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序输出Fibonacci数列，从中可以看出Java语言与C语言的相似性，不过Java在继承C语言语法时很多方面都有所改进，学习时应特别注意。</p><h2 id="标-识-符"><a href="#标-识-符" class="headerlink" title="标  识  符"></a>标  识  符</h2><p>Java字符集</p><p>与C语言或其他传统的高级程序设计语言不同，Java语言的基本符号采用Unicode字符集，而不是ASCII字符集，以方便支持多语种。</p><p>在Unicode字符集中，字母不仅仅限于英语，还包括其他语言的字符，包括汉字。Unicode字符集采用16位编码，一个字符在内存中占用两个字节。虽然现有的多数程序使用ASCII编码，但在运行前都被转换为Unicode字符。</p><h3 id="标识符构成规则"><a href="#标识符构成规则" class="headerlink" title="标识符构成规则"></a>标识符构成规则</h3><p>标识符是变量、类、方法、标号及其他各种用户自定义对象的命名。Java语言的标识符可以由字母、数字、下划线或$符号组成，以字母、下划线或$符开头，区分大小写，对标识符的长度没有特别限定。</p><p>Unicode字符集中的字母包括英文字母以及序号大于十六进制数0xC0的字符，因此可以使用汉字作标识符。以下都是合法的Java语言标识符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量1，$Str，_var1，myVar</span><br></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>与大多数程序设计语言一样，Java语言也有一些系统保留的标识符，称为关键字或保留字。</p><p>目前Java语言用到的关键字有：</p><p>abstract、boolean、break、byte、byvalue、case、catch、char、class、continue、default、do、double、else、extends、final、finally、float、for、if、implements、import、inner、instanceof、int、interface、long、native、new、null、package、private、protected、public、return、short、static、super、switch、synchronized、this、throw、throws、transient、try、var、volatile、void、while。</p><p>cast、const、future、generic、goto、operator、outer、rest等也被列为系统保留字，但目前的Java规范并未用到。另外，在Visual J++中true和false也作为关键字使用。</p><h2 id="数-据-类-型"><a href="#数-据-类-型" class="headerlink" title="数 据 类 型"></a>数 据 类 型</h2><p>Java语言的数据类型与C语言有相似之处，但对C语言的数据类型作了一定的简化。C中的一些数据类型在Java语言中不再支持，如结构体、枚举类型、共用体、指针等，但增加了布尔类型。Java语言在对数据的类型检查方面总的来说要比C语言更严格。</p><p>Java语言支持的数据类型包括简单数据类型，如整型、实型、字符型、布尔型，以及复合数据类型类与接口。下面首先介绍简单数据类型。</p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Java语言的整型分为byte、short、int、long四种</p><p>与C语言相似，Java语言中的数据也分为常量和变量，常量在程序执行的过程中其值不可改变，而变量的值可以改变。</p><h3 id="Java语言中的常量分为两种："><a href="#Java语言中的常量分为两种：" class="headerlink" title="Java语言中的常量分为两种："></a>Java语言中的常量分为两种：</h3><p>一种称为直接量，其字面代表了该常量的值；</p><p>另一种用标识符表示，定义方法与变量的定义类似，只是需要用关键字final修饰，表示该数据在执行过程中不可修改，Java语言编译器会作相应的检查，如果发现程序中有改变该常量值的语句，编译器将指出错误。</p><p>Java语言中的整型直接量可以用十进制、八进制和十六进制表示。</p><p>十进制表示方法最为常见，如：123、-780。</p><p>在书写十进制常量时，注意不能以0为打头字符，因为Java语言中以0开始的整型常量被当作八进制处理，例如：017、-0234，都是八进制表示的整型常量。</p><p>八进制数据使用的数字字符只能是0～7，不能出现8、9。</p><p>十六进制整型常量以0x或0X开始，例如：0x123、0X1AB，十六进制数据使用的数字字符是0～9和A～F(或a~f)。</p><p>整型常量中，byte、short、int表示方法相同，而长整型(long)常量必须在数后加字母L或l，表示该数是长整型，例如：0L、306l。<br>整型变量的定义与C语言相似 ，例如：</p><p>byte b; //指定变量b为byte型<br>short s; //指定变量s为short型<br>int i; //指定变量i为int型<br>long l; //指定变量l为long型</p><p>Java语言中的变量与C/C++程序一样，也必须先定义后才能使用，同样，它们也有各自的作用域。</p><p>Java语言中的变量定义有两种形式：</p><p>一种是类的成员；</p><p>另一种是局部变量，在方法或复合语句(由大括号括起的若干语句)中定义，分别在所定义的方法或复合语句中起作用，与C语言的局部变量类似。</p><p>变量定义的时候可以赋初值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int k=20;</span><br><span class="line">long x=200L,y=150L;</span><br></pre></td></tr></table></figure><p>用标识符定义常量的方法与变量的定义方法相似，用标识符定义常量时必须赋初值。例如：</p><p>final int IntVar=200;</p><p>有些教材将用这种方法定义的常量称为final变量或只读变量。</p><h2 id="实型"><a href="#实型" class="headerlink" title="实型"></a>实型</h2><p>Java语言的实型数据分为<br>单精度实数(float)和双精度实数(double)两种，<br>分别为32位和64位IEEE754-1985标准浮点数。</p><p>与C语言相同，Java的实型常量有两种表示形式：</p><p>(1) 十进制数形式。</p><p>十进制数形式由数字和小数点组成，且必须有小数点，如0.123、.123、123.、123.0。</p><p>(2) 科学计数法形式。</p><p>如：123e3或123E3，其中e或E之前必须有数字，且e或E后面的指数必须为整数。</p><p>实型常量缺省为double型，如果希望声明某个实型常量为float型，则要在数字后加f或F，如12.3F，它在机器中占4个字节，精度较低。</p><p>实型变量的定义与C语言类似，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float f=2.3f;  //指定变量f为float型</span><br><span class="line">double d=2.3;  //指定变量d为double型</span><br></pre></td></tr></table></figure><p>Java语言对数据类型的检查比C语言更严格，不允许用双精度的常量初始化单精度变量，因此下面的变量定义语句是错误的：</p><blockquote><p>float f=1.23;</p></blockquote><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p>Java语言使用Unicode字符集，因此其字符型数据在内存中占用2个字节，共16位，其范围为0～65 535。</p><p>字符常量是用单引号括起来的一个字符，如’a’、’A’。另外，与C语言相同，Java语言也使用转义字符，以反斜杠()开头，其后的字符转变为另外的含义。</p><p>字符型的类型标识符为char，下面是字符型变量的定义的例子：</p><p>char c=’a’；//指定变量c为char型，且赋初值为’a’<br>与C语言不同，Java语言不允许将字符型变量用作整型，因为Java不提供无符号整数类型，但可与整型进行混合运算。例如：<br>int i=’A’;<br>是非法的，而下面的语句是合法的：<br>int i=3;<br>i=i+’0’;</p><p>与C相同，Java语言用双引号(“)括起一串字符表示字符串常量，如”This is a string.\n”。但不同的是，Java中的字符串常量是作为字符串类String的一个对象来处理的，而不是一个字符数组。</p><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>与C语言不同，Java语言引入了布尔类型用以表示关系运算和逻辑运算的结果，布尔型数据只有两个值true和false。</p><p>布尔型变量用关键字boolean定义，例如：</p><p>boolean b=true；//定义b为布尔型变量，且初值为true<br>布尔型数据不可作为整型数据使用，不同于C语言中的0和非0。Java语言中应该使用布尔型数据的地方，不可使用其他类型的数据。</p><h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2><p>概述</p><p>运算符是指明对操作数所进行的运算的符号。按操作数的数目来分，可以有单目运算符、双目运算符和三目运算符，它们分别对应于一个、两个和三个操作数。Java语言中的运算符按照功能来分有下面几类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1) 算术运算符：+，-，*，/，%，++，- -；</span><br><span class="line">(2) 关系运算符：＞，＜，＞=，＜=，= =，!= ；</span><br><span class="line">(3) 布尔逻辑运算符：!，&amp;&amp;，||，&amp;，|；</span><br><span class="line">(4) 位运算符：＞＞，＜＜，＞＞＞，&amp;，|，^，～；</span><br><span class="line">(5) 赋值运算符：=，复合赋值运算符如+=；</span><br><span class="line">(6) 条件运算符：?: ；</span><br><span class="line">(7) 其他运算符：包括分量运算符，下标运算符[]，实例运算符instanceof，内存分配运算符new，强制类型转换运算符(类型)，方法调用运算符()等。</span><br><span class="line"></span><br><span class="line">Java程序通过各种不同的运算符与操作数连接起来构成的表达式完成各种运算。</span><br></pre></td></tr></table></figure></p><h2 id="算术运算符-1"><a href="#算术运算符-1" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符是最基本的运算符，Java语言的算术运算符与C语言的算术运算符非常相似。</p><p>Java语言中算术运算符的优先级和结合性与C语言相同。</p><p>Java语言对运算符+的功能进行了扩展，使它能够进行字符串的连接，如“abc”+“de”,得到串“abcde”。</p><p>另外，与C语言不同，取模运算符%操作数可以为浮点数，如37.2%10=7.2。</p><h3 id="其他需要注意的几点与C语言相同："><a href="#其他需要注意的几点与C语言相同：" class="headerlink" title="其他需要注意的几点与C语言相同："></a>其他需要注意的几点与C语言相同：</h3><p>(1) 除法运算。当两个运算对象均为整型数据时，作整除运算。</p><p>(2)  i++与++i的区别。</p><p>i++在使用i之后，使i的值加1，因此执行完i++后，整个表达式的值为原来i的值，而i的值加1。</p><p>++i在使用i之前，使i的值加1，因此执行完++i后，整个表达式和i的值均为i原来的值加1。</p><p>i–与–i的运算方式与++运算符相似。<br>++、–运算符只能对变量进行操作。</p><p>【程序2.2】  算术运算符的使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ArithmaticOp&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">int a=5+4;//a=9</span><br><span class="line">int b=a*2;//b=18</span><br><span class="line">int c=b/4;//c=4</span><br><span class="line">int d=b-c;//d=14</span><br><span class="line">int e=-d;//e=-14</span><br><span class="line">int f=e%4;//f=-2</span><br><span class="line">double g=18.4;</span><br><span class="line">double h=g%4;//h=2.4</span><br><span class="line">int i=3;</span><br><span class="line">int j=i++;//i=4,j=3</span><br><span class="line">int k=++i;//i=5,k=5</span><br><span class="line">System.out.println(&quot;a=&quot;+a);</span><br><span class="line">System.out.println(&quot;b=&quot;+b);</span><br><span class="line">System.out.println(&quot;c=&quot;+c);</span><br><span class="line">System.out.println(&quot;d=&quot;+d);</span><br><span class="line">System.out.println(&quot;e=&quot;+e);</span><br><span class="line">System.out.println(&quot;f=&quot;+f);</span><br><span class="line">System.out.println(&quot;g=&quot;+g);</span><br><span class="line">System.out.println(&quot;h=&quot;+h);</span><br><span class="line">System.out.println(&quot;i=&quot;+i);</span><br><span class="line">System.out.println(&quot;j=&quot;+j);</span><br><span class="line">System.out.println(&quot;k=&quot;+k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>与C语言一样，Java语言将赋值作为一种运算符处理。赋值运算的功能是将一个数据或表达式的值赋给一个变量。赋值运算符是双目运算符，左边的操作数必须是变量。</p><p>Java语言的赋值运算符可以分为两种：<br>基本赋值运算符和复合赋值运算符。</p><p>所有赋值运算符的优先级都相同，与其他运算符相比，赋值运算符的优先级最低。</p><p>基本赋值运算符是最简单的赋值运算符，格式为</p><blockquote><p>变量名=表达式</p></blockquote><p>先计算表达式，再将结果赋给变量，整个赋值表达式的值为赋值后变量的值。使用赋值运算符时，应尽量使变量和表达式的数据类型一致，否则，先将表达式的值转换为变量的数据类型再赋值。</p><p>复合赋值运算符是在基本运算符的基础上加上另一个运算符，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x*=a-b</span><br></pre></td></tr></table></figure><p>这个表达式与下面的表达式等价：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=x*(a-b)</span><br></pre></td></tr></table></figure><p>先计算复合赋值运算符右边的表达式，然后在变量与该表达式的值进行指定的运算后将结果赋给变量。</p><p>常见的双目算术运算符如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+、-、*、/、%</span><br></pre></td></tr></table></figure></p><p>以及下面将介绍的位运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;、&lt;&lt;、&amp;、|、^</span><br></pre></td></tr></table></figure></p><p>等都可以构成复合赋值运算符。</p><h2 id="关系运算符-1"><a href="#关系运算符-1" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符用来比较两个值，Java语言关系运算的结果为布尔类型的值true或false，而不是C / C++中的1或0。</p><h2 id="逻辑运算符-1"><a href="#逻辑运算符-1" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>Java语言的逻辑运算符只能对布尔型的数据进行运算</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在编程时，经常会出现不同类型的数据进行混合运算的情况，运算前应将不同类型的数据转换为相同类型。</p><h3 id="类型转换有两种方法："><a href="#类型转换有两种方法：" class="headerlink" title="类型转换有两种方法："></a>类型转换有两种方法：</h3><p>自动类型转换和强制类型转换。</p><p>整型、实型、字符型等数据混合运算时，Java语言编译器可以对它们进行自动类型转换。转换规则类似于C语言，从低级数据类型转换为高级数据类型：</p><p>(1)  (byte或short) op int→int；<br>(2)  (byte或short或int) op long→long；<br>(3)  (byte或short或int或long) op float→float；<br>(4)  (byte或short或int或long或float) op double→double；<br>(5)  char op int→int。</p><p>这里箭头左边表示参与运算的数据类型，op为运算符(如加、减、乘、除等)，右边表示转换后进行运算的数据类型。</p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>(1) 布尔型数据的使用；<br>(2) Java语言不再使用goto语句；<br>(3) 带标号的break和continue。</p><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><p>分支语句提供了一种控制机制，使得程序可以根据指定的条件选择执行部分语句或跳过某些语句不执行。</p><p>Java语言提供了两种分支语句：if-else、switch。</p><h2 id="条件语句if-else"><a href="#条件语句if-else" class="headerlink" title="条件语句if-else"></a>条件语句if-else</h2><p>if-else语句<br>根据判定条件的真假来执行两种操作中的一种，格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)</span><br><span class="line">语句1</span><br><span class="line">[ else</span><br><span class="line">语句2]</span><br><span class="line">其中，else子句是任选的，可以不出现。</span><br></pre></td></tr></table></figure><p>【程序2.5】  判断某一年是否为闰年。<br>闰年的条件是符合下面二者之一：<br>①能被4整除，但不能被100整除；<br>②能被4整除，又能被100整除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LeapYear&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">int year=2003;</span><br><span class="line">boolean leap;</span><br><span class="line">if(year%4!=0)</span><br><span class="line">leap=false;</span><br><span class="line">else if(year%100!=0)</span><br><span class="line">leap=true;</span><br><span class="line">else if(year%400!=0)</span><br><span class="line">leap=false;</span><br><span class="line">else</span><br><span class="line">leap=true;</span><br><span class="line">if(leap)</span><br><span class="line">System.out.println(year+&quot; is a leap year.&quot;);</span><br><span class="line">else </span><br><span class="line">System.out.println(year+&quot;is not a leap year.&quot;);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多分支语句switch"><a href="#多分支语句switch" class="headerlink" title="多分支语句switch"></a>多分支语句switch</h2><p>switch语句根据指定表达式的值来执行多个操作中的一个，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch (表达式)&#123;</span><br><span class="line">case  值1：语句段1；</span><br><span class="line">case  值2：语句段2 </span><br><span class="line">case 值N：语句段N</span><br><span class="line">[default：语句段N+1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句的作用是反复执行一段代码，直到满足终止循环的条件为止。Java中提供的循环语句有while语句、do-while语句和for语句.</p><p>1．while语句<br>while语句实现“当型”循环，格式为<br>while (布尔表达式)循环体</p><h2 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h2><p>do-while语句实现“直到型”循环，格式为：</p><p>do<br>循环体<br>while (布尔表达式);</p><p>do-while语句首先执行循环体，然后计算布尔表达式。如果布尔表达式的值为true，则重复上述过程，直到布尔表达式的结果为false。与while语句不同的是，do-while语句的循环体至少执行一次。</p><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>for语句也用来实现“当型”循环，它的一般格式为：</p><p>for (初始化表达式;布尔表达式;增量表达式)<br>循环体</p><p>for语句首先计算初始化表达式，然后判断布尔表达式的值是否为true，如果为true，则执行循环体中的语句，最后计算增量表达式。完成一次循环后，重新判断终止条件。</p><h2 id="结构化程序设计-1"><a href="#结构化程序设计-1" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h2><p>一、实训目的<br>1．理解定义变量的作用并掌握其方法。<br>2．掌握各种基本数据类型及其运算。<br>3．掌握表达式的使用和各种运算符的优先级控制。<br>4．掌握结构化程序设计的分支结构。<br>5．学习用if-else语句实现单分支。<br>6．学习用if-else语句和switch语句实现多分支。<br>7．掌握结构化程序设计的循环结构。<br>8．学习使用while语句、do-while语句和for语句实现循环。<br>9．学习控制循环终止条件，包括循环的正常退出和使用continue语句和break语句。</p><p>二、实训内容<br>1．使用if-else语句判断并输出今天是星期几。<br>提示：用Date类获取有关的信息，首先引入Date类：<br>import java.Util.Date;<br>然后创建一个Date类对象，并获取信息：<br>Date day=new Date();<br>int today = day.getDay()；//0表示为星期天，1表示为星期一……<br>2．使用switch语句完成上面的功能。<br>3．编写Java应用程序，找出所有的水仙花数并输出。水仙花数是三位数，它的各位数字的立方和等于这个三位数本身，例如371＝33+73+13，371就是一个水仙花数，请分别用while循环和for循环实现。<br>4．编写Java应用程序，找出所有符合下列条件的a、b、c：a、b、c为三个200～300之间的整数，其和为452。</p><h2 id="JAVA语言基本语法"><a href="#JAVA语言基本语法" class="headerlink" title="JAVA语言基本语法"></a>JAVA语言基本语法</h2><p>标识符、关键字和数据类型</p><h3 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h3><h3 id="Java程序开发过程-1"><a href="#Java程序开发过程-1" class="headerlink" title="Java程序开发过程"></a>Java程序开发过程</h3><p>编写Java源文件（可用文本编辑工具），文件名与类名相同<br>编译生成字节码文件（.class）(javac.exe命令)<br>解释执行字节码文件中的类（java.exe命令）</p><h3 id="环境变量的设置（path、classpath）"><a href="#环境变量的设置（path、classpath）" class="headerlink" title="环境变量的设置（path、classpath）"></a>环境变量的设置（path、classpath）</h3><ul><li>Win2000</li><li>命令窗口</li></ul><h3 id="Java程序的种类"><a href="#Java程序的种类" class="headerlink" title="Java程序的种类"></a>Java程序的种类</h3><ul><li>Application应用程序</li><li>Applet小程序</li></ul><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>集成开发环境:Jcreater<br>一个Applet小程序<br>标识符<br>关键字<br>数据类型</p><h2 id="Jcreater-pro"><a href="#Jcreater-pro" class="headerlink" title="Jcreater pro"></a>Jcreater pro</h2><p>一个类似于TC的Java集成开发环境<br>可以方便地编写java源文件<br>可以方便地编译、运行Java程序<br>Jcreater不是免费的软件<br>安装时，可以先安装SDK，然后再安装Jcreater<br>使用时注意：<br>创建文件时，注意只需创建java文件，不用创建java项目，注意文件的命名和文件的保存路径。</p><h2 id="Applet小程序的开发过程"><a href="#Applet小程序的开发过程" class="headerlink" title="Applet小程序的开发过程"></a>Applet小程序的开发过程</h2><p>编写源文件（Applet源程序）<br>编译生成字节码文件（.class）<br>编写html文件，将字节码文件嵌入其中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;applet code=“Boy.class”  height=&quot;120&quot; width=&quot;300&quot;&gt;&lt;/applet&gt;</span><br></pre></td></tr></table></figure></p><p>用浏览器打开html文件，即可自动调用Applet小程序并解释执行。<br>或是appletviewer调用html文件</p><h2 id="Java的Applet小程序"><a href="#Java的Applet小程序" class="headerlink" title="Java的Applet小程序"></a>Java的Applet小程序</h2><p>一个Java Applet程序也由若干个类组成，最简单的为一个类。<br>一个Applet小程序不需要main方法，但是必须有一个主类是Applet的子类。<br>如果要在窗口中绘制文字、图像，paint()方法是必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.applet.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">public class BoyApplet extends Applet//从Applet类继承而来</span><br><span class="line">&#123;</span><br><span class="line">public void paint(Graphics g)//paint方法用来绘制屏幕</span><br><span class="line">&#123;</span><br><span class="line">g.setColor(Color.red);//设置文字颜色为红色</span><br><span class="line">g.drawString(&quot;我一边喝着咖啡，一边学Java呢&quot;,5,30);</span><br><span class="line">g.setColor(Color.blue);//设置文字颜色为兰色</span><br><span class="line">g.drawString(&quot;我学得很认真！&quot;,10,50);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>分隔符：注释、空白、普通<br>注释符（软件编码规范中说：“可读性第一，效率第二”，注释一般占程序代码的20%-50%）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//  ：单行注释</span><br><span class="line">/*  */  ：多行注释</span><br><span class="line">/**   */：文档注释，可被解释成程序的正式文档</span><br></pre></td></tr></table></figure><p>空白：空格、回车、制表</p><h2 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h2><p>java中的包、类、方法、参数、变量等的名字</p><p>由大小写字母、数字、下划线、美元$组成，但不能以数字开头。<br>不能是Java中的关键字。</p><p>这里的字母也包括世界上任何国家的“字母表”中的字符，比如汉字、日文等。不建议使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：Inner$1、123、java hello、user_name、user-name</span><br></pre></td></tr></table></figure><h2 id="关键字、标识符的命名习惯"><a href="#关键字、标识符的命名习惯" class="headerlink" title="关键字、标识符的命名习惯"></a>关键字、标识符的命名习惯</h2><h2 id="关键字全部小写"><a href="#关键字全部小写" class="headerlink" title="关键字全部小写"></a>关键字全部小写</h2><p>具有专门的意义和用途，不能当作一般的标识符使用，这些标识符称为保留字(reserved word)（P11）</p><h2 id="标识符命名习惯"><a href="#标识符命名习惯" class="headerlink" title="标识符命名习惯"></a>标识符命名习惯</h2><p>类、接口名：每个词的首字母都要大写<br>方法、变量名：首字母要小写，其它单词首字母要大写<br>常量：字母全部大写，单词之间用下划线分隔<br>观察一个java程序，识别哪个标识符是类或接口名，哪个标识符是变量或方法名。</p><h2 id="Java语言的数据类型"><a href="#Java语言的数据类型" class="headerlink" title="Java语言的数据类型"></a>Java语言的数据类型</h2><p>数据类型概述<br> 基本数据类型<br>  数值<br>  整数：byte、short、int、long：8，16，32，64<br>  浮点：float、double：32，64<br>  字符：char：16<br>  逻辑：boolean：1<br> 引用数据类型：类、数组、接口</p><h2 id="数据类型—常量数据及变量声明"><a href="#数据类型—常量数据及变量声明" class="headerlink" title="数据类型—常量数据及变量声明"></a>数据类型—常量数据及变量声明</h2><p>常量数据</p><ul><li>整型： 23(十进制)、 0X63(十六进制) 、063(八进制)</li><li>长整型：25L</li><li>浮点常量：小数常量默认为是double型的，float类型后一定要加f(F)，34d、34.0是double类型常量，34f、34.0f是float类型常量。</li><li>逻辑常量：true、false</li><li>字符常量：’a’  ‘8’  ‘\n’  ‘我’ 都是字符常量（16进制表示的字符）占用两个字节，采用国际编码标准—Unicode码。</li><li>字符串常量：”a”  “dkdkdk\n” 。</li><li>null常量：表示对象的引用为空</li></ul><p>变量声明</p><ul><li>类型  变量名1[,变量名2][=变量初始值]；</li></ul><h2 id="基本数据类型的转换"><a href="#基本数据类型的转换" class="headerlink" title="基本数据类型的转换"></a>基本数据类型的转换</h2><h2 id="自动类型转换，表达式类型的自动提升"><a href="#自动类型转换，表达式类型的自动提升" class="headerlink" title="自动类型转换，表达式类型的自动提升"></a>自动类型转换，表达式类型的自动提升</h2><p>整形、实型、字符型数据可以进行混合运算。运算时，不同类型的数据先转化为同一类型，字符型会转换为数值型，然后进行运算。</p><ul><li>表达式的类型为存储长度最大，精度最高的数据类型。</li><li>当把级别低的表达式的值赋给级别高的变量时，系统会自动完成数据类型的转换。而级别高的表达式的值不能直接赋给级别低的变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：float f;  f=34*12;f=f+23.5;</span><br></pre></td></tr></table></figure><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>一般情况下，当精度高的类型向精度低的类型转换时，要明确指明，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double k=6;</span><br><span class="line">float b=(float)k;</span><br></pre></td></tr></table></figure></p><h2 id="JSP技术"><a href="#JSP技术" class="headerlink" title="JSP技术"></a>JSP技术</h2><p>Java Server Pages<br>基于Java Servlet以及整个Java体系的Web开发技术，利用这一技术可以创建安全、跨平台的动态网站。</p><h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p>训练目的</p><p>本次技能训练的目的是让学生掌握开发Applet小程序的过程。熟悉Java的数据类型、运算符和表达式，能熟练运用它们编写程序解决一定的问题。</p><p>训练内容及要求</p><p>1、编写、编译、运行一个java applet小程序，使用绿色字显示“你好，Java！我是XXX！”。<br>2、写出System.out.print()和System.out.println()的区别。<br>3、写出在实训过程遇到的问题和解决的办法，有哪些收获。</p><p>指导</p><p>（1）启动Jcreater，创建源文件（注意文件名与类名一致）保存到自己的工作目录中。<br>（2）使用训练Jcreater的菜单命令编译源文件。生成字节码文件。<br>（3）使用Jcreater创建一个html文件，并保存至自己的工作目录中，其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Applet code=”BoyApplet.class” width=”300” height=”300”&gt;&lt;/Applet&gt;</span><br></pre></td></tr></table></figure></p><p>其中BoyApplet.class要用你自己生成的字节码文件名代替。<br>（4）用浏览器打开html文件，观察运行效果。 </p><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><h3 id="了解类和对象的基本概念"><a href="#了解类和对象的基本概念" class="headerlink" title="了解类和对象的基本概念"></a>了解类和对象的基本概念</h3><p>来源：<a href="https://baike.baidu.com/item/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1394902?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1394902?fr=aladdin</a></p><p>类和对象（class）是两种以计算机为载体的计算机语言的合称。对象是对客观事物的抽象，类是对对象的抽象。类是一种抽象的数据类型。</p><p>它们的关系是，对象是类的实例，类是对象的模板。对象是通过new className产生的，用来调用类的方法;类的构造方法 。</p><h3 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h3><p>类，对象的定义</p><p>类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。</p><p>类是一种对数据的分装，我们可以理解为Java中的代码。</p><p>对象是具有类类型的变量。</p><blockquote><p>类和对象是面向对象编程技术中的最基本的概念。</p></blockquote><h2 id="类类型的声明"><a href="#类类型的声明" class="headerlink" title="类类型的声明"></a>类类型的声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class 类名</span><br><span class="line">&#123;</span><br><span class="line">    public：</span><br><span class="line">    公用的数据和成员函数</span><br><span class="line">    protected：</span><br><span class="line">    保护的数据和成员函数</span><br><span class="line">    private：</span><br><span class="line">    私有的数据和成员函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义对象方法"><a href="#定义对象方法" class="headerlink" title="定义对象方法"></a>定义对象方法</h2><p>1.先声明类类型，然后再定义对象<br>举例：Student stud1,stud2; //Student是已经声明的类类型<br>2.在声明类类型的同时定义对象 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Student//声明类类型</span><br><span class="line">&#123;</span><br><span class="line">    public://先声明公用部分</span><br><span class="line">    void display()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;″num:″&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;″name:″&lt;&lt;name&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;″sex:″&lt;&lt;sex&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    private://后声明私有部分</span><br><span class="line">    int num;</span><br><span class="line">    char name[20];</span><br><span class="line">    char sex;</span><br><span class="line">&#125;</span><br><span class="line">stud1，stud2;//定义了两个Student类的对象</span><br><span class="line">//在定义Student类的同时，定义了两个Student类的对象。</span><br></pre></td></tr></table></figure><p>3.不出现类名，直接定义对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> class//无类名</span><br><span class="line">&#123;</span><br><span class="line">    private://声明以下部分为私有的</span><br><span class="line">    ┆</span><br><span class="line">    public://声明以下部分为公用的</span><br><span class="line">    ┆</span><br><span class="line">&#125;</span><br><span class="line">stud1，stud2;//定义了两个无类名的类对象</span><br></pre></td></tr></table></figure><p>掌握类的定义方法<br>掌握对象的初始化<br>掌握类的成员函数的定义</p><h2 id="回顾—类的定义"><a href="#回顾—类的定义" class="headerlink" title="回顾—类的定义"></a>回顾—类的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[类的修饰字] class 类名称 [extends 父类名称][implements 接口名称列表]</span><br><span class="line">&#123;  </span><br><span class="line">    变量定义及初始化；</span><br><span class="line">    方法定义及方法体；</span><br><span class="line">&#125;</span><br><span class="line">类体，其中定义了该类中所有的变量和该类所支持的方法，称为成员变量和成员方法。</span><br></pre></td></tr></table></figure><h2 id="回顾—类的成员函数定义语法规范"><a href="#回顾—类的成员函数定义语法规范" class="headerlink" title="回顾—类的成员函数定义语法规范"></a>回顾—类的成员函数定义语法规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[方法修饰字] 返回类型  方法名称(参数1,参数2,…) [throws exceptionList]</span><br><span class="line">&#123;</span><br><span class="line">     …(statements;)    //方法体：方法的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[public | protected | private ] [static] [final | abstract] [native] [synchronized]</p><blockquote><p>返回类型可以是任意的Java数据类型，当一个方法不需要返回值时，返回类型为void。</p></blockquote><p>参数的类型可以是简单数据类型，也可以是引用数据类型（数组、类或接口），参数传递方式是值传递。</p><p>方法体是对方法的实现。它包括局部变量的声明以及所有合法的Java指令。局部变量的作用域只在该方法内部。</p><h2 id="回顾—对象的初始化"><a href="#回顾—对象的初始化" class="headerlink" title="回顾—对象的初始化"></a>回顾—对象的初始化</h2><p>（1）对象的生成<br>   通过new操作符生成一个对象；例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car demoCar;</span><br><span class="line">demoCar = new Car();</span><br></pre></td></tr></table></figure><p>（2）对象的构造过程</p><ul><li>为对象开辟空间，并对对象的成员变量进行缺省的初始化；</li><li>对成员变量进行指定的初始化；</li><li>调用构造方法。</li></ul><h2 id="教学内容和目标"><a href="#教学内容和目标" class="headerlink" title="教学内容和目标"></a>教学内容和目标</h2><p>掌握类的封装性</p><p>掌握类的继承性</p><h2 id="教学重难点-1"><a href="#教学重难点-1" class="headerlink" title="教学重难点"></a>教学重难点</h2><p>重点</p><ul><li>不同访问修饰符的应用</li><li>Java中类继承的定义</li></ul><p>难点</p><ul><li>类的继承特性</li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>“包”是由一组类和接口所组成的具有一定功能的集合</p><p>简单地说，将一组功能相关的类和接口打包起来形成的整体，就是包</p><p>两个类如果名字相同，只要所属的包不同，Java就会认为它们是不同的类</p><h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>在定义类或接口的源文件开始加入“package”关键字和包名，就将类或接口放到包里了</p><p>如果两个java源文件的开头都有相同的包名，则意味着这两个源文件中的所有类和接口都属于同一个包</p><h2 id="访问包中的类"><a href="#访问包中的类" class="headerlink" title="访问包中的类"></a>访问包中的类</h2><p>访问公开类的方法<br>(1) 用类的全名（包名+类名）访问；<br>(2) 导入包中的某个类；<br>(3) 导入包中的所有类。<br>如果某个类只访问一次，那么可以直接使用类的全名，形式是“包名.类名”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用“import”关键字导入一个类：</span><br><span class="line">import PackageName.ClassName;</span><br><span class="line"></span><br><span class="line">一次性导入所有类的方法：</span><br><span class="line">import PackageName.*;</span><br></pre></td></tr></table></figure><h2 id="管理Java的包"><a href="#管理Java的包" class="headerlink" title="管理Java的包"></a>管理Java的包</h2><p>Java系统建议的文件存储方式就是按照包名将源文件和二进制代码文件分级存放<br>将源文件放到与包名相同的路径下，包名对应子目录名</p><h2 id="使用Java的包"><a href="#使用Java的包" class="headerlink" title="使用Java的包"></a>使用Java的包</h2><p>设定Rectangle.java放在“graphics”子目录下<br>编译源文件的命令如下：<br>javac graphics\Rectangle.java</p><p>执行程序时，用小圆点“.”分隔包名和类：<br>java graphics.Rectangle</p><h2 id="CLASSPATH参数"><a href="#CLASSPATH参数" class="headerlink" title="CLASSPATH参数"></a>CLASSPATH参数</h2><p>如果你的Java包都放在一个固定的目录下，轻易不会改变它，那么你可以在操作系统中设置“CLASSPATH”环境变量</p><p>编译和运行Java程序时，不需要指定包路径参数，系统会自动从环境变量中读取</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装把对象的所有组成部分组合在一起</p><p>封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。</p><h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><p>封装性与访问级控制<br>类的一个优势在于类可以保护它的成员变量和成员函数不会被其它对象随意访问到<br>在Java程序里，可以为成员变量和函数设定四级访问级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private</span><br><span class="line">protected</span><br><span class="line">public</span><br><span class="line">default（缺省）</span><br></pre></td></tr></table></figure><h2 id="访问控制级别"><a href="#访问控制级别" class="headerlink" title="访问控制级别"></a>访问控制级别</h2><p>private（私有级）</p><ul><li>private是最严格的访问控制级</li><li>私有变量只能在它所在的类内部被访问到</li><li>它用于定义只在类内部使用的成员变量</li><li>成员变量，如果从外界随意改变它的值可能会造成不稳定的情况</li><li>成员函数，如果从外界调用，可能会危害到对象的状态或程序的运行</li></ul><p>protected（保护级）</p><ul><li>被定为保护级的成员可以被它所属的类、所属类的子类，以及处于同一个包里的其它类访问到</li><li>如果一个成员变量或成员函数可以被它的子类或相关的类访问，而不能被无关类访问的话，就可以用保护级</li><li>保护级就像家庭秘密，可以让家庭成员知道，也不介意让几个亲密朋友知道，但你不想让任何外人知道</li></ul><p>public（公开级）</p><ul><li>公开级是限制最少的访问级，任何类，不管它在哪个包里，都能够访问公开级的成员</li><li>公开级使用最方便，实际使用得也最多</li><li>需要注意的是：对于成员变量或成员函数，只有当你确认外界的类访问甚至修改它不会造成不希望的后果时，才使用公开级</li><li>公开级类似于公开张贴的信息，其中没有个人或家庭隐私，你不介意任何人知道</li></ul><p>default（缺省级）</p><ul><li>包访问级是成员的缺省访问级</li><li>如果没有定义访问级，那么它就是包访问级</li><li>权限：可以被属于同一个包的其它类所访问，但不能被其它包的类所访问</li><li>如果这个类的子类在其它包，则子类不能继承和访问父类中包访问级的成员</li><li>这一访问级假设在同一个包里的其它类都是可信任的朋友，但子类反而不能信任</li></ul><h2 id="类成员封装性总结"><a href="#类成员封装性总结" class="headerlink" title="类成员封装性总结"></a>类成员封装性总结</h2><p>public 同一个类，同一个包，子类，所有类<br>protected 同一个类，同一个包，子类<br>default 同一个类，同一个包<br>private 同一个类 </p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承性是面向对象程序设计语言的另一基本特征，通过继承可以实现代码的复用。继承而得到的类为子类，被继承的类为父类，父类包括所有直接或间接被继承的类。Java中不支持多重继承。通过在类的声明中加入extends子句来创建一个类的子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SubClass extends SuperClass</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以继承父类中访问权限设定为public、 protected、 default的成员变量和方法，但是不能继承访问权限为private的成员变量和方法。</p><p>一个类可以从另一个类中继承它的成员变量和函数，前者称为子类，后者称为父类。类的这种特点称为继承性</p><p>类的继承通过extends关键字来说明，extends关键字跟在类名称后面，形式如下：</p><p>class SubClass extends FatherClass { … }<br>其中SubClass是子类名，FatherClass是父类名</p><p>子类是作为另一个类的扩充或修正而定义的一个类。</p><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><p>类的继承性的特点</p><ul><li>在Java中，一个类只能有一个父类</li><li>Java只支持单继承，而不支持多重继承</li><li>单继承的类子代相承，会形成一棵继承树，结构较为清晰</li><li>多重继承会形成一张复杂的继承网，结构复杂，容易出错</li><li>如果需要多重继承，Java提供了一种接口技术，可以部分地实现多重继承的功能</li></ul><p>在Java中定义的所有类都直接或间接地是Object类的子类。以Object类为根，所有Java类形成一棵类继承树</p><h2 id="类的继承性的特点"><a href="#类的继承性的特点" class="headerlink" title="类的继承性的特点"></a>类的继承性的特点</h2><p>子类可以继承的部分：<br>(1) 父类中公开级的成员；<br>(2) 父类中保护级的成员；<br>(3) 如果子类和父类在同一个包里，则子类继承父类中缺省的包访问级的成员；</p><p>子类不能继承的部分：<br>(1) 父类中私有级的成员；<br>(2) 如果不在同一个包里，则缺省级的成员；<br>(3) 同名的成员函数或成员变量；</p><h2 id="构造函数的继承特点"><a href="#构造函数的继承特点" class="headerlink" title="构造函数的继承特点"></a>构造函数的继承特点</h2><p>父类相当于一个硬球，子类则是在球外的包装<br>构造对象时显然应当先构造最内部的硬球，也就是最顶端的父类<br>之后再从里往外一层层地构造外包装，直到最后整个对象都构造起来<br>如果父类的构造函数有参数，那么就需要用super关键字，它指代父类</p><p>何时选择继承?<br>一个很好的经验：“B是一个A吗?”<br>如果是则让B做A的子类.</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>3.1  面向对象的基本思想和基本概念<br>3.2  案例<br>3.3  类的声明与对象的创建<br>3.4  继承<br>3.5  包的使用<br>3.6  编程实例<br>实训三  面向对象程序设计<br>习题三 </p><h2 id="面向对象的基本思想和基本概念"><a href="#面向对象的基本思想和基本概念" class="headerlink" title="面向对象的基本思想和基本概念"></a>面向对象的基本思想和基本概念</h2><p>大部分传统的高级程序设计语言(如C语言)都是过程化的语言，在软件开发的过程中采用自顶向下逐步细化的方法将整个程序描述为一个过程。对于小型的系统，这种方法是可行的，但是当系统规模很大，复杂度很高时，用过程化方法描述变得十分困难，面向对象的软件开发方法可以很好地解决这个问题。</p><p>目前，面向对象的方法在软件开发工作中得到了广泛的应用，越来越多的软件开发工具开始支持面向对象的开发方法。Java语言就是一种面向对象的程序设计语言，要充分利用Java语言的特性首先应该理解面向对象的基本思想。</p><h2 id="面向对象的基本思想"><a href="#面向对象的基本思想" class="headerlink" title="面向对象的基本思想"></a>面向对象的基本思想</h2><p>面向对象的基本思想认为系统是由若干个对象构成的，每个对象都有各自的内部状态和运动规律，不同对象之间通过消息传送相互作用和联系。</p><p>采用对象的观点看待所要解决的问题，并将其抽象为系统是极其自然与简单的，因为它符合人类的思维习惯，使得应用系统更容易理解。同时，由于应用系统是由相互独立的对象构成的，使得系统的修改可以局部化，因此系统更易于维护。 </p><p>例如，对于一个企业的管理信息系统，将整个系统描述成一个过程是难以想像的，但可以分别描述各个部门的特性及工作流程，然后描述部门之间的联系。这里各个部门就是组成企业的对象，当然，在描述每个部门特性时可以采用同样的方法。</p><h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><p>对象是面向对象方法中的一个重要概念。</p><blockquote><p>所谓对象，是指客观世界中事物在计算机领域中的抽象，用一组数据和施加于该组数据上的一组操作(行为)来描述。</p></blockquote><p>对象的描述通常由三个部分组成：</p><p>(1) 私有的数据结构。用于描述对象的内部状态。<br>(2) 处理，称为操作或方法。它是施加于数据结构之上的。<br>(3) 接口。这是对象可被共享的部分，消息通过接口调用相应的操作。接口规定哪些操作是允许的，它不提供操作是如何实现的信息。</p><p>实际上，采用面向对象方法进行系统分析与设计时要描述的并不是一个个具体的对象。对于一个具体的系统而言，可能存在很多具有相同特征的对象，而且通常系统中对象的数目是不确定的。例如，对于一个学籍管理系统，存在许多学生对象，它们具有相同的结构特征和行为特征，只是表示内部状态的数据值不同。为了描述这种相同结构特征和行为特征的对象，面向对象方法引入了类的概念。这一点与人们在认识客观世界的事物时所采取的分类思想相同。人们在认识事物时总是将具有相同特征的事物归为一类，属于某类的一个事物具有该类事物的共同特征。</p><p>类是对一组具有相同特征的对象的抽象描述，所有这些对象都是这个类的实例。对于学籍管理系统，学生是一个类，而一个具体的学生则是学生类的一个实例。一个类的不同实例具有相同的操作或行为的集合和相同的信息结构或属性的定义，但属性值可以不同；不同的实例具有不同的对象标识。对于学生类中的每一个对象，描述它们所使用的数据结构相同，但是值不同。在程序设计语言中，类是一种数据类型，而对象是该类型的变量，变量名即是某个具体对象的标识。</p><p>因此，一个类的定义至少包含以下两个方面的描述：<br>(1) 该类所有实例的属性或结构的定义。<br>(2) 该类所有实例的操作(或行为)的定义。</p><p>类是构成Java语言程序的基本单位，一个完整的Java程序是由若干个类构成的，每个类由若干数据和方法构成，一个类的定义包含属性(数据)和方法(行为)两部分内容。</p><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>人们在对客观世界的事物进行描述时，经常采取分类的方法。类是有层次的，即某个大类的事物可能分为若干小类，而这些小类可能又分为若干个更小的类。</p><p>面向对象思想采纳了事物分类的层次思想，在描述类的时候，某些类之间具有结构和行为的共性。例如，描述教师与学生时均需描述姓名、年龄、身高、体重等属性，将这些共性抽取出来，形成一个单独的类——人，用于描述教师类和学生类的共性。类人的结构特征和行为特征可以被多个相关的类共享，教师类和学生类继承了类人的结构和行为特征。</p><p>Java语言支持类的继承，可以从一个类中派生出一个新的类，原来的类称为超类或父类，新类称为超类的子类或派生类。子类的对象具有超类对象的特征，同时又有其自身特有的特征。子类又可以派生出新的子类，子类的子类也称为派生类。</p><p>利用类之间的继承关系，可以简化类的描述，提高软件代码的可重用性。在设计一个新类时，不必从头设计编写全部的代码，可以通过从已有的具有类似特性的类中派生出一个类，继承原有类中的部分特性，再加上所需的新特性。</p><p>另外，人们在对客观世界的事物进行分类时，一个事物可能属于多个类，具有多个类的特性。例如，一个黑人学生，他既属于学生类，又属于黑人类。这种情形在面向对象方法中称为多继承，即一个类同时从多个类中派生出来，此时类的层次结构是网状的。</p><p>Java语言为了不使语法过于复杂，不支持多继承，只允许子类有一个超类，称为单继承。不过，Java语言提供了接口机制，可以在一定程度上模拟多继承。</p><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>多态性是面向对象系统的又一重要特性。所谓多态，即一个名词可具有多种语义，如一个方法名有多种功能，或者相同的接口有多种实现方法。</p><p>在Java语言中，多态性通过方法的重载、覆盖和接口来实现。</p><p>方法的重载是指多个方法具有相同的名称，但各个方法的参数表不同，即参数的类型和参数的数量不同。</p><p>覆盖是指在类的派生过程中，子类与超类的方法不仅名称相同，参数也完全相同，但它们的功能不同，这时子类中的方法覆盖了超类中同名的方法。</p><p>接口实际上是一种特殊的类，只给出方法的名称、参数和返回值的类型，方法的具体实现在实现该接口的类中给出。</p><blockquote><p>多态性使得方法的调用更加容易、灵活和方便。</p></blockquote><h2 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h2><p>封装是一种信息隐藏技术，对象内部对用户是隐藏的，不可直接访问；用户只能见到对象封装界面上的信息，通过对象的外部接口访问对象。</p><blockquote><p>用户向对象发送消息后，对象根据收到的消息调用内部方法作出响应。</p></blockquote><p>封装的目的在于将对象的使用者和对象的设计者分开，使用者无需知道对象内部实现的细节，只需知道对象接收的消息即可。</p><p>Java语言通过类来实现封装，类中定义的属性和方法分为私有的和公有的，私有属性和方法不能在对象的外部访问，只能由类内的方法访问。</p><p>而在对象的外部，只能访问对象的公有属性和方法，只需要知道公有属性的数据类型和名字以及公有方法的原型，至于这些方法是如何实现的对象外部并不需要知道。</p><p>这就像人们在使用电视机时只需要通过遥控器来操作即可，至于电视机内部细节用户则无需知道，这里遥控器上的按钮实际上就是电视机的外部接口。</p><blockquote><p>对象的封装特性可以提高模块之间的独立性，使得系统易于调试和维护。</p></blockquote><h2 id="类的声明与对象的创建"><a href="#类的声明与对象的创建" class="headerlink" title="类的声明与对象的创建"></a>类的声明与对象的创建</h2><p>类声明的基本语法</p><p>1．类的声明</p><p>Java语言类声明的完整语法很复杂，下面先介绍最简单的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">    类体</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>  类中定义的变量和方法都是类的成员，Java语言对类成员的访问有一定的权限限制。在定义属性和方法时，可以指定访问权限，Java中访问权限有private、protected和public。</p><h2 id="变量成员的定义"><a href="#变量成员的定义" class="headerlink" title="变量成员的定义"></a>变量成员的定义</h2><p>变量成员的定义形式类似于C语言中的变量定义，ComplexRoot类的变量成员a、b和disc。</p><p>变量成员定义的一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[final] [private|protected|public] 类型 属性名[=初值];</span><br></pre></td></tr></table></figure><blockquote><p>final为可选项，用final修饰的成员变量为常量。在程序中不能改变常量的值，常量必须在定义时初始化。</p></blockquote><p>成员变量初始化的方法与C语言相似，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"> int x=0,y=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>成员变量的类型可以是Java语言中的任意数据类型，包括简单类型、数组、类和接口。在类中，成员变量名应该是唯一的。</p></blockquote><h2 id="方法成员的定义"><a href="#方法成员的定义" class="headerlink" title="方法成员的定义"></a>方法成员的定义</h2><p>方法成员的定义形式与C语言的函数定义类似，基本形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[private|protected|public] 返回值类型 方法名([形式参数表])</span><br><span class="line">   &#123;</span><br><span class="line">       方法体    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> int func(int a，int b)</span><br><span class="line">  &#123;</span><br><span class="line">      if(a&gt;b)</span><br><span class="line">return a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的定义是错误的，当a&lt;=b时该方法在执行时没有确切的返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)  return 表达式;  或 return(表达式);</span><br><span class="line">(2)  return;。</span><br></pre></td></tr></table></figure><blockquote><p>第一种形式用于有返回值的情况，第二种形式用于无返回值的情况。对于第一种情况，return后的表达式类型应与声明的返回值类型一致，否则会产生编译错误。</p></blockquote><p>Java语言中的方法可以有参数也可以没有参数，参数类型可以是简单数据类型，如整型、实型、字符型、布尔型，也可以是复合类型，如数组、自定义类的对象。</p><blockquote><p>方法被调用时，必须给定实际参数，实际参数的类型应与形式参数的类型一致。对于简单类型数据，实际参数传递给形式参数时采用值传递，这一点与C语言相同；如果参数为复合类型，则传递引用，此时实参、形参为同一对象。</p></blockquote><h3 id="参数传递的方法。"><a href="#参数传递的方法。" class="headerlink" title="参数传递的方法。"></a>参数传递的方法。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">private int b;</span><br><span class="line">int Getb()&#123;return b;&#125;</span><br><span class="line">void Setb(int j)&#123;b=j;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MethodParm</span><br><span class="line">&#123;</span><br><span class="line">void Method1(int Parm1,B Parm2)</span><br><span class="line">&#123;</span><br><span class="line">Parm1=Parm1+10;</span><br><span class="line">Parm2.Setb(20);</span><br><span class="line">&#125;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">int a=10;</span><br><span class="line">B b=new B();</span><br><span class="line">b.Setb(10);</span><br><span class="line">MethodParm obj=new MethodParm();</span><br><span class="line">obj.Method1(a,b);</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b.Getb());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果为</span><br><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>如果局部变量或形式参数与变量成员同名，在该方法体中直接使用变量名则是对局部变量或形式参数的访问。如果需要访问变量成员，可通过关键字this来访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ComplexRoot(double a,double b,double disc)</span><br><span class="line">&#123;</span><br><span class="line">                   this.a=a;</span><br><span class="line">             this.b=b;</span><br><span class="line">            this.disc=disc;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，this.a访问当前对象的成员a，而赋值运算符后的a表示形式参数表中的a。</p></blockquote><p>类的构造方法与对象的初始化</p><p>类定义了一类对象的特性，每一个对象都是相应类的实例。定义一个类后，就可以定义对象，然后访问对象的方法和变量成员了。</p><p>1．new运算符</p><p>Java语言使用new运算符创建对象。</p><blockquote><p>Equation e=new Equation(1,2,1);</p></blockquote><p>创建了一个Equation类的对象，也可以写为下面的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Equation e;</span><br><span class="line">e=new Equation(1,2,1);</span><br></pre></td></tr></table></figure></p><p>即首先声明一个Equation类对象的引用e，与定义简单数据类型变量不同，这里尚未创建Equation类的对象。变量名e只是程序中访问对象的一条途径，并不是对象本身，执行下面的语句后e、e1表示同一个对象：</p><blockquote><p>Equation e1=e;</p></blockquote><p>这一点与C/C++语言不同，Java语言将这类数据类型称为引用类型，与C/C++中的指针相似。引用类型变量在未赋值前，其值为null。</p><p>定义对象引用后，用new运算符完成对象的创建工作，分配存储空间，并对其初始化。new运算符创建对象的一般方法为：</p><blockquote><p>变量名=new 类名([构造方法实参表]);</p></blockquote><p>类名可以是系统预定义的类，也可以是自定义的类。括号中是传递给构造方法的实参，用于初始化该对象。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法是一种特殊的方法，创建对象时被自动调用。与一般的方法不同，它没有返回值类型的说明，方法体中也不可以用return语句带回返回值。构造方法的方法名与类名相同</p><blockquote><p>OneRoot o=new OneRoot(a,b);</p></blockquote><p>其中，a、b为传递给构造方法的参数。<br>Java语言允许一个类有多个构造方法，只要这些方法的参数形式不同即可。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">int x,y;</span><br><span class="line">Point(int x,int y)&#123;this.x=x;this.y=y;&#125;</span><br><span class="line">Point()&#123;x=y=0;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的语句在创建Point类对象时分别调用不同的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p1=new Point(10,10);</span><br><span class="line">Point p2=new Point();</span><br></pre></td></tr></table></figure></p><p>在构造方法中可以通过this关键字调用该类中其他的构造方法。例如，上面的例子可改写为下面的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">  int x,y;</span><br><span class="line">   Point(int x,int y)&#123;this.x=x;this.y=y;&#125;</span><br><span class="line">   Point()&#123;this(0,0);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个构造方法调用了第一个构造方法，this后面括号中内容为传递给第一个构造方法的实参。如果该构造方法中还有其他的语句，应保证将this语句放在最前面。</p><h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>Java语言提供了三种初始化对象的方法，除了上面介绍的构造方法外，还可以采用下面两种方法：</p><p>(1) 定义变量成员时赋初值；<br>(2) 在类体中的初始化程序块。</p><h2 id="对象的初始化。"><a href="#对象的初始化。" class="headerlink" title="对象的初始化。"></a>对象的初始化。</h2><p>//ch3_3.java  对象的初始化方法演示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">int x=5;</span><br><span class="line">&#123;//初始化程序块开始</span><br><span class="line">System.out.println(x);</span><br><span class="line">x=6;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;//初始化程序块结束</span><br><span class="line">A(int i)</span><br><span class="line">&#123;</span><br><span class="line">x=i;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class InitDemo</span><br><span class="line">&#123;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A a=new A(7);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> 程序运行结果为：</span><br><span class="line">   5</span><br><span class="line">   6</span><br><span class="line">   7</span><br></pre></td></tr></table></figure></p><h2 id="对象的清除"><a href="#对象的清除" class="headerlink" title="对象的清除"></a>对象的清除</h2><p>与C/C++语言不同，Java语言中对象的清除是自动进行的，当系统内存用尽或用户在程序中调用System.gc时，Java运行系统启动垃圾收集机制，自动回收不再使用的对象。垃圾收集器可以自动判断哪些对象不再使用，例如，程序片断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a=new A();</span><br><span class="line">a=new A();</span><br></pre></td></tr></table></figure><p>在内存中创建了两个A类对象，执行该程序片断之后，第一次创建的A类对象在程序中无法再访问，Java垃圾收集器将自动收回该对象占用的空间。对不再使用的对象，程序中可以将对该对象的引用赋值为null，以释放资源。</p><p>Java语言允许用户为每个类定义一个特殊的方法finalize()，当垃圾收集器清除该类对象时将调用该方法，如果用户有一些特殊的清除工作可安排在finalize方法中。</p><p>但是，用户无法预测finalize()方法被调用的时间，即使调用System.gc强制启动垃圾收集，也可能因为其他任务的优先级高于垃圾收集任务，而不能立即启动。因此，一些与时间相关的代码不应加入到finalize()方法中。</p><h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><p>在对象创建之后，就可以使用该对象了，可以访问对象的变量成员和方法成员。访问成员的基本语法形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.变量成员名</span><br><span class="line">对象名.方法成员名([实际参数表])</span><br></pre></td></tr></table></figure></p><p>public 类内，子类，包内其他类，其他包内的类<br>private 类内<br>protected 类内，子类，包内其他类<br>friendly 类内，子类，包内其他类 </p><p>成员访问权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//ch3_4 成员访问权限演示 VistMember.java</span><br><span class="line">class A&#123;</span><br><span class="line">private int PrivateMember=0;</span><br><span class="line">public int PublicMember=0;</span><br><span class="line">int FriendMember=0;</span><br><span class="line">void Copy(A AObject)</span><br><span class="line">&#123;</span><br><span class="line">        PrivateMember=AObject.PrivateMember;//访问同类对象的private成员</span><br><span class="line">PublicMember=AObject.PublicMember;//访问同类对象的public成员</span><br><span class="line">FriendMember=AObject.FriendMember;//访问同类对象的friendly成员</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">private int PrivateMember=0;</span><br><span class="line">public int PublicMember=0;</span><br><span class="line">int FriendMember=0;</span><br><span class="line">void CopyA(A AObject)</span><br><span class="line">&#123;</span><br><span class="line">PrivateMember=AObject.PrivateMember;</span><br><span class="line">//错误，访问另一个类对象的private成员</span><br><span class="line">PublicMember=AObject.PublicMember;</span><br><span class="line">//访问另一个对象的public成员</span><br><span class="line">FriendMember=AObject.FriendMember;</span><br><span class="line">//访问另一个对象的friendly成员</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class VistMember</span><br><span class="line">&#123;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A aobj=new A();</span><br><span class="line">aobj.PublicMember = 20;</span><br><span class="line">aobj.FriendMember = 30;</span><br><span class="line">A aobj2=new A();</span><br><span class="line">aobj2.Copy(aobj);</span><br><span class="line">B bobj=new B();</span><br><span class="line">bobj.CopyA(aobj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java语言引入了一个与对象有关的运算符instanceof，用来测试一个指定的对象是否是指定类的实例，若是，则返回true；否则，返回false。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(obj1 instanceof Class1)&#123;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>obj1为对象名，Class1为类名，若obj1为Class1类的对象，则执行大括号中的语句。</p><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>从前面的介绍可以知道，对象创建之后，Java程序通过对象调用方法成员，在方法中使用变量成员名访问当前对象的成员。不过，在前面的例子中，有一个例外的情况，就是main方法，它是程序执行的入口点，Java程序开始执行时，并没有创建它所在类的对象。</p><p>main方法与其他方法的不同之处在于定义时前面有修饰符static，它是一个静态方法。Java语言允许用static修饰符定义静态的变量成员和方法成员。</p><h2 id="静态变量成员"><a href="#静态变量成员" class="headerlink" title="静态变量成员"></a>静态变量成员</h2><p>静态的变量成员通常称为类变量，而非静态的变量成员称为实例变量。Java语言在创建对象时不为静态变量成员分配空间，而只为非静态变量成员分配空间。因此，静态变量成员不依赖某一个具体的对象，即使没有创建一个它所属类的对象，它也是存在的，只要该类的代码装入，则该静态变量就是存在的，就可以使用。</p><p>因为静态变量成员不依赖于具体的对象，在访问时可以不像非静态变量成员那样通过对象访问。静态变量成员的访问方法为</p><blockquote><p>类名.静态变量成员名</p></blockquote><h3 id="对象计数器。"><a href="#对象计数器。" class="headerlink" title="对象计数器。"></a>对象计数器。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//ch3_5 静态变量的作用 NumberOfClass.java</span><br><span class="line">class MyClass&#123;</span><br><span class="line">static int count=0;</span><br><span class="line">public MyClass()&#123;count++;&#125;</span><br><span class="line">public void output()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;You have got &quot;+count+&quot; objects of MyClass&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class NumberOfClass</span><br><span class="line">&#123;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">MyClass c1,c2,c3,c4;</span><br><span class="line">c1=new MyClass();</span><br><span class="line">c1.output();</span><br><span class="line">c2=new MyClass();</span><br><span class="line">c2.output();</span><br><span class="line">c3=new MyClass();</span><br><span class="line">c3.output();</span><br><span class="line">c4=new MyClass();</span><br><span class="line">c4.output();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">程序运行结果为：</span><br><span class="line">You have got 1 objects of MyClass</span><br><span class="line">You have got 2 objects of MyClass</span><br><span class="line">You have got 3 objects of MyClass</span><br><span class="line">You have got 4 objects of MyClass</span><br></pre></td></tr></table></figure><p>前面例子中多次使用了System.out.println方法来输出数据，其中System为Java系统预定义的类，out为System类的静态变量成员。程序中使用它向标准输出设备输出数据，无需创建System类对象即可直接使用。而在C/C++语言中类似的功能是通过系统预定义的全局变量来实现的，例如C语言中的文件指针stdout、C++的流对象cout，而Java语言不允许定义全局变量，所有变量都必须在类中定义。</p><h2 id="静态变量的使用。"><a href="#静态变量的使用。" class="headerlink" title="静态变量的使用。"></a>静态变量的使用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//ch3_6 静态变量的使用</span><br><span class="line">public class Class1 &#123;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;The maximum integer is &quot;+Integer.MAX_VALUE );</span><br><span class="line">System.out.println(&quot;The minimum integer is &quot;+Integer.MIN_VALUE );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态方法成员"><a href="#静态方法成员" class="headerlink" title="静态方法成员"></a>静态方法成员</h2><p>静态方法与静态变量类似，不依赖于具体的对象，在调用时直接通过类名来调用：</p><blockquote><p>类名.静态方法名([方法的参数表])</p></blockquote><p>正如前面所说，main方法不依赖于任何对象直接被调用，因此必须将其定义为静态方法。</p><p>静态方法在调用时不通过对象调用，因此在定义静态方法时，在方法体中不能使用this，因为对静态方法来说，不存在当前对象，同样也不能直接访问所在类的非静态变量成员及方法成员。</p><p>静态方法的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//ch3_7 StaticMethod.java</span><br><span class="line">import java.math.*;</span><br><span class="line">public class StaticMethod</span><br><span class="line">&#123;</span><br><span class="line">double Radius;</span><br><span class="line">StaticMethod(double r)</span><br><span class="line">&#123;</span><br><span class="line">Radius=r;</span><br><span class="line">&#125;</span><br><span class="line">static double CircleArea(double r)</span><br><span class="line">&#123;</span><br><span class="line">return Math.PI*r*r;</span><br><span class="line">&#125;</span><br><span class="line">double Area()</span><br><span class="line">&#123;</span><br><span class="line">return Math.PI*Radius*Radius;</span><br><span class="line">&#125;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">        System.out.println(&quot;Area=&quot;+CircleArea(2.0));</span><br><span class="line">               //直接访问静态方法成员</span><br><span class="line">StaticMethod obj=new StaticMethod(2.0);</span><br><span class="line">System.out.println(&quot;Area=&quot;+obj.Area());</span><br><span class="line">              //通过对象访问非静态方法成员</span><br><span class="line">            &#125;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></p><h2 id="类内方法的重载"><a href="#类内方法的重载" class="headerlink" title="类内方法的重载"></a>类内方法的重载</h2><p>Java语言允许一个类有多个同名的方法成员，这些同名的方法具有不同形式的参数，在调用时只需带入不同的实参,Java编译器就可以根据实参的类型确定调用哪一个方法成员</p><p>类内方法重载一个最常见的例子就是前面使用的System.out.println方法，在前面的程序中用它来输出整型数据、实型数据、字符串等。下面是重载的println方法的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void println()</span><br><span class="line">public void println(boolean x)</span><br><span class="line">public void println(char x)</span><br><span class="line">public void println(int x)</span><br><span class="line">public void println(long x)</span><br><span class="line">public void println(float x)</span><br><span class="line">public void println(double x)</span><br><span class="line">public void println(char x[])</span><br><span class="line">public void println(String x)</span><br><span class="line">public void println(Object x)</span><br></pre></td></tr></table></figure><p>方法重载为程序调用带来了方便，用户无需为不同类型的数据选择输出方式，只需使用同一个方法即可实现不同类型数据的输出。</p><p>Java编译器对重载方法匹配时首先根据实参类型寻找形参类型与其完全匹配的方法，如果找不到，则按如下原则对实参作类型转换：</p><p>(1) 对于简单类型，按照byte、short、int、long、float、double的顺序进行转换；<br>(2) 如果实参为布尔型，不进行转换；<br>(3) 如果实参为复合数据类型，可以将子类对象转换为超类对象。</p><p>如果按以上原则对实参进行类型转换仍然找不到匹配的重载方法，则认为是错误。</p><p>程序3.8演示了方法重载中参数匹配的方法，OverLoad类有两个同名的方法成员max，main方法中多次调用了max。</p><p>第一次调用，两个实参为int类型，匹配第一个max方法；<br>第二次调用，两个实参为double类型，匹配第二个max方法；<br>最后一次调用，第一个实参为int类型，第二个实参为double类型，没有参数类型完全匹配的max方法，Java编译器将第一个实参转换为double类型后与第二个max匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">【程序3.8】  类内方法重载。</span><br><span class="line">//ch3_8 类内方法重载演示 OverLoad.java</span><br><span class="line">public class OverLoad</span><br><span class="line">&#123;</span><br><span class="line">int ix,iy;</span><br><span class="line">double dx,dy;</span><br><span class="line">OverLoad(int ix,int iy,double dx,double dy)</span><br><span class="line">&#123;</span><br><span class="line">        this.ix=ix;</span><br><span class="line">this.iy=iy;</span><br><span class="line">this.dx=dx;</span><br><span class="line">this.dy=dy;</span><br><span class="line">&#125;</span><br><span class="line">int max(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">if(a&gt;b)</span><br><span class="line">return a;</span><br><span class="line">else</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br><span class="line">double max(double a,double b)</span><br><span class="line">&#123;</span><br><span class="line">        if(a&gt;b)</span><br><span class="line">return a;</span><br><span class="line">else</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">OverLoad obj=new OverLoad(3,4,5.0,6.0);</span><br><span class="line">        System.out.println</span><br><span class="line">             (&quot;the max integer is &quot;+obj.max(obj.ix,obj.iy));</span><br><span class="line">System.out.println</span><br><span class="line">             (&quot;the max double is &quot;+obj.max(obj.dx,obj.dy));</span><br><span class="line">System.out.println(&quot;The max is &quot;+</span><br><span class="line">obj.max(obj.max(obj.ix,obj.iy),obj.max(obj.dx,obj.dy)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果为：</span><br><span class="line">the max integer is 4</span><br><span class="line">the max double is 6.0</span><br><span class="line">The max is 6.0</span><br></pre></td></tr></table></figure><p>使用方法重载还应注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(1)  Java编译器对实参进行类型转换时，应注意避免二义性。例如下面的程序片段：</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">   void m(int a,double b)</span><br><span class="line">  &#123; </span><br><span class="line">   &#125;</span><br><span class="line">  void m(double a,int b)</span><br><span class="line">    &#123;</span><br><span class="line">&#125;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">A obj=new A();</span><br><span class="line">obj.m(2,3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类A定义了两个同名方法m，在main方法中调用时两个实参为int类型，由于没有参数类型完全匹配的重载方法，因此Java编译器尝试对实参类型进行转换，这时有两种转换途径：将第一个实参转换为double类型与第二个m匹配，或者将第二个参数转换为double类型与第一个m匹配。Java编译器无法确定选择哪一种转换途径，这是不允许的。</p><p>类内方法重载时，不允许参数表完全一致，而只是返回值类型不同。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">void m(int a,int b)</span><br><span class="line">&#123; </span><br><span class="line">  &#125;</span><br><span class="line">   int m(int a,int b)</span><br><span class="line">   &#123; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Java语言定义了专门的字符串类型String，它是一种复合类型，一个字符串变量就是一个String类的对象，而C语言中的字符串只是一块连续的存储空间，用于存储若干个字符类型的数据。</p><p>创建String类对象<br>String类对象的创建与其他类型对象创建的方法是相同的，例如：</p><blockquote><p>String str=new String(“This is a string”);</p></blockquote><p>String类的构造方法有多个，常用的形式有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String()</span><br><span class="line">public String(String value)</span><br><span class="line">public String(char value[])</span><br></pre></td></tr></table></figure></p><p>由于字符串类型在程序设计中经常会用到，因而Java语言还提供了一种简便的方法来初始化String对象。例如：</p><blockquote><p>String str=”This is a string”;</p></blockquote><p>另外，在程序中大部分需要使用String类对象的地方可以直接使用字符串常量。例如：</p><blockquote><p>System.out.println(“This is a string”);</p></blockquote><p>这里，Java语言用字符串常量”This is a string”构造一个String类对象，然后将该对象作为实参传递给println方法。</p><h2 id="获取字符串的信息"><a href="#获取字符串的信息" class="headerlink" title="获取字符串的信息"></a>获取字符串的信息</h2><p>创建了String对象后，就可以通过调用String类的方法成员来对字符串进行各种操作或者获取有关字符串的信息了。例如，通过调用length方法可以获得字符串的长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;A String Object&quot;;</span><br><span class="line">int len=str.length();</span><br></pre></td></tr></table></figure></p><p>startsWith方法可以判断一个字符串的前缀是否为指定的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;Java String&quot;;</span><br><span class="line">boolean result=str.startsWith(&quot;Java&quot;);//result=true</span><br></pre></td></tr></table></figure></p><p>endsWith用于确定字符串是否以给定的字符串结尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;This is a string&quot;;</span><br><span class="line">boolean result=str.endsWith(&quot;String&quot;);//result=false</span><br><span class="line">boolean result=str.endsWith(&quot;string&quot;);//result=true</span><br></pre></td></tr></table></figure></p><p>如果需要比较两个字符串的值是否相等，可以使用equals方法，也可以直接使用关系运算符==。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String firstName=&quot;Nancy&quot;;</span><br><span class="line">if(firstName.equals(&quot;Nancy&quot;))&#123;</span><br><span class="line">              //条件满足，执行此程序段</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure></p><p>equals方法区分大小写，如果不区分大小写比较两个字符串是否相等，可以使用方法equalsIgnoreCae。</p><p>字符串的操作</p><p>String类还提供了一些方法用于从字符串中抽取字符串的某些部分，如一个字符或一个子串，下面介绍一些常用的方法。</p><p>charAt用于抽取指定位置的字符，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;Java string&quot;;</span><br><span class="line">char c=str.charAt(3);//c=&apos;a&apos;</span><br></pre></td></tr></table></figure></p><p>该方法的参数为希望抽取的字符所在的位置，这里位置是从0开始计数的。</p><p>subString用于提取字符串中从某个位置开始的若干个字符，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;Tom and Jerry&quot;;</span><br><span class="line">String str1=str.subString(4);//str1=&quot;and Jerry&quot;</span><br><span class="line">String str2=str.subString(4,7);//str2=&quot;and&quot;</span><br></pre></td></tr></table></figure></p><p>对字符串的操作(如合并字符串、替换字符)，String类也提供了一些方法，例如：replace方法可以将字符串中的一个字符替换为另一个字符，concat方法可以合并两个字符串。</p><p>replace方法有两个字符类型的参数，第一个为原来的字符，第二个为替换用的字符。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;java&quot;;</span><br><span class="line">String str1=str.replace(&apos;a&apos;, &apos;A&apos;); //str1=&quot;jAvA&quot;;</span><br></pre></td></tr></table></figure></p><p>concat方法有一个参数，为需要合并的字符串。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;First&quot;;</span><br><span class="line">String str1=str.concat(&quot;Program&quot;);   //str1=&quot;First Program&quot;</span><br></pre></td></tr></table></figure></p><p>需要注意的是：String类对象创建后，字符串的值是不能改变的，replace、concat方法并不改变原来字符串的值，而是创建了一个新的String类对象作为返回值。如果希望字符串在创建后值可以改变，应使用StringBuffer类。</p><p>Java语言中可以直接使用+运算连接两个字符串，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;First&quot;;</span><br><span class="line">String str1=str+&quot; Program&quot;; //str1=&quot;First Program&quot;</span><br></pre></td></tr></table></figure></p><h2 id="字符串与其他类型数据的转换"><a href="#字符串与其他类型数据的转换" class="headerlink" title="字符串与其他类型数据的转换"></a>字符串与其他类型数据的转换</h2><p>程序设计中经常需要将字符串转换为整型或实型数据，例如，从键盘输入一个整数，只能先读入字符串，然后将其转换为整数，因为System.in.read方法只提供了读取字符的方法；同样，反向的转换也经常会用到，例如，在Java Applet中将数据转换为字符串后输出。Java语言中这样的转换都可以通过简单数据类型的包装类来实现。</p><h2 id="String类的使用。"><a href="#String类的使用。" class="headerlink" title="String类的使用。"></a>String类的使用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//ch3_9 StringClass.java</span><br><span class="line">public class StringClass</span><br><span class="line">&#123;</span><br><span class="line">String myString=&quot;1&quot;;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">StringClass myObj = new StringClass();</span><br><span class="line">myObj.stringModifier(myObj.myString);</span><br><span class="line">           StringClass myObj = new StringClass();</span><br><span class="line">myObj.stringModifier(myObj.myString);</span><br><span class="line">System.out.println(&quot; &quot;+myObj.myString);</span><br><span class="line">&#125;</span><br><span class="line">void stringModifier(String theString)</span><br><span class="line">&#123;</span><br><span class="line">theString = theString+&quot;2&quot;;</span><br><span class="line">System.out.print(theString);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">程序的运行结果为</span><br><span class="line">12 1</span><br></pre></td></tr></table></figure><p>Java语言为每一个简单数据类型定义了一个类(如 int 对应 Integer， float 对应 Float)，称为包装类(Wrapper Class)。 </p><p>包装类为与该类型相关的方法和变量提供一个归属，如字符串转换和值域常量。</p><p>如果需要将简单类型变量转换为字符串，可以首先创建一个包装类对象，然后调用该对象的toString方法即可。例如：</p><p>String IntStr = new Integer(123).toString();<br>String DoubleStr = new Double(123.456D).toString();</p><p>实际上，Java语言中的每一个对象都有一个 toString() 方法。例如：</p><p>Date day = new Date();<br> //Date为Java类库中处理日期的类<br>System.out.println(day);<br>这里的输出语句相当于<br>System.out.println(day.toString());</p><p>前面提到，Java语言对+运算符的功能进行了扩展，可以允许字符串与int、float等类型的数据连接，实际上这里使用了包装类，例如：</p><p>String str=””+5;<br>相当于：<br>String str=””+(new Interger(5).toString());<br>即两个 String 的相加。</p><p>包装类的另一种构造方法以字符串作参数，可以使用该构造方法创建包装类对象，将字符串转换为简单类型数据。例如：</p><p>int intNumber = new Integer (“10”).intValue();<br>boolean con = new Boolean (“true”).booleanValue();</p><p>这里，Boolean为boolean类型的包装类，常用的包装类还有：Character包装char，Byte包装byte，Long包装long。</p><p>从包装类型对象获取基本类型值的方法为typeValue，其中type为相应的数据类型。例如：intValue获取int值，charValue获取char值，doubleValue获取double值。</p><p>另外，String类还提供了静态的方法valueOf，可以用来将基本类型的值转换为字符串。valueOf有多种形式，分别用于转换不同类型的数据，例如：</p><p>●  public static String valueOf(boolean b)；<br>●  public static String valueOf(char c)；<br>●  public static String valueOf(int i)；<br>●  public static String valueOf(long l)；<br>●  public static String valueOf(float f)；<br>●  public static String valueOf(double d)。</p><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><blockquote><p>String类是字符串常量，对象创建后值不可更改。</p></blockquote><p>而StringBuffer是字符串变量，它的对象是可以扩充和修改的。StringBuffer类的构造函数主要有以下几种形式：</p><p>●  public StringBuffer()：创建一个空的StringBuffer类的对象。<br>●  public StringBuffer( int length )：创建一个长度为参数length 的StringBuffer类的对象。<br>●  public StringBuffer( String str )：用一个已存在的字符串常量来创建StringBuffer类的对象。</p><h2 id="StringBuffer类的主要方法有："><a href="#StringBuffer类的主要方法有：" class="headerlink" title="StringBuffer类的主要方法有："></a>StringBuffer类的主要方法有：</h2><p>●  public String toString()：转换为String类对象并返回。由于很多类的方法需要String类的对象，如Graphics类的方法drawString，经常要将StringBuffer类的对象转换为String类的对象。</p><p>●  public StringBuffer append( boolean b )。<br>●  public StringBuffer append( char c )。<br>●  public StringBuffer append( int i)。<br>●  public StringBuffer append( long l )。<br>●  public StringBuffer append( float f )。<br>●  public StringBuffer append( double d )。 </p><p>以上六种方法可分别将boolean、char、int、long、float和double 六种类型的变量追加到StringBuffer类的对象的后面。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double d=123.4567;</span><br><span class="line">StringBuffer sb=new StringBuffer();</span><br><span class="line"></span><br><span class="line">sb.append(true);</span><br><span class="line">sb.append(&apos;c&apos;).append(d).append(99);</span><br><span class="line">//sb的值为truec123.456799</span><br></pre></td></tr></table></figure></p><p>●  public StringBuffer append( String str )：将字符串常量str追加到StringBuffer类的对象的后面。<br>●  public StringBuffer append( char str[] )：将字符数组str追加到StringBuffer类的对象的后面。<br>●  public StringBuffer append( char str[], int offset, int len )：将字符数组str从第offset个开始取len个字符，追加到StringBuffer类的对象的后面。</p><p>●  public StringBuffer insert( int offset, boolean b )。<br>●  public StringBuffer insert( int offset, char c )。<br>●  public StringBuffer insert( int offset, int i )。<br>●  public StringBuffer insert( int offset, long l )。<br>●  public StringBuffer insert( int offset, float f )。<br>●  public StringBuffer insert( int offset, double d )。<br>●  public StringBuffer insert( int offset, String str )。<br>●  public StringBuffer insert( int offset, char str[] )。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与其他程序设计语言一样，Java语言也支持数组。数组是一组类型相同的有序数据，数组中的每个元素具有相同的数组名，通过下标来唯一地确定数组中的元素。</p><h3 id="一维数组定义"><a href="#一维数组定义" class="headerlink" title="一维数组定义"></a>一维数组定义</h3><p> 一维数组定义形式为<br>type arrayName[];</p><p>其中，类型(type)可以为Java中的任意数据类型，包括简单类型和复合类型；数组名arrayName为一个合法的标识符，[]指明该变量是一个数组类型变量，可以写在数组名后，也可以写在数组名前。例如：</p><p>int []intArray;</p><p>为一个整型数组分配3个int型整数所占据的内存空间。这两部分也可以合在一起，定义数组时直接为其分配空间，格式如下：</p><p>type arrayName = new type[arraySize];<br>例如：<br>int intArray[]=new int[3];</p><p>引用数组元素</p><p>定义数组并为其分配了内存空间后，就可以引用数组中的每一个元素了。数组元素的引用方式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayName[index]</span><br><span class="line">其中：index为数组下标，它可以为int类型常量或表达式，如a[3]，b[i](i为整型)，c[6*i]等。</span><br></pre></td></tr></table></figure></p><p>Java语言数组的下标从0开始，一直到数组的长度减1，数组的长度可以通过属性length获得。对于上面例子中的数组intArray来说，它有3个元素，分别为intArray[0]、intArray[1]和intArray[2]。</p><h2 id="数组的使用。"><a href="#数组的使用。" class="headerlink" title="数组的使用。"></a>数组的使用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//ch3_10 ArrayTest.java</span><br><span class="line">public class ArrayTest&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">int i;</span><br><span class="line">int a[]=new int[5];</span><br><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">  a[i]=i;</span><br><span class="line">System.out.println(&quot;数组长度为：&quot;+a.length);</span><br><span class="line">for(i=0;i&lt;=a.length;i++)</span><br><span class="line">  System.out.println(&quot;a[&quot;+i+&quot;]=&quot;+a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">使用Visual J++ 6.0调试该程序后，首先输出结果如下：</span><br><span class="line">数组长度为：5</span><br><span class="line">a[0]=0</span><br><span class="line">a[1]=1</span><br><span class="line">a[2]=2</span><br><span class="line">a[3]=3</span><br><span class="line">a[4]=4</span><br></pre></td></tr></table></figure><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>可以按照上述的例子对数组元素进行赋值，也可以在定义数组的同时进行初始化。<br>例如：<br>int a[]={1,2,3,4,5};<br>用逗号(,)分隔数组的各个元素，系统自动为数组分配一定空间，无需再使用new分配空间。</p><h3 id="数组举例"><a href="#数组举例" class="headerlink" title="数组举例"></a>数组举例</h3><p>下面看几个使用一维数组的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【程序3.11】  用数组计算Fibonacci数列。</span><br><span class="line">  //ch3_11 Fibonacci.java</span><br><span class="line">  public class Fibonacci&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">int i;</span><br><span class="line">int f[]=new int[10];</span><br><span class="line">f[0]=f[1]=1;</span><br><span class="line">for(i=2;i&lt;10;i++)</span><br><span class="line">f[i]=f[i-1]+f[i-2];</span><br><span class="line">for(i=1;i&lt;=10;i++)</span><br><span class="line">System.out.println(&quot;F[&quot;+i+&quot;]=&quot;+f[i-1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="冒泡法排序。"><a href="#冒泡法排序。" class="headerlink" title="冒泡法排序。"></a>冒泡法排序。</h2><p>对给定数组的元素从小到大排列，采用冒泡法排序，相邻的两个元素进行比较，并把小的元素交到前面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> //ch3_12 BubbleSort.java</span><br><span class="line">  public class BubbleSort&#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   int i,j;</span><br><span class="line">   int intArray[]=&#123;20,1, -11,80,25&#125;;</span><br><span class="line"></span><br><span class="line">   int l=intArray.length;</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;l-1;i++)</span><br><span class="line">for(j=0;j&lt;l-i-1;j++)</span><br><span class="line">if(intArray[j]&gt;intArray[j+1])&#123;</span><br><span class="line">int t=intArray[j];</span><br><span class="line">intArray[j]=intArray[j+1];</span><br><span class="line">intArray[j+1]=t;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;l;i++)</span><br><span class="line">System.out.println(intArray[i]+&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果为：</span><br><span class="line">-11</span><br><span class="line">1</span><br><span class="line">20</span><br><span class="line">25</span><br><span class="line">80</span><br></pre></td></tr></table></figure></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Java语言将多维数组看作数组的数组。例如，二维数组可以看成一个特殊的一维数组，其每个元素又是一个一维数组。下面简单介绍一下二维数组的使用。</p><p>二维数组的定义方式为<br> type arrayName[][];<br>例如：<br>int intArray[][];</p><p>(1) 直接为每一维分配空间，如<br>int a[][]=new int[2][3];<br>(2) 从最高维开始，分别为每一维分配空间。如：<br>int a[][]=new int[2][];<br>a[0]=new int[3];<br>a[1]=new int[4];</p><h2 id="继-承"><a href="#继-承" class="headerlink" title="继    承"></a>继    承</h2><p>继承的基本语法</p><p>利用继承性可以提高代码的可重用性，提高软件开发的生产率。Java语言支持继承机制，在定义类时通过关键字extends指定超类的名称即可。</p><p> 1．子类的定义</p><p>子类定义的基本语法形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 子类名 extends 超类名&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java语言不支持多继承，因此超类名只有一个。子类继承超类的特性，也可以通过定义新的成员修改超类的特性或增加新的特性。 </p><p> Java语言在为子类对象分配空间时，不仅为子类中新定义的成员分配空间，同时也为超类中定义的成员(包括public、protected、private以及friendly成员)分配空间，在一定程度上可以认为一个子类对象内部包含一个超类对象。</p><p>Java语言允许将一个子类对象作为超类对象使用，当需要时可以进行隐含的类型转换。例如，若将一个方法的形式参数定义为超类对象，则在调用时可以将子类对象作为实际参数。Java语言中的各种类型的对象都可以当作Object类的对象使用，Object类中定义了Java语言对象的基本特性，例如前面用到的toString方法。如果在定义一个类时没有用extends关键字指定超类，则该类的超类为Object。</p><blockquote><p>超类中定义的成员根据其权限的不同在该类中的访问权限也不同</p></blockquote><p>子类在定义新的成员时，允许新成员与超类成员同名。对于同名变量成员，超类中的相应成员被隐藏。对于同名方法成员，如果参数形式相同且返回值类型相同，则超类中该方法成员被隐藏；如果参数形式不同，则调用时根据实参类型决定调用哪一个方法成员，与类内方法重载相同。Java语言不允许子类与超类方法同名，而参数形式相同但返回值类型不同。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>如果程序中需要访问被隐藏的同名超类成员，可以使用关键字super，super指代当前对象中在超类中定义的那一部分。</p><p>用super访问超类同名变量成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">int i;</span><br><span class="line">public Test()&#123;i=10;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test1 extends Test</span><br><span class="line">&#123;</span><br><span class="line">double i;</span><br><span class="line">public Test1()&#123;i=12.345678;&#125;</span><br><span class="line">public void print()</span><br><span class="line">&#123;</span><br><span class="line">        System.out.println(&quot;i of sub class &quot;+i);</span><br><span class="line">             //访问子类成员i</span><br><span class="line">System.out.println(&quot;i of super class &quot;+super.i);</span><br><span class="line">         //访问超类成员i</span><br><span class="line">&#125;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Test1 t1=new Test1();</span><br><span class="line">t1.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="子类对象的构造"><a href="#子类对象的构造" class="headerlink" title="子类对象的构造"></a>子类对象的构造</h2><p>子类对象在创建时需要调用超类的构造方法来构造超类中定义的那部分成员，如果在子类中不特别声明，则调用超类的不带参数的构造方法。</p><p>如果超类没有不带参数的构造方法，必须在子类的构造方法中用super关键字指定如何调用超类的构造方法。先看下面的程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">int a;</span><br><span class="line">A(int a)&#123;</span><br><span class="line">this.a=a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">int b;</span><br><span class="line">B(int b)&#123;</span><br><span class="line">this.b=b;</span><br><span class="line">System.out.println(&quot;Class B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Class1 &#123;</span><br><span class="line">public static void main (String[] args)</span><br><span class="line">&#123;</span><br><span class="line">B b=new B(10);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="final方法与final类"><a href="#final方法与final类" class="headerlink" title="final方法与final类"></a>final方法与final类</h2><p>通过在子类中定义与超类同名的方法成员，覆盖超类的方法成员，改变了超类原有的特征。有时可能程序员不希望子类修改超类原有的特性，这时可以将对应的方法定义为最终(final)方法，子类不再可以覆盖该方法。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    final void Method1()</span><br><span class="line">    &#123;System.out.println(&quot;This is a final method&quot;);&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>当从A类派生子类时，子类不可以定义与Method1形式相同的方法。</p></blockquote><p>关键字final也可以用来修饰类的定义，将一个类定义为最终类，则不再可以从该类派生出子类。基本语法形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final class 类名&#123;</span><br><span class="line">   //成员定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstract class Root&#123;</span><br><span class="line">public Root(double a,double b,double disc)</span><br><span class="line">&#123;</span><br><span class="line">this.a=a;this.b=b;  this.disc=disc;</span><br><span class="line">&#125;</span><br><span class="line">abstract void Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，第一个abstract表示定义一个抽象类，第二个abstract表示Print方法为抽象方法。如果一个类包含有抽象方法，该类必须声明为抽象类。</p><p>抽象方法在定义时无需给出方法体，只要给出方法的返回值类型和形式参数表即可。程序中不可创建抽象类对象，必须从抽象类派生出子类，在子类中实现所有抽象的方法后才可以创建子类的对象。如果子类没有实现超类中所有抽象方法，则子类也必须定义为抽象类。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java语言不支持多继承，但通过接口可以实现部分多继承的功能。</p><p>接口的定义</p><p>接口与抽象类相似，也表达一个抽象的概念。接口中的所有方法都是抽象的，每一个都没有方法体。另外，接口只可以定义static final变量成员。</p><p>接口用关键字interface来定义，基本的语法形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 &#123;</span><br><span class="line">              //成员定义</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></p><p>接口中所有方法都是抽象的，不要使用abstract。下面是一个简单的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Printable &#123;</span><br><span class="line">            public void Print();</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></p><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>接口的实现与继承类似，不过接口实现时使用关键字implements而不是extends。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class IntClass implements Printable&#123;</span><br><span class="line">             int a;</span><br><span class="line">            IntClass(int a)&#123;this.a=a;&#125;</span><br><span class="line">            public void Print()&#123;System.out.println(a);&#125;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></p><p>该类实现了上面定义的Printable接口。</p><p>当类实现特殊接口时，必须先定义该接口定义的所有抽象方法，然后才可以在该类的任何对象上调用接口的方法。与抽象类相似，允许使用接口名作为复合变量的类型，在运行时根据对象的实际类型决定调用哪个类中定义的方法，这个过程通常称为动态联编。</p><p>例如：<br>Printable obj=new IntClass(10);<br>obj.Print();</p><p>可以用instanceof运算符来判断某对象的类是否实现了特定的接口。</p><blockquote><p>一个类可以实现多个接口，多个接口名在implements后面一一列出，以逗号分隔。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">public class MyApplet extends Applet implements Runnable, MouseListener&#123; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="接口的派生"><a href="#接口的派生" class="headerlink" title="接口的派生"></a>接口的派生</h2><p>定义接口时也可以从已有的接口派生，新的接口包含了原来接口的所有成员。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface PrintName extends Printable&#123;</span><br><span class="line">            public String ClassName();</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p><h2 id="程序举例"><a href="#程序举例" class="headerlink" title="程序举例"></a>程序举例</h2><p>下面看一个完整的例子，该例演示了如何定义接口、实现接口和使用接口定义的方法。</p><p>接口的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Shape&#123;</span><br><span class="line">static double pi=3.14159;</span><br><span class="line">    public double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Circle implements Shape&#123;</span><br><span class="line">double Radius;</span><br><span class="line">Circle(double r)&#123;</span><br><span class="line">Radius=r;</span><br><span class="line">&#125;</span><br><span class="line"> public double area()&#123;</span><br><span class="line">return pi*Radius*Radius;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ch3_19 &#123;</span><br><span class="line"> public static void main(String argv[])</span><br><span class="line">&#123;</span><br><span class="line">Shape s=new Circle(2.0);</span><br><span class="line">System.out.println(&quot;Area is &quot;+s.area());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包-的-使-用"><a href="#包-的-使-用" class="headerlink" title="包 的 使 用"></a>包 的 使 用</h2><p>包的概念</p><p>Java程序编译后每一个类和接口都生成一个独立的class文件。对于一个大型程序，由于类和接口的数量很大，如果将它们全放在一起，往往显得杂乱无章，难于管理。Java语言提供了一种解决该问题的方法：将类和接口放在不同的包中。</p><p>一个包由一组类和接口组成，包内还可以有子包，类似于目录(文件夹)中可以有若干文件和子目录(子文件夹)一样。实际上，Java系统就是使用文件夹来存放包的，一个包对应一个文件夹，文件夹下有若干个class文件和子文件夹。</p><p>当要使用其他包内的类时，可以使用import语句引入其他包内的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里，java为包名，math为java包内的子包，*表示该包中所有类，该语句引入了java.math包中的所有类。</span><br></pre></td></tr></table></figure><p>ava包是Sun公司使用Java语言开发的类的集合，是随Java运行系统提供的，Java语言的很多功能依赖于该包中的类。</p><p>目前的Java虚拟机通常将java包以一种压缩文件的形式存储在特定的目录中。java包中的子包lang是自动引入的，无需使用import语句引入该包，前面提到的String、StringBuffer、Sytem等类均在该包中定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import也可以引入特定的类，只要用类名取代上面例子里的*即可。</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.Graphics;</span><br></pre></td></tr></table></figure></p><p>包的使用可以避免名字冲突，每一个类和接口的名字都包含在某个包中，不同的包中可以有同名的类和接口。</p><p>在程序中使用同名类时，可以加上包名以免引起歧义，例如java.awt.Button表示java.awt包中的Button类，此时无需使用import语句引入该类。</p><p>另外还应注意：使用import语句引入某个包中的所有类时并不包括该包的子包中的类。</p><h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><p>Java语言规定只能使用其他包中公有(public)的类和接口，即在定义该类时使用了public修饰符</p><h2 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h2><p>如果希望将程序中不同的类放在多个不同的包中，可以首先在程序的当前目录中创建相应的子目录，然后将相应的源文件放入对应的文件夹，分别编译，同时应在源文件前面加上相应的包定义语句。</p><h2 id="实训三-面向对象程序设计"><a href="#实训三-面向对象程序设计" class="headerlink" title="实训三  面向对象程序设计"></a>实训三  面向对象程序设计</h2><p>一、实训目的<br>1．掌握定义类、创建对象、使用类与对象的方法。<br>2．掌握类及其成员的修饰符的使用。<br>3．掌握如何定义和调用方法。<br>4．掌握形式参数定义，形式参数与实际参数的关系。<br>5．掌握静态变量与非静态变量、局部变量的使用以及静态方法与非静态方法的使用。<br>6．掌握构造方法的使用。<br>7．掌握字符串类、数组的使用。<br>8．掌握继承和重载的概念与实现方法。<br>9．掌握如何从已有类中派生子类。<br>10．掌握方法的覆盖和重载。<br>11．掌握定义包和接口的方法。<br>12．掌握多文件、多类程序编译和发布的方法。</p><p>二、实训内容</p><p>1．定义并使用一个新类(使用Visual J++完成本任务请参考第1章有关内容)。<br>(1) 使用纯文本编辑软件输入下面这个源程序，保存为Birthday.java。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Birthday </span><br><span class="line">&#123;</span><br><span class="line">public String year;</span><br><span class="line">public String month;</span><br><span class="line">public String day;</span><br><span class="line"></span><br><span class="line">public Birthday()</span><br><span class="line">&#123;</span><br><span class="line">year=&quot;0000&quot;;</span><br><span class="line">month=&quot;00&quot;;</span><br><span class="line">day=&quot;00&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Birthday(String y,String m,String d)</span><br><span class="line">&#123;</span><br><span class="line">year=y;</span><br><span class="line">month=m;</span><br><span class="line">day=d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getBirthday()</span><br><span class="line">&#123;</span><br><span class="line">String fullbirthday=month+&quot;/&quot;+day+&quot;/&quot;+year;</span><br><span class="line">return fullbirthday;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2) 编译这个程序，如果顺利完成，将在当前目录下生成一个名为Birthday.class的文件。<br>(3) 输入以下源程序，保存为useBirthday.java。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">           public class useBirthday </span><br><span class="line">           &#123;</span><br><span class="line">           public static void main(String argv[])</span><br><span class="line">            &#123;</span><br><span class="line">           Birthday birthday1=new Birthday();</span><br><span class="line">           Birthday birthday2=new Birthday(&quot;1949&quot;,&quot;10&quot;,&quot;01&quot;);</span><br><span class="line">          System.out.println(birthday1.getBirthday());</span><br><span class="line">          System.out.println(birthday2.getBirthday());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(4) 编译useBirthday.java后，执行以下命令运行程序：<br>java useBirthday</p><p>2．定义一个类Myclass，包含一个整型属性data和封装这两个属性的两个方法getData()和setData()。然后编写一个使用上面定义的类Myclass的Java Applet程序，实现数据的访问和输出。</p><p>3．编写一个类实现复数的运算。复数类Complex的属性有：<br>mReal：实部，代表复数的实数部分；<br>mImage：虚部，代表复数的虚数部分。</p><p>复数类Complex的方法有：</p><p>Complex(double r，double i)：构造函数，创建复数对象的同时完成复数的实部、虚部的初始化，r为实部的初值，i为虚部的初值。</p><p>getReal()：获得复数对象的实部。<br>getImage()：获得复数对象的虚部。</p><p>setReal(double d)：将当前复数对象的实部设置为给定的形式参数的值。<br>setReal(String s)：将当前复数对象的实部设置为给定的形式参数字符串字面所代表的值。</p><h2 id="习-题-三"><a href="#习-题-三" class="headerlink" title="习  题  三"></a>习  题  三</h2><p>1．类及类成员的访问控制符有哪些?</p><p>答：来源网络</p><p>public：<br>可以在任何地方进行访问，不受任何约束；<br>protected:<br>可被子类访问，不管是同一个包还是不同包<br>同一个包中非子类需要通过对象访问<br>private：<br>只能够被本类中的其它成员访问，而不能从类的外部进行访问<br>缺省：称为friendly，可被同一包的所有的类访问<br>final:<br>final修饰的类表示这个类不可被继承，被称为最终类<br>Static:<br>不能用来修饰类,可以用来修饰变量，用static修饰的变量称为静态变量，可以直接通过 类名.变量名<br>来调用</p><p>2．为什么说构造方法是一种特殊的方法? 特殊在哪里? 构造方法什么时候执行? </p><p>在java语言 中，构造函数又称构造方法。特殊性在于，与普通方法的区别是，他与类名相同，不返回结果也不加void返回值。构造函数的作用是初始化对象，即在创建对象时被系统调用（与普通方法不同，程序不能显示调用构造函数）。构造函数还能够被重载，即可以传入参数，当程序中包含有带参的构造函数时，系统将不会再提供的无参构造函数。</p><p>3．下面的关键字哪些是类及其成员的修饰符?<br>(1)  public      (2)  synchronized      (3)  class      (4)  void<br>(5)  private      (6)  protected        (7)  friendly      (8)  double</p><p>4．静态变量成员有什么特点? 类对象可以访问或修改静态变量成员吗？</p><p>1.特点一:静态变量的值是共享。比如说A类中有个静态变量V_A，A类创建了两个实例a，b。如果给实例a的变量V_A赋值，如a.V_A=1。那么这时候查看实例b的V_A变量的值也为1，也就是说A对象实例化的两个类共享同一个变量值，而且静态变量<br>2.特点二:不需要对象实例化就可以使用。比如A类中的静态变量V_A可以用A.V_A的形式使用</p><p>一、static变量有什么作用呢？<br>（1） 在函数体内，值维持不变，具有“记忆”功能；<br>（2）在模块内（但在函数体外），不能被模块外的其他函数访问；<br>（3）只在一个源文件中有效，不能被其他源文件使用。</p><p>引申：static变量只初始化一次 </p><p>5．对象初始化有哪几种方法? 写出它们的执行顺序。</p><p>1、构造器<br>创建对象时初始化，比较常见。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">classA&#123;</span><br><span class="line">publicA()</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public</span><br></pre></td></tr></table></figure><p>2、初始化块<br>较少见，用于有特殊要求的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java 创建对象的四种方式、java对象初始化顺序<br>java创建对象的几种方式：</p><p>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p><p>其中：<br>(1)和(2)都会明确的显式的调用构造函数 ；</p><p>(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；</p><p>(4)是从文件中还原类的对象，也不会调用构造函数。</p><p>对象的初始化顺序：</p><p>（1）类加载之后，按从上到下（从父类到子类）执行被static修饰的语句；</p><p>（2）当static语句执行完之后,再执行main方法；</p><p>（3）如果有语句new了自身的对象，将从上到下执行构造代码块、构造器（两者可以说绑定在一起）。</p><p>3、方法<br>即Setter方法，虽然方便（不必在创建对象时一次性初始化），但是可能引发空指针异常。</p><p>6．抽象类有什么作用? 接口与抽象类有什么区别？</p><p>接口和抽象类有什么区别?</p><p>你选择使用接口和抽象类的依据是什么？</p><p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。</p><p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。</p><p>人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.</p><p>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 </p><p>第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。<br>第二点． 接口可以多继承，抽象类不行<br>第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。<br>第四点． 接口中基本数据类型为static 而抽类象不是的。 </p><p>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。<br>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的</p><p>所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。</p><p>7．抽象方法有什么特点? 抽象方法的方法体在何处定义?</p><p>抽象方法一般都定义在父类里面,但这个父类也必须是抽象的,它的特点是没有方法体,只有方法名如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class A&#123;</span><br><span class="line">  public abstract void print();//print()方法没有方法体;</span><br><span class="line">&#125;</span><br><span class="line">//类B 继承A,类B 必须实现父类A中的抽象方法print()</span><br><span class="line">class B extends A&#123;</span><br><span class="line">  public void print()&#123;</span><br><span class="line">   //方法体....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象方法的好处就在于能让子类做一些特定的事</p><p>8．为什么定义fianl变量成员时往往声明为static的？</p><p>Java中常量为什么定义为public static final </p><p>final关键字定义常量，就使得他在被定义后无法再对此进行赋值。而有时候定义的常量是个随机数，这时为了保证不使每次初始化后常量改变，就需要加static了。在同一个对象中是不需要的。被static修饰的变量可以不通过对象用类名直接访问，且只被分配一次内存，节约内存。实质上，就是一个全局变量。static定义的类。。。不知道你指的是不是类中的静态方法。方法的话，和变量一样，可以用类名直接调用，但是不能直接访问这个类除静态外的变量和方法。如果是静态类的话，普通类是不支持声明为静态类的，只有内部类才可以。能直接作为一个普通类使用，不需要实例外部类。作用就很多了，它可以在他所属类创建之前就被访问，最常用的例子就是main方法了。他会独立于该类的任何对象。java虚拟机的加载的顺序为，先加载静态成员变量，然后是静态代码块；同等级的才按照前后顺序依次加载。</p><p>final是常量，这个是不占有存储空间的，只能通过对象来引用。<br>static是类成员（区别于对象成员），可以通过类（推荐）和对象来引用。只要你的类加载了，则你的类中static成员就一直可以使用。而final只能存活到对象销毁之前。<br>还有一种是 static final，这个是静态类成员变量，也不占内存。其他和static一样。</p><p>9．下面哪些访问控制修饰符的使用是合法的：<br>(1)  public class MyClass{…}<br>(2)  public protected int IntegerValue;<br>(3)  friendly float FloatValue;<br>(4)  String s;<br>10．final修饰符和abstract可以同时使用吗？为什么？</p><p>关键字final和abstract是否可以同时做类的修饰符，为什么？ </p><p>不可以的。<br>解释：final的类不能被重写和继承，而abstract的类是抽象类，本身没有实现，只能通过子类来实现，也就是说必须被继承。所以说它们是没法同时做修饰符的。</p><p>不可以。final修饰类代表该类不能有子类，abstract修饰的类为抽象类，抽象类就是给其他类继承的。明显存在矛盾</p><p>final关键字的用法：</p><p>   1、final关键字修饰变量（成员变量和局部变量的区别，引用变量和基本数据类型的区别）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2、final可以修饰方法</span><br><span class="line">3、final修饰类</span><br></pre></td></tr></table></figure></p><p>其中final修饰方法跟继承有关，而且不能被子类重写；</p><p>fianl修身类是不能被继承的；而且要注意：fianl修饰基本数据类型的成员变量必须赋值，否则编译器报错。并且fianl修饰的成员变量一旦赋值就不可改变。</p><p>abstract 关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abstract要注意一下几点：</span><br><span class="line"></span><br><span class="line">1.对于方法来说，加了abstract就没有意义了。</span><br><span class="line">2.有抽象方法的类一定是抽象类，抽象类不一定有抽象方法。然而方法中用了abstract，那本身就成了抽象类。</span><br><span class="line"></span><br><span class="line">    例如：public abstract class Shape&#123;&#125;  // 表示抽象类。</span><br><span class="line"></span><br><span class="line">3.抽象类不允许被实例化。</span><br><span class="line"></span><br><span class="line">4.抽象类有构造方法，子类可以通过shper调用父类的构造方法，对从父类的属性进行初始化。</span><br><span class="line"></span><br><span class="line">5.抽象关键字不可以与fianl关键字一起使用，因为abstract要求子类一定要重写父类的方法，但fianl不允许重写。</span><br><span class="line"></span><br><span class="line">6.抽象关键字不恶意和private关键字一起使用，因为private是私有的，不能被继承的内容代表根本不存在</span><br><span class="line"></span><br><span class="line">7.关键字不能与static一起使用，static是静态修饰符，代表不需要实例化对象，直接类名就可以调用，如果是抽象方法，没有方法实现调用方法会出错，所以不能一起使用。</span><br><span class="line"></span><br><span class="line">8.构造方法不允许被继承，也没有重写，不能用abstract修饰。</span><br><span class="line"></span><br><span class="line">注意：用abstract修饰的方法没有方法执行体，因为不行有任何内容；而且abstract修饰的方法在子类中必须重写，抽象类不能够被实例化，可子类创建对象进行调用。</span><br></pre></td></tr></table></figure></p><h2 id="类的定义和对象使用"><a href="#类的定义和对象使用" class="headerlink" title="类的定义和对象使用"></a>类的定义和对象使用</h2><p>Java程序的开发过程<br>数据类型<br>运算符和表达式<br>语句</p><h3 id="面向对象编程的基本概念"><a href="#面向对象编程的基本概念" class="headerlink" title="面向对象编程的基本概念"></a>面向对象编程的基本概念</h3><p>类的定义</p><ul><li>类首部</li><li>类体</li></ul><ol><li>成员变量</li><li>成员方法</li></ol><p>对象的创建与使用</p><ul><li>创建对象</li><li>使用对象</li></ul><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><h2 id="面向对象编程的基本概念-1"><a href="#面向对象编程的基本概念-1" class="headerlink" title="面向对象编程的基本概念"></a>面向对象编程的基本概念</h2><p>类和对象</p><ul><li>类是 定义对象的 模板，用来描述一类事物的 共有 属性 和 功能 。</li><li>对象 是 一个具体的 事物。</li></ul><p>例：<br>汽车类—某辆汽车<br>学生类—某个学生<br>窗口类—某个具体的窗口</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ul><li><p>类的定义 可以是 分层次 的，低层的类 具有 高层类的 属性 和 方法 ，称高层类为 父类 ，低层类 为 子类。 子类 使用父类中定义的 方法和变量 时，就像它们属于子类本身一样。</p></li><li><p>可以简化编程的过程，有利于代码的复用。 子类除了拥有 父类的方法和变量 之外，也可以 定义自己 方法和变量 。</p></li></ul><p>哺乳动物：胎生，能用母乳喂养幼仔。<br>猫：胎生，能用母乳喂养幼仔。会捉老鼠。</p><h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><p>类 是 Java语言中的一种 复合数据类型 ，是组成Java程序的 基本要素 。Java的类 具有两种基本成分： 数据和行为（状态和方法）。类的这两种 成分 被封装在类体中，与外界隔开。</p><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类首 [修饰符]  class 类名 [extends父类名]</p><p>类体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">[类成员变量声明；]</span><br><span class="line">[类方法声明]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最简单的类定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class  A</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类的修饰符有：<br>public、abstract、final……</p><blockquote><p>extends  父类名：表示所定义的类由“父类”继承而来。</p></blockquote><blockquote><p>implements 接口列表：该类对指定接口进行实现。</p></blockquote><h2 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h2><p>成员变量：是类的数据成分，在类体中直接定义，定义格式如下：</p><blockquote><p>[修饰符]    变量类型  成员变量名列表；</p></blockquote><p>成员变量的定义可以在定义前加修饰符：public、private、protected、final、static等，用来标识变量的使用范围和性质。</p><blockquote><p>局部变量：在方法体内定义的变量和方法的参数是局部变量。</p></blockquote><ol><li><p>变量类型可以是基本数据类型，也可以是引用数据类型，如：数组、类类型。</p></li><li><p>成员变量在整个类的内部有效，局部变量只在定义它的方法内有效。</p></li><li><p>局部变量名可以和成员变量名重名，此时局部变量会隐藏成员变量，如果想在该方法内部使用成员变量，使用关键字this。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class People</span><br><span class="line">&#123;</span><br><span class="line">float hight,weight;</span><br><span class="line">String head,ear,mouth; </span><br><span class="line">void speak(String s)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>成员方法是类的行为成分，声明格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]   返回值类型   方法名（[形参列表]） </span><br><span class="line">&#123;</span><br><span class="line">[方法体]</span><br><span class="line">[return  表达式；]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>修饰符：public 、 private、protected、static、final……</li><li>如果方法没有返回值，则使用void关键字。如果有返回值类型，则方法体中必须有return语句，并且表达式类型与方法类型一致。</li><li>形式参数列表的形式如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型名   形参名1，类型名   形参名2，……</span><br><span class="line">如：public void out(int x,int y,float f)</span><br><span class="line">&#123;System.out.println(“x=”+x+”y=”+y+”f=”+f); &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Triangle&#123;</span><br><span class="line">float sideA,sideB,sideC,lengthSum;</span><br><span class="line">void setSide(float sideA,float sideB,float sideC)&#123;</span><br><span class="line">this.sideA=sideA;</span><br><span class="line">this.sideB=sideB;</span><br><span class="line">this.sideC=sideC;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的定义–例1"><a href="#类的定义–例1" class="headerlink" title="类的定义–例1"></a>类的定义–例1</h2><p>定义描述“人”的类：<br>成员变量：姓名、性别、年龄；<br>成员方法：唱歌，跳舞，输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">String name,sex;</span><br><span class="line">int age;</span><br><span class="line">void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;I can sing!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void dance()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;I can dance!&quot;);</span><br><span class="line">&#125; </span><br><span class="line">void out()//成员变量的操作只能放在方法中</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;name:&quot;+name);</span><br><span class="line">System.out.println(&quot;age:&quot;+age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：一个类中可以没有main方法，此时它不是Java的application应用程序，也就是不能被Java虚拟机直接调用。</p><h2 id="类的定义–例2梯形"><a href="#类的定义–例2梯形" class="headerlink" title="类的定义–例2梯形"></a>类的定义–例2梯形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">梯形类：</span><br><span class="line">class Ladder</span><br><span class="line">&#123;</span><br><span class="line">float a,b,h;</span><br><span class="line">void setH(float h)</span><br><span class="line">&#123;</span><br><span class="line">this.h=h;</span><br><span class="line">&#125;</span><br><span class="line">float calculatArea()</span><br><span class="line">&#123;</span><br><span class="line">return   (a+b)*h/2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h2><p>如何调用类中定义的成员变量和成员方法，在Java中类只有实例化为对象后才能被使用(注：main方法为特殊方法，由系统调用) ，对象的使用“分三步走”：</p><p>1、声明对象<br>    类名  对象名；</p><p>2、分配内存（对象的实例化）<br>    对象名=new 类构造方法名（[实参表]）；</p><p>3、使用对象（对象的成员变量及方法的访问）<br>    对象名.方法名、对象名.成员变量名</p><p>声明和初始化可以合并：<br>类名  对象名=new 类的构造方法名（ [实参表] ）；<br>说明：<br>构造方法名与类名相同，如果一个类中未定义构造方法，系统自动定义。</p><h3 id="使用对象—例3"><a href="#使用对象—例3" class="headerlink" title="使用对象—例3"></a>使用对象—例3</h3><p>方法一：在同一个类中使用对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Person p;</span><br><span class="line">p=new Person();</span><br><span class="line">p.name=&quot;zhangsan&quot;;</span><br><span class="line">p.age=20;</span><br><span class="line">p.sing();</span><br><span class="line">p.out();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用对象—例4"><a href="#使用对象—例4" class="headerlink" title="使用对象—例4"></a>使用对象—例4</h3><p>方法二：在不同类中使用对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br><span class="line">class  PersonTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Person p;</span><br><span class="line">p=new Person();</span><br><span class="line">p.name=&quot;zhangsan&quot;;</span><br><span class="line">p.age=20;</span><br><span class="line">p.sing();</span><br><span class="line">p.out();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用对象—例5-梯形"><a href="#使用对象—例5-梯形" class="headerlink" title="使用对象—例5 梯形"></a>使用对象—例5 梯形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">float area;</span><br><span class="line">Ladder ladder=new Ladder();</span><br><span class="line">ladder.a=10.0f;</span><br><span class="line">ladder.b=20.0f;</span><br><span class="line">ladder.setH(5f);</span><br><span class="line">area=ladder.calculatArea();</span><br><span class="line">System.out.println(&quot;area=&quot;+area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象的内存模型"><a href="#对象的内存模型" class="headerlink" title="对象的内存模型"></a>对象的内存模型</h2><p>引用数据类型 与 引用变量：引用数据类型（数组、类）声明的变量为 引用变量 ，引用变量本身 并不存放数据 ，而只是 存放数据的地址  。 </p><blockquote><p>Java的内存分配 — Java把内存划分成两种： 栈内存、堆内存</p></blockquote><p>Person p;<br>声明对象p时，</p><p>在栈内存中分配空间，用来存放一个地址，此时地址未指向任何数据。</p><p>p=new Person();时，</p><p>首先在堆内存中为对象分配存储空间，并对各成员变量进行初始化，数值型为0，布尔型为false，引用型为null；然后 取得这个存储空间的地址（引用），将其“交给”引用变量p，以后对这个对象的操作全由p去控制。</p><blockquote><p>多次使用new便会创建多个不同的对象。</p></blockquote><p>在方法中定义的一些基本类型的变量和引用变量都是在方法的栈内存中分配。当在一段代码块（也就是一对{}之间）定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后， Java会自动释放为该变量分配的内存空间，以前所讲的变量分配都是在栈内存中存放的。</p><h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(“我是构造方法，已被调用！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们并没有调用对象的Person()方法，但是它却被执行了。<br>这个方法就是构造方法</p><h2 id="构造方法的说明"><a href="#构造方法的说明" class="headerlink" title="构造方法的说明"></a>构造方法的说明</h2><p>说明形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [构造方法修饰符] 方法名（[形式参数列表]）</span><br><span class="line">&#123;方法体&#125;</span><br></pre></td></tr></table></figure></p><p>⑴构造方法的名字与类的名字相同</p><p>⑵构造方法没有返回类型</p><p>(千万不要将返回值类型声明为void。也不能在方法内部使用return返回一个值。)</p><p>一般将构造方法声明为公共的public型。</p><p>⑶构造方法对对象的创建是必须的。</p><p>实际上Java语言为每一个类提供了一个默认的构造方法，也就是说，每个类都有构造方法。</p><p>如果不定义一个构造方法，Java语言将调用它提供的默认的构造方法对一个新的对象进行初始化。</p><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>在一个类中可以定义同名的方法，但是 参数的类型和个数 不能完全相同，</p><p>同名的方法可以有不同的方法体从而完成不同的任务，</p><p>当调用方法时，系统会自动调用与实际参数类型和个数相匹配的的那一个方法，</p><p>这就是方法的重载。</p><p>在面向对象编程中，这种同一个名字可以有不同解释的现象称为多态。</p><h2 id="类与对象-1"><a href="#类与对象-1" class="headerlink" title="类与对象"></a>类与对象</h2><p>方法的重载、static、包</p><p>类的定义</p><ul><li>成员变量说明</li><li>成员方法说明</li></ul><p>对象的创建和使用</p><ul><li>创建对象</li><li>通过对象引用成员变量和成员方法</li></ul><p>构造方法</p><ul><li>构造方法与一般成员方法的区别</li></ul><p>方法的重载</p><ul><li>成员方法的重载</li><li>构造方法的重载</li></ul><blockquote><p>static变量和static方法</p></blockquote><p>包</p><ul><li>package命令</li><li>import命令</li></ul><h2 id="方法的重载-1"><a href="#方法的重载-1" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>在一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同，即或者是参数的个数不同，或者是参数的类型不同。</p><p>同名的方法可以有不同的方法体从而完成不同的任务，当调用方法时，系统会根据调用方法的实际参数类型和个数自动调用相应的方法，这就是方法的重载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Heshang</span><br><span class="line">&#123;</span><br><span class="line">void dashui(String s)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println (s+&quot;挑水喝&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void dashui(String s1,String s2)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println (s1+&quot;和&quot;+s2+&quot;抬水喝&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void dashui(String s1,String s2,String s3)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println (s1+&quot; &quot;+s2+&quot; &quot;+s3+&quot;没水喝&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    Heshang h=new Heshang();</span><br><span class="line">    h.dashui(&quot;孙悟空&quot;);</span><br><span class="line">    h.dashui(&quot;孙悟空&quot;,&quot;猪八戒&quot;);</span><br><span class="line">    h.dashui(&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">String name;int age;float height,weight;</span><br><span class="line">public Person()</span><br><span class="line">&#123;</span><br><span class="line">age=18;</span><br><span class="line">name=&quot;无名&quot;;</span><br><span class="line">&#125;</span><br><span class="line">public Person(String name)</span><br><span class="line">&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">public Person(String name,int age,float height,float weight)</span><br><span class="line">&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.age=age;</span><br><span class="line">this.height=height;</span><br><span class="line">this.weight=weight;</span><br><span class="line">&#125;</span><br><span class="line">void out()//成员变量的操作只能放在方法中</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(“姓名:”+name+“ 年龄:”+age+“岁”+</span><br><span class="line">&quot; 身高:&quot;+height+&quot;米&quot;+&quot; 体重:&quot;+weight+&quot;斤&quot;);</span><br><span class="line">System.out.println ();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class PersonTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Person p1,p2,p3;</span><br><span class="line">p1=new Person();</span><br><span class="line">p2=new Person(&quot;孙悟空&quot;);</span><br><span class="line">p3=new Person(&quot;猪八戒&quot;,300,2.8f,380);</span><br><span class="line">p1.out();p2.out();p3.out();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象变量的赋值"><a href="#对象变量的赋值" class="headerlink" title="对象变量的赋值"></a>对象变量的赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class PersonTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Person p1,p2,p3;</span><br><span class="line">p1=new Person();</span><br><span class="line">p2=new Person(&quot;孙悟空&quot;);</span><br><span class="line">p3=new Person(&quot;猪八戒&quot;,300,2.8f,380);</span><br><span class="line">p1=p2;</span><br><span class="line">p1.name= “唐僧”;p1.age=50;</span><br><span class="line"> p1.out(); p2.out(); p3.out();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象变量的赋值，只是对象中保存的地址发生的变化，而并未改变对象的状态。<br>如果一个对象没有任何变量引用它，则它成为垃圾内存。</p><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>静态变量/静态方法：对于成员变量/成员方法的声明，可以在类型的前面加修饰符“static”，称之为静态变量/静态方法。</p><p>类变量/类方法和实例变量/实例方法：静态变量/静态方法属于类而不属于类的某个实例，可直接由类名来调用（类名·变量名/类名·方法名），因此也叫类变量/类方法；</p><p>非静态的成员变量/方法必须实例化后通过对象名来调用（对象名·变量名/对象名·方法），因此称为实例变量/实例方法。</p><p>说明：类变量和类方法也可以通过实例调用。</p><p>类变量，它属于类所有，且在所有的实例中都共享同一个内存空间；</p><p>实例变量，对于每一个实例，这个变量都拥有独自的内存空间。</p><p>类方法，在类加载时分配方法入口地址，因此可被类直接调用。</p><p>实例方法，只有创建类的对象，才会分配方法入口地址，并只能通过对象调用方法。</p><p>main()方法是静态的，因此java虚拟机在执行main方法时不需创建main方法所在类的实例就可以直接调用。</p><h2 id="类变量-类方法、实例变量-实例方法"><a href="#类变量-类方法、实例变量-实例方法" class="headerlink" title="类变量/类方法、实例变量/实例方法"></a>类变量/类方法、实例变量/实例方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class StaticDemo</span><br><span class="line">&#123;</span><br><span class="line">    static int x;</span><br><span class="line">    int y;</span><br><span class="line">    public static int getX()</span><br><span class="line">    &#123;</span><br><span class="line">return x;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void setX(int newX)</span><br><span class="line">    &#123;</span><br><span class="line">x=newX;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getY()</span><br><span class="line">    &#123;</span><br><span class="line">return y;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setY(int newY)</span><br><span class="line">    &#123;</span><br><span class="line">y=newY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存模型分析"><a href="#内存模型分析" class="headerlink" title="内存模型分析"></a>内存模型分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ShowDemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;静态变量 x=&quot;+StaticDemo.getX());</span><br><span class="line">        StaticDemo a=new StaticDemo();</span><br><span class="line">        StaticDemo b=new StaticDemo();</span><br><span class="line">        a.setX(10);</span><br><span class="line">        a.setY(20);</span><br><span class="line">        b.setX(30);</span><br><span class="line">        b.setY(40);</span><br><span class="line">        System.out.println(&quot;静态变量 a.x=&quot;+a.getX());</span><br><span class="line">        System.out.println(&quot;实例变量 a.y=&quot;+a.getY());</span><br><span class="line">        System.out.println(&quot;静态变量 b.x=&quot;+b.getX());</span><br><span class="line">        System.out.println(&quot;实例变量 b.y=&quot;+b.getY());</span><br><span class="line">        System.out.println(&quot;静态变量 x=&quot;+StaticDemo.getX());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="static应用注意事项"><a href="#static应用注意事项" class="headerlink" title="static应用注意事项"></a>static应用注意事项</h2><p>总结（静态成员在使用时应该注意）：</p><p>1、静态方法中只能直接调用同类中其他静态成员，而不能调用非静态成员。反之，则可以。<br>2、静态成员的引用直接通过类名引用，也可以通过该类的对象来引用。<br>3、静态方法中不能使用super和this变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例3：</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    static int i=10;</span><br><span class="line">    String s=&quot;hello world!&quot;;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">System.out.println(&quot;i=&quot;+i);</span><br><span class="line">       //System.out.println(&quot;s=&quot;+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this关键字只能用在实例方法或构造方法中，代表使用该方法的当前的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void setAge(int age)</span><br><span class="line">&#123;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Person p1,p2,p3;</span><br><span class="line">p1=new Person();</span><br><span class="line">p2=new Person(&quot;孙悟空&quot;);</span><br><span class="line">p3=new Person(&quot;猪八戒&quot;,300,2.8f,380);</span><br><span class="line">p1.setAge(18);p2.setAge(19);p3.setAge(20);</span><br><span class="line">p1.out();p2.out();p3.out();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h2><p>为了便于管理大型软件系统中数目众多的类，解决类命名冲突的问题，java引入了包。<br>Java中的包与文件系统的目录层次结构是一一对应的。一个包中可以包含子包，包名与子包名间用“·”分隔。<br>Java提供的类和接口是按不同的用途分别放在不同的包中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.applet</span><br><span class="line">java.awt</span><br><span class="line">java.lang</span><br><span class="line">java.io</span><br><span class="line">java.net</span><br><span class="line">java.util</span><br></pre></td></tr></table></figure></p><h2 id="package-语句"><a href="#package-语句" class="headerlink" title="package 语句"></a>package 语句</h2><p>功能：创建包<br>格式：package 包名[.子包名[…]];<br>要求：此语句必须放在整个源程序第一条语句<br>例：package  p;//(在当前目录下创建一个p包)<br>      package  a.b;//（在当前目录下创建a，在a下再创建b）<br>注意：嵌套的包名之间以圆点分隔（“.”）。如果源文件中省略了package语句，则文件中定义的类隐含在一个无名包中，这个无名包就是源文件所在的位置。</p><blockquote><p>引入java包中的类和接口import语句</p></blockquote><p>一般情况下import语句紧跟在package语句之后<br>功能：将其他包中的类引入到当前程序中。<br>格式：import  带包层次结构的类名;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">1、引入包时，类名可以使用通配符“*”，表示包模块中某个层次的类全引入进来。</span><br><span class="line">例：import  java.io.*;</span><br><span class="line">import java.awt.Graphics;</span><br><span class="line">2、java会自动引入lang包下的所有类和接口。</span><br><span class="line">3、前缀包名法：不用import语句也可以引入其他包中的类和接口。</span><br></pre></td></tr></table></figure><h2 id="类与对象-2"><a href="#类与对象-2" class="headerlink" title="类与对象"></a>类与对象</h2><blockquote><p>访问权限、类的继承、对象的上转型</p></blockquote><p>访问权限</p><p>私有变量和私有方法（private关键字）<br>共有变量和共有方法(public关键字)<br>保护变量和保护方法(protected关键字)</p><p>友好变量和友好方法<br>public类与友好类</p><p>类的继承（重点）</p><p>创建子类<br>子类的继承性</p><blockquote><p>成员变量的隐藏和方法的重写</p></blockquote><p>final类和final方法</p><p>对象的上转型对象<br>多态性</p><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>用一个类创建一个对象后，通过对象可以访问这个类的成员变量和成员方法，但这种访问是有一定限制的。</p><p>这种限制取决于在声明变量和成员方法时使用的修饰符：public、private、protected、友好（未使用修饰符）。</p><h3 id="private变量和方法"><a href="#private变量和方法" class="headerlink" title="private变量和方法"></a>private变量和方法</h3><p>访问权限最小，只能在同一个类中被访问。</p><ul><li>同一个类的方法中直接访问。</li><li>同一个类的对象也可以引用本类的私有成员。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Tom</span><br><span class="line">&#123;</span><br><span class="line">private  float weight;</span><br><span class="line">private static String name;</span><br><span class="line"></span><br><span class="line">private void out()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println (name+&quot;体重：&quot;+weight+&quot;斤&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">    Tom.name=&quot;汤姆猫&quot;;</span><br><span class="line">Tom cat=new Tom();</span><br><span class="line">    cat.weight=20; //或cat.setWeight(20);</span><br><span class="line">    cat.out();    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的私有成员不能在另一个类中引用<br>私有的类变量和类方法也只能在本类中使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Jerry</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">    Tom.name=&quot;汤姆猫&quot;;//非法使用类变量</span><br><span class="line">Tom cat=new Tom();</span><br><span class="line">    cat.weight=20;//非法引用变量weight</span><br><span class="line">cat.setWeight(20);//合法地调用方法setWeight()</span><br><span class="line">    cat.out();//非法调用方法out()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="public变量和方法"><a href="#public变量和方法" class="headerlink" title="public变量和方法"></a>public变量和方法</h2><p>访问权限最大，可以在不同类、不同包的类中访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package p1;</span><br><span class="line">public class Area</span><br><span class="line">&#123;</span><br><span class="line">public float getArea(float r)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(&quot;方法一：&quot;);</span><br><span class="line">return 3.14f*r*r;</span><br><span class="line">&#125;</span><br><span class="line">public double getArea(float x,int y)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(&quot;方法二：&quot;);</span><br><span class="line">return x*y;</span><br><span class="line">&#125;</span><br><span class="line">public float getArea(int x,float y)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(&quot;方法三：&quot;);</span><br><span class="line">return x*y;</span><br><span class="line">&#125;</span><br><span class="line">public double getArea(float x,float y,float z)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(&quot;方法四：&quot;);</span><br><span class="line">return (x+x+y*y+z*z)*2.0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package p2;</span><br><span class="line">import p1.Area;</span><br><span class="line">class AreaTest</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">    Area a=new Area();</span><br><span class="line">    System.out.println (a.getArea(2.0f));</span><br><span class="line">    System.out.println (a.getArea(12,2.7f));</span><br><span class="line">    System.out.println (a.getArea(2.7f,12));</span><br><span class="line">    System.out.println (a.getArea(2.0f,10,20));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友好变量和方法"><a href="#友好变量和方法" class="headerlink" title="友好变量和方法"></a>友好变量和方法</h2><p>不使用修饰符：public、private、protected，即缺省这些修饰符的情况。<br>比private权限级别高一级<br>友好成员只能被同类或同包中的不同类引用。</p><h2 id="protected变量和方法"><a href="#protected变量和方法" class="headerlink" title="protected变量和方法"></a>protected变量和方法</h2><p>比友好成员高一级，比public低一级。<br>不能在不同包的类中被引用。<br>如果不同包中的类是本类的子类，则子类的对象可以引用本类的受保护成员。</p><h3 id="方法的访问控制"><a href="#方法的访问控制" class="headerlink" title="方法的访问控制"></a>方法的访问控制</h3><p>同类 public    protected 友好 private</p><p>同包不同类 public protected 友好</p><p>不同包子类 public protected</p><p>通用 public </p><h3 id="public类和友好类"><a href="#public类和友好类" class="headerlink" title="public类和友好类"></a>public类和友好类</h3><p>如果定义类时，使用public修饰，则该类为公共类。可以在不同的包中被其他类使用。<br>如果未使用修饰符，则为友好类。只能被同包里的类使用。</p><h2 id="类的继承-1"><a href="#类的继承-1" class="headerlink" title="类的继承"></a>类的继承</h2><p>继承：由已有类创建新类的机制。新类继承已有类的成员，并可根据需要增加自己新的成员。已有类称为父类，新类称为已有类的子类。</p><p>Java不支持多继承，一个子类只能有一个父类，但一个父类可以派生出若干个子类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Person</span><br><span class="line">&#123;</span><br><span class="line">     String name;</span><br><span class="line">     int age;</span><br><span class="line">     public void setAge(int age)</span><br><span class="line">     &#123;</span><br><span class="line">this.age=age;</span><br><span class="line">     &#125;</span><br><span class="line">     public void out()</span><br><span class="line">     &#123;</span><br><span class="line">     System.out.println(&quot;姓名:&quot;+name+&quot; 年龄:&quot;+age+&quot;岁&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person</span><br><span class="line">&#123;</span><br><span class="line">     int java,flash;</span><br><span class="line">     void learn()</span><br><span class="line">     &#123;</span><br><span class="line">          System.out.println (name+&quot; is learning!&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     void outStudent()</span><br><span class="line">     &#123;</span><br><span class="line">System.out.println (&quot;java:&quot;+java+</span><br><span class="line">&quot;\tflash:&quot;+flash);</span><br><span class="line">     &#125;</span><br><span class="line">     public static void main(String[]args)</span><br><span class="line">     &#123;</span><br><span class="line">    Student s=new Student();</span><br><span class="line">    s.name=&quot;孙悟空&quot;;</span><br><span class="line">    s.age=500;s.java=80;s.flash=85;</span><br><span class="line">    s.learn();</span><br><span class="line">    s.outStudent();s.out();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的继承性"><a href="#类的继承性" class="headerlink" title="类的继承性"></a>类的继承性</h2><p>子类和父类在同一包中<br>子类可继承其父类中非私有成员（不是private的成员）<br>子类和父类不在同一包中<br>子类只能继承受保护的和共有成员（public、protected）</p><h2 id="成员变量的隐藏和方法的重写"><a href="#成员变量的隐藏和方法的重写" class="headerlink" title="成员变量的隐藏和方法的重写"></a>成员变量的隐藏和方法的重写</h2><p>成员变量的隐藏：如果在子类中定义了与父类中同名的变量，父类的这个变量将被隐藏。</p><p>方法的重写：如果子类中定义了与父类同名、同类型、相同参数的方法，则称子类覆盖了父类的方法。</p><p>这是子类的一种“变异”，子类可以根据需要把从父类继承来的方法进行改造。<br>比如：在student类中重新声明变量age和方法out()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    Student s=new Student();</span><br><span class="line">    s.name=&quot;孙悟空&quot;;</span><br><span class="line">    s.age=500;</span><br><span class="line">s.java=80;</span><br><span class="line">s.flash=85;</span><br><span class="line">    s.learn();</span><br><span class="line">    s.out();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="super变量"><a href="#super变量" class="headerlink" title="super变量"></a>super变量</h2><p>特殊变量super，提供了对父类的访问。</p><p>1、可以使用super访问父类被子类隐藏的变量或覆盖的方法。<br>如：在student类中改写out方法时，可以使用super.out();来调用父类中对name和age的输出。调用父类的变量super.name。</p><p>2、可能通过Super([参数表])来高用父类的构造方法。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。<br>如：在Person类中只定义带参数的构造方法，如何定义子类Student的构造方法？？？？？？？</p><h2 id="final类和final成员"><a href="#final类和final成员" class="headerlink" title="final类和final成员"></a>final类和final成员</h2><p>final类：不能派生子类。<br>final变量，其值不能在程序运行过程中改变，是常量。<br>final方法，不能被子类方法重写。</p><h2 id="对象的上转型对象"><a href="#对象的上转型对象" class="headerlink" title="对象的上转型对象"></a>对象的上转型对象</h2><p>父类的变量能否引用子类的对象？能。</p><p>子类的变量能否引用父类的对象？不能。</p><p>父类的变量称为子类对象的上转型对象。</p><p>Person  p;<br>p=new Student();</p><p>Student s;<br>s=new Student();</p><p>p=s;</p><h2 id="上转型对象操作说明"><a href="#上转型对象操作说明" class="headerlink" title="上转型对象操作说明"></a>上转型对象操作说明</h2><p>上转型对象不能操作子类新增成员<br>上转型对象可以操作从父类继承的成员，或在子类中重写的父类成员。<br>上转型对象在被改写的成员时，调用子类成员，而非父类成员。<br>上转型对象通过强制类型转换成为子类对象。</p><h2 id="多态性-1"><a href="#多态性-1" class="headerlink" title="多态性"></a>多态性</h2><p>在程序中同一符号或名字在不同情况下具有不同解释的现象称为多态性。表现在两方面：<br>方法的重载。</p><p>对象的上转型对象。子类可以改写父类的方法，而上转型对象（父类的对象）可以调用改写后的方法。不同的子类可能改写的内容不同。比如：动物类中的cry()方法，在子类“猫”中可以改写为“喵喵”，而在子类“狗”中可以改定为“汪汪”。猫类的和狗类的上转型对象在调用cry()方法时是各不相同的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">访问权限</span><br><span class="line">种类，级别顺序</span><br><span class="line">子类</span><br><span class="line">子类继承</span><br><span class="line">成员的隐藏和重写</span><br><span class="line">对象的上转型对象</span><br><span class="line">多态性</span><br></pre></td></tr></table></figure><h3 id="类的继承-2"><a href="#类的继承-2" class="headerlink" title="类的继承"></a>类的继承</h3><p>相关知识点<br>子类的构造方法与父类构造方法之间的关系：子类构造方法的第一条语句隐含调用父类的构造方法—super();<br>子类继承父类中的非private成员（在同一个包中）<br>子类继承父类中的非private与非友好成员（不同的包中）<br>子类中的成员与父类中成员相同，则隐藏父类成员<br>父类的对象变量（对象的上转型对象）可以引用子类的对象</p><h2 id="抽象类与抽象方法-1"><a href="#抽象类与抽象方法-1" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><ul><li>类的多态</li><li>抽象方法与抽象类</li></ul><h2 id="多态性-2"><a href="#多态性-2" class="headerlink" title="多态性"></a>多态性</h2><p>在程序中同一符号或名字在不同情况下具有不同解释的现象称为多态性。表现在两方面：<br>方法的重载。</p><p>对象的上转型对象。子类可以改写父类的方法，而上转型对象（父类的对象）可以调用改写后的方法。不同的子类可能改写的内容不同。比如：动物类中的cry()方法，在子类“猫”中可以改写为“喵喵”，而在子类“狗”中可以改定为“汪汪”。猫类的和狗类的上转型对象在调用cry()方法时是各不相同的。</p><h2 id="抽象方法与抽象类"><a href="#抽象方法与抽象类" class="headerlink" title="抽象方法与抽象类"></a>抽象方法与抽象类</h2><p>用关键字abstract修饰的类就是抽象类。</p><p>没有方法体的方法，且首部用关键字abstract修饰，就是抽象方法。声明抽象方法的格式：</p><blockquote><p>[修饰符…]abstract 返回值类型 方法名([形参列表]); </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AAnimal</span><br><span class="line">&#123;</span><br><span class="line">public String  name;</span><br><span class="line">public int age;</span><br><span class="line">public void print()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;名字:&quot;+name);</span><br><span class="line">System.out.println(&quot;大小:&quot;+age);</span><br><span class="line">&#125;</span><br><span class="line">public abstract void run();</span><br><span class="line">public abstract void cry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象方法与抽象类使用说明</p><p>含有抽象方法的类必须定义为抽象类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AAnimal//错误</span><br><span class="line">&#123;</span><br><span class="line">public String  name;</span><br><span class="line">public int age;</span><br><span class="line">public void print()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;名字:&quot;+name);</span><br><span class="line">System.out.println(&quot;大小:&quot;+age);</span><br><span class="line">&#125;</span><br><span class="line">public abstract void run();</span><br><span class="line">public abstract void cry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能由抽象类直接创建对象。它只能做为父类使用，<br>由它派生的子类必须实现抽象类中所有的抽象方法，<br>才能创建对象。</p><p>抽象方法的实现：<br>子类重写父类的抽象方法，<br>增加方法体，<br>使之成为一个非抽象方法。<br>可以空实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    AAnimal a;</span><br><span class="line">    a=new AAnimal();//错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Dog extends AAnimal</span><br><span class="line">&#123;</span><br><span class="line">String type;</span><br><span class="line">public Dog()</span><br><span class="line">&#123;</span><br><span class="line">type=&quot;宠物狗&quot;;</span><br><span class="line">&#125;</span><br><span class="line">public void run()&#123;&#125;</span><br><span class="line">public void cry()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println (&quot;汪汪叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    Dog a;</span><br><span class="line">    a=new Dog();</span><br><span class="line">    a.name=&quot;欢欢&quot;;a.age=2;</span><br><span class="line">    a.print();</span><br><span class="line">    a.cry();</span><br><span class="line">    System.out.println (&quot;这是一只&quot;+a.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子类没有实现抽象基类(父类)中所有的抽象方法，则子类也必须定义成一个抽象类。即：抽象的子类也必须使用修饰符：abstract</p><p>可以将没有任何抽象方法的类声明为abstract，避免由这个类直接创建任何的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">abstract  class Dog extends AAnimal</span><br><span class="line">&#123;</span><br><span class="line">String type;</span><br><span class="line">public Dog()</span><br><span class="line">&#123;</span><br><span class="line">type=&quot;宠物狗&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//public void run()&#123;&#125;</span><br><span class="line">public void cry()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println (&quot;汪汪叫&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Bird extends AnimalClass//定义鸟类继承动物类</span><br><span class="line">&#123;</span><br><span class="line">public Bird()//构造方法初始化</span><br><span class="line">&#123;</span><br><span class="line">name=&quot;麻雀&quot;;</span><br><span class="line">age=3;</span><br><span class="line">&#125;</span><br><span class="line">public void run()//实现父类的抽象方法</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;会飞&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void cry()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println (&quot;叽叽喳喳&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>用abstract关键字来修饰一个类时，这个类叫做抽象类；用abstract来修饰一个方法时，该方法叫做抽象方法。</p><p>abstract类必须被继承，abstract方法必须被重写。</p><p>抽象类不能被实例化（直接创建对象）。</p><p>抽象方法只需声明，而不需实现（无方法体）。</p><h2 id="接口及应用"><a href="#接口及应用" class="headerlink" title="接口及应用"></a>接口及应用</h2><p>接口的基本概念<br>接口定义<br>接口实现<br>接口应用举例<br>理解接口<br>Jar文件（略）</p><h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>在《Thinking in Java》一书中，作者对接口有这样的描述：“接口（interface）比抽象（abstract）的概念更进了一步。你可以把一个接口看成是一个纯的抽象类。”</p><p>为什么使用接口？</p><p>1、Java中不允许类的多继承，但在解决实际问题过程中，仅仅依靠单一继承在很多情况下都不能将问题的复杂性表述完整。</p><p>通过接口可以实现多继承。</p><p>如：Father类有playFootball()，Mother类有sing()，如果采用类的继承来产生一个Son类，则它只能从一个类中继承。要么继承Father，要么继承Mother。</p><p>2、接口在面向对象的设计与编程中应用非常广泛，特别是实现 软件模块间的连接 方面有着巨大的优势。</p><h2 id="接口的声明-及注意事项"><a href="#接口的声明-及注意事项" class="headerlink" title="接口的声明  及注意事项"></a>接口的声明  及注意事项</h2><p>如果一个抽象类中所有的方法都是抽象的，就可以将这个类用另外一种方式来定义，也就是接口定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[public] interface 接口名 [extends  父接口名列表]</span><br><span class="line">&#123;</span><br><span class="line">数据类型   常量名=常数;</span><br><span class="line">返回值  方法名([参数列表]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>几点说明：</p><p>1、interface是接口的关键字，定义接口和定义类相似。并被编译为class文件。<br>2、接口的访问控制符只有public，如果使用public修饰符，则可以被所有类和接口使用，且接口名与文件名相同。如果不使用public，则接口只能被同一个包中的类和接口使用。<br>3、接口中所有的方法都是public abstract 即公共的抽象方法。4、接口中可以有数据成员，这些数据成员默认都是public static final即公共类常量。</p><h2 id="接口声明实例"><a href="#接口声明实例" class="headerlink" title="接口声明实例"></a>接口声明实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Father.java  文件名</span><br><span class="line">public interface  Father//父亲会踢球</span><br><span class="line">&#123;</span><br><span class="line">public abstract void playFootball ();</span><br><span class="line">&#125;</span><br><span class="line">//Mother.java   文件名</span><br><span class="line">public interface Mother//母亲爱唱歌</span><br><span class="line">&#123;</span><br><span class="line">public abstract void sing();</span><br><span class="line">&#125;</span><br><span class="line">//Flyable.java  能飞的动物</span><br><span class="line">public interface Flyable </span><br><span class="line">&#123;</span><br><span class="line">void fly();</span><br><span class="line">&#125;</span><br><span class="line">//Talkable.java 能说话的动物</span><br><span class="line">public interface Talkable </span><br><span class="line">&#123;</span><br><span class="line">void talk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口的实现与多继承"><a href="#接口的实现与多继承" class="headerlink" title="接口的实现与多继承"></a>接口的实现与多继承</h2><p>接口的实现通过类来完成，在定义类时使用“implements  接口名列表”短语，并在类体中实现接口中的抽象方法。接口和实现类之间的关系实质上是继承的关系<br>1、一个类可以实现多个接口，从而实现多继承。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SmartChild implements Father,Mother</span><br><span class="line">&#123;</span><br><span class="line">public void playFootball()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;我会踢足球！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void sing()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;我会唱歌！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">SmartChild child=new SmartChild();</span><br><span class="line">child.playFootball();</span><br><span class="line">child.sing();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类实现接口时的注意事项"><a href="#类实现接口时的注意事项" class="headerlink" title="类实现接口时的注意事项"></a>类实现接口时的注意事项</h2><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>在类声明部分，用implements关键字指明该类将要实现哪些接口。<br>实现接口的类必须在类体中给出所有方法的实现，否则该类应该声明为抽象类。<br>接口中的方法都是public的，所以实现方法时也必须加上public，否则编译报错。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>一个接口可以继承另一个接口<br>Java中不允许类的多继承，但允许接口的多继承<br>在java中一个类可以实现多个接口<br>一个类在继承另一个类的同时，可以实现多个接口。</p><h3 id="将小程序改为应用程序"><a href="#将小程序改为应用程序" class="headerlink" title="将小程序改为应用程序"></a>将小程序改为应用程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Computable</span><br><span class="line">&#123;</span><br><span class="line">final int MAX=100;</span><br><span class="line">void speak(String s);</span><br><span class="line">int f(int x);</span><br><span class="line">float g(float x,float y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class China implements Computable</span><br><span class="line">&#123;</span><br><span class="line">int xuehao;</span><br><span class="line">public int f(int x)</span><br><span class="line">&#123;</span><br><span class="line">int sum=0;</span><br><span class="line">for (int i = 1; i&lt;=x; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=i;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br><span class="line">public float g(float x,float y)</span><br><span class="line">&#123;</span><br><span class="line">return 6;</span><br><span class="line">&#125;</span><br><span class="line">public void speak(String s)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口应用实例—程序模块间的连接"><a href="#接口应用实例—程序模块间的连接" class="headerlink" title="接口应用实例—程序模块间的连接"></a>接口应用实例—程序模块间的连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//PCI接口，可看成一种标准</span><br><span class="line">interface PCI  </span><br><span class="line">&#123;</span><br><span class="line">void setName(String s);</span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//符合PCI接口标准的网卡，即实现了PCI</span><br><span class="line">class NetworkCard implements PCI  </span><br><span class="line">&#123;</span><br><span class="line">String name;</span><br><span class="line">public NetworkCard()</span><br><span class="line">&#123;</span><br><span class="line">name=&quot;D-Link&quot;;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String s)//实现接口中的抽象方法</span><br><span class="line">&#123;</span><br><span class="line">name=s;</span><br><span class="line">&#125;</span><br><span class="line">public void run()//实现接口中的抽象方法</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(name+&quot;网卡已开始工作！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结</p><p>1、接口的概念：如果一个方法中的所有方法都是抽象的，则可以以接口的形式进行定义。<br>2、接口定义：使用interface关键字进行定义，数据成员隐含修饰符：public static final，方法隐含修饰符：public  abstract<br>3、接口实现：通过类来实现，使用implements短语。<br>4、接口应用。</p><h2 id="时间、日期和Math类"><a href="#时间、日期和Math类" class="headerlink" title="时间、日期和Math类"></a>时间、日期和Math类</h2><p>数组<br>声明数组：int  [] a; 或 int  a[];</p><p>数组创建：a=new int[10];</p><p>数组静态初始化：int[]a={1,0,2,3,4,5,5,7,4,12};</p><p>数组元素引用：a[0]…a[9]</p><p>字符串</p><p>String类<br>String构造方法<br>String类的成员方法：length()、equals()等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串与数值类型转换</span><br><span class="line">Date类</span><br><span class="line">SimpleDateFormat类</span><br><span class="line">Calendar类</span><br><span class="line">Math类</span><br><span class="line">AWT工具集简介</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lang包中类</span><br><span class="line">- Integer类—parseInt()</span><br><span class="line">- Float类—parseFloat()</span><br><span class="line">- Double类—parseDouble()</span><br><span class="line">- 将字符串转换为数值时，字符串必须是合法数值格式的字符串，否则会产生转换异常。</span><br><span class="line"></span><br><span class="line">数值转换为字符串</span><br><span class="line">- String.value(3.14159)</span><br><span class="line">- 3.14159+&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="Date、SimpleDateFormat类"><a href="#Date、SimpleDateFormat类" class="headerlink" title="Date、SimpleDateFormat类"></a>Date、SimpleDateFormat类</h2><p>Date  d=new Date();获取系统日期某个瞬间。<br>SimpleDateFormat类：对日期进行格式化。format()方法可以对指定日期进行格式化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line">class E1</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    Date d=new Date();</span><br><span class="line">    SimpleDateFormat sdf=</span><br><span class="line">    new SimpleDateFormat(&quot;yyyy年MMMdd日HH时mm分&quot;);</span><br><span class="line">    System.out.println (sdf.format(d));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><p>该类的静态方法getInstance()可获取当前系统日历：Calendar d=Calendar.getInstance();</p><p>通过该类提供的get(int  field)方法来获取日历中各字段的值。field应该使用该类的相关常量字段。</p><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>常用方法参考javaAPI文档<br>猜数游戏<br>JOptionPane中的showInputDialog()方法。</p><h3 id="猜数游戏"><a href="#猜数游戏" class="headerlink" title="猜数游戏"></a>猜数游戏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import javax.swing.*;</span><br><span class="line">class E3</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    int num,count=0;</span><br><span class="line">    num=(int)(Math.random()*20+1);</span><br><span class="line">    int i=Integer.parseInt(JOptionPane.showInputDialog(&quot;请输入你猜1-20的数&quot;));</span><br><span class="line">   while(i!=num&amp;&amp;count&lt;=6)</span><br><span class="line">    &#123;</span><br><span class="line">    count++;</span><br><span class="line">    if (i&gt;num)</span><br><span class="line">        i=Integer.parseInt(JOptionPane.showInputDialog(&quot;第&quot;+count+&quot;次！太大了，请重新输入&quot;));</span><br><span class="line">    else</span><br><span class="line">        i=Integer.parseInt(JOptionPane.showInputDialog(&quot;第&quot;+count+&quot;次！太小了，请重新输入&quot;));    </span><br><span class="line">    &#125;</span><br><span class="line">    if(i==num)</span><br><span class="line">   &#123;</span><br><span class="line">    JOptionPane.showMessageDialog(null,&quot;猜对了&quot;);</span><br><span class="line">    System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Java-的GUI概述"><a href="#Java-的GUI概述" class="headerlink" title="Java 的GUI概述"></a>Java 的GUI概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、图形用户界面GUI（Graphics User Interface)，就是应用程序提供给用户操作的图形界面，包括窗口、菜单、按钮、工具栏和其他各种界面元素。</span><br><span class="line">2、在Java里有两个包为GUI设计提供了丰富的功能：awt(abstract windows toolkit)包和Swing包。</span><br><span class="line">3、awt是java的早期版本，组件种类有限，只提供基本的GUI设计工具。</span><br><span class="line">4、Swing包是SUN公司对早期版本的改进版本，它不仅包括AWT中所有部件，并且提供了更加丰富的部件和功能，它足以完全实现GUI设计所需的一切功能。</span><br><span class="line">5、Swing会用到AWT中许多知识，掌握了AWT，也就基本掌握了Swing。</span><br></pre></td></tr></table></figure><h2 id="初识awt实例"><a href="#初识awt实例" class="headerlink" title="初识awt实例"></a>初识awt实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.*;//引用awt包中的组件类</span><br><span class="line">public class TestFrame</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;//产生一个具有标题栏的框架窗口</span><br><span class="line">Frame f=new Frame(“我的框架窗口”); </span><br><span class="line">Pane p=new Pane();//创建一个面板</span><br><span class="line">p.add(new Button(“确定”));//向面板中填加按钮</span><br><span class="line">f.add(p);//向窗口中填加面板</span><br><span class="line">f.setSize(300,300);//设置窗口的大小</span><br><span class="line">f.show();//显示窗口</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图形用户界面程序中可以使用各种各样的图形界面元素，如文本框、按钮、列表框、对话框等，我们将这些图形用户界面元素称为GUI组件。</p><p>ATW为各种GUI组件提供了对应的Java组件类，这些组件类都是java.awt.Component的直接或间接的子类。</p><h2 id="GUI组件分类"><a href="#GUI组件分类" class="headerlink" title="GUI组件分类"></a>GUI组件分类</h2><p>在AWT的概念中，窗口系统中所显示的各种对象都统称为“GUI组件”（Component）。组件有基本组件和容器组件之分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、顾名思义，基本组件是不可再分割的组件，基本组件各自都有它们特定的功能。基本组件是构成图形用户界面的基本元素。</span><br><span class="line">2、容器组件是用来包含其他组件的，故称之为容器（container）。用户可以把各种组件放入到容器中，也可以把容器放到另一个容器中，从而形成具有层次的组件结构。 </span><br><span class="line">3、AWT提供了的容器类有：Frame类、Dia1og类和Panel类。除了AWT提供的容器外，Applet类也是一个容器，它是Panel类的一个子类。</span><br></pre></td></tr></table></figure><h2 id="AWT-标准组件图示"><a href="#AWT-标准组件图示" class="headerlink" title="AWT 标准组件图示"></a>AWT 标准组件图示</h2><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Button 按钮</span><br><span class="line">Checkbox 复选框</span><br><span class="line">CheckboxGroup 单选框</span><br><span class="line">Choice 下拉式列表</span><br><span class="line">List 列表</span><br><span class="line">Menu 菜单</span><br><span class="line">TextField 文本框</span><br><span class="line">Label 标签</span><br><span class="line">Canvas 画布</span><br><span class="line">TextArea 多行文本框</span><br><span class="line">ScrollBar 滚动条</span><br></pre></td></tr></table></figure><h2 id="Applet小程序编写及运行"><a href="#Applet小程序编写及运行" class="headerlink" title="Applet小程序编写及运行"></a>Applet小程序编写及运行</h2><p>Java有两种类型的程序：应用程序(application)、小应用程序(applet)。 </p><p>Java应用程序只有一个程序入口—main方法，通过JVM调用执行，小应用程序是嵌入到网页中由浏览器调用执行的，其中不必包含main方法。</p><p>回忆一下小应用程序的书写格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.applet.*;</span><br><span class="line"> public class MyApplet extends Applet</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>每个小应用程序中必须有一个主类，冠以public，并且从Applet类继承。<br>小应用程序的运行：<br>将小应用程序源文件编译成字节码文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编写html文件，使用&lt;applet&gt; 标签将字节码文件嵌入其中</span><br><span class="line">用浏览器打开html文件或者用appletviewer小程序浏览器。</span><br></pre></td></tr></table></figure><h3 id="身手"><a href="#身手" class="headerlink" title="身手"></a>身手</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.applet.Applet;</span><br><span class="line">import java.awt.*;</span><br><span class="line">public class Test extends Applet</span><br><span class="line">&#123;</span><br><span class="line">public void paint(Graphics g)</span><br><span class="line">&#123;</span><br><span class="line">g.drawOval(10,10,100,100);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.html文件--&gt;</span><br><span class="line">&lt;applet code=Test height=120 width=400&gt;&lt;/applet&gt;</span><br></pre></td></tr></table></figure><p>任何与绘图有关的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.awt.Graphics，Graphics类的对象不是由new产生的，</span><br></pre></td></tr></table></figure><p>一般由系统直接将生好的Graphics对象当作方法的参数，交给程序设计者去处理.例如: public void  paint(Graphics g)，每一个GUI组件都有paint方法，利用Graphics对象可以在组件中绘制图像或字符串。</p><h2 id="Html标签"><a href="#Html标签" class="headerlink" title="Html标签"></a>Html标签</h2><p>基本形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;applet code=Test height=120 width=400&gt;&lt;/applet&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Applet 属性&gt;</span><br><span class="line">Code：指出要加载的类名，直接写类名，则要求类与html文件在同一路径下。</span><br><span class="line">Height、width：指出applet显示区的高和宽</span><br></pre></td></tr></table></figure><p>字符串转换为数值<br>获取系统当前日期及时间<br>Math类的静态方法<br>AWT包简介<br>Applet 类简单</p><p>首先通过JavaAPI文档，学习以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javax.swing包中的类JOptionPane中的showInputDialog()方法</span><br><span class="line">java.lang包中的Integer类中的parseInt()方法</span><br><span class="line">java.util包中的Date类</span><br><span class="line">java.text包中的SimpleDateFormat类</span><br><span class="line">java.lang包中的Math类中的random()方法</span><br></pre></td></tr></table></figure><h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><p>类的定义<br>类的封装特性<br>类的继承特性<br>类的多态特性</p><h2 id="回顾—类的定义-1"><a href="#回顾—类的定义-1" class="headerlink" title="回顾—类的定义"></a>回顾—类的定义</h2><p>类的严格定义及修饰字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[类的修饰字] class 类名称 [extends 父类名称][implements 接口名称列表]</span><br><span class="line"> &#123;  </span><br><span class="line"></span><br><span class="line">       变量定义及初始化；</span><br><span class="line"></span><br><span class="line">       方法定义及方法体；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类体，其中定义了该类中所有的变量和该类所支持的方法，称为成员变量和成员方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类的修饰字：  [public] [abstract | final]</span><br><span class="line">                          缺省方式为 package</span><br></pre></td></tr></table></figure><h2 id="回顾—封装性"><a href="#回顾—封装性" class="headerlink" title="回顾—封装性"></a>回顾—封装性</h2><p>封装性与访问级控制<br>类的一个优势在于类可以保护它的成员变量和成员函数不会被其它对象随意访问到<br>在Java程序里，可以为成员变量和函数设定四级访问级</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private</span><br><span class="line">protected</span><br><span class="line">public</span><br><span class="line">default（缺省）</span><br></pre></td></tr></table></figure><h2 id="回顾—继承"><a href="#回顾—继承" class="headerlink" title="回顾—继承"></a>回顾—继承</h2><p>继承性是面向对象程序设计语言的另一基本特征，通过继承可以实现代码的复用。</p><p>继承而得到的类为子类，被继承的类为父类，父类包括所有直接或间接被继承的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java中不支持多重继承。通过在类的声明中加入extends子句来创建一个类的子类</span><br><span class="line"></span><br><span class="line">class SubClass extends SuperClass</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回顾—类的多态性"><a href="#回顾—类的多态性" class="headerlink" title="回顾—类的多态性"></a>回顾—类的多态性</h2><p>多态是指在一棵继承树中的类可以有多个同名但不同方法体以及不同形参的方法。两种情况</p><p>覆盖</p><p>重载</p><h2 id="掌握数组的定义和使用"><a href="#掌握数组的定义和使用" class="headerlink" title="掌握数组的定义和使用"></a>掌握数组的定义和使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java数组类的定义和使用</span><br><span class="line">难点</span><br><span class="line">多维数组的定义和使用</span><br></pre></td></tr></table></figure><h2 id="Java中的数组"><a href="#Java中的数组" class="headerlink" title="Java中的数组"></a>Java中的数组</h2><p>数组的特点</p><p>数组：可以容纳很多同类型的数据的结构<br>数组中存放的每个数据称为数组的一个元素，元素的数量称为数组的长度<br>在Java语言中，数组的长度是在数组创立时就固定了的，以后不能更改</p><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一维数组变量的声明格式有如下两种:</span><br><span class="line">(1)数组元素的数据类型[ ]      变量名;</span><br><span class="line">(2)数组元素的数据类型     变量名[ ];</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">int [ ]  c; </span><br><span class="line">String[ ]  names; </span><br><span class="line">int  c[ ]; </span><br><span class="line">String  names[ ];</span><br></pre></td></tr></table></figure><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>Java数组实际上也是对象，所以可通过new 关键字来创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[ ] c;       // 声明</span><br><span class="line">c = new int[12];     // 创建对象，并分配内存</span><br><span class="line"></span><br><span class="line">声明时不必指定数组的大小</span><br><span class="line">上面的两个语句可以简化成一个语句</span><br><span class="line"></span><br><span class="line">int[ ] c = new int[12];</span><br></pre></td></tr></table></figure><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>基本数据类型的元素初始化为0值或false</p><p>非基本数据类型的元素初始化为null </p><p>可以采用循环结构初始化数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double[ ] squares; </span><br><span class="line">squares = new double[100]; </span><br><span class="line">for (int i=0; i &lt; squares.length; i++)</span><br><span class="line">&#123; </span><br><span class="line">    squares[i] = i*i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过初始化语句创建数组"><a href="#通过初始化语句创建数组" class="headerlink" title="通过初始化语句创建数组"></a>通过初始化语句创建数组</h2><p>Java语言允许通过数组的初始化语句创建数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[ ] n = &#123; 10, 20, 30, 40, 50 &#125;;</span><br></pre></td></tr></table></figure><p>上面语句创建了一个含有五个元素的数组</p><p>下标值分别为0, 1, 2, 3, 4</p><p>这时不需要运算符new</p><h2 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h2><p>当定义了一个数组，并用运算符new为它分配了内存空间后，就可以引用数组中的每一个元素了。元素的引用方式为</p><p>arrayName[index]</p><p>index为数组下标，可以是整型常数或表达式，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：arrayName[1], arrayName[i], arrayName[6*i]等。</span><br></pre></td></tr></table></figure><p>下标是0序的，即从0开始，一直到数组长度减1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int[ ] c = new int[12];</span><br><span class="line"></span><br><span class="line">c 是数组名</span><br><span class="line"></span><br><span class="line">如何获得数组的长度?</span><br><span class="line">c.length</span><br><span class="line"></span><br><span class="line">第一个数组元素的下标为0 </span><br><span class="line">使用数组可以通过数组名与下标</span><br><span class="line"></span><br><span class="line">每个数组元素类似于普通的变量</span><br><span class="line">c[ 0 ] = 3;</span><br><span class="line">c[ 0 ] += 5;</span><br></pre></td></tr></table></figure><p>注意事项</p><p>当通过循环遍历数组时<br>下标永远不要低于0<br>下标永远要比数组元素个数小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当数组下标出错，Java 产生 ArrayIndexOutOfBoundsException</span><br></pre></td></tr></table></figure><h2 id="多维数组-1"><a href="#多维数组-1" class="headerlink" title="多维数组"></a>多维数组</h2><p>最常用的多维数组是二维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[ ][ ] a = new int[3][4];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class J_FillArray</span><br><span class="line">&#123;</span><br><span class="line">    public static void main (String args[])</span><br><span class="line">    &#123; </span><br><span class="line">        int[ ][ ] matrix = new int[4][5]; </span><br><span class="line">        for (int row=0; row &lt; 4; row++)</span><br><span class="line">        &#123; </span><br><span class="line">            for (int col=0; col &lt; 5; col++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[row][col] = row + col; </span><br><span class="line">            &#125; // 内部for循环结束</span><br><span class="line">        &#125; // 外部for循环结束</span><br><span class="line">    &#125; // 方法main结束</span><br><span class="line">&#125; // 类J_FillArray结束</span><br></pre></td></tr></table></figure><p>通过初始化语句创建数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double[ ][ ] c =</span><br><span class="line">    &#123; </span><br><span class="line">       &#123;1.0, 2.0, 3.0, 4.0&#125;, </span><br><span class="line">       &#123;0.0, 1.0, 0.0, 0.0&#125;, </span><br><span class="line">       &#123;0.0, 0.0, 1.0, 0.0&#125; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Java的多维数组实际上是<br>数组的数组<br>即创建以数组为元素的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">意味着: 二维数组的每一行可以具有不同的列数</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[ ][ ];</span><br><span class="line">a = new int[ 3 ][ ];            // allocate rows</span><br><span class="line">a[ 0 ] = new int[ 3 ];         // allocate row 0</span><br><span class="line">a[ 1 ] = new int[ 2 ];         // allocate row 1</span><br><span class="line">a.length                 行数</span><br><span class="line">a[ i ].length            第i行列数</span><br></pre></td></tr></table></figure><p>要点</p><h2 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串"></a>数组与字符串</h2><p>接口及接口声明</p><p>interface<br>接口中的方法都是：public abstract<br>接口中的数据都是：public static final<br>接口可以直接多继承：extends 父接口列表</p><p>接口实现</p><p>在类中实现接口：implements 接口名列表<br>在类中要改写接口中的所有抽象方法<br>一个类可以实现多个接口<br>一个类可以从父类继承的同时实现接口</p><p>接口应用</p><p>只关心功能的有无，不关心功能的具体实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组的概念</span><br><span class="line">数组声明</span><br><span class="line">数组创建</span><br><span class="line">数组元素引用</span><br><span class="line">数组元素初始化</span><br><span class="line">字符串说明及初始化</span><br><span class="line">字符串处理</span><br></pre></td></tr></table></figure><h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><p>数组是相同类型的数据元素按顺序组成的一种复合数据类型。数组中的每个元素通过数组名加下标进行引用。数组分为一维数组和多维数组。</p><p>数组的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)一个数组中所有的元素应该是同一类型；</span><br><span class="line">(2)数组中的元素是有顺序的；</span><br><span class="line">(3)数组中的一个元素通过数组名和数组下标来确定。</span><br></pre></td></tr></table></figure><p>数组的使用过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)声明数组</span><br><span class="line">(2)创建数组</span><br><span class="line">(3)使用数组元素</span><br></pre></td></tr></table></figure></p><h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>一维数组声明的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型    数组名[ ]；或 类型[ ] 数组名；</span><br><span class="line">数组名为Java标识符。“[ ]”部分指明该变量是一个数组类型变量。其中不能有元素个数说明。</span><br></pre></td></tr></table></figure><p>二维数组声明格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型 数组名[] []；或 类型 [] []数组名；</span><br><span class="line">类型 []数组名[]；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如：int a[];或 int[]a;</span><br><span class="line">String[]args;或 String args[]</span><br><span class="line">int a[][];或int [][]a;或 int []a[];</span><br><span class="line">Person p[];</span><br></pre></td></tr></table></figure><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>创建数组—为数组分配内存空间。<br>格式：数组名=new 类型[元素个数];<br>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int []num;int myTwo[][];</span><br><span class="line">num=new int[3];</span><br><span class="line">myTwo=new int[2][3];</span><br><span class="line">myTwo=new int[2][];</span><br></pre></td></tr></table></figure><p>声明和创建数组可以合并</p><blockquote><p>类型  数组名[]=new 类型[元素个数];</p></blockquote><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int []num=new int[3];</span><br></pre></td></tr></table></figure><p>创建数组时，自动为数组元素初始化。</p><h2 id="数组元素的使用"><a href="#数组元素的使用" class="headerlink" title="数组元素的使用"></a>数组元素的使用</h2><p>数组元素的标识：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标]</span><br><span class="line">下标使用范围从0开始到（元素个数-1）为止。</span><br><span class="line">其中下标为非负的整型常数或表达式，其数据类型只能为byte,short,int, 而不能为long。</span><br><span class="line">数组名[下标1][下标2]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class ArrayTest</span><br><span class="line">&#123;</span><br><span class="line">int arr[];</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    ArrayTest a=new ArrayTest();</span><br><span class="line">    a.arr=new int[3];</span><br><span class="line">    a.arr[0]=3;</span><br><span class="line">    a.arr[1]=4;</span><br><span class="line">    a.arr[2]=5;</span><br><span class="line">    for (int i = 0; i&lt;3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println (a.arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组初始化-1"><a href="#数组初始化-1" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>new分配内存时自动初始化数组</p><p>通常在创建数组时，Java会使每个数组元素初始化为一个默认值。在许多情况下，并不希望数组的初值为默认值，此时，就需要用赋值语句来对数组进行初始化。</p><p>静态初始化：声明数组时直接赋初值(不需要new)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr1[]=&#123;2,4,6,8&#125;;</span><br><span class="line">char [] arr2=&#123;‘字’,‘符’,‘数’,‘组’&#125;;</span><br><span class="line">String []arr3=&#123;&quot;how &quot;,&quot;are &quot;,&quot;you!&quot;&#125;;</span><br></pre></td></tr></table></figure></p><p>元素个数由{}中给出的元素个数来确定</p><p>二维数组初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr3[][]=&#123;&#123;1,2,3,4&#125;,&#123;2,3,4&#125;,&#123;5,3&#125;&#125;;</span><br></pre></td></tr></table></figure></p><p>思考和验证：这时可用数组元素有哪些呢？</p><h2 id="使用数组注意事项"><a href="#使用数组注意事项" class="headerlink" title="使用数组注意事项"></a>使用数组注意事项</h2><p>定义数组：无论用什么方式定义数组，都不能指定长度，int  a[5];是错误的</p><p>使用数组中的元素：必须对数组引用变量赋一个有效的数组对象（通过new产生或是用{ }静态初始化产生）后，才可以引用数组中的每个元素。</p><p>获取数组的长度：<br>数组名.length</p><h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><p>Java使用java.lang包中的类String来声明和创建一个字符串变量，因此字符串变量是类类型的变量，是一个对象。（要求理解）</p><p>字符串常量<br>声明字符串变量</p><p>创建字符串（要求掌握）</p><p>可以将一个字符串常量直接赋值给字符串变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s;s=&quot;we are student!&quot;;</span><br></pre></td></tr></table></figure><p>也可以使用String类的构造方法来创建字符串，如：</p><blockquote><p>String s;s=new String(“we are student!”);</p></blockquote><p>String类的构造方法</p><p>获取字符串长度：String对象的length()方法。</p><blockquote><p>String s=”你好”;s.length()值为2。</p></blockquote><p>例：字符串的声明与创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class StringTest</span><br><span class="line">&#123;</span><br><span class="line">String name;</span><br><span class="line">String sex;</span><br><span class="line">void out()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println (&quot;name:&quot;+name);</span><br><span class="line">System.out.println (&quot;sex:&quot;+sex);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    StringTest st=new StringTest();</span><br><span class="line">    char ch[]=&#123;&apos;b&apos;,&apos;o&apos;,&apos;y&apos;&#125;;</span><br><span class="line">    st.name=new String(&quot;Rose&quot;);</span><br><span class="line">    st.sex=new String(ch1);</span><br><span class="line">    st.out();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>==：比较两个字符串是不是同一个对象<br>equals()方法：比较两个字符串的内容是否相同<br>比较方法：s1.equals(s2)，s1和s2分别是两上字符串变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    StringTest st=new StringTest();</span><br><span class="line">    char ch[]=&#123;&apos;b&apos;,&apos;o&apos;,&apos;y&apos;&#125;;</span><br><span class="line">    st.name=new String(&quot;Rose&quot;);</span><br><span class="line">    if(st.name==&quot;Rose&quot;)</span><br><span class="line">    System.out.println (&quot;yes&quot;);</span><br><span class="line">    else</span><br><span class="line">    System.out.println (&quot;no&quot;);</span><br><span class="line">    st.sex=new String(ch);</span><br><span class="line">    st.out();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><p>equalsIgnoreCase()<br>返回值类型：boolean<br>忽略大小写比较</p><p>startWith()、endWith()<br>返回值类型：boolean<br>检查字符串前缀、后缀是否为指定字符串</p><p>compareTo(String s)<br>返回值类型：int<br>按字典序比较当前字符串与s的大小，返回值&gt;0、=0、&lt;0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Sort</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    String a[]=&#123;&quot;boy&quot;,&quot;apple&quot;,&quot;Applet&quot;,&quot;girl&quot;,&quot;Hat&quot;&#125;;</span><br><span class="line">    for (int i=0;i&lt;a.length-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    for(int j=i+1;j&lt;a.length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    if(a[j].compareTo(a[i])&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">    String temp=a[i];</span><br><span class="line">    a[i]=a[j];</span><br><span class="line">    a[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i&lt;a.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    System.out.print(&quot;  &quot;+a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>检索:indexOf()<br>截取:substring()<br>替换:replace()</p><h2 id="字符串与数值转换"><a href="#字符串与数值转换" class="headerlink" title="字符串与数值转换"></a>字符串与数值转换</h2><p>字符串转为整数</p><p>Integer类中的parseInt()方法<br>parseByte()、parseShort()、parseLong()</p><p>字符串转换为float或double型</p><p>Float类中的parseFloat()方法<br>Double类中的parseDouble()方法</p><p>数值转换为字符串</p><p>String类中的valueOf()方法</p><p>对象的字符串表示</p><p>对象的toString()方法</p><p>StringTokenizer类分析字符串</p><p>Character类</p><p>字符串与字符、字节数组</p><h2 id="面向对象程序设计-1"><a href="#面向对象程序设计-1" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>回顾—类的定义</p><p>类的严格定义及修饰字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[类的修饰字] class 类名称 [extends 父类名称][implements 接口名称列表]</span><br><span class="line"> &#123;  </span><br><span class="line">       变量定义及初始化；</span><br><span class="line">       方法定义及方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类体，其中定义了该类中所有的变量和该类所支持的方法，称为成员变量和成员方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类的修饰字：  [public] [abstract | final]</span><br><span class="line"></span><br><span class="line">缺省方式为 package</span><br></pre></td></tr></table></figure><h2 id="类的成员函数定义语法规范"><a href="#类的成员函数定义语法规范" class="headerlink" title="类的成员函数定义语法规范"></a>类的成员函数定义语法规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[方法修饰字] 返回类型  方法名称(参数1,参数2,…) [throws exceptionList]</span><br><span class="line">&#123;</span><br><span class="line">(statements;)    //方法体：方法的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>[public | protected | private ] [static] [final | abstract] [native] [synchronized]</p></blockquote><p>返回类型可以是任意的Java数据类型，当一个方法不需要返回值时，返回类型为void。</p><p>参数的类型可以是简单数据类型，也可以是引用数据类型（数组、类或接口），参数传递方式是值传递。</p><p>方法体是对方法的实现。它包括局部变量的声明以及所有合法的Java指令。局部变量的作用域只在该方法内部。</p><h2 id="回顾—对象的初始化-1"><a href="#回顾—对象的初始化-1" class="headerlink" title="回顾—对象的初始化"></a>回顾—对象的初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）对象的生成</span><br><span class="line">   通过new操作符生成一个对象；例如：</span><br><span class="line">Car    demoCar;</span><br><span class="line">demoCar = new Car();</span><br><span class="line">（2）对象的构造过程</span><br><span class="line"> 为对象开辟空间，并对对象的成员变量进行缺省的初始化；</span><br><span class="line"> 对成员变量进行指定的初始化；</span><br><span class="line"> 调用构造方法。</span><br></pre></td></tr></table></figure><p>重点<br>不同访问修饰符的应用<br>Java中类继承的定义<br>难点<br>类的继承特性</p><h2 id="包-1"><a href="#包-1" class="headerlink" title="包"></a>包</h2><p>“包”是由一组类和接口所组成的具有一定功能的集合<br>简单地说，将一组功能相关的类和接口打包起来形成的整体，就是包<br>两个类如果名字相同，只要所属的包不同，Java就会认为它们是不同的类</p><h2 id="创建包-1"><a href="#创建包-1" class="headerlink" title="创建包"></a>创建包</h2><p>在定义类或接口的源文件开始加入“package”关键字和包名，就将类或接口放到包里了<br>如果两个java源文件的开头都有相同的包名，则意味着这两个源文件中的所有类和接口都属于同一个包</p><h2 id="访问包中的类-1"><a href="#访问包中的类-1" class="headerlink" title="访问包中的类"></a>访问包中的类</h2><p>访问公开类的方法<br>(1) 用类的全名（包名+类名）访问；<br>(2) 导入包中的某个类；<br>(3) 导入包中的所有类。<br>如果某个类只访问一次，那么可以直接使用类的全名，形式是“包名.类名”</p><p>用“import”关键字导入一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import PackageName.ClassName;</span><br></pre></td></tr></table></figure></p><p>一次性导入所有类的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import PackageName.*;</span><br></pre></td></tr></table></figure></p><h2 id="管理Java的包-1"><a href="#管理Java的包-1" class="headerlink" title="管理Java的包"></a>管理Java的包</h2><p>Java系统建议的文件存储方式就是按照包名将源文件和二进制代码文件分级存放<br>将源文件放到与包名相同的路径下，包名对应子目录名</p><h2 id="使用Java的包-1"><a href="#使用Java的包-1" class="headerlink" title="使用Java的包"></a>使用Java的包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设定Rectangle.java放在“graphics”子目录下</span><br><span class="line">编译源文件的命令如下：</span><br><span class="line">javac graphics\Rectangle.java</span><br><span class="line">执行程序时，用小圆点“.”分隔包名和类：</span><br><span class="line">java graphics.Rectangle</span><br></pre></td></tr></table></figure><h2 id="CLASSPATH参数-1"><a href="#CLASSPATH参数-1" class="headerlink" title="CLASSPATH参数"></a>CLASSPATH参数</h2><p>如果你的Java包都放在一个固定的目录下，轻易不会改变它，那么你可以在操作系统中设置“CLASSPATH”环境变量<br>编译和运行Java程序时，不需要指定包路径参数，系统会自动从环境变量中读取</p><h2 id="封装-2"><a href="#封装-2" class="headerlink" title="封装"></a>封装</h2><p>封装把对象的所有组成部分组合在一起</p><p>封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。</p><h2 id="封装性-1"><a href="#封装性-1" class="headerlink" title="封装性"></a>封装性</h2><p>封装性与访问级控制<br>类的一个优势在于类可以保护它的成员变量和成员函数不会被其它对象随意访问到<br>在Java程序里，可以为成员变量和函数设定四级访问级：<br>private<br>protected<br>public<br>default（缺省）</p><h2 id="访问控制级别-1"><a href="#访问控制级别-1" class="headerlink" title="访问控制级别"></a>访问控制级别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private（私有级）</span><br><span class="line">private是最严格的访问控制级</span><br><span class="line">私有变量只能在它所在的类内部被访问到</span><br><span class="line">它用于定义只在类内部使用的成员变量</span><br><span class="line">成员变量，如果从外界随意改变它的值可能会造成不稳定的情况</span><br><span class="line">成员函数，如果从外界调用，可能会危害到对象的状态或程序的运行</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected（保护级）</span><br><span class="line">被定为保护级的成员可以被它所属的类、所属类的子类，以及处于同一个包里的其它类访问到</span><br><span class="line">如果一个成员变量或成员函数可以被它的子类或相关的类访问，而不能被无关类访问的话，就可以用保护级</span><br><span class="line">保护级就像家庭秘密，可以让家庭成员知道，也不介意让几个亲密朋友知道，但你不想让任何外人知道</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public（公开级）</span><br><span class="line">公开级是限制最少的访问级，任何类，不管它在哪个包里，都能够访问公开级的成员</span><br><span class="line">公开级使用最方便，实际使用得也最多</span><br><span class="line">需要注意的是：对于成员变量或成员函数，只有当你确认外界的类访问甚至修改它不会造成不希望的后果时，才使用公开级</span><br><span class="line">公开级类似于公开张贴的信息，其中没有个人或家庭隐私，你不介意任何人知道</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default（缺省级）</span><br><span class="line">包访问级是成员的缺省访问级</span><br><span class="line">如果没有定义访问级，那么它就是包访问级</span><br><span class="line">权限：可以被属于同一个包的其它类所访问，但不能被其它包的类所访问</span><br><span class="line">如果这个类的子类在其它包，则子类不能继承和访问父类中包访问级的成员</span><br><span class="line">这一访问级假设在同一个包里的其它类都是可信任的朋友，但子类反而不能信任</span><br></pre></td></tr></table></figure><h2 id="类成员封装性总结-1"><a href="#类成员封装性总结-1" class="headerlink" title="类成员封装性总结"></a>类成员封装性总结</h2><h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><p>继承性是面向对象程序设计语言的另一基本特征，通过继承可以实现代码的复用。继承而得到的类为子类，被继承的类为父类，父类包括所有直接或间接被继承的类。Java中不支持多重继承。通过在类的声明中加入extends子句来创建一个类的子类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SubClass extends SuperClass</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以继承父类中访问权限设定为public、 protected、 default的成员变量和方法，但是不能继承访问权限为private的成员变量和方法。<br>一个类可以从另一个类中继承它的成员变量和函数，前者称为子类，后者称为父类。类的这种特点称为继承性</p><h2 id="继承-2"><a href="#继承-2" class="headerlink" title="继承"></a>继承</h2><p>类的继承通过extends关键字来说明，extends关键字跟在类名称后面，形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class SubClass extends FatherClass &#123;  &#125;</span><br></pre></td></tr></table></figure><p>其中SubClass是子类名，FatherClass是父类名</p><h2 id="继承的特点-1"><a href="#继承的特点-1" class="headerlink" title="继承的特点"></a>继承的特点</h2><p>类的继承性的特点<br>在Java中，一个类只能有一个父类<br>Java只支持单继承，而不支持多重继承<br>单继承的类子代相承，会形成一棵继承树，结构较为清晰<br>多重继承会形成一张复杂的继承网，结构复杂，容易出错<br>如果需要多重继承，Java提供了一种接口技术，可以部分地实现多重继承的功能</p><p>类的继承性的特点<br>在Java中定义的所有类都直接或间接地是Object类的子类。以Object类为根，所有Java类形成一棵类继承树</p><h2 id="类的继承性的特点-1"><a href="#类的继承性的特点-1" class="headerlink" title="类的继承性的特点"></a>类的继承性的特点</h2><p>子类可以继承的部分：<br>(1) 父类中公开级的成员；<br>(2) 父类中保护级的成员；<br>(3) 如果子类和父类在同一个包里，则子类继承父类中缺省的包访问级的成员；</p><p>子类不能继承的部分：<br>(1) 父类中私有级的成员；<br>(2) 如果不在同一个包里，则缺省级的成员；<br>(3) 同名的成员函数或成员变量；</p><h2 id="构造函数的继承特点-1"><a href="#构造函数的继承特点-1" class="headerlink" title="构造函数的继承特点"></a>构造函数的继承特点</h2><p>构造函数是比较特殊的一类<br>在继承时，构造函数不会被继承，也不会被覆盖<br>父类和子类的构造函数依然是独立存在，并且分别发挥着作用</p><p>父类相当于一个硬球，子类则是在球外的包装<br>构造对象时显然应当先构造最内部的硬球，也就是最顶端的父类<br>之后再从里往外一层层地构造外包装，直到最后整个对象都构造起来<br>如果父类的构造函数有参数，那么就需要用super关键字，它指代父类</p><h2 id="类与对象-3"><a href="#类与对象-3" class="headerlink" title="类与对象"></a>类与对象</h2><p>3.1  面向对象的基本思想和基本概念<br>3.2  案例<br>3.3  类的声明与对象的创建<br>3.4  继承<br>3.5  包的使用<br>3.6  编程实例<br>实训三  面向对象程序设计<br>习题三 </p><h2 id="面向对象的基本思想和基本概念-1"><a href="#面向对象的基本思想和基本概念-1" class="headerlink" title="面向对象的基本思想和基本概念"></a>面向对象的基本思想和基本概念</h2><p>大部分传统的高级程序设计语言(如C语言)都是过程化的语言，在软件开发的过程中采用自顶向下逐步细化的方法将整个程序描述为一个过程。对于小型的系统，这种方法是可行的，但是当系统规模很大，复杂度很高时，用过程化方法描述变得十分困难，面向对象的软件开发方法可以很好地解决这个问题。</p><p>目前，面向对象的方法在软件开发工作中得到了广泛的应用，越来越多的软件开发工具开始支持面向对象的开发方法。Java语言就是一种面向对象的程序设计语言，要充分利用Java语言的特性首先应该理解面向对象的基本思想。</p><h2 id="面向对象的基本思想-1"><a href="#面向对象的基本思想-1" class="headerlink" title="面向对象的基本思想"></a>面向对象的基本思想</h2><p>面向对象的基本思想认为系统是由若干个对象构成的，每个对象都有各自的内部状态和运动规律，不同对象之间通过消息传送相互作用和联系。</p><p>采用对象的观点看待所要解决的问题，并将其抽象为系统是极其自然与简单的，因为它符合人类的思维习惯，使得应用系统更容易理解。同时，由于应用系统是由相互独立的对象构成的，使得系统的修改可以局部化，因此系统更易于维护。 </p><p> 例如，对于一个企业的管理信息系统，将整个系统描述成一个过程是难以想像的，但可以分别描述各个部门的特性及工作流程，然后描述部门之间的联系。这里各个部门就是组成企业的对象，当然，在描述每个部门特性时可以采用同样的方法。</p><h2 id="对象与类-1"><a href="#对象与类-1" class="headerlink" title="对象与类"></a>对象与类</h2><p>对象是面向对象方法中的一个重要概念。所谓对象，是指客观世界中事物在计算机领域中的抽象，用一组数据和施加于该组数据上的一组操作(行为)来描述。</p><p>对象的描述通常由三个部分组成：</p><p>(1) 私有的数据结构。<br>用于描述对象的内部状态。<br>(2) 处理，称为操作或方法。<br>它是施加于数据结构之上的。<br>(3) 接口。<br>这是对象可被共享的部分，消息通过接口调用相应的操作。接口规定哪些操作是允许的，它不提供操作是如何实现的信息。</p><p>实际上，采用面向对象方法进行系统分析与设计时要描述的并不是一个个具体的对象。对于一个具体的系统而言，可能存在很多具有相同特征的对象，而且通常系统中对象的数目是不确定的。</p><p>例如，对于一个学籍管理系统，存在许多学生对象，它们具有相同的结构特征和行为特征，只是表示内部状态的数据值不同。为了描述这种相同结构特征和行为特征的对象，面向对象方法引入了类的概念。这一点与人们在认识客观世界的事物时所采取的分类思想相同。人们在认识事物时总是将具有相同特征的事物归为一类，属于某类的一个事物具有该类事物的共同特征。</p><p>类是对一组具有相同特征的对象的抽象描述，所有这些对象都是这个类的实例。对于学籍管理系统，学生是一个类，而一个具体的学生则是学生类的一个实例。一个类的不同实例具有相同的操作或行为的集合和相同的信息结构或属性的定义，但属性值可以不同；不同的实例具有不同的对象标识。对于学生类中的每一个对象，描述它们所使用的数据结构相同，但是值不同。在程序设计语言中，类是一种数据类型，而对象是该类型的变量，变量名即是某个具体对象的标识。</p><p>因此，一个类的定义至少包含以下两个方面的描述：</p><p>(1) 该类所有实例的属性或结构的定义。<br>(2) 该类所有实例的操作(或行为)的定义。</p><p>类是构成Java语言程序的基本单位，一个完整的Java程序是由若干个类构成的，每个类由若干数据和方法构成，一个类的定义包含属性(数据)和方法(行为)两部分内容。</p><h2 id="继承性-1"><a href="#继承性-1" class="headerlink" title="继承性"></a>继承性</h2><p>人们在对客观世界的事物进行描述时，经常采取分类的方法。类是有层次的，即某个大类的事物可能分为若干小类，而这些小类可能又分为若干个更小的类。</p><p>面向对象思想采纳了事物分类的层次思想，在描述类的时候，某些类之间具有结构和行为的共性。例如，描述教师与学生时均需描述姓名、年龄、身高、体重等属性，将这些共性抽取出来，形成一个单独的类——人，用于描述教师类和学生类的共性。类人的结构特征和行为特征可以被多个相关的类共享，教师类和学生类继承了类人的结构和行为特征。</p><p>Java语言支持类的继承，可以从一个类中派生出一个新的类，原来的类称为超类或父类，新类称为超类的子类或派生类。子类的对象具有超类对象的特征，同时又有其自身特有的特征。子类又可以派生出新的子类，子类的子类也称为派生类。</p><p>利用类之间的继承关系，可以简化类的描述，提高软件代码的可重用性。在设计一个新类时，不必从头设计编写全部的代码，可以通过从已有的具有类似特性的类中派生出一个类，继承原有类中的部分特性，再加上所需的新特性。</p><p>另外，人们在对客观世界的事物进行分类时，一个事物可能属于多个类，具有多个类的特性。例如，一个黑人学生，他既属于学生类，又属于黑人类。这种情形在面向对象方法中称为多继承，即一个类同时从多个类中派生出来，此时类的层次结构是网状的。</p><p>Java语言为了不使语法过于复杂，不支持多继承，只允许子类有一个超类，称为单继承。不过，Java语言提供了接口机制，可以在一定程度上模拟多继承。</p><h2 id="多态性-3"><a href="#多态性-3" class="headerlink" title="多态性"></a>多态性</h2><p>多态性是面向对象系统的又一重要特性。所谓多态，即一个名词可具有多种语义，如一个方法名有多种功能，或者相同的接口有多种实现方法。</p><p>在Java语言中，多态性通过方法的重载、覆盖和接口来实现。<br>方法的重载是指多个方法具有相同的名称 ，但各个方法的参数表不同，即参数的类型和参数的数量不同。</p><p>覆盖是指在类的派生过程中，子类与超类的方法不仅名称相同，参数也完全相同，但它们的功能不同，这时子类中的方法覆盖了超类中同名的方法。</p><p>接口实际上是一种特殊的类，只给出方法的名称、参数和返回值的类型，方法的具体实现在实现该接口的类中给出。</p><h2 id="封装-3"><a href="#封装-3" class="headerlink" title="封装"></a>封装</h2><p>封装是一种信息隐藏技术，对象内部对用户是隐藏的，不可直接访问；用户只能见到对象封装界面上的信息，通过对象的外部接口访问对象。用户向对象发送消息后，对象根据收到的消息调用内部方法作出响应。封装的目的在于将对象的使用者和对象的设计者分开，使用者无需知道对象内部实现的细节，只需知道对象接收的消息即可。</p><p>Java语言通过类来实现封装，类中定义的属性和方法分为私有的和公有的，私有属性和方法不能在对象的外部访问，只能由类内的方法访问。而在对象的外部，只能访问对象的公有属性和方法，只需要知道公有属性的数据类型和名字以及公有方法的原型，至于这些方法是如何实现的对象外部并不需要知道。这就像人们在使用电视机时只需要通过遥控器来操作即可，至于电视机内部细节用户则无需知道，这里遥控器上的按钮实际上就是电视机的外部接口。</p><p>对象的封装特性可以提高模块之间的独立性，使得系统易于调试和维护。</p><h2 id="类的声明与对象的创建-1"><a href="#类的声明与对象的创建-1" class="headerlink" title="类的声明与对象的创建"></a>类的声明与对象的创建</h2><p>类声明的基本语法</p><p>1．类的声明<br>Java语言类声明的完整语法很复杂，下面先介绍最简单的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java的课程体系"><a href="#java的课程体系" class="headerlink" title="java的课程体系"></a>java的课程体系</h2><p>Java语法基础<br>Java面向对象的编程<br>Java的高级编程接口：4个专题<br>Java图形GUI编程<br>多线程编程<br>I/O编程<br>网络编程</p><h3 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h3><p>了解java的产生与发展<br>理解java语言的特性<br>理解java虚拟机jvm的特性和功能<br>理解字节码和垃圾收集的概念<br>列举出在java平台上实现代码安全的方法<br>知道在java中定义类，包，applets和applications<br>掌握编码，编译，运行java应用程序的步骤<br>安装，搭建java开发运行环境<br>第一个java程序<br>带包的java程序<br>JVM搜索类的顺序和类加载<br>CLASSPATH的应用<br>常用的java命令</p><h3 id="Java的产生与发展"><a href="#Java的产生与发展" class="headerlink" title="Java的产生与发展"></a>Java的产生与发展</h3><p>Java的产生</p><p>Sun公司的Green项目<br>基于c++开发的Oak语言<br>Mosaic和Netscape到JavaHot浏览器<br>Internet的蓬勃发展推动了java的发展(Applet)<br>Java(爪哇)  名字的由来</p><p>Java的发展</p><p>Java的现状<br>纯面向对象的语言<br>平台无关性，一次编写，到处运行<br>适合于基于Internet应用程序开发<br>Java的地位确立<br>IT产业很多大公司购买了java的许可证<br>众多软件开发商已支持java软件产品<br>Intranet是企业信息系统最佳的解决方案，java发挥了不可替代的作用<br>Java的发展与其分支<br>95.5.23 Oak改名为java<br>98.12. java1.2，后来改名为java2<br>陆续出现了java1.3,java1.4<br>2004.12 java1.5版本推出   命名为java5.0<br>后来陆续出现java6.0,java7.0</p><h3 id="Java的产生与发展-1"><a href="#Java的产生与发展-1" class="headerlink" title="Java的产生与发展"></a>Java的产生与发展</h3><p>Java的发展与其分支<br>java在今天已形成了庞大的体系,经过十年发展,已有了3个平台标准<br>三大技术平台都提供了相应的开发工具包(SDK:SoftWare Development Kits)</p><p>java SE –标准版应用平台<br>java EE–企业级应用平台<br>java ME—微型版应用平台：应用在存储,运算很小的受限的平台</p><h2 id="Java语言的特性-1"><a href="#Java语言的特性-1" class="headerlink" title="Java语言的特性"></a>Java语言的特性</h2><p>什么是java?<br>程序设计语言；开发环境；应用环境；部署环境<br>Java的特性<br>提供更简单的方式写程序<br>无指针，无需做内存管理<br>提供庞大的类库，纯粹面向对象设计<br>支持静态和动态的代码继承和重用<br>提供一个可解释执行的环境<br>支持任何开发平台<br>只写一次，到处使用<br>支持多线程<br>支持动态升级<br>以上特性如何实现<br>Java虚拟机：JVM<br>垃圾收集：Garbage Collection<br>代码安全：Code Security<br>字节码文件：Verifying</p><p>JVM与跨平台性:<br>一次编写，到处运行：不同操作系统,不同数据库,不同的服务器<br>数据类型也可以实现跨平台<br>Java虚拟机的作用<br>程序的开发及运行方式<br>Java的工作方式：先编译后解释</p><h2 id="Java是先编译后解释执行"><a href="#Java是先编译后解释执行" class="headerlink" title="Java是先编译后解释执行"></a>Java是先编译后解释执行</h2><p>Java源文件先通过编译生成一个字节码文件bytecode<br>字节码不与当前OS相关，结构中立的，是二进制文件。任何平台编译生成的字节码都是一样的。<br>字节码文件不能直接执行，必须需要JVM的支撑才能运行<br>JVM是sun开发的，字节码的结构也是sun定义的,他们之间有很好的接口<br>JVM存在的意义实际上就是屏蔽掉底层平台的差异，为上层结构中立的字节码统一运行的环境，而JVM会将字节码转化成相应的底层平台的机器码执行<br>java解释器功能是用JVM来实现的，java的解释器是在jvm中运行的</p><h2 id="JVM的作用："><a href="#JVM的作用：" class="headerlink" title="JVM的作用："></a>JVM的作用：</h2><p>对下是屏蔽掉了底层平台的差异，对于上层的字节码而言不需要关心它运行在什么平台上，由JVM去把底层平台的差异屏蔽掉<br>对上为结构中立的字节码提供了统一的运行环境，实现了字节码的跨平台</p><h2 id="Java的垃圾收集器"><a href="#Java的垃圾收集器" class="headerlink" title="Java的垃圾收集器"></a>Java的垃圾收集器</h2><p>Java的垃圾收集解除了程序员分配存储器的责任，它提供了一种系统级线程以便跟踪每一存储器的分配情况。在Java虚拟机的空闲周期，垃圾收集线程检查并释放那些可被释放的存储器。<br>内存泄漏<br>垃圾收集线程<br>垃圾收集调用的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.System.gc()/java.lang.Runtime.gc()</span><br></pre></td></tr></table></figure><p>Java代码的安全性</p><h2 id="字节码的作用"><a href="#字节码的作用" class="headerlink" title="字节码的作用"></a>字节码的作用</h2><p>字节码的结构是JVM特定指定的<br>字节码不会破坏，篡改系统<br>禁止运行时堆栈溢出  防止蠕虫病毒袭击<br>参数类型正确<br>类型转换正确</p><p>安装，搭建java开发运行环境</p><p>官方网站下载JDK</p><blockquote><p>官方网站：<code>http://java.sun.com</code></p></blockquote><blockquote><p>不同系统平台，JDK不一样，选择适合于自己平台的JDK</p></blockquote><h2 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h2><p>Windows直接安装运行jdk的可执行exe文件<br>Linux系统将JDK文件压缩包解压后放入opt目录，配置初始化文件的环境变量<br>Windows下JDK安装后，会有2个文件夹生成<br>JDK：java开发工具软件包，它包含了java的编译，调试，运行整个环境和包含了整个类库的软件包<br>JRE：java运行环境<br>JDK,JRE和JVM</p><p>JDK，JRE和JVM</p><p>jre是jdk的子集，在一套完整的jdk中就包含了jre<br>jre只负责运行一个编译好的java程序（字节码文件bytecode）<br>jdk它可以去编译，调试，运行整个操作过程都支持<br>在jre内部有一个软件组件jvm就是java虚拟机</p><h2 id="JDK的结构简介"><a href="#JDK的结构简介" class="headerlink" title="JDK的结构简介"></a>JDK的结构简介</h2><p>bin目录：java开发调试的命令,  exe文件,连接库文件，编译器等等<br>编译一个java文件：javac；运行一个字节码文件：java<br>jre目录：jdk中自带的jre<br>src压缩文件：放置的是jdk类库的源码文件，按包结构组织的<br>demo:：java代码的演示实例文件<br>include：用于编译本地方法的文件<br>docs：html格式的类库文档<br>lib：类库文件<br>Java程序开发环境配置<br>在windows平台：autoexec.bat文件；使用对话框(右击我的电脑／属性／高级／环境变量／系统或用户的环境变量)操作<br>Unix平台需要分shell：csh $HOME/.cshrc   bsh/ksh  $HOME/.profile<br>环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME：保存jdk的安装目录</span><br><span class="line">windows : set  JAVA_HOME=c:\programfiles\java\jdk1.5.0_09</span><br><span class="line">csh: setenv JAVA_HOME  /opt/jdk1.5.0_09</span><br><span class="line">bsh/ksh: JAVA_HOME=/opt/jdk1.5.0_09</span><br><span class="line">CLASSPATH：系统搜索字节码（类文件.class）文件的搜索路径。设置系统在查找字节码文件时，它的搜索路径。</span><br><span class="line">windows: set CLASSPATH=.; %JAVA_HOME%\jre\lib\rt.jar;</span><br><span class="line">csh: setenv CLASSPATH  .:$JAVA_HOME/jre/lib/rt.jar</span><br><span class="line">bsh/ksh:  CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar</span><br></pre></td></tr></table></figure><p>PATH：设置命令的搜索路径，在执行命令时，操作系统就会在PATH设置的路径去查找命令的可执行文件。<br>设置path不能覆盖原有的，可以使用特殊符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">windows：%PATH%;  Linux：$PATH:</span><br><span class="line">windows: set PATH=%PATH%;%JAVA_HOME%\bin;</span><br><span class="line">csh: setenv PATH $PATH:$JAVA_HOME/bin</span><br><span class="line">bsh/ksh: PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p>Linux系统使用bsh/ksh时则需要export  JAVA_HOME CLASSPATH PATH 将环境变量设置为全局的<br>编辑，编译，调试，运行一个java程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">写第一个java程序：HelloWorld.java</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">String str=“Hello World!”; </span><br><span class="line">        System.out.println(“The String  is:：”+str);</span><br><span class="line">System.out.println(&quot;MyAge is: &quot;+age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个程序掌握以下概念<br>一个java源文件中可以定义多个类，但最多只能有一个类用public来修饰，而且该public修饰的类名要与java源文件名一样。</p><p>一个java应用程序应该包含一个主方法，而且主方法的签名是固定不变的。主方法定义在哪个类中并不做固定安排。<br>定义的所有的代码中，只看到类的定义。在类中去封装其他变量或方法。</p><p>编译HelloWorld.java程序</p><p>开始\运行\cmd进入dos,修改当前目录为d:\javacode\day01<br>使用javac HelloWorld.java命令编译<br>编译成功后，到day01程序目录下查看，发现有2个.class文件得出有效结论<br>编译报错则根据错误提示找出错误位置然后修改程序重新编译<br>举例来演示学习错误提示<br>假如将String的S写为小写  ：string str=“HelloWorld!”;<br>假如将out写为out：System.otu.println(“The String  is: “+str);<br>再次编译一下，查看错误提示，必须要会读错误提示<br>分析错误提示，排除错误是基本的能力</p><h2 id="包的概念，含义和使用"><a href="#包的概念，含义和使用" class="headerlink" title="包的概念，含义和使用"></a>包的概念，含义和使用</h2><p>运行HelloWorld程序：</p><p>包含有主方法的程序才可以运行,没有包含主方法的类是不能运行的<br>开始\运行\cmd进入dos;使用cd d:\javacode\day01进入程序目录<br>使用 java HelloWorld(包含有主方法的类的类名)来运行<br>使用java Student就会报告错误提示没有主方法<br>要求学员做HelloWorld程序并操作演示几种错误情况和调错</p><p>带包的java程序<br>包的声明：package day01     package是关键字   day01是包名</p><p>包的概念和含义<br>包名的命名符合标识符命名规则即可<br>企业项目开发中,包的命名也有企业规范的如：com.shunshi.abs.model<br>.来隔开每一部分，每一部分都是包结构<br>com.shunshi这个是软件公司网址的url，可以区分确认哪个公司开发的软件产品   com.sun/com.ibm，这样包名不会产生冲突<br>abs是项目名，model是项目中的模块/子模块名<br>写MySecondJava.java程序<br>使用包结构 package com.shunshi.corejava.day01<br>使用包后，如何编译<br>写MySecondJava.java，使用包声明： package corejava.day01;</p><blockquote><p>编译程序：javac  –d  .   MySecondJava.java</p></blockquote><h2 id="JVM搜索类的顺序与类加载"><a href="#JVM搜索类的顺序与类加载" class="headerlink" title="JVM搜索类的顺序与类加载"></a>JVM搜索类的顺序与类加载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d选项的作用：</span><br><span class="line">把编译好的字节码放在你指定的目录下，所以需要指定目录</span><br><span class="line">如果源文件声明了包结构，那么在给定的目录位置下会按照包结构自动创建目录结构，编译好的字节码文件是放在最终的子目录下</span><br></pre></td></tr></table></figure><h2 id="为什么使用包？"><a href="#为什么使用包？" class="headerlink" title="为什么使用包？"></a>为什么使用包？</h2><p>企业项目开发中方便管理不同的类<br>用包来分门别类地组织不同模块功能的类<br>使用包的好处：举例：航班机票预定项目</p><p>JVM搜索类的顺序与类加载<br>使用包结构编译后，如何运行？<br>使用java，注意：java corejava.day01.MySecondJava<br>如何运行？类加载<br>演示错误情况的发生</p><p>直接使用 java MySecondJava  则报告找不到这个类的定义的错误提示<br>为什么找不到？从系统如何去找类来说，与jvm在查找类时的搜索顺序有关系<br>直接进入包结构目录cd corejava\day01,使用java MySecondJava运行，则报告找不到类的定义同时给出错误原因（找到的类与要运行的类不一致）</p><h2 id="Java-常用命令"><a href="#Java-常用命令" class="headerlink" title="Java 常用命令"></a>Java 常用命令</h2><p>为什么不一致呢？找到的是带包的，运行的是不带包的<br>CLASSPATH的应用<br>深刻理解java技术体系<br>如何使用第三方的java技术</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>javac 选项  源文件名    编译java 源文件</p><p>-d<br>查看javac命令到底有哪些选项，直接使用javac/javac -help命令回车<br>java 选项  类名 [参数]  运行java程序<br>jdb  选项  类名 [参数]   进行debug调试的命令<br>javadoc  选项  包名   源文件名   生成jdk的api形式的程序文档</p><p>在java源文件中允许使用文档形式的注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释  //注释内容</span><br><span class="line">多行注释 /*注释内容*/  多行注释不能嵌套,但可以嵌套单行注释</span><br><span class="line">文档注释  /**注释内容*/</span><br></pre></td></tr></table></figure><p>出现在类的定义，方法的定义，属性的定义之前，用来说明类的含义，方法的含义，属性的含义<br>使用javadoc命令给MySecondJava.java生成文档注释<br>在MySecondJava.java中，类前，主方法前写一些文档注释<br>使用javadoc命令将文件MySecondJava.java中的文档注释抽取出来生成程序文档。javadoc –d .\doc  MySecondJava.java</p><h3 id="分析程序文档结构和理解jdk的API文档"><a href="#分析程序文档结构和理解jdk的API文档" class="headerlink" title="分析程序文档结构和理解jdk的API文档"></a>分析程序文档结构和理解jdk的API文档</h3><blockquote><p>jar {ctxu}[vfm0Mi] [jar-file] [manifest-file] [-C  directory] files 创建/展开/更新一个jar文件</p></blockquote><p>jar文件：sun公司定义的一种文件格式，与zip格式相同，可以用普通的解压缩工具解开。jar文件压缩的一般是java的字节码文件,按照包结构组织好的.class文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建jar文件:  将d:\corejava\day01中的1个.class文件打包成一个jar文件</span><br><span class="line">jar   -cvf  first.jar   .\corejava   不与源文件放在一起   </span><br><span class="line">c  代表创建jar文件</span><br><span class="line">v  是可视化即可以看见创建过程和创建详细清单</span><br><span class="line"> f  代表可在后面指定jar文件名</span><br></pre></td></tr></table></figure><p>解压生成后jar文件，有corejava和META-INF2个文件夹<br>jar文件有什么作用？<br>将开发的类打包jar文件给客户，客户得到后只需要设置classpath后就可以用了<br>开发一个中间件，将中间件的程序打包成jar<br>打包day01.jar（corejava\day01中的.class）给第三个程序MyThirdJava使用。<br>写MyThirdJava.java程序</p><p>知道java的特殊符号<br>熟悉java的标识符<br>掌握java的关键字的使用<br>理解java各数据类型的存储和使用<br>原始数据类型<br>基本数据类型的转换<br>定义类，对象，成员变量和引用变量<br>类的声明<br>类变量与类成员变量<br>创建类的对象实例和使用默认值<br>描述引用变量与类对象的关系<br>掌握表达式和运算符的使用</p><h2 id="Java中的特殊符号"><a href="#Java中的特殊符号" class="headerlink" title="Java中的特殊符号"></a>Java中的特殊符号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注释</span><br><span class="line">单行注释：//</span><br><span class="line">多行注释：/* */</span><br><span class="line">这两种注释只能通过打开源文件来查看，写程序一定要写注释。注释与程序应是2:1</span><br><span class="line">多行注释：/** */</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个注释可以不打开源文件来查看，java中有一个javadoc工具，它的作用是将源文件中的/**  */</span><br></pre></td></tr></table></figure><p>注释单独抽出来放在另一个文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如： javadoc –d  .  Hello.java,执行后，会在当前目录下生成一个doc目录，里面文件就可查看注释了。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其他符号</span><br><span class="line">;   一个语句的结束</span><br><span class="line">&#123;   &#125;  一个语句块</span><br><span class="line">空白字符    空格，tab,回车,换行等</span><br></pre></td></tr></table></figure><h2 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h2><p>标识符：程序中的组件名字，包括类名，方法的参数名，变量名，方法名，包名等<br>定义标识符的规则：<br>    以_ ,$,字母开头；<br>    只含有_,$,字母，数字;<br>    没有长度限制，不能有空格；<br>    不能使用java的关键字或保留字<br>    大小写敏感</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：_abc √, $ABC √,2A ×,A# ×,For√,顺时 √</span><br><span class="line">Java开发的命名习惯</span><br><span class="line">所有的命名要望文生义，这样才具有良好的可读性</span><br><span class="line">Total，Sum，ShunshiStudent，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类名，接口名：每个单词的首字母大写，其他字母小写  如类MyFirstJava，Player，Teacher</span><br><span class="line">属性，方法,，局部变量名：第一个单词全小写，从第二个单词开始以后每个单词首字母大写，其他字母小写    如方法 getName()     setDoctorBirthday()</span><br><span class="line">常量：每个单词所有字母全部大写，单词之间用_来连接  java中使用final修饰   final int MARK_GREED=22;</span><br><span class="line">包名：所有字母全部小写  如package com.shunshi.corejava.day01</span><br></pre></td></tr></table></figure><h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h2><p>关键字：对Java技术编译器有特殊的含义，可以被编译器识别执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract  do  implements  private throw  boolean double import  protected  throws </span><br><span class="line">break  else  instanceof  public  transient  byte   extends  int   return  true </span><br><span class="line">case   false   interface  short    try    catch    final   long     static   void </span><br><span class="line">char   finally   native   super    volatile   class    float    new    switch     while </span><br><span class="line">continue   for    null     synchronized   default    if     package    this</span><br></pre></td></tr></table></figure><p>Java关键字特点</p><p>java关键字与c++很多相似，只要与c++一样的，它的含义都与c++中的相同<br>有些关键字c++有，而java没有</p><p>sizeof 求出某种类型的变量的占内存的大小<br>为什么c++有sizeof？<br>因为不同机器内存占用空间大小不一样 16，32，64位，取决于操作系统平台。<br>为什么Java不需要？<br>因为有JVM。</p><p>java中的关键字都是小写的<br>true、false和null为小写，而不是象在C++语言中那样为大写。严格地讲，它们不是关键字。</p><h2 id="Java关键字-1"><a href="#Java关键字-1" class="headerlink" title="Java关键字"></a>Java关键字</h2><p>有些关键字java没有取消保留下来，但它自己也不用它也不给程序员用<br>goto和const不是Java编程语言中使用的关键字，而是保留字。<br>什么是保留字？<br>为什么保留下来但不能用?<br>在java中final替代const<br>goto在c++代表无条件跳转，功能很好，但不能经常用，要谨慎。<br>很多建议去掉goto关键字，没有理解goto真正含义。<br>为什么c++到现在都没有删除掉goto?它有一个特殊使命<br>Java中使用break代替goto<br>跳出一层循环 ：break<br>跳出多层循环：break out<br>        out是一个标号，可以跳到out标识处</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">break避免滥用goto，把goto功能削弱了，只能跳到外层循环</span><br><span class="line">java中加入新的关键字enum assert</span><br><span class="line">enum：枚举</span><br><span class="line">assert：断言</span><br></pre></td></tr></table></figure><h2 id="Java的原始数据类型"><a href="#Java的原始数据类型" class="headerlink" title="Java的原始数据类型"></a>Java的原始数据类型</h2><p>boolean   true/false<br>byte  8位整型  1个字节<br>short 16位整型 2个字节<br>int 32位整型 4个字节<br>long 64位整型 8个字节<br>char 16位 unicode 字符  2个字节<br>double 64位浮点数字型 8个字节<br>float  32位浮点数字型 4个字节</p><h3 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h3><p>Java中定义boolean类型<br>boolean b=true;<br>Java中的boolean类型的取值只能是true,false<br>Java中的boolean类型不能与int通用，而在c++中可以<br>C++中,0代表false,非0代表true<br>boolean与int通用好还是不好呢？不好<br>举例说明 c++中的boolean与int通用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">if(0&lt;a&lt;2) cout&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="Integer-数据类型—byte-short-int-long"><a href="#Integer-数据类型—byte-short-int-long" class="headerlink" title="Integer 数据类型—byte,short,int,long"></a>Integer 数据类型—byte,short,int,long</h2><p>Java中的4种整型类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte: 1个字节 –128(-27)-127(27-1)</span><br><span class="line">short: 2个字节 –32768(-215)-32767(215-1)</span><br><span class="line">int: 4个字节 –2147483648 (-231) -2147483647 (-231-1)</span><br><span class="line">long: 8个字节  –263-263-1</span><br></pre></td></tr></table></figure><p> Java的不同整型占用内存空间的大小不一样<br> Java中整型的存储规则与c++一样， 但java整型没有无符号和有符号的区分，这与c++不一样。Java中所有整型都是有符号的，这样就可以求出每个整型能表示的范围。</p><p>以byte为例说明<br>Byte是8位整型  1个字节 最多可表示28=256个数  从(-27)-128到127(27-1)<br>为什么是-128-127而不是-127-128呢？与整型数据在内存的存储规则有关<br>整型数据在内存空间中的存储方式<br>    正整数（最高位为0）在内存中是存储原码<br>    负整数（最高位为1）在内存中是存储其补码    补码是不考虑符号情况下原码取反后末位加1。以-5来分析补码<br>分析一些特殊数字：8位全为1则是数字-1，8位全为0则是数字0<br>不考虑符号位最大的数是01111111表示数字127，最小的数10000000表示数字-128</p><h2 id="Integer-数据类型在内存的存储方式"><a href="#Integer-数据类型在内存的存储方式" class="headerlink" title="Integer 数据类型在内存的存储方式"></a>Integer 数据类型在内存的存储方式</h2><p>为什么用补码存储负数？方便二进制计算，例如-128+127=-1<br>其他类型的整型在内存的存储方式与byte相同，只是空间更大。其他类型的整型表示数的范围如前面<br> 整型数据表示<br>long类型使用  l或L来表示<br>int的不同进制：十六进制用0x或H表示    8进制用0或O表示   10进制用D或10表示<br>默认类型为int</p><h2 id="char数据类型"><a href="#char数据类型" class="headerlink" title="char数据类型"></a>char数据类型</h2><p>char类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> char 字符型为16位， 2个字节，与c++不一样,采用的是unicode编码，unicode编码是统一编码，可包含字母，数字，符号，中文文字等</span><br><span class="line">unicode码是采用16进制表示的 如‘\u0061’</span><br><span class="line">2个字节的unicode编码可以表示216个字符，字符使用单引号‘’来表示</span><br><span class="line">127个ASCII码全可表示 英文字符，控制字符，数字，标点符  </span><br><span class="line">表示其他语言的字符：中文，德语，法语，阿拉伯等</span><br><span class="line">一个char类型本质上是一个整型</span><br></pre></td></tr></table></figure></p><p>char与short都是16位的，他们的差别？<br>通过查询unicode编码集可以获取一个整型值对应的unicode字符<br>unicode编码集包含了ASCII码集的<br>在0-127内unicode编码值与ASCII码值一样，表示的字符也一样<br>常见的ASCII码值 ：A:65  a:97  0:48<br>通过unicode码得到码值可以将16进制转换为10进制</p><h2 id="String类型简介"><a href="#String类型简介" class="headerlink" title="String类型简介"></a>String类型简介</h2><p>Java中的转义字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\’   ：‘ 单引号     \” ： “双引号    \\ ：\顺斜杠  \n：换行   \t：tab制表符       </span><br><span class="line">\b：退格      \0：‘\u0000’   unicode码值为0的空字符</span><br></pre></td></tr></table></figure><p>String类型<br>String类型：字符串类型，它不是java的8种基本类型，是类的类型<br>String是java的一个类，这个类的实例叫做String对象<br>Java中字符串用””双引号来引用<br>Java中的字符串类不是以‘\0’结尾</p><p>String类是Java中使用最多的类，它有很多有用的方法，查看jdk的api文档<br>获得String类的对象变量<br>String str1=“Hello”;      String str2=new String(“ World!”);</p><p>String可做什么操作<br>使用+号来连接字符串<br>String s1=“12”; int ia=3; int ib=4;<br>System.out.println(s1+ia+ib); System.out.println(ia+ib+s1);<br>char charAt(int)：返回参数int指示位置上的字符<br>System.out.println(str1.charAt(0));<br>String concat(String)：将当前String与参数String连接起来返回新串<br>System.out.println(str1.concat(str2));</p><p>boolean contains(charSequence s)：判断一个字符串中是否包含参数的子串<br>String str3=“Hello World!”;    System.out.println(str3.contains(str1));</p><p>boolean equals(String)：比较2个字符串内容是否相等,不忽略大小写<br>String s2=“Hello”; String s3=“Hello”; System.out.println(s2.equals(s3));</p><p>boolean equalsIgnoreCase(String)：比较2个字符串内容是否相等，忽略大小写<br>String s4=“heLLo”; System.out.println(s4.equals(s3)); System.out.println(s4.equalsIgnoreCase(s3));</p><p>int  indexOf(String/char)：获得参数字符/字符串在改字符串中的第一次出现的位置索引，假如找不到则返回-1<br>System.out.println(str3.indexOf(“Wor”)); System.out.println(str3.indexOf(‘o’));</p><p>length()：获得字符串的长度<br>System.out.println(str3.length());<br>写TestString.java，演示上面String的功能</p><h2 id="浮点型数据类型"><a href="#浮点型数据类型" class="headerlink" title="浮点型数据类型"></a>浮点型数据类型</h2><p>浮点数据类型：２种<br>float：单精度，３２位　４个字节　使用f或者F表示<br>double：双精度　６４位　８个字节　默认类型  使用d或者D表示</p><p>浮点数举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float fa=123.4f;√  float fb=123.4;×  默认是double  double直接赋给float精度丢失</span><br><span class="line">float fc=12.5E300F;√  float fd=(float)12.5E301; √</span><br><span class="line">double da=123D;  double db=123.456d;  double dc=123.45e301;</span><br></pre></td></tr></table></figure><p>浮点数据类型的存储方式<br>整型存储方式是精确存储<br>浮点存储方式是近似存储：实数范围太大了，实数太多了，无法在内存中对应每一个实数的状态<br>浮点数的近似存储在程序中的问题：写TestFloat.java<br>实型值分母可为0，double d=0.0/0.0; System.out.println(d);编译正确<br>double a=2.0,b=1.91,c=0.09;<br>if(a-b==c) System.out.println(“ok”);else System.out.pringln(“no ok”);<br>结果输出”on ok”。实型数值直接比较相等不安全，不要直接比较相等，但可以比较大小。</p><p>假如一定想要2个实型数值比较是否相等，可以考虑比较2个实型数的差是否在一个非常小的范围内<br>想要输出“ok”，则if(Math.abs(a-b-c)&lt;(1e-6)) System.out.println(“ok”);</p><h3 id="Math类-1"><a href="#Math类-1" class="headerlink" title="Math类"></a>Math类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lang包下的类，它里面定义了很多方法来实现常用的数学运算</span><br><span class="line">Math类中的方法都是静态的</span><br><span class="line"></span><br><span class="line">Math类中的方法：</span><br><span class="line">abs()：求绝对值</span><br><span class="line">sqrt()：求平方根</span><br><span class="line">pow()：求乘方</span><br><span class="line">cos(),sin(),tan(),ctan()：数学的三角函数运算</span><br><span class="line">random()：获得0-1之间的随机数</span><br><span class="line">在TestFloat.java中测试使用Math类中的方法</span><br><span class="line">Math.abs(-5)</span><br><span class="line">Math.sqrt(9)</span><br><span class="line">Math.pow(2,3)</span><br><span class="line">Math.random()*100：获得0-100之间的随机数</span><br></pre></td></tr></table></figure><h2 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换"></a>数据类型之间的转换</h2><p>数据类型之间的转换分为2种<br>自动类型转换<br>a类型转换为b类型时，a的取值范围是b的取值范围的完全子集 这就是自动类型转换<br>在java的8种基本类型中，除boolean以外，其他7种类型都是可以相互转换的。<br>7种原始类型之间可自动转换结构图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte→short→int→long→float→double</span><br><span class="line">     char</span><br></pre></td></tr></table></figure><p>顺着箭头方向可自动转换；逆着箭头方向则是强制转换<br>强制类型转换：只要不能自动转换的，则只能是强制转换<br>整型数据之间的强转：改变数据的符号；改变数值</p><blockquote><p>int a=0x2aff; byte b=(byte)a;   b为-1</p></blockquote><p>强制转换的原理：从最低位开始取到目标类型长度为止<br>整型之间的强转是保留二进制低位，去掉高位，需要考虑在内存中如何存储<br>实型强转整型是保留整数，去掉小数，不考虑实型在内存中的如何存储<br>写一个DataTypeTest.java程序演示数据类型转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">byte+byte会自动提升为int</span><br><span class="line">byte a1=1,a2=2;byte a3=a1+a2;×(精度丢失)</span><br><span class="line">+=不进行类型提升</span><br><span class="line">byte c=3; c=c+3; c+=3;System.out.println(c);</span><br><span class="line">默认整型为int,int，long提升为float有精度丢失</span><br><span class="line">float fa=37; System.out.println(fa); </span><br><span class="line">int ia=(int)fa; System.out.println(ia);</span><br><span class="line">long la=0xffffffffffL;float fb=la;System.out.println(fb);</span><br><span class="line">long lb=(long)fb;  System.out.println(lb);</span><br><span class="line">整型之间的强转</span><br><span class="line">int a=0x2aff; byte b=(byte)a;  System.out.println(b);</span><br><span class="line">float转换为double会有精度丢失</span><br><span class="line">float fe=1234.56f; double de=fe; System.out.println(de);</span><br><span class="line">float ff=(float)de; System.out.println(ff);</span><br><span class="line">整型除法</span><br><span class="line">System.out.println(5/2);</span><br><span class="line">System.out.println((float)5/2);</span><br><span class="line">char与int的转换</span><br><span class="line">char c1=‘A’; int iic=c1;System.out.println(iic);</span><br><span class="line">char c2=99; System.out.println(c2);</span><br></pre></td></tr></table></figure><h2 id="Java中的特殊类型——对象"><a href="#Java中的特殊类型——对象" class="headerlink" title="Java中的特殊类型——对象"></a>Java中的特殊类型——对象</h2><p>为什么会有对象?<br>早些时候的编程语言和初级程序员将每个变量看作相互无关的实体。例如，如果一个程序需处理某个日期，则要声明三个单独的整数：int day, month, year;<br>尽管这种作法很容易理解，但它存在两个重大缺陷<br>名称太多，会引起混乱<br>忽略了各个变量之间的联系<br>例如：若程序需同时记录几个日期，则需要三个不同的声明,要记录两个生日, 则要使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int  myBirthDay, myBirthMonth, myBirthYear;</span><br><span class="line">int yourBirthDay, yourBirthMonth, yourBirthYear;</span><br></pre></td></tr></table></figure><p>忽视了日、月和年之间的联系并把每个变量都作为一个独立的值，每个变量都是一个独立单元(在本例中为date)的一部分并被相应地处理<br>Java的对象类型<br>为克服上述两种缺陷，Java编程语言使用类来表示这种新类型<br>Java除了８中基本类型，还有一种类类型或者叫做对象类型(或是一个类，或是一个接口)<br>Java的类类型不是表达一个简单的数据，而是表达一个较复杂的数据(复合数据) </p><p>例如：描述一个学生，定义一个学生类，它包含学生的相关信息：姓名，性别，年龄，专业<br>创建一个学生类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">private String name;</span><br><span class="line">private boolean sex;</span><br><span class="line">private int age;</span><br><span class="line">private String major;</span><br><span class="line"></span><br><span class="line">public Student(String name,boolean sex,int age,String major)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">this.sex=sex;</span><br><span class="line">this.age=age;</span><br><span class="line">this.major=major;</span><br><span class="line">&#125;</span><br><span class="line">public void setName(String name)&#123;</span><br><span class="line">this.name=name;</span><br><span class="line">&#125;</span><br><span class="line">public void setSex(boolean sex)&#123;</span><br><span class="line">this.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age)&#123;</span><br><span class="line">this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">public void setMajor(String major)&#123;</span><br><span class="line">this.major=major;</span><br><span class="line">&#125;</span><br><span class="line">public String  getName()&#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line">public boolean getSex()&#123;</span><br><span class="line">return sex;</span><br><span class="line">&#125;</span><br><span class="line">public int  getAge()&#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public String getMajor()&#123;</span><br><span class="line">return major;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Student就是一个新的类型，就像int,float等一样可以用来定义变量</span><br><span class="line">例如：Student  stu;   声明一个Student的变量stu，则它里面的name,sex,age,major也都隐含声明了，name,sex,age,major称为stu的成员变量。</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>类类型／对象类型的数据的存储方式与基本类型数据存储方式的差别<br>类型创建一个Student对象：<br>Student stu; stu=new Student(“LiDW’,true,22,”computer”);<br>原始类型的声明<br>    int x;x=7; float y=9.9f;<br>把类看作一个类型的话，它的使用其实和基本类型int等一样，只不过赋值是赋的一个复杂的复合类型数据，是new出的对象<br>存储形式的差别<br>int x; x=7; 基本类型声明变量时就已经创建了变量并分配空间，无论它是否已经赋值，赋值只是将值放入已分配的空间<br>Student stu;对象类型声明Student stu;时，在内存空间也给stu分配了空间。<br>那分配了多少空间？Student中所有成员变量的空间大小和吗？<br>不是取决于Student的大小，与Student的大小无关<br>那stu是什么？在java中把stu叫做引用，这个引用与c++中的引用完全不一样<br>Java中的引用与c++的指针相似，java中没有指针，只有引用，它保存的也是一个地址值(内存空间中的Student对象的地址)<br>Java中的引用与c++的指针有差别<br>C++中指针可被程序员操作：int<em> p;  p++,p–,</em>p等等，所以很危险，不安全<br>Java中不允许程序员对引用做操作，只能通过引用访问对象，但不能对引用进行++,–等操作，所以java语言更安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Java的引用需要多少个字节呢？</span><br><span class="line"></span><br><span class="line">引用无论什么类型都保存的是内存中的地址值</span><br><span class="line">地址值常见的是4个字节，相对来讲很固定的值</span><br><span class="line">地址值的长度严格来讲也取决于不同的机器平台，由机器的寻址空间决定的。例如常用的是32位机器，所以4个字节</span><br><span class="line"></span><br><span class="line">那么stu=new Student(“LiWD”,true,22,”computer”)又干什么？</span><br><span class="line"></span><br><span class="line">在内存空间中又开辟了一个区域专门用来保存该Student对象的数据</span><br><span class="line">赋值语句将开辟的对象空间的地址赋给stu，stu就指向这个对象</span><br><span class="line">综上所述，对象类型的存储方式即需要两个空间：引用空间，对象空间</span><br><span class="line"></span><br><span class="line">Java中的对象与引用的关系：可以打个比方来看看</span><br><span class="line"></span><br><span class="line">对象可以看作是充满氢气的气球，气球中的空气就是对象中的数据，气球我们无法直接拿到</span><br><span class="line">任何时候我们拿到气球都必须通过连接它的一根绳子，这跟绳子就可以看作是引用</span><br><span class="line"></span><br><span class="line">深入理解对象与引用的关系</span><br><span class="line"></span><br><span class="line">同一个气球可不可以有多根绳子连着它？可以  就像双胞胎牵同一个气球</span><br></pre></td></tr></table></figure></p><p>Student stu1=new Student(“LiWD”,true,22,”computer”);<br>Student stu2=stu1;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">stu2,stu1保存的是相同的地址值，stu2,stu1指向同一个对象</span><br><span class="line">通过stu1修改了对象Student的数据值后，通过stu2访问的对象也就改了</span><br><span class="line"></span><br><span class="line">### 可不可能一根绳子同时栓着多个气球？不能</span><br><span class="line"></span><br><span class="line">如果一根绳子没有连任何气球，那么对于这个引用的访问有意义吗？没有意义</span><br><span class="line"></span><br><span class="line">Student stu3=null;定义了一个空引用，没有指向任何对象</span><br><span class="line"></span><br><span class="line">假如使用stu3去访问name,age等会报告空指针异常 NullPointerException</span><br><span class="line"></span><br><span class="line">如果某一个气球没有任何绳子栓着，那它怎么办？飞走了</span><br><span class="line"></span><br><span class="line">这个气球就无法访问了，变成垃圾。(垃圾占用空间，但我们无法访问)</span><br><span class="line"></span><br><span class="line">Student stu4=new Student(“LiWD”,true,22,”computer”); stu4=null;</span><br><span class="line"></span><br><span class="line">### Java的垃圾回收机制</span><br><span class="line"></span><br><span class="line">Java不让程序员管理内存</span><br><span class="line"></span><br><span class="line">一个系统级线程专门扫描内存，回收垃圾</span><br><span class="line"></span><br><span class="line">垃圾回收是自动进行的，程序员可以建议但不能控制，程序员调用java.lang.System.gc()来告诉JVM做垃圾回收。程序员建议后，也不一定就回收。</span><br><span class="line"></span><br><span class="line">一般java.lang.System.gc()语句放在前面程序已释放了很多垃圾后，则调用该语句执行的可能性大</span><br><span class="line">Java的垃圾回收并不是马上回收，jvm有一套算法来确定什么时候进行垃圾回收</span><br><span class="line">Java垃圾回收与c++内存释放的比较差异：打个比方</span><br><span class="line">C++内存释放：相当于学校食堂吃饭，吃饭后要将餐盘送到回收处，若你不做则大家会鄙视你。若大家都不做，则长时间就没有餐盘了。</span><br><span class="line">Java垃圾回收：相当于餐馆中吃饭，吃完了，只结帐就走了。餐馆自然有人来回收。无需自己把餐盘送到后台。</span><br><span class="line"></span><br><span class="line">理解对象</span><br><span class="line">对象无处不在;对象彼此联系;对象有属性;对象有方法</span><br><span class="line"></span><br><span class="line">&gt; There are students and a teacher in classroom</span><br><span class="line"></span><br><span class="line">## Java的运算符</span><br><span class="line"></span><br><span class="line">赋值运算符：一个简单的赋值=和11个复合赋值</span><br></pre></td></tr></table></figure></p><p>=，*=，/=，%=，+=，-=，&lt;&lt;=(左移位)，&gt;&gt;=(右移位)，&gt;&gt;&gt;=，&amp;=(按位与)，^=(按位异或)，|=(按位或)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">复合赋值运算不会产生自动类型的提升 byte b1=2; b1+=2;√ b1=b1+2;×</span><br><span class="line">比较运算符</span><br></pre></td></tr></table></figure></p><blockquote><p>，&gt;=，&lt;，&lt;=,instanceof(比较类型)，= =，!=<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Java的数据类型中哪些是可用比较运算符来连接的</span><br><span class="line"></span><br><span class="line">算术运算符</span><br></pre></td></tr></table></figure></p></blockquote><p>+,-,*,/,%<br>5/2，   (float)5/2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 移位运算符</span><br><span class="line"></span><br><span class="line">所有的移位运算只能针对整型数据操作</span><br></pre></td></tr></table></figure></p><blockquote><blockquote><p>(右移,右移一位等于除2)，&lt;&lt;(左移,左移一位等于乘2)，&gt;&gt;&gt;(无符号右移)<br>有符号的右移：则移走后最左边高位填补为原来的符号位<br>有符号的左移：则移出去的不管，移进来用0来填补<br>无符号右移：则移出去的不管，移进来都用0填补<br>int a=68; a=a&lt;&lt;34; System.out.println(a); 超出了范围，移出后全为0？实际上不是这样的。a&lt;&lt;34等价于a&lt;&lt;(34%32)<br>int in1=20;System.out.println(in1&gt;&gt;1);  10  System.out.println(in1&gt;&gt;&gt;1); 10<br>int in2=-20;System.out.println(in2&gt;&gt;1); -10  System.out.println(in2&gt;&gt;&gt;1); 很大的数<br> 位运算符<br>&amp;(按位与)，|(按位或)，~(按位求反)，^(按位异或)<br>例：  int a=0x5a2b;  int b=0x7332;   a&amp;b a|b a^b<br>位运算符什么时候用？用来干什么？<br>例：int a=0x8a3d;<br><code>`</code></p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/39.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/categories/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="我的书籍" scheme="https://huangguangda.github.io/tags/%E6%88%91%E7%9A%84%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android应用基础知识</title>
    <link href="https://huangguangda.github.io/2018/05/01/1/"/>
    <id>https://huangguangda.github.io/2018/05/01/1/</id>
    <published>2018-05-01T07:50:00.000Z</published>
    <updated>2018-05-08T06:36:20.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/37.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><p>来源：<a href="https://developer.android.google.cn/guide/" target="_blank" rel="noopener">https://developer.android.google.cn/guide/</a></p><h2 id="Android-简介"><a href="#Android-简介" class="headerlink" title="Android 简介"></a>Android 简介</h2><p>Android 提供了一个内容丰富的应用框架，支持您在 Java 语言环境中为移动设备开发创新应用和游戏。在左侧导航窗格列出的文档中，提供了有关如何使用各种 Android API 开发应用的详细信息。</p><p>如果您是 Android 应用开发新手，则需了解以下有关 Android 应用框架的基本概念，这一点至关重要：</p><p>应用提供多个入口点<br>Android 应用都是将各种可单独调用的不同组件加以组合开发而成。例如，组件可以是为用户界面提供一个屏幕的单个“Activity”，也可以是在后台独立执行工作的“服务”。</p><p>您可以使用 intent 从一个组件启动另一个组件。甚至，您还可以启动不同应用中的组件，例如，启动地图应用中的 Activity 以显示地址。此模式可为单个应用提供多个入口点，并使任何应用均能够像用户“默认设置”一样处理其他应用可能调用的操作。</p><p>应用可适应不同的设备<br>Android 提供了一个自适应应用框架，可用以为不同的设备配置提供独特的资源。例如，您可以针对不同的屏幕尺寸创建不同的 XML 布局文件，系统将根据当前设备的屏幕尺寸确定要应用的布局。</p><p>如有任何应用功能需要相机等特定的硬件，则可在运行时查询设备功能的可用性。如有必要，您还可以声明您的应用所必需的功能，使 Google Play 商店等应用市场不得在不支持这些功能的设备上安装您的应用。</p><h2 id="构建您的第一个应用"><a href="#构建您的第一个应用" class="headerlink" title="构建您的第一个应用"></a>构建您的第一个应用</h2><p>欢迎从事 Android 应用开发！</p><p>本课将介绍如何构建您的第一个 Android 应用。您将学习如何使用 Android Studio 创建 Android 项目和运行可调试版本的应用。您还将了解一些 Android 应用设计的基础知识，包括如何构建简单的界面和处理用户输入。</p><h2 id="创建-Android-项目"><a href="#创建-Android-项目" class="headerlink" title="创建 Android 项目"></a>创建 Android 项目</h2><p>本课将向您介绍如何使用 Android Studio 创建新的 Android 项目并说明该项目中的一些文件。</p><p>在 Welcome to Android Studio 窗口中，点击 Start a new Android Studio project。</p><p>或者如果您已打开项目，请选择 File &gt; New Project。</p><p>在 New Project 屏幕中，输入以下值：<br>Application Name：“My First App”<br>Company Domain：“example.com”<br>您可能需要更改项目位置，但无需更改其他选项。</p><p>点击 Next。</p><p>在 Target Android Devices 屏幕中，保留默认值并点击 Next。<br>在 Add an Activity to Mobile 屏幕中，选择 Empty Activity，然后点击 Next。<br>在 Configure Activity 屏幕中，保留默认值并点击 Finish。<br>经过一些处理后，Android Studio 将打开 IDE。</p><p>下面让我们花一点时间回顾一下最重要的文件。</p><p>首先，请确保已打开 Project 窗口（选择 View &gt; Tool Windows &gt; Project），并从窗口顶部的下拉列表中选择 Android 视图。随后，您可以看到下列文件：</p><p>app &gt; java &gt; com.example.myfirstapp &gt; MainActivity.java</p><p>这是主 Activity（您的应用的入口点）。当您构建和运行应用时，系统会启动此 Activity 的实例并加载其布局。</p><p>app &gt; res &gt; layout &gt; activity_main.xml</p><p>此 XML 文件会定义 Activity 界面的布局。它包含一个带有文本“Hello world!”的 TextView 元素。</p><p>app &gt; manifests &gt; AndroidManifest.xml</p><p>manifest 文件描述应用的基本特性并定义其每个组件。</p><p>Gradle Scripts &gt; build.gradle</p><p>您会看到具有此名称的两个文件：一个用于项目，一个用于“应用”模块。每个模块均有自己的 build.gradle 文件，但此项目当前仅有一个模块。您将主要使用模块的 build.gradle 文件配置 Gradle 工具编译和构建您的应用的方式。如需了解有关此文件的更多信息，请参阅配置构建。</p><h2 id="运行您的应用"><a href="#运行您的应用" class="headerlink" title="运行您的应用"></a>运行您的应用</h2><p>现在，您可以在真实设备或模拟器上运行应用。</p><p>在真实设备上运行</p><p>按照以下步骤设置您的设备：</p><p>使用一根 USB 电缆将您的设备连接到您的开发机器。如果您是在 Windows 上开发，可能需要为您的设备安装相应的 USB 驱动程序。</p><p>按照以下步骤操作，在 Developer options 中启用 USB debugging。<br>首先，您必须启用开发者选项：</p><p>打开 Settings 应用。<br>（仅在 Android 8.0 或更高版本上）选择 System。<br>滚动到底部，然后选择 About phone。<br>滚动到底部，点按 Build number 7 次。<br>返回上一屏幕，在底部附近可找到 Developer options。<br>打开 Developer options，然后向下滚动以找到并启用 USB debugging。</p><p>按照以下步骤操作，在您的设备上运行应用：</p><p>在 Android Studio 中，点击 Project 窗口中的 app 模块，然后选择 Run &gt; Run（或点击工具栏中的 Run  ）。<br>在 Select Deployment Target 窗口中，选择您的设备，然后点击 OK。<br>Android Studio 会在您连接的设备上安装并启动应用。</p><p>至此，“hello world”将在您的设备上运行！要开始开发应用，请继续学习下一课。</p><p>在模拟器上运行<br>按照以下步骤操作，在模拟器上运行应用：</p><p>在 Android Studio 中，点击 Project 窗口中的 app 模块，然后选择 Run &gt; Run（或点击工具栏中的 Run  ）。</p><p>在 Select Deployment Target 窗口中，点击 Create New Virtual Device。 </p><p>在 Select Hardware 屏幕中，选择电话设备（如 Pixel），然后点击 Next。</p><p>在 System Image 屏幕中，选择具有最高 API 级别的版本。如果您未安装该版本，将显示一个 Download 链接，因此，请点击该链接并完成下载。</p><p>点击 Next。</p><p>在 Android Virtual Device (AVD) 屏幕上，保留所有设置不变，然后点击 Finish。</p><p>返回到 Select Deployment Target 对话框中，选择您刚刚创建的设备，然后点击 OK。</p><p>Android Studio 会在模拟器上安装并启动应用。</p><h2 id="构建简单的界面"><a href="#构建简单的界面" class="headerlink" title="构建简单的界面"></a>构建简单的界面</h2><p>Android 应用的界面使用布局（ViewGroup 对象）和微件（View 对象）层次结构构建。布局是一种不可见的容器，用于控制其子视图在屏幕上的位置。微件是界面组件，例如按钮和文本框。</p><p>ViewGroup 对象如何在布局中形成分支并容纳 View 对象的图解</p><p>Android 为 ViewGroup 和 View 类提供了一个 XML 词汇，因此您的大多数界面都在 XML 文件中定义。</p><h2 id="打开布局编辑器"><a href="#打开布局编辑器" class="headerlink" title="打开布局编辑器"></a>打开布局编辑器</h2><p>首先，请按照以下步骤设置您的工作区：</p><p>在 Android Studio 的 Project 窗口中，打开 app &gt; res &gt; layout &gt; activity_main.xml。<br>要为布局编辑器留出更多空间，请选择 View &gt; Tool Windows &gt; Project 以隐藏 Project 窗口，或者点击 Android Studio 左侧的 Project  ）。<br>如果您的编辑器显示 XML 源代码，请点击窗口底部的 Design 标签。<br>点击 Select Design Surface  并选择 Blueprint。<br>点击工具栏中的 Show   并确保选中 Show Constraints。<br>确保 Autoconnect 关闭。工具栏中的提示应为 Turn On Autoconnect  （因为它现在处于关闭状态）。<br>点击工具栏中的 Default Margins，  然后选择 16（您稍后仍然可以调整每个视图的外边距）。<br>点击工具栏中的 Device in Editor，  然后选择 Pixel XL。</p><p>左下方的 Component Tree 窗口显示布局的视图层次结构。在本例中，根视图是 ConstraintLayout，仅包含一个 TextView 对象。</p><p>ConstraintLayout 是一种布局，它根据同级视图和父布局的约束条件为每个视图定义位置。这样一来，您可以创建具有扁平视图层次结构的简单布局和复杂布局。也就是说，它可以避免对嵌套布局（布局内的布局，如图 2 所示）的需求，嵌套布局会增加绘制界面所需的时间。</p><p>例如，您可以声明以下布局（在图 4 中）：</p><p>视图 A 显示在父布局上方 16dp 处。<br>视图 A 显示在父布局左侧 16dp 处。<br>视图 B 显示在视图 A 右侧 16dp 处。<br>视图 B 与视图 A 的顶部对齐。<br>在后面几部分中，您将构建一个与此布局类似的布局。</p><h2 id="添加一个文本框"><a href="#添加一个文本框" class="headerlink" title="添加一个文本框"></a>添加一个文本框</h2><p>首先，您需要移除布局中已有的内容。因此，请点击 Component Tree 窗口中的 TextView，然后按 Delete。</p><p>在左侧的 Palette 窗口中，点击左侧窗格中的 Text，然后将 Plain Text 拖放到设计编辑器中靠近布局顶部的位置。这是一个接受纯文本输入的 EditText 微件。</p><p>在设计编辑器中点击视图。现在，您可以在每个角上看到大小调整手柄（正方形），并在每个边上看到约束锚点（圆形）。</p><p>为了能更好地控制，您可能需要使用工具栏中的按钮放大编辑器。</p><p>点击并按住顶边上的锚点，将其向上拖动，直至锚点吸附到布局的顶部，然后释放。这是一个约束条件 - 它指定视图应位于距离布局顶部 16dp 的位置（因为您将默认外边距设置为 16dp）。<br>类似地，从视图左侧创建一个约束条件，将其限制在布局左侧。</p><h2 id="添加一个按钮"><a href="#添加一个按钮" class="headerlink" title="添加一个按钮"></a>添加一个按钮</h2><p>按钮被限制在文本框及其基线的右侧</p><p>在 Palette 窗口中，点击左侧窗格中的 Widgets，然后将 Button 拖放到设计编辑器中靠近右侧的位置。</p><p>从按钮左侧创建一个约束条件，将其限制在文本框的右侧。</p><p>要在水平对齐中约束视图，您需要在文本基线之间创建一个约束条件。因此，请点击按钮，然后点击 Edit Baseline， 它将显示在设计编辑器中选定视图的正下方。基线锚点显示在按钮内部。点击并按住此锚点，然后将其拖动到文本框中显示的基线锚点。</p><p>注：您还可以使用顶部或底部边缘创建水平对齐，不过，按钮在其图像周围包含内边距，因此如果您按照这种方式对齐这些视图，视觉对齐将是错误的。</p><h2 id="更改界面字符串"><a href="#更改界面字符串" class="headerlink" title="更改界面字符串"></a>更改界面字符串</h2><p>要预览界面，请点击工具栏中的 Select Design Surface  并选择 Design。请注意，文本输入使用“Name”预填充，按钮标记为“Button”。现在，您将更改这些字符串。</p><p>打开 Project 窗口，然后打开 app &gt; res &gt; values &gt; strings.xml。</p><p>这是一个字符串资源文件，您应在这个文件中指定所有界面字符串。这样您可以在一个位置管理所有界面字符串，让字符串的查找、更新和本地化变得更加容易（与您的布局或应用代码中的硬编码字符串相比）。</p><p>点击编辑器窗口顶部的 Open editor。这将打开 Translations Editor，它为添加和编辑您的默认字符串提供了一个简单的界面，并且有助于保持您的所有已翻译字符串井然有序。</p><h2 id="用于添加新字符串的对话框"><a href="#用于添加新字符串的对话框" class="headerlink" title="用于添加新字符串的对话框"></a>用于添加新字符串的对话框</h2><p>点击 Add Key，  以文本框“提示文本”的形式创建新字符串。<br>为键名输入“edit_message”。<br>为值输入“Enter a message”。<br>点击 OK。<br>再添加一个名称为“button_send”并且值为“Send”的键。</p><p>现在，您可以为每个视图设置这些字符串。点击标签栏中的 activity_main.xml 以返回布局文件，然后按照以下步骤添加字符串：</p><p>点击布局中的文本框，如果 Attributes 窗口在右侧还未显示，请点击右侧边栏上的 Attributes  。<br>找到 text 属性（当前设为“Name”）并删除值。<br>找到 hint 属性，然后点击文本框右侧的 Pick a Resource  。在出现的对话框中，双击列表中的 edit_message。<br>现在，点击布局中的按钮，找到 text 属性，点击 Pick a Resource，  然后选择 button_send。</p><h2 id="让文本框大小灵活调整"><a href="#让文本框大小灵活调整" class="headerlink" title="让文本框大小灵活调整"></a>让文本框大小灵活调整</h2><p>要创建一个可以适应不同屏幕尺寸的布局，您现在将让文本框拉伸以填充剩余的所有水平空间（扣除按钮和所有外边距后的空间）。</p><p>首先，请点击工具栏中的 Show  并选择 Blueprint。</p><p>点击 Center Horizontally 的结果</p><p>点击以将宽度更改为 Match Constraints</p><p>现在，文本框将拉伸以填充剩余空间</p><p>选择两个视图（点击一个，按住 Shift 并点击另一个），然后右键点击任何一个视图并选择 Chain &gt; Create Horizontal Chain。</p><p>链是两个或更多视图之间的双向约束条件，它让您可以采用一致的方式放置链接的视图。</p><p>选择按钮并打开 Attributes 窗口。使用 Attributes 窗口顶部的视图检查器将右外边距设置为 16。<br>现在，点击文本框以查看其属性。点击两次宽度指示器，确保将其设置为 Match Constraints，如图 9 中的标注 1 所示。<br>“Match constraints”表示宽度将延长以符合水平约束条件和外边距的定义。因此，文本框将拉伸以填充水平空间（扣除按钮和所有外边距后的空间）。</p><h2 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h2><p>如果已在上一课中将您的应用安装到设备上，只需点击工具栏中的 Apply Changes，  使用新布局更新应用。或者点击 Run，  安装并运行应用。</p><h2 id="启动另一个-Activity"><a href="#启动另一个-Activity" class="headerlink" title="启动另一个 Activity"></a>启动另一个 Activity</h2><h2 id="响应-Send-按钮"><a href="#响应-Send-按钮" class="headerlink" title="响应 Send 按钮"></a>响应 Send 按钮</h2><p>按照以下步骤操作，在 MainActivity.java 中添加一个由按钮调用的函数：</p><p>在文件 app &gt; java &gt; com.example.myfirstapp &gt; MainActivity.java 中，添加 sendMessage() 函数存根，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Called when the user taps the Send button */</span><br><span class="line">    public void sendMessage(View view) &#123;</span><br><span class="line">        // Do something in response to button</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可能会看到一条错误，因为 Android Studio 无法解析用作函数参数的 View 类。因此，请点击，将您的光标放置在 View 声明上，然后按 Alt + Enter（在 Mac 上，则按 Option + Return），执行快速修复。（如果出现一个菜单，请选择 Import class。）</p><p>现在，返回到 activity_main.xml 文件，从按钮调用此函数：<br>在布局编辑器中点击以选择按钮。<br>在 Attributes 窗口中，找到 onClick 属性并从下拉列表中选择 sendMessage [MainActivity]。</p><p>现在，当点按按钮时，系统将调用 sendMessage() 函数。</p><p>记下此函数中的详细信息，要让系统将此函数视为与 android:onClick 属性兼容，需要这些详细信息。具体来说，函数必须声明以下内容：</p><ul><li>公共访问</li><li>空返回值</li><li>以 View 作为唯一参数（它是之前点击的 View 对象）</li></ul><p>接下来，您需要填写此函数以读取文本字段的内容，并将该文本传递给另一个 Activity。</p><h2 id="构建一个-Intent"><a href="#构建一个-Intent" class="headerlink" title="构建一个 Intent"></a>构建一个 Intent</h2><p>Intent 是指在相互独立的组件（如两个 Activity）之间提供运行时绑定功能的对象。Intent 表示一个应用“执行某项操作的意向”。您可以将 intent 用于各种任务，但在本课中，您的 intent 用于启动另一个 Activity。</p><p>在 MainActivity.java 中，添加 EXTRA_MESSAGE 常量和 sendMessage() 代码，如此处所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    public static final String EXTRA_MESSAGE = &quot;com.example.myfirstapp.MESSAGE&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Called when the user taps the Send button */</span><br><span class="line">    public void sendMessage(View view) &#123;</span><br><span class="line">        Intent intent = new Intent(this, DisplayMessageActivity.class);</span><br><span class="line">        EditText editText = (EditText) findViewById(R.id.editText);</span><br><span class="line">        String message = editText.getText().toString();</span><br><span class="line">        intent.putExtra(EXTRA_MESSAGE, message);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android Studio 将再次遇到 Cannot resolve symbol 错误，因此，请按 Alt + Enter（在 Mac 上，则按 Option + Return）。您的导入应按如下所示方式结束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Intent;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.EditText;</span><br></pre></td></tr></table></figure><p>DisplayMessageActivity 仍有错误，但没关系；您将在下一部分中修复该错误。</p><p>下面是 sendMessage() 中的操作：</p><p>Intent 构造函数采用两个参数：</p><p>Context 是第一个参数（之所以使用 this 是因为 Activity 类是 Context 的子类）</p><p>应用组件的 Class，系统应将 Intent（在本例中，为应启动的 Activity）传递至该类。</p><p>putExtra() 函数将 EditText 的值添加到 intent。Intent 能够以名为 extra 的键值对形式携带数据类型。您的键是一个公共常量 EXTRA_MESSAGE，因为下一个 Activity 将使用该键来检索文本值。为 intent extra 定义键时最好使用应用的软件包名称作为前缀。这可以确保在您的应用与其他应用交互时这些键始终保持唯一。</p><p>startActivity() 函数将启动 Intent 指定的 DisplayMessageActivity 实例。现在，您需要创建该类。</p><h2 id="创建第二个-Activity"><a href="#创建第二个-Activity" class="headerlink" title="创建第二个 Activity"></a>创建第二个 Activity</h2><p>在 Project 窗口中，右键点击 app 文件夹并选择 New &gt; Activity &gt; Empty Activity。</p><p>在 Configure Activity 窗口中，为 Activity Name 输入“DisplayMessageActivity”，然后点击 Finish（保留所有其他属性设置为默认值）。</p><p>Android Studio 会自动执行三项操作：</p><p>创建 DisplayMessageActivity.java 文件。</p><p>创建对应的 activity_display_message.xml 布局文件。</p><p>在 AndroidManifest.xml 中添加必需的 <activity> 元素。</activity></p><p>如果运行应用并在第一个 Activity 上点按按钮，将启动第二个 Activity，但它为空。这是因为第二个 Activity 使用模板提供的空布局。</p><h2 id="添加文本视图"><a href="#添加文本视图" class="headerlink" title="添加文本视图"></a>添加文本视图</h2><p>位于布局顶部中心的文本视图</p><p>新 Activity 包括一个空白的布局文件，因此，现在您需要在消息将要显示的位置添加一个文本视图。</p><p>打开文件 app &gt; res &gt; layout &gt; activity_display_message.xml。<br>点击工具栏中的 Turn On Autoconnect （Autoconnect 随后应启用）。</p><p>在 Palette 窗口中，点击 Text，然后将 TextView 拖动到布局中 - 将其放置在靠近布局顶部中心的位置，使其吸附到出现的垂直线上。Autoconnect 将添加左侧和右侧约束条件，在水平中心放置视图。</p><p>再从文本视图的顶部创建一个约束条件，将其限制在布局顶部</p><p>也可以在 Attributes 窗口中展开 textAppearance 并更改属性（例如 textSize 和 textColor），对文本样式进行一些调整。</p><p>显示消息<br>现在，您将修改第二个 Activity，以显示第一个 Activity 传递的消息。</p><p>在 DisplayMessageActivity.java 中，向 onCreate() 函数添加下列代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_display_message);</span><br><span class="line">    </span><br><span class="line">    // Get the Intent that started this activity and extract the string</span><br><span class="line">    Intent intent = getIntent();</span><br><span class="line">    String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE);</span><br><span class="line"></span><br><span class="line">    // Capture the layout&apos;s TextView and set the string as its text</span><br><span class="line">    TextView textView = findViewById(R.id.textView);</span><br><span class="line">    textView.setText(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按 Alt + Enter（在 Mac 上，则按 Option + Return）导入缺少的类。您的导入应按如下所示方式结束：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import android.content.Intent;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.widget.TextView;</span><br></pre></td></tr></table></figure><h2 id="添加向上导航"><a href="#添加向上导航" class="headerlink" title="添加向上导航"></a>添加向上导航</h2><p>您的应用中不是主入口的每个屏幕（所有不是主屏幕的屏幕）都应提供导航，以便用户在应用栏中点按“向上”按钮后可以返回应用层次结构中的逻辑父屏幕。</p><p>您需要做的全部工作是在 AndroidManifest.xml 文件中声明哪个 Activity 是逻辑父项。因此，请打开 app &gt; manifests &gt; AndroidManifest.xml 处的文件，找到 DisplayMessageActivity 的 <activity> 标记，然后将其替换为以下代码：</activity></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;.DisplayMessageActivity&quot;</span><br><span class="line">          android:parentActivityName=&quot;.MainActivity&quot; &gt;</span><br><span class="line">    &lt;!-- The meta-data tag is required if you support API level 15 and lower --&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name=&quot;android.support.PARENT_ACTIVITY&quot;</span><br><span class="line">        android:value=&quot;.MainActivity&quot; /&gt;</span><br><span class="line">&lt;/activity&gt;</span><br><span class="line">Android 系统现在会在应用栏中自动添加“向上”按钮。</span><br></pre></td></tr></table></figure><h2 id="运行应用-1"><a href="#运行应用-1" class="headerlink" title="运行应用"></a>运行应用</h2><p>现在，点击工具栏中的 Apply Changes，再次运行应用  。当应用打开后，在文本字段中键入一条消息，点按 Send 以在第二个 Activity 中查看显示的消息。</p><h2 id="应用基础知识"><a href="#应用基础知识" class="headerlink" title="应用基础知识"></a>应用基础知识</h2><p>Android 应用采用 Java 编程语言编写。Android SDK 工具将您的代码 — 连同任何数据和资源文件 — 编译到一个 APK：Android 软件包，即带有 .apk 后缀的存档文件中。一个 APK 文件包含 Android 应用的所有内容，它是基于 Android 系统的设备用来安装应用的文件。</p><p>安装到设备后，每个 Android 应用都运行在自己的安全沙箱内：</p><p>Android 操作系统是一种多用户 Linux 系统，其中的每个应用都是一个不同的用户；<br>默认情况下，系统会为每个应用分配一个唯一的 Linux 用户 ID（该 ID 仅由系统使用，应用并不知晓）。系统为应用中的所有文件设置权限，使得只有分配给该应用的用户 ID 才能访问这些文件；<br>每个进程都具有自己的虚拟机 (VM)，因此应用代码是在与其他应用隔离的环境中运行；<br>默认情况下，每个应用都在其自己的 Linux 进程内运行。Android 会在需要执行任何应用组件时启动该进程，然后在不再需要该进程或系统必须为其他应用恢复内存时关闭该进程。<br>Android 系统可以通过这种方式实现最小权限原则。也就是说，默认情况下，每个应用都只能访问执行其工作所需的组件，而不能访问其他组件。 这样便营造出一个非常安全的环境，在这个环境中，应用无法访问系统中其未获得权限的部分。</p><p>不过，应用仍然可以通过一些途径与其他应用共享数据以及访问系统服务：</p><p>可以安排两个应用共享同一 Linux 用户 ID，在这种情况下，它们能够相互访问彼此的文件。 为了节省系统资源，可以安排具有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一 VM（应用还必须使用相同的证书签署）。<br>应用可以请求访问设备数据（如用户的联系人、短信、可装载存储装置 [SD 卡]、相机、蓝牙等）的权限。 用户必须明确授予这些权限。 如需了解详细信息，请参阅 使用系统权限。<br>以上内容阐述了有关 Android 应用在系统内存在方式的基础知识。本文的其余部分将向您介绍以下内容：</p><p>用于定义应用的核心框架组件<br>您用来声明组件和应用必需设备功能的清单文件<br>与应用代码分离并允许您的应用针对各种设备配置适当优化其行为的资源<br>应用组件<br>应用组件是 Android 应用的基本构建基块。每个组件都是一个不同的点，系统可以通过它进入您的应用。 并非所有组件都是用户的实际入口点，有些组件相互依赖，但每个组件都以独立实体形式存在，并发挥特定作用 — 每个组件都是唯一的构建基块，有助于定义应用的总体行为。</p><p>共有四种不同的应用组件类型。每种类型都服务于不同的目的，并且具有定义组件的创建和销毁方式的不同生命周期。</p><p>以下便是这四种应用组件类型：</p><p>Activity<br>Activity 表示具有用户界面的单一屏幕。例如，电子邮件应用可能具有一个显示新电子邮件列表的 Activity、一个用于撰写电子邮件的 Activity 以及一个用于阅读电子邮件的 Activity。 尽管这些 Activity 通过协作在电子邮件应用中形成了一种紧密结合的用户体验，但每一个 Activity 都独立于其他 Activity 而存在。 因此，其他应用可以启动其中任何一个 Activity（如果电子邮件应用允许）。 例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的 Activity，以便用户共享图片。<br>Activity 作为 Activity 的子类实现，您可以在 Activity 开发者指南中了解有关它的更多详情。</p><p>服务<br>服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。 服务不提供用户界面。 例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与 Activity 的交互。 诸如 Activity 等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。<br>服务作为 Service 的子类实现，您可以在服务开发者指南中了解有关它的更多详情。</p><p>内容提供程序<br>内容提供程序管理一组共享的应用数据。您可以将数据存储在文件系统、SQLite 数据库、网络上或您的应用可以访问的任何其他永久性存储位置。 其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。 例如，Android 系统可提供管理用户联系人信息的内容提供程序。 因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分（如 ContactsContract.Data），以读取和写入有关特定人员的信息。<br>内容提供程序也适用于读取和写入您的应用不共享的私有数据。 例如，记事本示例应用使用内容提供程序来保存笔记。</p><p>内容提供程序作为 ContentProvider 的子类实现，并且必须实现让其他应用能够执行事务的一组标准 API。 如需了解详细信息，请参阅内容提供程序开发者指南。</p><p>广播接收器<br>广播接收器是一种用于响应系统范围广播通知的组件。 许多广播都是由系统发起的 — 例如，通知屏幕已关闭、电池电量不足或已拍摄照片的广播。应用也可以发起广播 — 例如，通知其他应用某些数据已下载至设备，并且可供其使用。 尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知，在发生广播事件时提醒用户。 但广播接收器更常见的用途只是作为通向其他组件的“通道”，设计用于执行极少量的工作。 例如，它可能会基于事件发起一项服务来执行某项工作。<br>广播接收器作为 BroadcastReceiver 的子类实现，并且每条广播都作为 Intent 对象进行传递。 如需了解详细信息，请参阅 BroadcastReceiver 类。</p><p>Android 系统设计的独特之处在于，任何应用都可以启动其他应用的组件。 例如，如果您想让用户使用设备的相机拍摄照片，很可能有另一个应用可以执行该操作，那么您的应用就可以利用该应用，而不是开发一个 Activity 来自行拍摄照片。 您不需要集成甚至链接到该相机应用的代码，而是只需启动拍摄照片的相机应用中的 Activity。 完成拍摄时，系统甚至会将照片返回您的应用，以便您使用。对用户而言，就好像相机真正是您应用的组成部分。</p><p>当系统启动某个组件时，会启动该应用的进程（如果尚未运行），并实例化该组件所需的类。 例如，如果您的应用启动相机应用中拍摄照片的 Activity，则该 Activity 会在属于相机应用的进程，而不是您的应用的进程中运行。因此，与大多数其他系统上的应用不同，Android 应用并没有单一入口点（例如，没有 main() 函数）。</p><p>由于系统在单独的进程中运行每个应用，且其文件权限会限制对其他应用的访问，因此您的应用无法直接启动其他应用中的组件， 但 Android 系统却可以。因此，要想启动其他应用中的组件，您必须向系统传递一则消息，说明您想启动特定组件的 Intent。 系统随后便会为您启动该组件。</p><p>启动组件<br>四种组件类型中的三种 — Activity、服务和广播接收器 — 通过名为 Intent 的异步消息进行启动。Intent 会在运行时将各个组件相互绑定（您可以将 Intent 视为从其他组件请求操作的信使），无论组件属于您的应用还是其他应用。</p><p>Intent 使用 Intent 对象创建，它定义的消息用于启动特定组件或特定类型的组件 — Intent 可以是显式的，也可以是隐式的。</p><p>对于 Activity 和服务， Intent 定义要执行的操作（例如，“查看”或“发送”某个内容），并且可以指定要执行操作的数据的 URI（以及正在启动的组件可能需要了解的信息）。 例如， Intent 传达的请求可以是启动一个显示图像或打开网页的 Activity。 在某些情况下，您可以启动 Activity 来接收结果，在这种情况下，Activity 也会在 Intent 中返回结果（例如，您可以发出一个 Intent，让用户选取某位联系人并将其返回给您 — 返回 Intent 包括指向所选联系人的 URI）。</p><p>对于广播接收器， Intent 只会定义要广播的通知（例如，指示设备电池电量不足的广播只包括指示“电池电量不足”的已知操作字符串）。</p><p>Intent 不会启动另一个组件类型 - 内容提供程序，后者会在成为 ContentResolver 的请求目标时启动。 内容解析程序通过内容提供程序处理所有直接事务，使得通过提供程序执行事务的组件可以无需执行事务，而是改为在 ContentResolver 对象上调用方法。 这会在内容提供程序与请求信息的组件之间留出一个抽象层（以确保安全）。</p><p>每种类型的组件有不同的启动方法：</p><p>您可以通过将 Intent 传递到 startActivity() 或 startActivityForResult()（当您想让 Activity 返回结果时）来启动 Activity（或为其安排新任务）。<br>您可以通过将　Intent 传递到 startService() 来启动服务（或对执行中的服务下达新指令）。 或者，您也可以通过将 Intent 传递到 bindService() 来绑定到该服务。<br>您可以通过将 Intent 传递到 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast() 等方法来发起广播；<br>您可以通过在 ContentResolver 上调用 query() 来对内容提供程序执行查询。<br>如需了解有关 Intent 用法的详细信息，请参阅 Intent 和 Intent 过滤器文档。 以下文档中还提供了有关启动特定组件的详细信息： Activity、服务、BroadcastReceiver 和内容提供程序。</p><p>清单文件<br>在 Android 系统启动应用组件之前，系统必须通过读取应用的 AndroidManifest.xml 文件（“清单”文件）确认组件存在。 您的应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。</p><p>除了声明应用的组件外，清单文件还有许多其他作用，如：</p><p>确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限<br>根据应用使用的 API，声明应用所需的最低 API 级别<br>声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕<br>应用需要链接的 API 库（Android 框架 API 除外），如 Google 地图库<br>其他功能<br>声明组件<br>清单文件的主要任务是告知系统有关应用组件的信息。例如，清单文件可以像下面这样声明 Activity：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest ... &gt;</span><br><span class="line">    &lt;application android:icon=&quot;@drawable/app_icon.png&quot; ... &gt;</span><br><span class="line">        &lt;activity android:name=&quot;com.example.project.ExampleActivity&quot;</span><br><span class="line">                  android:label=&quot;@string/example_label&quot; ... &gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p><p>在 <application> 元素中，android:icon 属性指向标识应用的图标所对应的资源。</application></p><p>在 <activity> 元素中，android:name 属性指定 Activity 子类的完全限定类名，android:label 属性指定用作 Activity 的用户可见标签的字符串。</activity></p><p>您必须通过以下方式声明所有应用组件：</p><p>Activity 的 <activity> 元素<br>服务的 <service> 元素<br>广播接收器的 <receiver> 元素<br>内容提供程序的 <provider> 元素<br>您包括在源代码中，但未在清单文件中声明的 Activity、服务和内容提供程序对系统不可见，因此也永远不会运行。 不过，广播接收器可以在清单文件中声明或在代码中动态创建（如 BroadcastReceiver 对象）并通过调用 registerReceiver() 在系统中注册。</provider></receiver></service></activity></p><p>如需了解有关如何为您的应用构建清单文件的详细信息，请参阅 AndroidManifest.xml 文件文档。</p><p>声明组件功能<br>如上文启动组件中所述，您可以使用 Intent 来启动 Activity、服务和广播接收器。 您可以通过在 Intent 中显式命名目标组件（使用组件类名）来执行此操作。 不过，Intent 的真正强大之处在于隐式 Intent 概念。 隐式 Intent 的作用无非是描述要执行的操作类型（还可选择描述您想执行的操作所针对的数据），让系统能够在设备上找到可执行该操作的组件，并启动该组件。 如果有多个组件可以执行 Intent 所描述的操作，则由用户选择使用哪一个组件。</p><p>系统通过将接收到的 Intent 与设备上的其他应用的清单文件中提供的 Intent 过滤器进行比较来确定可以响应 Intent 的组件。</p><p>当您在应用的清单文件中声明 Activity 时，可以选择性地加入声明 Activity 功能的 Intent 过滤器，以便响应来自其他应用的 Intent。 您可以通过将 <intent-filter> 元素作为组件声明元素的子项进行添加来为您的组件声明 Intent 过滤器。</intent-filter></p><p>例如，如果您开发的电子邮件应用包含一个用于撰写新电子邮件的 Activity，则可以像下面这样声明一个 Intent 过滤器来响应“send” Intent（以发送新电子邮件）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ... &gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;application ... &gt;</span><br><span class="line">        &lt;activity android:name=&quot;com.example.project.ComposeEmailActivity&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;</span><br><span class="line">                &lt;data android:type=&quot;*/*&quot; /&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p><p>然后，如果另一个应用创建了一个包含ACTION_SEND 操作的 Intent，并将其传递到 startActivity()，则系统可能会启动您的 Activity，以便用户能够草拟并发送电子邮件。</p><p>如需了解有关创建 Intent 过滤器的详细信息，请参阅 Intent 和 Intent 过滤器文档。</p><p>声明应用要求<br>基于 Android 系统的设备多种多样，并非所有设备都提供相同的特性和功能。 为防止将您的应用安装在缺少应用所需特性的设备上，您必须通过在清单文件中声明设备和软件要求，为您的应用支持的设备类型明确定义一个配置文件。 其中的大多数声明只是为了提供信息，系统不会读取它们，但 Google Play 等外部服务会读取它们，以便当用户在其设备中搜索应用时为用户提供过滤功能。</p><p>例如，如果您的应用需要相机，并使用 Android 2.1（API 级别 7）中引入的 API，您应该像下面这样在清单文件中以要求形式声明这些信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ... &gt;</span><br><span class="line">    &lt;uses-feature android:name=&quot;android.hardware.camera.any&quot;</span><br><span class="line">                  android:required=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;uses-sdk android:minSdkVersion=&quot;7&quot; android:targetSdkVersion=&quot;19&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p><p>现在，没有相机且 Android 版本低于 2.1 的设备将无法从 Google Play 安装您的应用。</p><p>不过，您也可以声明您的应用使用相机，但并不要求必须使用。 在这种情况下，您的应用必须将 required 属性设置为 “false”，并在运行时检查设备是否具有相机，然后根据需要停用任何相机功能。</p><p>设备兼容性文档中提供了有关如何管理应用与不同设备兼容性的详细信息。</p><p>应用资源<br>Android 应用并非只包含代码 — 它还需要与源代码分离的资源，如图像、音频文件以及任何与应用的视觉呈现有关的内容。 例如，您应该通过 XML 文件定义 Activity 用户界面的动画、菜单、样式、颜色和布局。 使用应用资源能够在不修改代码的情况下轻松地更新应用的各种特性，并可通过提供备用资源集让您能够针对各种设备配置（如不同的语言和屏幕尺寸）优化您的应用。</p><p>对于您的 Android 项目中包括的每一项资源，SDK 构建工具都会定义一个唯一的整型 ID，您可以利用它来引用应用代码或 XML 中定义的其他资源中的资源。 例如，如果您的应用包含一个名为 logo.png 的图像文件（保存在 res/drawable/ 目录中），则 SDK 工具会生成一个名为 R.drawable.logo 的资源 ID，您可以利用它来引用该图像并将其插入您的用户界面。</p><p>提供与源代码分离的资源的其中一个最重要优点在于，您可以提供针对不同设备配置的备用资源。 例如，通过在 XML 中定义 UI 字符串，您可以将字符串翻译为其他语言，并将这些字符串保存在单独的文件中。 然后，Android 系统会根据向资源目录名称追加的语言限定符（如为法语字符串值追加 res/values-fr/）和用户的语言设置，对您的 UI 应用相应的语言字符串。</p><p>Android 支持许多不同的备用资源限定符。限定符是一种加入到资源目录名称中，用来定义这些资源适用的设备配置的简短字符串。 再举一例，您应该经常会根据设备的屏幕方向和尺寸为 Activity 创建不同的布局。 例如，当设备屏幕为纵向（长型）时，您可能想要一种垂直排列按钮的布局；但当屏幕为横向（宽型）时，应按水平方向排列按钮。 要想根据方向更改布局，您可以定义两种不同的布局，然后对每个布局的目录名称应用相应的限定符。 然后，系统会根据当前设备方向自动应用相应的布局。</p><h2 id="应用资料"><a href="#应用资料" class="headerlink" title="应用资料"></a>应用资料</h2><p>提供资源<br>您应该始终外部化应用资源，例如图像和代码中的字符串，这样有利于您单独维护这些资源。 此外，您还应该为特定设备配置提供备用资源，方法是将它们分组到专门命名的资源目录中。 在运行时，Android 会根据当前配置使用适当的资源。例如，您可能需要根据屏幕尺寸提供不同的 UI 布局，或者根据语言设置提供不同的字符串。</p><p>外部化应用资源后，即可使用在项目 R 类中生成的资源 ID 访问这些资源。有关如何在应用中使用资源，我们将在访问资源中讨论。 本文档介绍如何对 Android 项目中的资源进行分组，以及如何为特定的设备配置提供备用资源。</p><p>分组资源类型<br>您应将各种资源放入项目 res/ 目录的特定子目录下。例如，以下是一个简单项目的文件层次结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyProject/</span><br><span class="line">    src/  </span><br><span class="line">        MyActivity.java  </span><br><span class="line">    res/</span><br><span class="line">        drawable/  </span><br><span class="line">            graphic.png  </span><br><span class="line">        layout/  </span><br><span class="line">            main.xml</span><br><span class="line">            info.xml</span><br><span class="line">        mipmap/  </span><br><span class="line">            icon.png </span><br><span class="line">        values/  </span><br><span class="line">            strings.xml</span><br></pre></td></tr></table></figure></p><p>正如您在此示例中所看到的那样，res/ 目录包含所有资源（在子目录下）：一个图像资源、两个布局资源、启动器图标的 mipmap/ 目录以及一个字符串资源文件。资源目录名称非常重要，将在表 1 中进行介绍。</p><p>注：如需了解有关使用 mipmap 文件夹的详细信息，请参阅管理项目概览。</p><p>表 1. 项目 res/ 目录内支持的资源目录。</p><p>目录    资源类型<br>animator/    用于定义属性动画的 XML 文件。<br>anim/    定义渐变动画的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 animator/ 目录。）<br>color/    用于定义颜色状态列表的 XML 文件。请参阅颜色状态列表资源<br>drawable/<br>位图文件（.png、.9.png、.jpg、.gif）或编译为以下可绘制对象资源子类型的 XML 文件：</p><p>位图文件<br>九宫格（可调整大小的位图）<br>状态列表<br>形状<br>动画可绘制对象<br>其他可绘制对象<br>请参阅 可绘制对象资源。</p><p>mipmap/    适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 mipmap/ 文件夹管理启动器图标的详细信息，请参阅管理项目概览。<br>layout/    用于定义用户界面布局的 XML 文件。 请参阅布局资源。<br>menu/    用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。请参阅菜单资源。<br>raw/<br>要以原始形式保存的任意文件。要使用原始 InputStream 打开这些资源，请使用资源 ID（即 R.raw.filename）调用 Resources.openRawResource()。</p><p>但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 assets/ 目录下（而不是 res/raw/）。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。</p><p>values/<br>包含字符串、整型数和颜色等简单值的 XML 文件。</p><p>其他 res/ 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而 values/ 目录中的文件可描述多个资源。对于此目录中的文件，<resources> 元素的每个子元素均定义一个资源。例如，<string> 元素创建 R.string 资源，<color> 元素创建 R.color 资源。</color></string></resources></p><p>由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：</p><p>arrays.xml，用于资源数组（类型化数组）。<br>colors.xml：颜色值。<br>dimens.xml：尺寸值。<br>strings.xml：字符串值。<br>styles.xml：样式。<br>请参阅字符串资源、样式资源和更多资源类型。</p><p>xml/    可以在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件（如可搜索配置）都必须保存在此处。<br>注意：切勿将资源文件直接保存在 res/ 目录内，这会导致出现编译错误。</p><p>如需了解有关某些资源类型的详细信息，请参阅资源类型文档。</p><p>保存在表 1 中定义的子目录下的资源是“默认”资源。即，这些资源定义应用的默认设计和内容。但是，采用 Android 技术的不同设备类型可能需要不同类型的资源。例如，如果设备的屏幕尺寸大于标准屏幕，则应提供不同的布局资源，以充分利用额外的屏幕空间。 或者，如果设备的语言设置不同，则应提供不同的字符串资源，以转换用户界面中的文本。 要为不同的设备配置提供这些不同资源，除了默认资源以外，您还需要提供备用资源。</p><p>提供备用资源</p><p>图 1. 两种不同的设备，均使用不同的布局资源。</p><p>几乎每个应用都应提供备用资源以支持特定的设备配置。 例如，对于不同的屏幕密度和语言，您应分别包括备用可绘制对象资源和备用字符串资源。 在运行时，Android 会检测当前设备配置并为应用加载合适的资源。</p><p>为一组资源指定特定于配置的备用资源：</p><p>在 res/ 中创建一个以 &lt;resources_name&gt;-&lt;config_qualifier&gt; 形式命名的新目录。</p><p>&lt;resources_name&gt; 是相应默认资源的目录名称（如表 1 中所定义）。</p><p><qualifier> 是指定要使用这些资源的各个配置的名称（如表 2 中所定义）。<br>您可以追加多个 <qualifier>。以短划线将其分隔。</qualifier></qualifier></p><p>注意：追加多个限定符时，必须按照表 2 中列出的相同顺序放置它们。如果限定符的顺序错误，则该资源将被忽略。</p><p>将相应的备用资源保存在此新目录下。这些资源文件的名称必须与默认资源文件完全一样。<br>例如，以下是一些默认资源和备用资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res/</span><br><span class="line">    drawable/   </span><br><span class="line">        icon.png</span><br><span class="line">        background.png    </span><br><span class="line">    drawable-hdpi/  </span><br><span class="line">        icon.png</span><br><span class="line">        background.png</span><br></pre></td></tr></table></figure></p><p>hdpi 限定符表示该目录中的资源适用于屏幕密度较高的设备。其中每个可绘制对象目录中的图像已针对特定的屏幕密度调整大小，但是文件名完全相同。 这样一来，用于引用 icon.png 或 background.png 图像的资源 ID 始终相同，但是 Android 会通过将设备配置信息与资源目录名称中的限定符进行比较，选择最符合当前设备的各个资源版本。</p><p>Android 支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。表 2 按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。</p><p>表 2. 配置限定符名称。</p><p>配置    限定符值    说明<br>MCC 和 MNC    示例：<br>mcc310<br>mcc310-mnc004<br>mcc208-mnc00<br>等等<br>移动国家代码 (MCC)，（可选）后跟设备 SIM 卡中的移动网络代码 (MNC)。例如，mcc310 是指美国的任一运营商，mcc310-mnc004 是指美国的 Verizon 公司，mcc208-mnc00 是指法国的 Orange 公司。</p><p>如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM 卡。</p><p>也可以单独使用 MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”限定符（稍后进行介绍）。 如果决定使用 MCC 和 MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。</p><p>另请参阅配置字段 mcc 和 mnc，这两个字段分别表示当前的移动国家代码和移动网络代码。</p><p>语言和区域    示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">en</span><br><span class="line">fr</span><br><span class="line">en-rUS</span><br><span class="line">fr-rFR</span><br><span class="line">fr-rCA</span><br><span class="line">等等</span><br></pre></td></tr></table></figure></p><p>语言通过由两个字母组成的 ISO 639-1 语言代码定义，可以选择后跟两个字母组成的 ISO 3166-1-alpha-2 区域码（前带小写字母“r”）。</p><p>这些代码不区分大小写；r 前缀用于区分区域码。 不能单独指定区域。</p><p>如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。</p><p>有关针对其他语言本地化应用的完整指南，请参阅本地化。</p><p>另请参阅 locale 配置字段，该字段表示当前的语言区域。</p><p>布局方向    ldrtl<br>ldltr<br>应用的布局方向。ldrtl 是指“布局方向从右到左”。ldltr 是指“布局方向从左到右”，这是默认的隐式值。</p><p>它适用于布局、图片或值等任何资源。</p><p>例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">res/</span><br><span class="line">    layout/   </span><br><span class="line">        main.xml  (Default layout)</span><br><span class="line">    layout-ar/  </span><br><span class="line">        main.xml  (Specific layout for Arabic)</span><br><span class="line">    layout-ldrtl/  </span><br><span class="line">        main.xml  (Any &quot;right-to-left&quot; language, except</span><br><span class="line">                  for Arabic, because the &quot;ar&quot; language qualifier</span><br><span class="line">                  has a higher precedence.)</span><br></pre></td></tr></table></figure></p><p>注：要为应用启用从右到左的布局功能，必须将 supportsRtl 设置为 “true”，并将 targetSdkVersion 设置为 17 或更高版本。</p><p>此项为 API 级别 17 中新增配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smallestWidthsw&lt;N&gt;dp</span><br></pre></td></tr></table></figure></p><p>示例：<br>sw320dp<br>sw600dp<br>sw720dp<br>等等<br>屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 <n>dp。</n></p><p>例如，如果布局要求屏幕区域的最小尺寸始终至少为 600dp，则可使用此限定符创建布局资源 res/layout-sw600dp/。仅当可用屏幕的最小尺寸至少为 600dp 时，系统才会使用这些资源，而不考虑 600dp 所代表的边是用户所认为的高度还是宽度。smallestWidth 是设备的固定屏幕尺寸特性；设备的 smallestWidth 不会随屏幕方向的变化而改变。</p><p>设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿 smallestWidth 轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。 因此，使用的值应该是布局所需要的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。</p><p>以下是一些可用于普通屏幕尺寸的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">320，适用于屏幕配置如下的设备：</span><br><span class="line">240x320 ldpi（QVGA 手机）</span><br><span class="line">320x480 mdpi（手机）</span><br><span class="line">480x800 hdpi（高密度手机）</span><br><span class="line">480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。</span><br><span class="line">600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。</span><br><span class="line">720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。</span><br><span class="line">应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备 smallestWidth 的值。</span><br></pre></td></tr></table></figure></p><p>此项为 API 级别 13 中新增配置。</p><p>另请参阅 android:requiresSmallestWidthDp 属性和 smallestScreenWidthDp 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。</p><p>如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。</p><p>可用宽度    w<n>dp</n></p><p>示例：<br>w720dp<br>w1024dp<br>等等<br>指定资源应该使用的最小可用屏幕宽度，以 dp 为单位，由 <n> 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。</n></p><p>应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI 元素，考虑到这些 UI 元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。</p><p>此项为 API 级别 13 中新增配置。</p><p>另请参阅 screenWidthDp 配置字段，该字段存放当前屏幕宽度。</p><p>如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。</p><p>可用高度    h<n>dp</n></p><p>示例：<br>h720dp<br>h1024dp<br>等等<br>指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 <n> 值定义。 在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。</n></p><p>应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI 元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。 非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。</p><p>此项为 API 级别 13 中新增配置。</p><p>另请参阅 screenHeightDp 配置字段，该字段存放当前屏幕宽度。</p><p>如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。</p><p>屏幕尺寸    small<br>normal<br>large<br>xlarge<br>small：尺寸类似于低密度 QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp 单位。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。<br>normal：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp 单位。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。<br>large：尺寸类似于中等密度 VGA 屏幕的屏幕。 大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。<br>xlarge：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。 API 级别 9 中的新增配置。<br>注：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。</p><p>注意：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统不会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。</p><p>此项为 API 级别 4 中新增配置。</p><p>如需了解详细信息，请参阅支持多种屏幕。</p><p>另请参阅 screenLayout 配置字段，该字段表示屏幕是小尺寸、标准尺寸还是大尺寸。</p><p>屏幕纵横比    long<br>notlong<br>long：宽屏，如 WQVGA、WVGA、FWVGA<br>notlong：非宽屏，如 QVGA、HVGA 和 VGA<br>此项为 API 级别 4 中新增配置。</p><p>它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。</p><p>另请参阅 screenLayout 配置字段，该字段指示屏幕是否为宽屏。</p><p>圆形屏幕    round<br>notround<br>round：圆形屏幕，例如圆形可穿戴式设备<br>notround：方形屏幕，例如手机或平板电脑<br>此项为 API 级别 23 中新增配置。</p><p>另请参阅 isScreenRound() 配置方法，其指示屏幕是否为宽屏。</p><p>屏幕方向    port<br>land<br>port：设备处于纵向（垂直）<br>land：设备处于横向（水平）<br>如果用户旋转屏幕，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。</p><p>另请参阅 orientation 配置字段，该字段指示当前的设备方向。</p><p>UI 模式    car<br>desk<br>television<br>appliance watch<br>car：设备正在车载手机座上显示<br>desk：设备正在桌面手机座上显示<br>television：设备正在电视上显示，为用户提供“十英尺”体验，其 UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互<br>appliance：设备用作不带显示屏的装置<br>watch：设备配有显示屏，戴在手腕上<br>此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。</p><p>如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读确定并监控插接状态和类型。</p><p>如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。 可以使用 UiModeManager 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。</p><p>夜间模式    night<br>notnight<br>night：夜间<br>notnight：白天<br>此项为 API 级别 8 中新增配置。</p><p>如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。 可以使用 UiModeManager 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。</p><p>屏幕像素密度 (dpi)    ldpi<br>mdpi<br>hdpi<br>xhdpi<br>xxhdpi<br>xxxhdpi<br>nodpi<br>tvdpi<br>anydpi<br>ldpi：低密度屏幕；约为 120dpi。<br>mdpi：中等密度（传统 HVGA）屏幕；约为 160dpi。<br>hdpi：高密度屏幕；约为 240dpi。<br>xhdpi：超高密度屏幕；约为 320dpi。此项为 API 级别 8 中新增配置<br>xxhdpi：超超高密度屏幕；约为 480dpi。此项为 API 级别 16 中新增配置<br>xxxhdpi：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多种屏幕”中的注释）；约为 640dpi。 此项为 API 级别 18 中新增配置<br>nodpi：它可用于您不希望缩放以匹配设备密度的位图资源。<br>tvdpi：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组， 主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行缩放。此项为 API 级别 13 中新增配置<br>anydpi：此限定符适合所有屏幕密度，其优先级高于其他限定符。 这对于矢量可绘制对象很有用。 此项为 API 级别 21 中新增配置<br>六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略 tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为 1.33*mdpi。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。</span><br><span class="line"></span><br><span class="line">注：使用密度限定符并不表示资源仅适用于该密度的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。</span><br></pre></td></tr></table></figure></p><p>如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅支持多种屏幕。</p><p>触摸屏类型    notouch<br>finger<br>notouch：设备没有触摸屏。<br>finger：设备有一个专供用户通过手指直接与其交互的触摸屏。<br>另请参阅 touchscreen 配置字段，该字段指示设备上的触摸屏类型。</p><p>键盘可用性    keysexposed<br>keyshidden<br>keyssoft<br>keysexposed：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。 如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。<br>keyshidden：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。<br>keyssoft：设备已经启用软键盘（无论是否可见）。<br>如果提供了 keysexposed 资源，但未提供 keyssoft 资源，那么只要系统已经启用软键盘，就会使用 keysexposed 资源，而不考虑键盘是否可见。</p><p>如果用户打开硬键盘，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。</p><p>另请参阅配置字段 hardKeyboardHidden 和 keyboardHidden，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。</p><p>主要文本输入法    nokeys<br>qwerty<br>12key<br>nokeys：设备没有用于文本输入的硬按键。<br>qwerty：设备具有标准硬键盘（无论是否对用户可见）。<br>12key：设备具有 12 键硬键盘（无论是否对用户可见）。<br>另请参阅 keyboard 配置字段，该字段指示可用的主要文本输入法。</p><p>导航键可用性    navexposed<br>navhidden<br>navexposed：导航键可供用户使用。<br>navhidden：导航键不可用（例如，位于密封盖子后面）。<br>如果用户显示导航键，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。</p><p>另请参阅 navigationHidden 配置字段，该字段指示导航键是否处于隐藏状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主要非触摸导航方法nonav</span><br><span class="line">dpad</span><br><span class="line">trackball</span><br><span class="line">wheel</span><br><span class="line">nonav：除了使用触摸屏以外，设备没有其他导航设施。</span><br><span class="line">dpad：设备具有用于导航的方向键。</span><br><span class="line">trackball：设备具有用于导航的轨迹球。</span><br><span class="line">wheel：设备具有用于导航的方向盘（不常见）。</span><br><span class="line">另请参阅 navigation 配置字段，该字段指示可用的导航方法类型。</span><br></pre></td></tr></table></figure></p><p>平台版本（API 级别）    示例：<br>v3<br>v4<br>v7<br>等等<br>设备支持的 API 级别。例如，v1 对应于 API 级别 1（带有 Android 1.0 或更高版本系统的设备），v4 对应于 API 级别 4（带有 Android 1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅 Android API 级别文档。</p><p>注：有些配置限定符是从 Android 1.0 才开始添加，因此并非所有版本的 Android 系统都支持所有限定符。使用新限定符会隐式添加平台版本限定符，因此较旧版本系统的设备必然会忽略它。 例如，使用 w600dp 限定符会自动包括 v13 限定符，因为可用宽度限定符是 API 级别 13 中的新增配置。为了避免出现任何问题，请始终包含一组默认资源（一组“不带限定符”的资源）。 如需了解详细信息，请参阅利用资源提供最佳设备兼容性部分。</p><p>限定符命名规则<br>以下是一些关于使用配置限定符名称的规则：</p><p>您可以为单组资源指定多个限定符，并使用短划线分隔。例如，drawable-en-rUS-land 适用于横排美国英语设备。<br>这些限定符必须遵循表 2 中列出的顺序。例如：<br>错误：drawable-hdpi-port/<br>正确：drawable-port-hdpi/<br>不能嵌套备用资源目录。例如，您不能拥有 res/drawable/drawable-en/。<br>值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。<br>对于每种限定符类型，仅支持一个值。例如，若要对西班牙语和法语使用相同的可绘制对象文件，则您肯定不能拥有名为 drawable-rES-rFR/ 的目录，而是需要两个包含相应文件的资源目录，如 drawable-rES/ 和 drawable-rFR/。然而，实际上您无需将相同的文件都复制到这两个位置。相反，您可以创建指向资源的别名。 请参阅下面的创建别名资源。<br>将备用资源保存到以这些限定符命名的目录中之后，Android 会根据当前设备配置在应用中自动应用这些资源。 每次请求资源时，Android 都会检查备用资源目录是否包含所请求的资源文件，然后查找最佳匹配资源（下文进行介绍）。 如果没有与特定设备配置匹配的备用资源，则 Android 会使用相应的默认资源（一组用于不含配置限定符的特定资源类型的资源）。</p><p>创建别名资源<br>如果您想将某一资源用于多种设备配置（但是不想作为默认资源提供），则无需将同一资源放入多个备用资源目录中。 相反，您可以（在某些情况下）创建备用资源，充当保存在默认资源目录下的资源的别名。</p><p>注：并非所有资源都会提供相应机制让您创建指向其他资源的别名。 特别是，xml/ 目录中的动画资源、菜单资源、原始资源以及其他未指定资源均不提供此功能。</p><p>例如，假设您有一个应用图标 icon.png，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，您可以将用于二者的图像另存为 icon_ca.png（除 icon.png 以外的任何名称），并将其放入默认 res/drawable/ 目录中。然后，在 res/drawable-en-rCA/ 和 res/drawable-fr-rCA/ 中创建 icon.xml 文件，使用 <bitmap> 元素引用 icon_ca.png 资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。）</bitmap></p><p>可绘制对象<br>要创建指向现有可绘制对象的别名，请使用 <bitmap> 元素。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:src=&quot;@drawable/icon_ca&quot; /&gt;</span><br></pre></td></tr></table></figure></bitmap></p><p>如果将此文件另存为 icon.xml（例如，在备用资源目录中，另存为 res/drawable-en-rCA/），则会编译到可作为 R.drawable.icon 引用的资源中，但实际上它是 R.drawable.icon_ca 资源（保存在 res/drawable/ 中）的别名。</p><p>布局<br>要创建指向现有布局的别名，请使用包装在 <merge> 中的 <include> 元素。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;merge&gt;</span><br><span class="line">    &lt;include layout=&quot;@layout/main_ltr&quot;/&gt;</span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure></include></merge></p><p>如果将此文件另存为 main.xml，则会编译到可作为 R.layout.main 引用的资源中，但实际上它是 R.layout.main_ltr 资源的别名。</p><p>字符串和其他简单值<br>要创建指向现有字符串的别名，只需将所需字符串的资源 ID 用作新字符串的值即可。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string name=&quot;hello&quot;&gt;Hello&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;hi&quot;&gt;@string/hello&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br><span class="line">R.string.hi 资源现在是 R.string.hello 的别名。</span><br></pre></td></tr></table></figure></p><p>其他简单值的原理相同。 例如，颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;color name=&quot;red&quot;&gt;#f00&lt;/color&gt;</span><br><span class="line">    &lt;color name=&quot;highlight&quot;&gt;@color/red&lt;/color&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p><p>利用资源提供最佳设备兼容性<br>要使应用支持多种设备配置，则务必为应用使用的每种资源类型提供默认资源，这一点非常重要。</p><p>例如，如果应用支持多种语言，请始终包含不带语言和区域限定符的 values/ 目录（用于保存字符串）。相反，如果您将所有字符串放入带有语言和区域限定符的目录中，则在语言设置不支持您的字符串的设备上运行应用时，应用将会崩溃。 但是，只要提供默认 values/ 资源，应用就会正常运行（即使用户不理解该语言，这也总比崩溃要好）。</p><p>同样，如果您根据屏幕方向提供不同的布局资源，则应选择一个方向作为默认方向。 例如，不要在 layout-land/ 和 layout-port/ 中分别提供横向和纵向的布局资源，而是保留其中之一作为默认设置，例如：layout/ 用于横向，layout-port/ 用于纵向。</p><p>提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 minSdkVersion 设置为 4，并使用夜间模式（night 或 notnight，API 级别 8 中新增配置）限定所有可绘制对象资源，则 API 级别 4 设备无法访问可绘制对象资源，而且会崩溃。在这种情况下，您可能希望 notnight 成为默认资源，为此，您应排除该限定符，使可绘制对象资源位于 drawable/ 或 drawable-night/ 中。</p><p>因此，为了提供最佳设备兼容性，请始终为应用正确运行所必需的资源提供默认资源。 然后，使用配置限定符为特定的设备配置创建备用资源。</p><p>这条规则有一个例外：如果应用的 minSdkVersion 为 4 或更高版本，则在提供带屏幕密度限定符的备用可绘制对象资源时，不需要默认可绘制对象资源。 即使没有默认可绘制对象资源，Android 也可以从备用屏幕密度中找到最佳匹配项并根据需要缩放位图。 但是，为了在所有类型的设备上提供最佳体验，您应该为所有三种类型的密度提供备用可绘制对象。</p><p>Android 如何查找最佳匹配资源<br>当您请求要为其提供备用资源的资源时，Android 会根据当前的设备配置选择要在运行时使用的备用资源。为演示 Android 如何选择备用资源，假设以下可绘制对象目录分别包含相同图像的不同版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">drawable/</span><br><span class="line">drawable-en/</span><br><span class="line">drawable-fr-rCA/</span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-12key/</span><br><span class="line">drawable-port-ldpi/</span><br><span class="line">drawable-port-notouch-12key/</span><br><span class="line">同时，假设设备配置如下：</span><br></pre></td></tr></table></figure></p><p>语言区域 = en-GB<br>屏幕方向 = port<br>屏幕像素密度 = hdpi<br>触摸屏类型 = notouch<br>主要文本输入法 = 12key</p><p>通过将设备配置与可用的备用资源进行比较，Android 从 drawable-en-port 中选择可绘制对象。</p><p>系统使用以下逻辑决定要使用的资源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">图 2. Android 如何查找最佳匹配资源的流程图。</span><br><span class="line"></span><br><span class="line">淘汰与设备配置冲突的资源文件。</span><br><span class="line">drawable-fr-rCA/ 目录与 en-GB 语言区域冲突，因而被淘汰。</span><br><span class="line"></span><br><span class="line">drawable/</span><br><span class="line">drawable-en/</span><br><span class="line">drawable-fr-rCA/</span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-12key/</span><br><span class="line">drawable-port-ldpi/</span><br><span class="line">drawable-port-notouch-12key/</span><br></pre></td></tr></table></figure><p>例外：屏幕像素密度是唯一一个未因冲突而被淘汰的限定符。 尽管设备的屏幕密度为 hdpi，但是 drawable-port-ldpi/ 未被淘汰，因为此时每个屏幕密度均视为匹配。如需了解详细信息，请参阅支持多种屏幕文档。</p><p>选择列表（表 2）中（下一个）优先级最高的限定符。（先从 MCC 开始，然后下移。）<br>是否有资源目录包括此限定符？<br>若无，请返回到第 2 步，看看下一个限定符。（在该示例中，除非达到语言限定符，否则答案始终为“否”。）<br>若有，请继续执行第 4 步。<br>淘汰不含此限定符的资源目录。在该示例中，系统会淘汰所有不含语言限定符的目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drawable/</span><br><span class="line">drawable-en/</span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-12key/</span><br><span class="line">drawable-port-ldpi/</span><br><span class="line">drawable-port-notouch-12key/</span><br></pre></td></tr></table></figure></p><p>例外：如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅支持多种屏幕。</p><p>返回并重复第 2 步、第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被淘汰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drawable-en/</span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-12key/</span><br><span class="line">剩下的目录是 drawable-en-port。</span><br></pre></td></tr></table></figure></p><p>尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中（不过，仍会将不带语言限定符的资源目录包含在该池中）。</p><p>根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统不会使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。</p><p>注：限定符的优先顺序（表 2 中）比与设备完全匹配的限定符数量更加重要。例如，在上面的第 4 步中，列表剩下的最后选项包括三个与设备完全匹配的限定符（方向、触摸屏类型和输入法），而 drawable-en 只有一个匹配参数（语言）。但是，语言的优先顺序高于其他两个限定符，因此 drawable-port-notouch-12key 被淘汰。</p><p>如需了解有关如何在应用中使用资源的更多信息，请转至访问资源。</p><p>处理运行时变更<br>有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。 发生这种变化时，Android 会重启正在运行的 Activity（先后调用 onDestroy() 和 onCreate()）。重启行为旨在通过利用与新设备配置匹配的备用资源自动重新加载您的应用，来帮助它适应新配置。</p><p>要妥善处理重启行为，Activity 必须通过常规的Activity 生命周期恢复其以前的状态，在 Activity 生命周期中，Android 会在销毁 Activity 之前调用 onSaveInstanceState()，以便您保存有关应用状态的数据。 然后，您可以在 onCreate() 或 onRestoreInstanceState() 期间恢复 Activity 状态。</p><p>要测试应用能否在保持应用状态完好的情况下自行重启，您应该在应用中执行各种任务时调用配置变更（例如，更改屏幕方向）。 您的应用应该能够在不丢失用户数据或状态的情况下随时重启，以便处理如下事件：配置发生变化，或者用户收到来电并在应用进程被销毁很久之后返回到应用。 要了解如何恢复 Activity 状态，请阅读 Activity 生命周期。</p><p>但是，您可能会遇到这种情况：重启应用并恢复大量数据不仅成本高昂，而且给用户留下糟糕的使用体验。 在这种情况下，您有两个其他选择：</p><p>在配置变更期间保留对象<br>允许 Activity 在配置变更时重启，但是要将有状态对象传递给 Activity 的新实例。</p><h2 id="自行处理配置变更"><a href="#自行处理配置变更" class="headerlink" title="自行处理配置变更"></a>自行处理配置变更</h2><p>阻止系统在某些配置变更期间重启 Activity，但要在配置确实发生变化时接收回调，这样，您就能够根据需要手动更新 Activity。</p><p>在配置变更期间保留对象<br>如果重启 Activity 需要恢复大量数据、重新建立网络连接或执行其他密集操作，那么因配置变更而引起的完全重启可能会给用户留下应用运行缓慢的体验。 此外，依靠系统通过onSaveInstanceState() 回调为您保存的 Bundle，可能无法完全恢复 Activity 状态，因为它并非设计用于携带大型对象（例如位图），而且其中的数据必须先序列化，再进行反序列化，这可能会消耗大量内存并使得配置变更速度缓慢。 在这种情况下，如果 Activity 因配置变更而重启，则可通过保留 Fragment 来减轻重新初始化 Activity 的负担。此片段可能包含对您要保留的有状态对象的引用。</p><p>当 Android 系统因配置变更而关闭 Activity 时，不会销毁您已标记为要保留的 Activity 的片段。 您可以将此类片段添加到 Activity 以保留有状态的对象。</p><p>要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作：</p><p>扩展 Fragment 类并声明对有状态对象的引用。<br>在创建片段后调用 setRetainInstance(boolean)。<br>将片段添加到 Activity。<br>重启 Activity 后，使用 FragmentManager 检索片段。<br>例如，按如下方式定义片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RetainedFragment extends Fragment &#123;</span><br><span class="line"></span><br><span class="line">    // data object we want to retain</span><br><span class="line">    private MyDataObject data;</span><br><span class="line"></span><br><span class="line">    // this method is only called once for this fragment</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        // retain this fragment</span><br><span class="line">        setRetainInstance(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(MyDataObject data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyDataObject getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：尽管您可以存储任何对象，但是切勿传递与 Activity 绑定的对象，例如，Drawable、Adapter、View 或其他任何与 Context 关联的对象。否则，它将泄漏原始 Activity 实例的所有视图和资源。 （泄漏资源意味着应用将继续持有这些资源，但是无法对其进行垃圾回收，因此可能会丢失大量内存。）</p><p>然后，使用 FragmentManager 将片段添加到 Activity。在运行时配置变更期间再次启动 Activity 时，您可以获得片段中的数据对象。 例如，按如下方式定义 Activity：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MyActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private RetainedFragment dataFragment;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line"></span><br><span class="line">        // find the retained fragment on activity restarts</span><br><span class="line">        FragmentManager fm = getFragmentManager();</span><br><span class="line">        dataFragment = (DataFragment) fm.findFragmentByTag(“data”);</span><br><span class="line"></span><br><span class="line">        // create the fragment and data the first time</span><br><span class="line">        if (dataFragment == null) &#123;</span><br><span class="line">            // add the fragment</span><br><span class="line">            dataFragment = new DataFragment();</span><br><span class="line">            fm.beginTransaction().add(dataFragment, “data”).commit();</span><br><span class="line">            // load the data from the web</span><br><span class="line">            dataFragment.setData(loadMyData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // the data is available in dataFragment.getData()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        // store the data in the fragment</span><br><span class="line">        dataFragment.setData(collectMyLoadedData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在此示例中，onCreate() 添加了一个片段或恢复了对它的引用。此外，onCreate() 还将有状态的对象存储在片段实例内部。onDestroy() 对所保留的片段实例内的有状态对象进行更新。</p><p>自行处理配置变更<br>如果应用在特定配置变更期间无需更新资源，并且因性能限制您需要尽量避免重启，则可声明 Activity 将自行处理配置变更，这样可以阻止系统重启 Activity。</p><p>注：自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源。 只能在您必须避免 Activity 因配置变更而重启这一万般无奈的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并不建议使用此方法。</p><p>要声明由 Activity 处理配置变更，请在清单文件中编辑相应的 <activity> 元素，以包含 android:configChanges 属性以及代表要处理的配置的值。android:configChanges 属性的文档中列出了该属性的可能值（最常用的值包括 “orientation” 和 “keyboardHidden”，分别用于避免因屏幕方向和可用键盘改变而导致重启）。您可以在该属性中声明多个配置值，方法是用管道 | 字符分隔这些配置值。</activity></p><p>例如，以下清单文件代码声明的 Activity 可同时处理屏幕方向变更和键盘可用性变更：</p><activity android:name=".MyActivity" android:configchanges="orientation|keyboardHidden" android:label="@string/app_name">    <p>现在，当其中一个配置发生变化时，MyActivity 不会重启。相反，MyActivity 会收到对 onConfigurationChanged() 的调用。向此方法传递 Configuration 对象指定新设备配置。您可以通过读取 Configuration 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的 Resources 对象会相应地进行更新，以根据新配置返回资源，这样，您就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。</p><p>注意：从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本（正如 minSdkVersion 和 targetSdkVersion 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 “orientation” 值以外，您还必须添加 “screenSize” 值。 也就是说，您必须声明 android:configChanges=”orientation|screenSize”。但是，如果您的应用面向 API 级别 12 或更低版本，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重启 Activity）。</p><p>例如，以下 onConfigurationChanged() 实现检查当前设备方向：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onConfigurationChanged(Configuration newConfig) &#123;</span><br><span class="line">   super.onConfigurationChanged(newConfig);</span><br><span class="line">   // Checks the orientation of the screen</span><br><span class="line">   if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">   Toast.makeText(this, &quot;landscape&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">   &#125; else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)&#123;</span><br><span class="line">   Toast.makeText(this, &quot;portrait&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Configuration 对象代表所有当前配置，而不仅仅是已经变更的配置。大多数时候，您并不在意配置具体发生了哪些变更，而且您可以轻松地重新分配所有资源，为您正在处理的配置提供备用资源。 例如，由于 Resources 对象现已更新，因此您可以通过 setImageResource() 重置任何 ImageView，并且使用适合于新配置的资源（如提供资源中所述）。</p><p>请注意，Configuration 字段中的值是与 Configuration 类中的特定常量匹配的整型数。有关要对每个字段使用哪些常量的文档，请参阅 Configuration 参考文档中的相应字段。</p><p>请谨记：在声明由 Activity 处理配置变更时，您有责任重置要为其提供备用资源的所有元素。 如果您声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 onConfigurationChanged() 期间将每个资源重新分配给每个元素。</p><p>如果无需基于这些配置变更更新应用，则可不用实现 onConfigurationChanged()。在这种情况下，仍将使用在配置变更之前用到的所有资源，只是您无需重启 Activity。 但是，应用应该始终能够在保持之前状态完好的情况下关闭和重启，因此您不得试图通过此方法来逃避在正常 Activity 生命周期期间保持您的应用状态。 这不仅仅是因为还存在其他一些无法禁止重启应用的配置变更，还因为有些事件必须由您处理，例如用户离开应用，而在用户返回应用之前该应用已被销毁。</p><p>如需了解有关您可以在 Activity 中处理哪些配置变更的详细信息，请参阅 android:configChanges 文档和 Configuration 类。</p><h2 id="本地化您的应用"><a href="#本地化您的应用" class="headerlink" title="本地化您的应用"></a>本地化您的应用</h2><p>Android可在许多地区的许多设备上运行。为了覆盖大多数用户，您的应用应以适合使用您的应用的区域设置的方式处理文本，音频文件，数字，货币和图形。</p><p>本文档介绍了本地化Android应用的最佳做法。</p><p>您应具备Java编程语言的工作知识，熟悉Android资源加载，XML中用户界面元素的 声明，活动生命周期等开发注意事项以及国际化和本地化的一般原则。</p><p>尽量使用Android资源框架将应用程序的本地化方面与核心的基于Java的功能分开，这是一个很好的做法：</p><p>您可以将应用程序用户界面的大部分或全部内容放入资源文件中，如本文档和 提供资源中所述。<br>另一方面，用户界面的行为是由基于Java的代码驱动的。例如，如果用户根据语言环境输入需要格式化或排序不同的数据，则可以使用Java编程语言以编程方式处理数据。本文档不包括如何本地化您的基于Java的代码。<br>有关在您的应用中本地化字符串的简短指南，请参阅培训课程， 支持不同的语言。</p><p>概述：Android中的资源切换<br>资源是文本字符串，布局，声音，图形以及您的Android应用所需的任何其他静态数据。应用程序可以包含多组资源，每组资源都针对不同的设备配置进行了自定义。当用户运行应用程序时，Android会自动选择并加载与设备最匹配的资源。</p><p>（本文档重点介绍本地化和区域设置，有关资源切换和您可以指定的所有配置类型（屏幕方向，触摸屏类型等）的完整说明，请参阅 提供替代资源。</p><p>当您编写应用程序时，可以为您的应用程序创建默认和替代资源以供使用。当用户运行您的应用时，Android系统会根据设备的区域设置选择要加载的资源。要创建资源，请将文件放置在项目res/目录的特定子目录中。</p><p>为什么默认资源很重要<br>每当应用程序在您未提供区域设置特定文本的语言环境中运行时，Android会从中加载默认字符串 res/values/strings.xml。如果此缺省文件不存在，或者缺少应用程序需要的字符串，那么您的应用程序不会运行并显示错误。下面的例子说明了默认文本文件不完整时会发生什么。</p><p>例：</p><p>应用程序的基于Java的代码仅涉及两个字符串，text_a 而且text_b。这个程序包括一个本地化的资源文件（res/values-en/strings.xml定义）text_a和 text_b英语。此应用程序还包含一个默认资源文件（res/values/strings.xml），其中包含一个定义text_a，但不包括text_b：</p><p>当此应用在设置为英语的语言环境设备上启动时，该应用可能无问题地运行，因为它 res/values-en/strings.xml包含两个所需的文本字符串。<br>但是，如果在设置为英语以外的语言的设备上启动此应用程序，用户将看到错误消息和强制关闭按钮。该应用程序无法加载。<br>为防止出现这种情况，请确保res/values/strings.xml 文件存在，并确定每个需要的字符串。这种情况适用于所有类型的资源，而不仅仅是字符串：您需要创建一组默认资源文件，其中包含应用程序调用的所有资源 - 布局，可绘制，动画等。有关测试的信息，请参阅 测试默认值资源。</p><p>使用资源进行本地化<br>如何创建默认资源<br>将应用程序的默认文本放入 res/values/strings.xml。</p><p>文本字符串res/values/strings.xml应使用默认语言，这是您希望大多数应用用户说话的语言。</p><p>默认资源集还必须包含任何默认的可绘制和布局，并且可以包含其他类型的资源，如动画：</p><p>res/drawable/（必需的目录至少保存一个图形文件，用于Google Play上应用的图标）<br>res/layout/ （需要保存定义默认布局的XML文件的目录）<br>res/anim/（如果您有任何 文件夹，则需要）res/anim-<qualifiers><br>res/xml/（如果您有任何 文件夹，则需要）res/xml-<qualifiers><br>res/raw/（如果您有任何 文件夹，则需要）res/raw-<qualifiers><br>提示：在您的代码中，检查每个对Android资源的引用。确保为每个资源定义了一个默认资源。还要确保默认的字符串文件是完整的：本地化的 字符串文件可以包含字符串的一个子集，但是默认的字符串文件必须包含它们全部。</qualifiers></qualifiers></qualifiers></p><p>如何创建替代资源<br>本地化应用程序的很大一部分是为不同语言提供替代文本。在某些情况下，您还可以提供其他图形，声音，布局和其他特定于语言环境的资源。</p><p>应用程序可以指定许多 目录，每个目录都有不同的限定符。要为不同的区域设置创建替代资源，请使用指定语言或语言区域组合的限定符。（资源目录的名称必须符合Provide Alternative Resources中所述的命名方案 ，否则您的应用程序无法编译。）res/<qualifiers>/</qualifiers></p><p>例：</p><p>假设你的应用的默认语言是英文。假设您还想将应用中的所有文本本地化为法文，并将您应用中的大部分文本（除应用标题外的所有文本）本地化为日文。在这种情况下，您可以创建三个备选strings.xml 文件，每个文件都存储在特定于语言环境的资源目录中：</p><p>res/values/strings.xml<br>包含应用程序使用的所有字符串的英文文本，包括名为字符串的文本title。<br>res/values-fr/strings.xml<br>包含所有字符串的法文文本，包括title。<br>res/values-ja/strings.xml<br>包含所有字符串除外的 日文文本title。<br>如果您的基于Java的代码引用R.string.title，那么在运行时会发生以下情况：</p><p>如果设备设置为法语以外的任何语言，则Android会title从该res/values/strings.xml文件加载 。<br>如果设备设置为法语，则Android会title从该 res/values-fr/strings.xml文件加载。<br>请注意，如果设备设置为日语，Android会title在res/values-ja/strings.xml文件中查找 。但是由于该文件中不包含此类字符串，Android会回退到默认值，并title从res/values/strings.xml文件加载英文 。</p><p>哪些资源优先？<br>如果多个资源文件与设备的配置相匹配，则Android会根据一组规则来决定要使用哪个文件。在可以在资源目录名称中指定的限定符中，语言环境几乎总是优先。</p><p>例：</p><p>假设一个应用程序包含一组默认图形和另外两组图形，每个图形均针对不同的设备设置进行了优化：</p><p>res/drawable/<br>包含默认图形。<br>res/drawable-small-land-stylus/<br>包含经过优化的图形，用于预期来自手写笔输入的设备，并且具有横向方向的QVGA低密度屏幕。<br>res/drawable-ja/<br>包含针对日语使用而优化的图形。<br>如果应用程序在配置为使用日语的设备上运行，则Android会加载图形res/drawable-ja/，即使该设备恰好是需要从触控笔输入的设备，并且横向上具有QVGA低密度屏幕。</p><p>例外：在选择过程中唯一的优先于区域设置的限定符是MCC和MNC（移动国家代码和移动网络代码）。</p><p>例：</p><p>假设您有以下情况：</p><p>应用程序代码要求 R.string.text_a<br>有两个相关的资源文件可用：<br>res/values-mcc404/strings.xml，其中包含 text_a应用的默认语言，在这种情况下为英文。<br>res/values-hi/strings.xml，其中包括 text_a印地文。<br>该应用程序在具有以下配置的设备上运行：<br>SIM卡连接到印度的移动网络（MCC 404）。<br>语言设置为Hindi（hi）。<br>即使设备配置为印地语，Android 也会text_a从 res/values-mcc404/strings.xml（英语）加载。这是因为在资源选择过程中，Android更喜欢MCC匹配的语言匹配。</p><p>选择过程并不总是像这些例子所表明的那样简单。请阅读Android如何找到最佳匹配资源，以获取更详细的流程描述。所有的限定符都按照提供替代资源表2中的优先顺序进行了描述和列出。</p><p>参考代码中的资源<br>在您的应用程序的基于Java的代码中，您可以使用语法 或 。 有关更多信息，请参阅访问资源。R.resource_type.resource_nameandroid.R.resource_type.resource_name</p><p>管理本地化字符串<br>将所有字符串移动到strings.xml中<br>在构建应用程序时，不要硬编码任何字符串。相反，将所有字符串声明为默认strings.xml文件中的资源，这使得更新和本地化变得容易。strings.xml然后可以轻松提取，翻译文件中的字符串并将其集成到应用程序中（具有适当的限定符），而不会对编译代码进行任何更改。</p><p>如果您使用文本生成图像，请将这些字符串放入strings.xml，并在翻译后重新生成图像。</p><p>遵循Android用户界面字符串指南<br>当你设计和开发的用户界面，请确保您密切关注如何你跟你的用户。一般来说，使用简洁且简洁的简洁压缩样式，并在整个UI中使用一致的样式。</p><p>确保您阅读并遵循材料设计建议书写风格和文字选择。这样做可以让您的应用看起来更加精美，并帮助用户更快地理解您的用户界面。</p><p>此外，尽可能使用Android标准术语，例如操作栏，选项菜单，系统栏，通知等UI元素。正确和一致地使用Android术语可以使翻译更轻松，并为用户带来更好的最终产品。</p><p>为声明字符串提供足够的上下文<br>在您的strings.xml文件中声明字符串时，请确保描述使用字符串的上下文。这些信息对翻译非常重要，并可以提高翻译质量。它还可以帮助您更有效地管理您的字符串。</p><p>这里是一个例子：</p><p>&lt;！ - 提交表单的动作。此文本位于可放置30个字符的按钮上 - &gt; <string name="“login_submit_button”"> 登录&lt;/ string&gt;</string></p><p>考虑提供上下文信息，其中可能包括：</p><p>这是什么字符串？何时何地呈现给用户？<br>这是在布局？例如，按钮中的翻译比文本框中的翻译更不灵活。<br>标记不应该翻译的消息部分<br>字符串常常包含不应该翻译成其他语言的文本。常见示例可能是一段代码，一个值的占位符，一个特殊符号或名称。在准备翻译字符串时，请查找并标记应保持原样的文本，而无需翻译，以便翻译人员不会更改它。</p><p>要标记不应翻译的文本，请使用<a href="xliff:g" target="_blank" rel="noopener">xliff:g</a> 占位符标记。下面是一个示例标签，可确保在翻译过程中文本“％1 $ s”不会更改（否则可能会中断该消息）：</p><p><string name="“countdown”"> &lt;xliff：g id = “time” example = “5 days” &gt; ％1 $ s &lt;/ xliff：g&gt; until holiday &lt;/ string&gt; </string></p><p>当您声明占位符标记时，请始终添加一个id属性，以说明占位符的用途。如果您的应用程序稍后替换了占位符值，请确保提供示例属性以阐明预期用途。</p><p>以下是一些占位符标签的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources xmlns：xliff = “urn：oasis：names：tc：xliff：document：1.2” &gt; &lt;！ - 一个特殊的unicode符号的示例占位符 - &gt; &lt;string name = “star_rating” &gt; 查看我们的5 &lt;xliff ：摹ID = “明星” &gt; \ u2605 &lt;/ XLIFF：g&gt;的&lt;/字符串&gt; &lt;！ -示例占位符一个一个网址- &gt; &lt;字符串名称= “app_homeurl” &gt;     请访问我们的&lt;XLIFF：摹ID = “application_homepage” &gt; http：//my/app/home.html &lt;/ xliff：g&gt;&lt;/字符串&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;！ - 名称示例占位符 - &gt; &lt;string name = “prod_name” &gt;     在&lt;xliff：g id = “prod_gamegroup” &gt; Game Group &lt;/ xliff：g&gt; &lt;/ string&gt; &lt;！ - placeholder for a literal  - &gt; &lt;string name = “promo_message” &gt;     请使用“ &lt;xliff：g id = ”promotion_code“ &gt; ABCDEFG &lt;/ xliff：g&gt; ”来获得折扣。&lt;/ string&gt; ... &lt;/ resources&gt;</span><br></pre></td></tr></table></figure><p>本地化清单<br>有关本地化和分发Android应用程序的完整概述，请参阅本地化核对表文档。</p><p>本地化提示<br>设计您的应用程序以在任何语言环境中工作<br>您不能假设用户运行您的应用的设备。该设备可能具有您未预期的硬件，或者可能设置为您不打算或者无法测试的语言环境。设计您的应用程序，使其正常运行或无论其运行在哪个设备上都会优雅地失败。</p><p>重要提示：确保您的应用包含一整套默认资源。</p><p>确保包含 res/drawable/和res/values/文件夹（文件夹名称中没有任何其他修饰符），其中包含您的应用程序需要的所有图像和文本。</p><p>如果某个应用程序即使缺少一个默认资源，也不会在设置为不受支持的区域设置的设备上运行。例如， res/values/strings.xml默认文件可能缺少应用程序需要的一个字符串：当应用程序在不支持的语言环境中运行并尝试加载时res/values/strings.xml，用户会看到一条错误消息和一个强制关闭按钮。</p><p>有关更多信息，请参阅测试默认资源。</p><p>设计灵活的布局<br>如果您需要重新排列布局以适合特定语言（例如，德语的长词），则可以为该语言创建替代布局（例如res/layout-de/main.xml）。但是，这样做可能会让您的应用难以维护。最好创建一个更灵活的单一布局。</p><p>另一种典型情况是需要不同布局的语言。例如，您可能有一个联系表单，当应用程序以日语运行时应该包含两个名称字段，而当应用程序以其他语言运行时，应该包含三个名称字段。您可以通过以下两种方式之一处理：</p><p>根据语言或者可以编程启用或禁用的字段创建一个布局<br>主布局包含另一个包含可更改字段的布局。第二个布局可以针对不同的语言有不同的配置。<br>避免创建比您需要更多的资源文件和文本字符串<br>您可能不需要为应用中的每个资源创建特定于语言环境的替代方案。例如，res/layout/main.xml文件中定义的布局 可能在任何语言环境中工作，在这种情况下，不需要创建任何替代布局文件。</p><p>另外，您可能不需要为每个字符串创建替代文本。例如，假设如下：</p><p>您应用的默认语言是美式英语。应用程序使用的每个字符串都是使用美国英语拼写定义的 res/values/strings.xml。<br>对于一些重要的短语，你想提供英式英语拼写。当您的应用在英国的设备上运行时，您希望使用这些替代字符串。<br>为此，您可以创建一个名为的小文件 res/values-en-rGB/strings.xml，其中仅包含应用程序在英国运行时应该不同的字符串。对于所有其他字符串，应用程序将回退到默认值并使用其中定义的内容res/values/strings.xml。</p><p>使用Android Context对象进行手动区域设置查找<br>您可以使用ContextAndroid提供的对象查找语言环境：</p><p>字符串区域设置= 上下文。getResources （）。getConfiguration （）。区域设置。getDisplayName （）;<br>使用应用翻译服务<br>该应用翻译服务被整合到游戏控制台，它也是从访问Android的工作室。这是一种快速简便的方式，可以即时报价并向翻译公司下订单。您可以为应用UI字符串，Play商品详情文本，IAP名称和广告活动文本订购翻译为一种或多种语言。</p><p>测试本地化应用<br>在设备上测试<br>请记住，您正在测试的设备可能与其他地区的消费者可用的设备有很大不同。您设备上可用的区域设置可能与其他设备上可用的区域设置不同。此外，设备屏幕的分辨率和密度可能会有所不同，这可能会影响UI中字符串和绘图的显示。</p><p>要更改设备上的区域设置或语言，请使用设置应用程序。</p><p>在模拟器上测试<br>有关使用模拟器的详细信息，请参阅Android模拟器。</p><p>创建和使用自定义区域设置<br>“自定义”区域设置是Android系统图像未明确支持的语言/区域组合。您可以通过在模拟器中创建自定义语言环境来测试应用程序在自定义语言环境中的运行方式。有两种方法可以做到这一点：</p><p>使用可从应用程序选项卡访问的自定义区域设置应用程序。（创建自定义区域设置后，通过按住区域名称来切换到该区域。）<br>如下所述，从adb shell更改为自定义区域设置。<br>当您将模拟器设置为Android系统映像中不可用的语言环境时，系统本身将以其默认语言显示。但是，您的应用应该正确定位。</p><p>从adb shell更改模拟器语言环境<br>通过使用adb shell来更改模拟器中的区域设置。</p><p>选择您想要测试的地区并确定其BCP-47语言标签，例如，加拿大法语将是fr-CA。<br>启动一个模拟器。<br>从主机上的命令行shell中运行以下命令：<br>adb shell<br>或者如果您连接了设备，请通过添加以下-e选项来指定您希望仿真器：<br>adb -e shell<br>在adb shell提示符（#）下，运行以下命令：用步骤1中的相应代码替换括号内的部分。<br>setprop persist.sys.locale [BCP-47 language tag];stop;sleep 5;start<br>例如，要用加拿大法语进行测试：</p><p>setprop persist.sys.locale fr-CA;stop;sleep 5;start</p><p>这会导致模拟器重新启动。（它看起来像是完全重新启动，但不是。）主屏幕再次出现后，重新启动您的应用程序，并使用新的区域设置启动应用程序。</p><p>测试默认资源<br>以下是如何测试应用程序是否包含所需的每个字符串资源：</p><p>将模拟器或设备设置为您的应用不支持的语言。例如，如果应用程序中有法文字符串 res/values-fr/但没有任何西班牙字符串 res/values-es/，则将模拟器的区域设置为西班牙语。（您可以使用自定义语言环境应用程序将模拟器设置为不支持的语言环境。）<br>运行应用程序。<br>如果应用程序显示错误消息和强制关闭按钮，则可能正在查找不可用的字符串。确保您的 res/values/strings.xml文件包含应用程序使用的每个字符串的定义。<br>如果测试成功，请将其重复用于其他类型的配置。例如，如果应用程序具有调用的布局文件， res/layout-land/main.xml但不包含调用的文件 res/layout-port/main.xml，则将模拟器或设备设置为纵向方向并查看应用程序是否运行。</p><h2 id="乱七八糟"><a href="#乱七八糟" class="headerlink" title="乱七八糟"></a>乱七八糟</h2></activity>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/37.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Developers" scheme="https://huangguangda.github.io/categories/Developers/"/>
    
    
      <category term="Developers" scheme="https://huangguangda.github.io/tags/Developers/"/>
    
  </entry>
  
  <entry>
    <title>教育系统APP(八)</title>
    <link href="https://huangguangda.github.io/2018/04/28/1/"/>
    <id>https://huangguangda.github.io/2018/04/28/1/</id>
    <published>2018-04-28T07:52:36.000Z</published>
    <updated>2018-05-08T06:38:53.427Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote><p><img src="/images/35.jpg" style="width: 100%;height: 100%"></p><a id="more"></a><h2 id="项目“课程”的模块2"><a href="#项目“课程”的模块2" class="headerlink" title="项目“课程”的模块2"></a>项目“课程”的模块2</h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><p>学习目标<br>1.1 掌握课程模块的开发，实现用VideoView完成视频的播放<br>1.2 掌握课程模块的开发，实现用JSONObject完成Json数据的解析<br>1.3 掌握课程模块的开发，实现用数据库保存播放记录    </p></li><li><p>项目实操<br>2.1 课程详情<br>2.1.1 课程详情界面布局<br>2.1.2 课程详情Item<br>2.1.3 课程详情界面适配器和数据库<br>2.1.4 课程详情界面逻辑代码    </p><p>2.2 视频播放<br>2.2.1 视频播放布局<br>2.2.2 视频播放逻辑代码    </p><p>2.3 播放记录<br>2.3.1 播放记录布局<br>2.3.2 播放记录item<br>2.3.3 播放记录adapter<br>2.3.4 播放记录逻辑代码</p></li><li><p>任务实施<br>3.1 json解析<br>3.2 播放网络视频    </p></li></ol><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><p>1.1掌握课程模块的开发，实现用VideoView完成视频的播放<br>1.2掌握课程模块的开发，实现用JSONObject完成Json数据的解析<br>1.3掌握课程模块的开发，实现用数据库保存播放记录</p><p>课程模块主要用于展示课程中的视频信息，当点击课程列表时会跳转到课程详情界面，在该界面中可以播放相应章节的视频。同时为了方便用户查看已学习的视频，还在“我”的界面中添加了一个播放记录。本章将对课程界面进行详细讲解。</p><h2 id="项目实操"><a href="#项目实操" class="headerlink" title="项目实操"></a>项目实操</h2><p>课程详情<br>课程详情界面布局<br>把本章所需要的图片放入drawable文件夹中</p><p><img src="/images/36.png" alt="36"></p><p>在res包下新建一个资源包，命名为raw，放入视频文件video11.mp4 </p><p>新建一个布局文件，命名为activity_video_list<br>课程详情布局代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;@android:color/white&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;200dp&quot;</span><br><span class="line">        android:background=&quot;@drawable/default_video_list_icon&quot;/&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;50dp&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">        &lt;RelativeLayout</span><br><span class="line">            android:layout_width=&quot;0dp&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight=&quot;1&quot;</span><br><span class="line">            android:background=&quot;@drawable/video_list_intro_icon&quot;&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id=&quot;@+id/tv_intro&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;46dp&quot;</span><br><span class="line">                android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">                android:background=&quot;#30B4FF&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:text=&quot;简 介&quot;</span><br><span class="line">                android:textColor=&quot;#FFFFFF&quot;</span><br><span class="line">                android:textSize=&quot;20sp&quot;/&gt;</span><br><span class="line">        &lt;/RelativeLayout&gt;</span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width=&quot;1dp&quot;</span><br><span class="line">            android:layout_height=&quot;48dp&quot;</span><br><span class="line">            android:background=&quot;#C3C3C3&quot;/&gt;</span><br><span class="line">        &lt;RelativeLayout</span><br><span class="line">            android:layout_width=&quot;0dp&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight=&quot;1&quot;</span><br><span class="line">            android:background=&quot;@drawable/video_list_intro_icon&quot;&gt;</span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id=&quot;@+id/tv_video&quot;</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;46dp&quot;</span><br><span class="line">                android:layout_centerVertical=&quot;true&quot;</span><br><span class="line">                android:background=&quot;#FFFFFF&quot;</span><br><span class="line">                android:gravity=&quot;center&quot;</span><br><span class="line">                android:text=&quot;视 频&quot;</span><br><span class="line">                android:textColor=&quot;#000000&quot;</span><br><span class="line">                android:textSize=&quot;20sp&quot;/&gt;</span><br><span class="line">        &lt;/RelativeLayout&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">        &lt;ListView</span><br><span class="line">            android:id=&quot;@+id/lv_video_list&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:layout_marginLeft=&quot;15dp&quot;</span><br><span class="line">            android:layout_marginRight=&quot;15dp&quot;</span><br><span class="line">            android:divider=&quot;#E4E4E4&quot;</span><br><span class="line">            android:dividerHeight=&quot;1dp&quot;</span><br><span class="line">            android:scrollbars=&quot;none&quot;</span><br><span class="line">            android:visibility=&quot;gone&quot;/&gt;</span><br><span class="line">        &lt;ScrollView</span><br><span class="line">            android:id=&quot;@+id/sv_chapter_intro&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">            &lt;LinearLayout</span><br><span class="line">                android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                android:orientation=&quot;horizontal&quot;&gt;</span><br><span class="line">                &lt;TextView</span><br><span class="line">                    android:id=&quot;@+id/tv_chapter_intro&quot;</span><br><span class="line">                    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">                    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">                    android:lineSpacingMultiplier=&quot;1.5&quot;</span><br><span class="line">                    android:padding=&quot;10dp&quot;</span><br><span class="line">                    android:text=&quot;安卓简介&quot;</span><br><span class="line">                    android:textColor=&quot;@android:color/black&quot;</span><br><span class="line">                    android:textSize=&quot;14sp&quot;/&gt;</span><br><span class="line">            &lt;/LinearLayout&gt;</span><br><span class="line">        &lt;/ScrollView&gt;</span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>课程详情Item<br>课程详情界面里也有一个课程列表，这里我们用ListView就可以了。<br>新建一个布局文件，命名为video_list_item。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:background=&quot;@android:color/white&quot;</span><br><span class="line">    android:gravity=&quot;center_vertical&quot;</span><br><span class="line">    android:paddingBottom=&quot;15dp&quot;</span><br><span class="line">    android:paddingTop=&quot;15dp&quot;&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/iv_left_icon&quot;</span><br><span class="line">        android:layout_width=&quot;25dp&quot;</span><br><span class="line">        android:layout_height=&quot;25dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/course_bar_icon&quot;/&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/tv_video_title&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_marginLeft=&quot;10dp&quot;</span><br><span class="line">        android:gravity=&quot;center_vertical&quot;</span><br><span class="line">        android:text=&quot;[第一节]Android简介&quot;</span><br><span class="line">        android:textColor=&quot;#333333&quot;</span><br><span class="line">        android:textSize=&quot;14sp&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>课程详情界面适配器和数据库<br>先写一个视频的属性类，命名为VideoBean</p><p>VideoBean.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.Bean;</span><br><span class="line"></span><br><span class="line">public class VideoBean &#123;</span><br><span class="line">    public int chapterId;//章节Id</span><br><span class="line">    public int videoId;//视频Id</span><br><span class="line">    public String videoPath;//视频播放地址</span><br><span class="line">    public String title;//章节标题</span><br><span class="line">    public String secondTitle;//视频标题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写完属性类，我们来完善数据库的代码，为后面的播放记录做准备。<br>打开Sqlite包下的SQLiteHelper.java，补充视频表的代码。</p><p>SQLiteHelper.java </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.Sqlite;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.database.sqlite.SQLiteDatabase;</span><br><span class="line">import android.database.sqlite.SQLiteOpenHelper;</span><br><span class="line"></span><br><span class="line">public class SQLiteHelper extends SQLiteOpenHelper&#123;</span><br><span class="line">    private static final int DB_VERSION = 1;</span><br><span class="line">    public static String DB_NAME = &quot;bxg.db&quot;;</span><br><span class="line">    public static final String U_USER_INFO = &quot;userInfo&quot;;</span><br><span class="line">    public static final String U_VIDEO_PLAY_LIST=&quot;videoplaylist&quot;;</span><br><span class="line"></span><br><span class="line">    /*public SQLiteHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123;</span><br><span class="line">        super(context, name, factory, version);</span><br><span class="line">    &#125;*/</span><br><span class="line">    public SQLiteHelper(Context context)&#123;</span><br><span class="line">        super(context, DB_NAME, null, DB_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(SQLiteDatabase db) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 当这个SQLiteOpenHelper的子类类被实例化时会创建指定名的数据库，在onCreate中创建个人信息表</span><br><span class="line">         * **/</span><br><span class="line">        db.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + U_USER_INFO + &quot;( &quot;</span><br><span class="line">                + &quot;_id  INTEGER PRIMARY KEY AUTOINCREMENT, &quot;</span><br><span class="line">                + &quot;userName VARCHAR, &quot;</span><br><span class="line">                + &quot;nickName VARCHAR, &quot;</span><br><span class="line">                + &quot;sex VARCHAR, &quot;</span><br><span class="line">                + &quot;signature VARCHAR, &quot;</span><br><span class="line">                + &quot;qq VARCHAR &quot;</span><br><span class="line">                + &quot;)&quot;);</span><br><span class="line">        db.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + U_VIDEO_PLAY_LIST + &quot;( &quot;</span><br><span class="line">                + &quot;_id INTEGER PRIMARY KEY AUTOINCREMENT, &quot;</span><br><span class="line">                + &quot;userName VARCHAR, &quot; //用户名</span><br><span class="line">                + &quot;chapterId INT, &quot; //章节</span><br><span class="line">                + &quot;videoId int, &quot;       //小节id</span><br><span class="line">                + &quot;videoPath VARCHAR,&quot;  //视频地址</span><br><span class="line">                + &quot;title VARCHAR,&quot;//视频章节名称</span><br><span class="line">                + &quot;secondTitle VARCHAR&quot;//视频名单</span><br><span class="line">                + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当数据库版本号增加才会调用此方法</span><br><span class="line">     **/</span><br><span class="line">    @Override</span><br><span class="line">    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;</span><br><span class="line">        db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + U_USER_INFO);</span><br><span class="line">        db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + U_VIDEO_PLAY_LIST);</span><br><span class="line">        onCreate(db);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到Utils包下的DBUtils.java中补充操作数据表的方法。</p><p>DBUtils.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.utils;</span><br><span class="line"></span><br><span class="line">import android.content.ContentValues;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.database.Cursor;</span><br><span class="line">import android.database.sqlite.SQLiteDatabase;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Bean.UserBean;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Sqlite.SQLiteHelper;</span><br><span class="line"></span><br><span class="line">public class DBUtils &#123;</span><br><span class="line">    private static DBUtils instance = null;</span><br><span class="line">    private static SQLiteHelper helper;</span><br><span class="line">    private static SQLiteDatabase db;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造方法，只有当类被实例化时候调用</span><br><span class="line">     * 实例化SQLiteHelper类，从中得到一个课读写的数据库</span><br><span class="line">     **/</span><br><span class="line">    public DBUtils(Context context) &#123;</span><br><span class="line">        helper = new SQLiteHelper(context);</span><br><span class="line">        db = helper.getWritableDatabase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 得到这个类的实例</span><br><span class="line">     **/</span><br><span class="line">    public static DBUtils getInstance(Context context) &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new DBUtils(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 保存个人资料信息</span><br><span class="line">     **/</span><br><span class="line">    public void saveUserInfo(UserBean bean) &#123;</span><br><span class="line">        ContentValues cv = new ContentValues();</span><br><span class="line">        cv.put(&quot;userName&quot;, bean.userName);</span><br><span class="line">        cv.put(&quot;nickName&quot;, bean.nickName);</span><br><span class="line">        cv.put(&quot;sex&quot;, bean.sex);</span><br><span class="line">        cv.put(&quot;signature&quot;, bean.signature);</span><br><span class="line">        cv.put(&quot;qq&quot;,bean.qq);</span><br><span class="line">        //Convenience method for inserting a row into the database.</span><br><span class="line">        //注意，我们是从数据库使用插入方法，传入表名和数据集完成插入</span><br><span class="line">        db.insert(SQLiteHelper.U_USER_INFO, null, cv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取个人资料信息</span><br><span class="line">     **/</span><br><span class="line">    public UserBean getUserInfo(String userName) &#123;</span><br><span class="line">        String sql = &quot;SELECT * FROM &quot; + SQLiteHelper.U_USER_INFO + &quot; WHERE userName=?&quot;;</span><br><span class="line">        //?和下面数组内元素会逐个替换，可以多条件查询=?and =?</span><br><span class="line">        //You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs.</span><br><span class="line">        Cursor cursor = db.rawQuery(sql, new String[]&#123;userName&#125;);</span><br><span class="line">        UserBean bean = null;</span><br><span class="line">        //Move the cursor to the next row.</span><br><span class="line">        while (cursor.moveToNext()) &#123;</span><br><span class="line">            bean = new UserBean();</span><br><span class="line">            //根据列索引获取对应的数值，因为这里查询结果只有一个，我们也不需要对模型UserBean进行修改，</span><br><span class="line">            //直接将对应用户名的所有数据从表中动态赋值给bean</span><br><span class="line">            bean.userName = cursor.getString(cursor.getColumnIndex(&quot;userName&quot;));</span><br><span class="line">            bean.nickName = cursor.getString(cursor.getColumnIndex(&quot;nickName&quot;));</span><br><span class="line">            bean.sex = cursor.getString(cursor.getColumnIndex(&quot;sex&quot;));</span><br><span class="line">            bean.signature = cursor.getString(cursor.getColumnIndex(&quot;signature&quot;));</span><br><span class="line">            bean.qq = cursor.getString(cursor.getColumnIndex(&quot;qq&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改个人资料信息,这里的key指代表字段，value表示数值</span><br><span class="line">     **/</span><br><span class="line">    public void updateUserInfo(String key, String value, String userName) &#123;</span><br><span class="line">        ContentValues cv = new ContentValues();</span><br><span class="line">        cv.put(key, value);</span><br><span class="line">        //Convenience method for updating rows in the database.</span><br><span class="line">        db.update(SQLiteHelper.U_USER_INFO, cv, &quot;userName=?&quot;, new String[]</span><br><span class="line">                &#123;userName&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void saveVideoPlayList(VideoBean videoBean, String userName)&#123;</span><br><span class="line">        if (hasVideoPlay(videoBean.chapterId, videoBean.videoId, userName))&#123;</span><br><span class="line">            boolean isDelete = delVideoPlay(videoBean.chapterId, videoBean.videoId, userName);</span><br><span class="line">            if (!isDelete)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ContentValues cv = new ContentValues();</span><br><span class="line">        cv.put(&quot;userName&quot;, userName);</span><br><span class="line">        cv.put(&quot;chapterId&quot;, videoBean.chapterId);</span><br><span class="line">        cv.put(&quot;videoId&quot;, videoBean.videoId);</span><br><span class="line">        cv.put(&quot;videoPath&quot;, videoBean.videoPath);</span><br><span class="line">        cv.put(&quot;title&quot;, videoBean.title);</span><br><span class="line">        cv.put(&quot;secondTitle&quot;, videoBean.secondTitle);</span><br><span class="line">        db.insert(SQLiteHelper.U_VIDEO_PLAY_LIST, null, cv);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean delVideoPlay(int chapterId, int videoId, String userName)&#123;</span><br><span class="line">        boolean delSuccess = false;</span><br><span class="line">        int row = db.delete(SQLiteHelper.U_VIDEO_PLAY_LIST,</span><br><span class="line">                &quot; chapterId=? AND videoId=? AND userName=?&quot;,</span><br><span class="line">                new String[]&#123;chapterId + &quot;&quot;, videoId + &quot;&quot;, userName&#125;);</span><br><span class="line">        if (row &gt; 0)&#123;</span><br><span class="line">            delSuccess = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return delSuccess;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean hasVideoPlay(int chapterId, int videoId, String userName)&#123;</span><br><span class="line">        boolean hasVideo = false;</span><br><span class="line">        String sql = &quot;SELECT * FROM &quot; + SQLiteHelper.U_VIDEO_PLAY_LIST +</span><br><span class="line">                &quot; WHERE chapterId=? AND videoId=? AND userName=?&quot;;</span><br><span class="line">        Cursor cursor = db.rawQuery(sql, new String[]&#123;chapterId + &quot;&quot;, videoId + &quot;&quot;, userName&#125;);</span><br><span class="line">        if (cursor.moveToNext())&#123;</span><br><span class="line">            hasVideo = true;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">        return hasVideo;</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;VideoBean&gt; getVideoHistory(String s)&#123;</span><br><span class="line">        String sql = &quot;SELECT * FROM &quot; + SQLiteHelper.U_VIDEO_PLAY_LIST + &quot; WHERE userName=?&quot;;</span><br><span class="line">        Cursor cursor = db.rawQuery(sql, new String[]&#123;s&#125;);</span><br><span class="line">        List&lt;VideoBean&gt; vbl = new ArrayList&lt;&gt;();</span><br><span class="line">        VideoBean bean = null;</span><br><span class="line">        while (cursor.moveToNext())&#123;</span><br><span class="line">            bean = new VideoBean();</span><br><span class="line">            bean.chapterId = cursor.getInt(cursor.getColumnIndex(&quot;chapterId&quot;));</span><br><span class="line">            bean.videoId = cursor.getInt(cursor.getColumnIndex(&quot;videoId&quot;));</span><br><span class="line">            bean.videoPath = cursor.getString(cursor.getColumnIndex(&quot;videoPath&quot;));</span><br><span class="line">            bean.title = cursor.getString(cursor.getColumnIndex(&quot;title&quot;));</span><br><span class="line">            bean.secondTitle = cursor.getString(cursor.getColumnIndex(&quot;secondTitle&quot;));</span><br><span class="line">            vbl.add(bean);</span><br><span class="line">            bean = null;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor.close();</span><br><span class="line">        return vbl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器代码：<br>VideoListItemAdapter.java </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.adapter;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.SharedPreferences;</span><br><span class="line">import android.graphics.Color;</span><br><span class="line">import android.text.TextUtils;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line">import android.widget.BaseAdapter;</span><br><span class="line">import android.widget.ImageView;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Activity.VideoPlayActivity;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.R;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.utils.AnalysisUtils;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.utils.DBUtils;</span><br><span class="line"></span><br><span class="line">public class VideoListItemAdapter extends BaseAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;VideoBean&gt; objects = new ArrayList&lt;VideoBean&gt;();</span><br><span class="line">    private int selectedPosition = -1;</span><br><span class="line"></span><br><span class="line">    private DBUtils db;</span><br><span class="line">    private Context context;</span><br><span class="line">    private LayoutInflater layoutInflater;</span><br><span class="line"></span><br><span class="line">    public VideoListItemAdapter(Context context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">        this.layoutInflater = LayoutInflater.from(context);</span><br><span class="line">        db = DBUtils.getInstance(context);</span><br><span class="line">    &#125;</span><br><span class="line">    public void setData(List&lt;VideoBean&gt; vbl)&#123;</span><br><span class="line">        this.objects = vbl;</span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return objects.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSelectedPosition(int position)&#123;</span><br><span class="line">        selectedPosition = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public VideoBean getItem(int position) &#123;</span><br><span class="line">        return objects.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getItemId(int position) &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">        if (convertView == null) &#123;</span><br><span class="line">            convertView = layoutInflater.inflate(R.layout.video_list_item, null);</span><br><span class="line">            convertView.setTag(new ViewHolder(convertView));</span><br><span class="line">        &#125;</span><br><span class="line">        initializeViews((VideoBean)getItem(position), (ViewHolder) convertView.getTag(), position, convertView);</span><br><span class="line">        return convertView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initializeViews(final VideoBean object, final ViewHolder holder, final int position, View convertView) &#123;</span><br><span class="line">        holder.ivLeftIcon.setImageResource(R.drawable.course_bar_icon);</span><br><span class="line">        holder.tvVideoTitle.setTextColor(Color.parseColor(&quot;#333333&quot;));</span><br><span class="line">        if (object != null)&#123;</span><br><span class="line">            holder.tvVideoTitle.setText(object.secondTitle);</span><br><span class="line">            if (selectedPosition == position)&#123;</span><br><span class="line">                holder.ivLeftIcon.setImageResource(R.drawable.course_intro_icon);;</span><br><span class="line">                holder.tvVideoTitle.setTextColor(Color.parseColor(&quot;$009958&quot;));</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                holder.ivLeftIcon.setImageResource(R.drawable.course_bar_icon);</span><br><span class="line">                holder.tvVideoTitle.setTextColor(Color.parseColor(&quot;#333333&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        convertView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                setSelectedPosition(position);</span><br><span class="line">                if (object != null)&#123;</span><br><span class="line">                    String videoPath = object.videoPath;</span><br><span class="line">                    notifyDataSetChanged();</span><br><span class="line">                    if (TextUtils.isEmpty(videoPath))&#123;</span><br><span class="line">                        Toast.makeText(context, &quot;本地没有此视频，暂无法播放&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        if (readLoginStatus())&#123;</span><br><span class="line">                            String userName = AnalysisUtils.readLoginUserName(context);</span><br><span class="line">                            db.saveVideoPlayList(objects.get(position), userName);</span><br><span class="line">                        &#125;</span><br><span class="line">                        //视频播放</span><br><span class="line">                        Intent intent = new Intent(context, VideoPlayActivity.class);</span><br><span class="line">                        intent.putExtra(&quot;videoPath&quot;, videoPath);</span><br><span class="line">                        intent.putExtra(&quot;position&quot;, position);</span><br><span class="line">                        ((Activity) context).startActivityForResult(intent, 1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean readLoginStatus()&#123;</span><br><span class="line">        SharedPreferences sp = context.getSharedPreferences(&quot;loginInfo&quot;, Context.MODE_PRIVATE);</span><br><span class="line">        boolean isLogin = sp.getBoolean(&quot;isLogin&quot;, false);</span><br><span class="line">        return isLogin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected class ViewHolder &#123;</span><br><span class="line">        private ImageView ivLeftIcon;</span><br><span class="line">        private TextView tvVideoTitle;</span><br><span class="line"></span><br><span class="line">        public ViewHolder(View view) &#123;</span><br><span class="line">            ivLeftIcon = (ImageView) view.findViewById(R.id.iv_left_icon);</span><br><span class="line">            tvVideoTitle = (TextView) view.findViewById(R.id.tv_video_title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>课程详情界面逻辑代码<br>先把data.json文件放进assets文件夹。</p><p>VideoListActivity的逻辑代码</p><p>VideoListActivity.java </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.Activity;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.graphics.Color;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.ListView;</span><br><span class="line">import android.widget.ScrollView;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">import org.json.JSONArray;</span><br><span class="line">import org.json.JSONException;</span><br><span class="line">import org.json.JSONObject;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.R;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.adapter.VideoListItemAdapter;</span><br><span class="line"></span><br><span class="line">public class VideoListActivity extends Activity&#123;</span><br><span class="line">    private TextView tvIntro;</span><br><span class="line">    private TextView tvVideo;</span><br><span class="line">    private ListView lvVideoList;</span><br><span class="line">    private ScrollView svChapterIntro;</span><br><span class="line">    private TextView tvChapterIntro;</span><br><span class="line">    private List&lt;VideoBean&gt; videoList;</span><br><span class="line">    private int chapterId;</span><br><span class="line">    private String intro;</span><br><span class="line">    private VideoListItemAdapter adapter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_video_list);</span><br><span class="line">        chapterId = getIntent().getIntExtra(&quot;id&quot;, 0);</span><br><span class="line">        intro = getIntent().getStringExtra(&quot;intro&quot;);</span><br><span class="line">        initData();</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //把json文件转换为字符串</span><br><span class="line">    private String read(InputStream is)&#123;</span><br><span class="line">        BufferedReader reader = null;</span><br><span class="line">        StringBuilder sb = null;</span><br><span class="line">        String line = null;</span><br><span class="line">        try&#123;</span><br><span class="line">            sb = new StringBuilder();</span><br><span class="line">            reader = new BufferedReader(new InputStreamReader(is));</span><br><span class="line">            while ((line = reader.readLine()) != null)&#123;</span><br><span class="line">                sb.append(line);</span><br><span class="line">                sb.append(&quot;\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            if (is != null)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                    if (reader != null)&#123;</span><br><span class="line">                        reader.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;catch (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //解析json</span><br><span class="line">    private void initData() &#123;</span><br><span class="line">        JSONArray jsonArray;</span><br><span class="line">        try&#123;</span><br><span class="line">            InputStream is = getResources().getAssets().open(&quot;data.json&quot;);</span><br><span class="line">            jsonArray = new JSONArray(read(is));</span><br><span class="line">            videoList = new ArrayList&lt;VideoBean&gt;();</span><br><span class="line">            for (int i = 0; i &lt; jsonArray.length(); i++)&#123;</span><br><span class="line">                VideoBean bean = new VideoBean();</span><br><span class="line">                JSONObject jsonObj = jsonArray.getJSONObject(i);</span><br><span class="line">                if (jsonObj.getInt(&quot;chapterId&quot;) == chapterId)&#123;</span><br><span class="line">                    bean.chapterId = jsonObj.getInt(&quot;chapterId&quot;);</span><br><span class="line">                    bean.videoId = Integer.parseInt(jsonObj.getString(&quot;videoId&quot;));</span><br><span class="line">                    bean.title = jsonObj.getString(&quot;title&quot;);</span><br><span class="line">                    bean.secondTitle = jsonObj.getString(&quot;secondTitle&quot;);</span><br><span class="line">                    bean.videoPath = jsonObj.getString(&quot;videoPath&quot;);</span><br><span class="line">                    videoList.add(bean);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;catch (JSONException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        tvIntro = (TextView) findViewById(R.id.tv_intro);</span><br><span class="line">        tvVideo = (TextView) findViewById(R.id.tv_video);</span><br><span class="line">        lvVideoList = (ListView) findViewById(R.id.lv_video_list);</span><br><span class="line">        svChapterIntro = (ScrollView) findViewById(R.id.sv_chapter_intro);</span><br><span class="line">        tvChapterIntro = (TextView) findViewById(R.id.tv_chapter_intro);</span><br><span class="line">        adapter = new VideoListItemAdapter(this);</span><br><span class="line">        lvVideoList.setAdapter(adapter);</span><br><span class="line">        adapter.setData(videoList);</span><br><span class="line">        tvChapterIntro.setText(intro);</span><br><span class="line">        tvIntro.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;));</span><br><span class="line">        tvVideo.setBackgroundColor(Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">        tvIntro.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">        tvVideo.setTextColor(Color.parseColor(&quot;#000000&quot;));</span><br><span class="line">        tvIntro.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                lvVideoList.setVisibility(View.GONE);</span><br><span class="line">                svChapterIntro.setVisibility(View.VISIBLE);</span><br><span class="line">                tvIntro.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;));</span><br><span class="line">                tvVideo.setBackgroundColor(Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">                tvIntro.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">                tvVideo.setTextColor(Color.parseColor(&quot;#000000&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        tvVideo.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                lvVideoList.setVisibility(View.VISIBLE);</span><br><span class="line">                svChapterIntro.setVisibility(View.GONE);</span><br><span class="line">                tvIntro.setBackgroundColor(Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">                tvVideo.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;));</span><br><span class="line">                tvIntro.setTextColor(Color.parseColor(&quot;#000000&quot;));</span><br><span class="line">                tvVideo.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onActivityResult(int requestCode, int resultCode, Intent data)&#123;</span><br><span class="line">        super.onActivityResult(requestCode,resultCode,data);</span><br><span class="line">        if (data != null)&#123;</span><br><span class="line">            int position = data.getIntExtra(&quot;position&quot;, 0);</span><br><span class="line">            adapter.setSelectedPosition(position);</span><br><span class="line">            lvVideoList.setVisibility(View.VISIBLE);</span><br><span class="line">            svChapterIntro.setVisibility(View.GONE);</span><br><span class="line">            tvIntro.setBackgroundColor(Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">            tvVideo.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;));</span><br><span class="line">            tvIntro.setTextColor(Color.parseColor(&quot;#000000&quot;));</span><br><span class="line">            tvVideo.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到CourseListItemAdapter.java中添加上跳转至视频详情页面的代码。<br>CourseListItemAdapter.java </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.adapter;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.support.v7.widget.RecyclerView;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line">import android.widget.ImageView;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Activity.VideoListActivity;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Bean.CourseBean;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.R;</span><br><span class="line"></span><br><span class="line">public class CourseListItemAdapter extends RecyclerView.Adapter&lt;CourseListItemAdapter.ViewHolder&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;CourseBean&gt; objects = new ArrayList&lt;CourseBean&gt;();</span><br><span class="line">    private Context context;</span><br><span class="line">    private LayoutInflater layoutInflater;</span><br><span class="line"></span><br><span class="line">    public CourseListItemAdapter(Context context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">        this.layoutInflater = LayoutInflater.from(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">        LayoutInflater inflater = LayoutInflater.from(parent.getContext());</span><br><span class="line">        View view=inflater.inflate(R.layout.course_list_item,parent,false);</span><br><span class="line">        return new ViewHolder(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(ViewHolder holder, int position)&#123;</span><br><span class="line">        initializeViews(objects.get(position), holder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(List&lt;CourseBean&gt; objects)&#123;</span><br><span class="line">        this.objects=objects;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getItemId(int position) &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return objects.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initializeViews(final CourseBean object, ViewHolder holder) &#123;</span><br><span class="line">        if (object != null)&#123;</span><br><span class="line">            holder.tvCourseImgTitle.setText(object.imgTitle);</span><br><span class="line">            holder.tvCourseTitle.setText(object.title);</span><br><span class="line">            switch (object.id)&#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_1_icon);</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_2_icon);</span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_3_icon);</span><br><span class="line">                    break;</span><br><span class="line">                case 4:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_4_icon);</span><br><span class="line">                    break;</span><br><span class="line">                case 5:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_5_icon);</span><br><span class="line">                    break;</span><br><span class="line">                case 6:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_6_icon);</span><br><span class="line">                    break;</span><br><span class="line">                case 7:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_7_icon);</span><br><span class="line">                    break;</span><br><span class="line">                case 8:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_8_icon);</span><br><span class="line">                    break;</span><br><span class="line">                case 9:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_9_icon);</span><br><span class="line">                    break;</span><br><span class="line">                case 10:</span><br><span class="line">                    holder.ivCourseImg.setImageResource(R.drawable.chapter_10_icon);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            holder.ivCourseImg.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(View v) &#123;</span><br><span class="line">                    Intent intent = new Intent(context, VideoListActivity.class);</span><br><span class="line">                    intent.putExtra(&quot;id&quot;, object.id);</span><br><span class="line">                    intent.putExtra(&quot;intro&quot;, object.intro);</span><br><span class="line">                    context.startActivity(intent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected class ViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line">        private ImageView ivCourseImg;</span><br><span class="line">        private TextView tvCourseImgTitle;</span><br><span class="line">        private TextView tvCourseTitle;</span><br><span class="line"></span><br><span class="line">        public ViewHolder(View view) &#123;</span><br><span class="line">            super(view);</span><br><span class="line">            ivCourseImg = (ImageView) view.findViewById(R.id.iv_course_img);</span><br><span class="line">            tvCourseImgTitle = (TextView) view.findViewById(R.id.tv_course_img_title);</span><br><span class="line">            tvCourseTitle = (TextView) view.findViewById(R.id.tv_course_title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再到AndroidManifest.xml中声明activity </p><p>视频播放<br>视频播放布局<br>新建布局文件，命名为activity_video_play。</p><p>activity_video_play.xml </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;VideoView</span><br><span class="line">        android:id=&quot;@+id/videoView&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p>视频播放逻辑代码</p><p>VideoPlayActivity.java </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.Activity;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.pm.ActivityInfo;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.text.TextUtils;</span><br><span class="line">import android.view.KeyEvent;</span><br><span class="line">import android.widget.MediaController;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line">import android.widget.VideoView;</span><br><span class="line"></span><br><span class="line">import cn.edu.gdmec.android.vicdemo.R;</span><br><span class="line"></span><br><span class="line">public class VideoPlayActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private VideoView videoView;</span><br><span class="line">    private MediaController controller;</span><br><span class="line">    private String videoPath;</span><br><span class="line">    private int position;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_video_play);</span><br><span class="line">        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</span><br><span class="line">        videoPath = getIntent().getStringExtra(&quot;videoPath&quot;);</span><br><span class="line">        position = getIntent().getIntExtra(&quot;position&quot;, 0);</span><br><span class="line">        videoView = findViewById(R.id.videoView);</span><br><span class="line">        controller = new MediaController(this);</span><br><span class="line">        videoView.setMediaController(controller);</span><br><span class="line">        play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void play() &#123;</span><br><span class="line">        if(TextUtils.isEmpty(videoPath))&#123;</span><br><span class="line">            Toast.makeText(this,&quot;本地没有此视频，暂无法播放&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String uri = &quot;android.resource://&quot; + getPackageName() + &quot;/&quot; + R.raw.video11;</span><br><span class="line">        videoView.setVideoPath(uri);</span><br><span class="line">        videoView.start();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onKeyDown(int keyCode, KeyEvent event)&#123;</span><br><span class="line">        Intent data = new Intent();</span><br><span class="line">        data.putExtra(&quot;position&quot;, position);</span><br><span class="line">        setResult(RESULT_OK, data);</span><br><span class="line">        return super.onKeyDown(keyCode, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到VideoListItemAdapter.java里补上跳转视频播放页面的代码。<br>VideoListItemAdapter.java </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//视频播放</span><br><span class="line">Intent intent = new Intent(context, VideoPlayActivity.class);</span><br><span class="line">intent.putExtra(&quot;videoPath&quot;, videoPath);</span><br><span class="line">intent.putExtra(&quot;position&quot;, position);</span><br><span class="line">((Activity) context).startActivityForResult(intent, 1);</span><br></pre></td></tr></table></figure><p>到AndroidManifest.xml中声明activity </p><h2 id="播放记录"><a href="#播放记录" class="headerlink" title="播放记录"></a>播放记录</h2><p>播放记录布局<br>新建布局文件，命名为activity_play_history</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:background=&quot;@android:color/white&quot;&gt;</span><br><span class="line">    &lt;include layout=&quot;@layout/main_title_bar&quot;/&gt;</span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">        &lt;ListView</span><br><span class="line">            android:id=&quot;@+id/lv_list&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:divider=&quot;#E4E4E4&quot;</span><br><span class="line">            android:dividerHeight=&quot;1dp&quot;</span><br><span class="line">            android:scrollbars=&quot;none&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tv_none&quot;</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:gravity=&quot;center&quot;</span><br><span class="line">            android:text=&quot;暂无播放记录&quot;</span><br><span class="line">            android:textColor=&quot;@android:color/darker_gray&quot;</span><br><span class="line">            android:textSize=&quot;16sp&quot;</span><br><span class="line">            android:visibility=&quot;gone&quot;/&gt;</span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>播放记录item<br>新建布局文件，命名为play_history_list_item<br>play_history_list_item.xml </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:orientation=&quot;horizontal&quot;</span><br><span class="line">    android:background=&quot;@android:color/white&quot;</span><br><span class="line">    android:gravity=&quot;center_vertical&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;&gt;</span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:id=&quot;@+id/iv_video_icon&quot;</span><br><span class="line">            android:layout_width=&quot;100dp&quot;</span><br><span class="line">            android:layout_height=&quot;75dp&quot;</span><br><span class="line">            android:src=&quot;@drawable/video_play_icon2&quot;/&gt;</span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:layout_width=&quot;30dp&quot;</span><br><span class="line">            android:layout_height=&quot;30dp&quot;</span><br><span class="line">            android:src=&quot;@android:drawable/ic_media_play&quot;/&gt;</span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;</span><br><span class="line">        android:layout_marginLeft=&quot;15dp&quot;</span><br><span class="line">        android:layout_gravity=&quot;center_vertical&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/tv_adapter_title&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:textSize=&quot;16sp&quot;</span><br><span class="line">            android:textColor=&quot;#333333&quot;</span><br><span class="line">            android:text=&quot;第1章 Android基础入门&quot;</span><br><span class="line">            android:gravity=&quot;center_vertical&quot;/&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_marginTop=&quot;4dp&quot;</span><br><span class="line">            android:id=&quot;@+id/tv_video_title&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;match_parent&quot;</span><br><span class="line">            android:textSize=&quot;12sp&quot;</span><br><span class="line">            android:textColor=&quot;#a3a3a3&quot;</span><br><span class="line">            android:text=&quot;Android系统简介&quot;</span><br><span class="line">            android:gravity=&quot;center_vertical&quot;/&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><h2 id="播放记录adapter"><a href="#播放记录adapter" class="headerlink" title="播放记录adapter"></a>播放记录adapter</h2><p>PlayHistoryListItemAdapter.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.adapter;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line">import android.widget.BaseAdapter;</span><br><span class="line">import android.widget.ImageView;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Activity.VideoPlayActivity;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.R;</span><br><span class="line"></span><br><span class="line">public class PlayHistoryListItemAdapter extends BaseAdapter &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;VideoBean&gt; objects = new ArrayList&lt;VideoBean&gt;();</span><br><span class="line"></span><br><span class="line">    private Context context;</span><br><span class="line">    private LayoutInflater layoutInflater;</span><br><span class="line"></span><br><span class="line">    public PlayHistoryListItemAdapter(Context context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">        this.layoutInflater = LayoutInflater.from(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(List&lt;VideoBean&gt; vbl)&#123;</span><br><span class="line">        this.objects = vbl;</span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return objects.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public VideoBean getItem(int position) &#123;</span><br><span class="line">        return objects.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getItemId(int position) &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">        if (convertView == null) &#123;</span><br><span class="line">            convertView = layoutInflater.inflate(R.layout.play_history_list_item, null);</span><br><span class="line">            convertView.setTag(new ViewHolder(convertView));</span><br><span class="line">        &#125;</span><br><span class="line">        initializeViews((VideoBean)getItem(position), (ViewHolder) convertView.getTag(), convertView);</span><br><span class="line">        return convertView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initializeViews(final VideoBean object, ViewHolder holder, final View convertView) &#123;</span><br><span class="line">        if (object != null)&#123;</span><br><span class="line">            holder.tvAdapterTitle.setText(object.title);</span><br><span class="line">            holder.tvVideoTitle.setText(object.secondTitle);</span><br><span class="line">            switch (object.chapterId)&#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon1);</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon2);</span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon3);</span><br><span class="line">                    break;</span><br><span class="line">                case 4:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon4);</span><br><span class="line">                    break;</span><br><span class="line">                case 5:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon5);</span><br><span class="line">                    break;</span><br><span class="line">                case 6:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon6);</span><br><span class="line">                    break;</span><br><span class="line">                case 7:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon7);</span><br><span class="line">                    break;</span><br><span class="line">                case 8:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon8);</span><br><span class="line">                    break;</span><br><span class="line">                case 9:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon9);</span><br><span class="line">                    break;</span><br><span class="line">                case 10:</span><br><span class="line">                    holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon10);</span><br><span class="line">                    break;</span><br><span class="line">                    default:</span><br><span class="line">                        holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon1);</span><br><span class="line">                        break;</span><br><span class="line">            &#125;</span><br><span class="line">            convertView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(View v) &#123;</span><br><span class="line">                    if (object == null)&#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Intent intent = new Intent(context, VideoPlayActivity.class);</span><br><span class="line">                    intent.putExtra(&quot;videoPath&quot;, object.videoPath);</span><br><span class="line">                    context.startActivity(intent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected class ViewHolder &#123;</span><br><span class="line">        private ImageView ivVideoIcon;</span><br><span class="line">        private TextView tvAdapterTitle;</span><br><span class="line">        private TextView tvVideoTitle;</span><br><span class="line"></span><br><span class="line">        public ViewHolder(View view) &#123;</span><br><span class="line">            ivVideoIcon = (ImageView) view.findViewById(R.id.iv_video_icon);</span><br><span class="line">            tvAdapterTitle = (TextView) view.findViewById(R.id.tv_adapter_title);</span><br><span class="line">            tvVideoTitle = (TextView) view.findViewById(R.id.tv_video_title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="播放记录逻辑代码"><a href="#播放记录逻辑代码" class="headerlink" title="播放记录逻辑代码"></a>播放记录逻辑代码</h2><p>PlayHistoryActivity.java </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.Activity;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.graphics.Color;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.ListView;</span><br><span class="line">import android.widget.RelativeLayout;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.R;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.adapter.PlayHistoryListItemAdapter;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.utils.AnalysisUtils;</span><br><span class="line">import cn.edu.gdmec.android.vicdemo.utils.DBUtils;</span><br><span class="line"></span><br><span class="line">public class PlayHistoryActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private TextView tv_back;</span><br><span class="line">    private TextView tv_main_title;</span><br><span class="line">    private TextView tv_save;</span><br><span class="line">    private RelativeLayout title_bar;</span><br><span class="line">    private ListView lv_list;</span><br><span class="line">    private TextView tv_none;</span><br><span class="line">    private List&lt;VideoBean&gt; vbl;</span><br><span class="line">    private DBUtils db;</span><br><span class="line">    private PlayHistoryListItemAdapter adapter;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_play_history);</span><br><span class="line">        db = DBUtils.getInstance(this);</span><br><span class="line">        vbl = new ArrayList&lt;VideoBean&gt;();</span><br><span class="line">        vbl = db.getVideoHistory(AnalysisUtils.readLoginUserName(this));</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        tv_back = findViewById(R.id.tv_back);</span><br><span class="line">        tv_main_title = findViewById(R.id.tv_main_title);</span><br><span class="line">        tv_save = findViewById(R.id.tv_save);</span><br><span class="line">        title_bar = findViewById(R.id.title_bar);</span><br><span class="line">        lv_list = findViewById(R.id.lv_list);</span><br><span class="line">        tv_none = findViewById(R.id.tv_none);</span><br><span class="line">        tv_main_title.setText(&quot;播放记录&quot;);</span><br><span class="line">        title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;));</span><br><span class="line">        if (vbl.size() == 0)&#123;</span><br><span class="line">            tv_none.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">        adapter = new PlayHistoryListItemAdapter(this);</span><br><span class="line">        adapter.setData(vbl);</span><br><span class="line">        lv_list.setAdapter(adapter);</span><br><span class="line">        tv_back.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                PlayHistoryActivity.this.fileList();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyinfoFragment.java里补上跳转视频播放页面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//跳转到播放记录页面</span><br><span class="line">                    Intent intent = new Intent(getActivity(), PlayHistoryActivity.class);</span><br><span class="line">                    getActivity().startActivity(intent);</span><br></pre></td></tr></table></figure><p>到AndroidManifest.xml中声明activity<br>AndroidManifest.xml </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    package=&quot;cn.edu.gdmec.android.vicdemo&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;application</span><br><span class="line">        android:allowBackup=&quot;true&quot;</span><br><span class="line">        android:icon=&quot;@drawable/app_icon&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;</span><br><span class="line">        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:supportsRtl=&quot;true&quot;</span><br><span class="line">        android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.SplashActivity&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">        &lt;!--添加实现类--&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.MainActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.RegisterActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.LoginActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.SettingActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.ModifyPswActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.FindPwdActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.UserInfoActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.ChangeUserInfoActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.ExercisesDetailActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.VideoListActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.VideoPlayActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">        &lt;activity android:name=&quot;.Activity.PlayHistoryActivity&quot;&gt;&lt;/activity&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><h2 id="任务实施"><a href="#任务实施" class="headerlink" title="任务实施"></a>任务实施</h2><p>json解析<br>将res/assets包下的data.Json文件打开，把下面的json数据覆盖掉原来的数据，更改解析json数据的代码，把新的json数据解析出来并成功展示。</p><p>播放网络视频<br>修改VideoView控件和AndroidManifest.xml的代码，使其能成功播放下面json数据里的网络视频。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">json数据：</span><br><span class="line">[&#123;</span><br><span class="line"> &quot;chapterId&quot;: 1,</span><br><span class="line"> &quot;data&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">   &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">   &quot;title&quot;: &quot;第1章 Android 基础入门&quot;,</span><br><span class="line">   &quot;secondTitle&quot;: &quot;迷情巧克力&quot;,</span><br><span class="line">   &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/PaGWXOMYz-rMWm-r9a2MvILINHMc0YBXe2i-dg__.mp4?ssig=acb6880de7200e266864581d97c0654d&amp;time_stamp=1524887992615&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=PaGWXOMYz-rMWm-r9a2MvILINHMc0YBXe2i-dg__&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">   &quot;title&quot;: &quot;第1章 Android 基础入门&quot;,</span><br><span class="line">   &quot;secondTitle&quot;: &quot;命运是什么&quot;,</span><br><span class="line">   &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/KP7xXv0IllZsjnK1HjVlkbGfb5yWj7mPbaEOmQ__.mp4?ssig=7d445a22609119e57b50c8fa9a84a11b&amp;time_stamp=1524888071281&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=KP7xXv0IllZsjnK1HjVlkbGfb5yWj7mPbaEOmQ__&quot;</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;chapterId&quot;: 2,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第2章 Android UI开发&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;水银为什么是液体&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/cnngO-Co7rFlVPzkS7qqoaxR7OFH72uvYDDiew__.mp4?ssig=b91b143afbaadb8472b57b17e0c213e5&amp;time_stamp=1524888092840&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=cnngO-Co7rFlVPzkS7qqoaxR7OFH72uvYDDiew__&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第2章 Android UI开发&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;汽车的历史&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/6S23U5PMRtOQzu99NeITYztd0xtKFW2xDYxwXQ__.mp4?ssig=afa07a802aca690154953446fc5de4d4&amp;time_stamp=1524888118545&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=6S23U5PMRtOQzu99NeITYztd0xtKFW2xDYxwXQ__&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;chapterId&quot;: 3,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第3章 Activity&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;汽车的历史&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/6S23U5PMRtOQzu99NeITYztd0xtKFW2xDYxwXQ__.mp4?ssig=afa07a802aca690154953446fc5de4d4&amp;time_stamp=1524888118545&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=6S23U5PMRtOQzu99NeITYztd0xtKFW2xDYxwXQ__&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;chapterId&quot;: 3,</span><br><span class="line">    &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第3章 Activity&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;Activity中的数据传递&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;chapterId&quot;: 4,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第4章 数据存储&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;文件存储&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第4章 数据存储&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;XML序列化与SharedPreferences&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;chapterId&quot;: 5,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第5章 SQLite 数据库&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;SQLite数据库的使用&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第5章 SQLite 数据库&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;ListView控件的使用&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;chapterId&quot;: 6,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第6章 广播接收者&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;内容提供者简介&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第6章 广播接收者&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;内容提供者的访问&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;chapterId&quot;: 7,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第7章 服务&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;广播接收者与自定义广播&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第7章 服务&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;广播类型与常用的广播接收者&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;chapterId&quot;: 8,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第8章 内容提供者&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;服务的创建与生命周期&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第8章 内容提供者&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;服务的启动方式&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;chapterId&quot;: 9,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第9章 网络编程&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;访问网络&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第9章 网络编程&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;数据的提交方式&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  &quot;chapterId&quot;: 10,</span><br><span class="line">  &quot;data&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第10章 高级编程&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;图形图像处理与动画&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;videoId&quot;: &quot;2&quot;,</span><br><span class="line">    &quot;title&quot;: &quot;第10章 高级编程&quot;,</span><br><span class="line">    &quot;secondTitle&quot;: &quot;多媒体、与Fragment&quot;,</span><br><span class="line">    &quot;videoPath&quot;: &quot;&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="总结-完"><a href="#总结-完" class="headerlink" title="总结 完"></a>总结 完</h2><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>VideoListActivity </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//解析json</span><br><span class="line">    private void initData() &#123;</span><br><span class="line">        //JSONArray jsonArray;</span><br><span class="line">        JSONArray jsonArray,jsonArray1;</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;VideoBean&gt; list1 = new ArrayList&lt;VideoBean&gt;();</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            InputStream is = getResources().getAssets().open(&quot;data.json&quot;);</span><br><span class="line">            jsonArray = new JSONArray(read(is));</span><br><span class="line">            videoList = new ArrayList&lt;VideoBean&gt;();</span><br><span class="line">            for (int i = 0; i &lt; jsonArray.length(); i++)&#123;</span><br><span class="line">                VideoBean bean = new VideoBean();</span><br><span class="line">                JSONObject jsonObj = jsonArray.getJSONObject(i);</span><br><span class="line">                if (jsonObj.getInt(&quot;chapterId&quot;) == chapterId)&#123;</span><br><span class="line">                    bean.chapterId = jsonObj.getInt(&quot;chapterId&quot;);</span><br><span class="line"></span><br><span class="line">                    /*bean.videoId = Integer.parseInt(jsonObj.getString(&quot;videoId&quot;));</span><br><span class="line">                    bean.title = jsonObj.getString(&quot;title&quot;);</span><br><span class="line">                    bean.secondTitle = jsonObj.getString(&quot;secondTitle&quot;);</span><br><span class="line">                    bean.videoPath = jsonObj.getString(&quot;videoPath&quot;);</span><br><span class="line">                    videoList.add(bean);*/</span><br><span class="line">                    String ss =jsonObj.getString(&quot;data&quot;);</span><br><span class="line">                    jsonArray1 = new JSONArray(ss);</span><br><span class="line">                    for (int j=0;j&lt;jsonArray1.length();j++)&#123;</span><br><span class="line">                        JSONObject jsonObject = (JSONObject) jsonArray1.get(j);</span><br><span class="line"></span><br><span class="line">                        Iterator&lt;String&gt; iterator = jsonObject.keys();</span><br><span class="line">                        while (iterator.hasNext())&#123;</span><br><span class="line">                            String key = iterator.next();</span><br><span class="line">                            String value = jsonObject.getString(key);</span><br><span class="line">                            list.add(value);</span><br><span class="line">                        &#125;</span><br><span class="line">                        bean.videoId = Integer.parseInt(list.get(0));</span><br><span class="line">                        bean.title = list.get(1);</span><br><span class="line">                        bean.secondTitle = list.get(2);</span><br><span class="line">                        bean.videoPath = list.get(3);</span><br><span class="line">                        videoList.add(bean);</span><br><span class="line">                        bean = new VideoBean();</span><br><span class="line">                        list.clear();</span><br><span class="line">                        Log.i(&quot;Ss&quot;,videoList.toString());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                bean = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;catch (JSONException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>VideoPlayActivity </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package cn.edu.gdmec.android.vicdemo.Activity;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Intent;</span><br><span class="line">import android.content.pm.ActivityInfo;</span><br><span class="line">import android.net.Uri;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.text.TextUtils;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.view.KeyEvent;</span><br><span class="line">import android.view.WindowManager;</span><br><span class="line">import android.widget.MediaController;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line">import android.widget.VideoView;</span><br><span class="line"></span><br><span class="line">import cn.edu.gdmec.android.vicdemo.R;</span><br><span class="line"></span><br><span class="line">public class VideoPlayActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private VideoView videoView;</span><br><span class="line">    private MediaController controller;</span><br><span class="line">    private String videoPath;</span><br><span class="line">    private int position;////传递视频详情界面点击的视频位置</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        //设置界面全屏显示</span><br><span class="line">        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);</span><br><span class="line">        setContentView(R.layout.activity_video_play);</span><br><span class="line">        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</span><br><span class="line">        //获取从播放记录界面传递过来的视频地址</span><br><span class="line">        videoPath = getIntent().getStringExtra(&quot;videoPath&quot;);</span><br><span class="line">        position = getIntent().getIntExtra(&quot;position&quot;, 0);</span><br><span class="line"></span><br><span class="line">        videoView = findViewById(R.id.videoView);</span><br><span class="line">        controller = new MediaController(this);</span><br><span class="line">        videoView.setMediaController(controller);</span><br><span class="line">        play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void play() &#123;</span><br><span class="line">        if(TextUtils.isEmpty(videoPath))&#123;</span><br><span class="line">            Toast.makeText(this,&quot;本地没有此视频，暂无法播放&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //String uri = &quot;android.resource://&quot; + getPackageName() + &quot;/&quot; + R.raw.video11;</span><br><span class="line">        Log.i(&quot;Video&quot;,videoPath);</span><br><span class="line">        String uri = videoPath;</span><br><span class="line">        Uri uri1 = Uri.parse(uri);</span><br><span class="line">        videoView.setVideoURI(uri1);</span><br><span class="line">        //videoView.setVideoPath(uri);</span><br><span class="line">        videoView.start();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onKeyDown(int keyCode, KeyEvent event)&#123;</span><br><span class="line">        //把视频详情界面传递过来的被点击视频的位置传递回去</span><br><span class="line">        Intent data = new Intent();</span><br><span class="line">        data.putExtra(&quot;position&quot;, position);</span><br><span class="line">        setResult(RESULT_OK, data);</span><br><span class="line">        return super.onKeyDown(keyCode, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;用一切抱怨的时间去努力&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/35.jpg&quot; style=&quot;width: 100%;height: 100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教育系统APP" scheme="https://huangguangda.github.io/categories/%E6%95%99%E8%82%B2%E7%B3%BB%E7%BB%9FAPP/"/>
    
    
      <category term="教育系统APP" scheme="https://huangguangda.github.io/tags/%E6%95%99%E8%82%B2%E7%B3%BB%E7%BB%9FAPP/"/>
    
  </entry>
  
</feed>
