<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function(){
        if('https://huangguangda.github.io/'){
            if (prompt('请输入文章密码') !== 'https://huangguangda.github.io/'){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/6f697dad.js","daovoice")
  daovoice('init', {
      app_id: "6f697dad"
    });
  daovoice('update');
  </script>















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="我的书籍,">





  <link rel="alternate" href="/atom.xml" title="达叔小生" type="application/atom+xml">






<meta name="description" content="用一切抱怨的时间去努力">
<meta name="keywords" content="我的书籍">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA语言-985大学">
<meta property="og:url" content="https://huangguangda.github.io/2018/05/02/1/index.html">
<meta property="og:site_name" content="达叔小生">
<meta property="og:description" content="用一切抱怨的时间去努力">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://huangguangda.github.io/images/39.jpg">
<meta property="og:updated_time" content="2018-06-06T18:25:55.079Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JAVA语言-985大学">
<meta name="twitter:description" content="用一切抱怨的时间去努力">
<meta name="twitter:image" content="https://huangguangda.github.io/images/39.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://huangguangda.github.io/2018/05/02/1/">




<!-- 网页加载条 -->
<script src="https://neveryu.github.io/js/src/pace.min.js"></script>
  <title>JAVA语言-985大学 | 达叔小生</title>
  









  <!-- 音频播放 -->
<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/huangguangda" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">达叔小生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">爱好分享的码农</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-书籍">
          <a href="/books" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br>
            
            书籍
          </a>
        </li>
      
        
        <li class="menu-item menu-item-电影">
          <a href="/movies" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-chrome"></i> <br>
            
            电影
          </a>
        </li>
      
        
        <li class="menu-item menu-item-站点">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点
          </a>
        </li>
      
        
        <li class="menu-item menu-item-公益">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益
          </a>
        </li>
      
        
        <li class="menu-item menu-item-课本">
          <a href="/book/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-apple"></i> <br>
            
            课本
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://huangguangda.github.io/2018/05/02/1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="达叔小生">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="达叔小生">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">JAVA语言-985大学</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T23:32:04+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/我的书籍/" itemprop="url" rel="index">
                    <span itemprop="name">我的书籍</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  70,596
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  269
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote class="blockquote-center">用一切抱怨的时间去努力</blockquote>

<p><img src="/images/39.jpg" style="width: 100%;height: 100%"></p>
<a id="more"></a>
<p>记录收藏，记录要点，来源各个大佬，部分内容也来源网络</p>
<h2 id="Java学习课程——基础篇"><a href="#Java学习课程——基础篇" class="headerlink" title="Java学习课程——基础篇"></a>Java学习课程——基础篇</h2><h2 id="第一篇-Java-入门导论"><a href="#第一篇-Java-入门导论" class="headerlink" title="第一篇  Java 入门导论"></a>第一篇  Java 入门导论</h2><ul>
<li>对Java的历史、Java平台、Java语言建立基本概念。并实际地导览读者到网络上去看Java所构筑的网络新世界。然后再开始学习几个简易的入门程序，开始建立Java程序的概念与印象。 </li>
</ul>
<h2 id="本篇包括："><a href="#本篇包括：" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第1章  Java 概说<br>第2章  Java的世界<br>第3章  先来一杯Java 吧 </p>
<h2 id="第二篇-面向对象程序设计（一）"><a href="#第二篇-面向对象程序设计（一）" class="headerlink" title="第二篇  面向对象程序设计（一）"></a>第二篇  面向对象程序设计（一）</h2><ul>
<li>在开始学习Java语言时，先针对其面向对象的特性，诸如对象、类、封装、继承等概念加以说明。避开语言上的枝节探讨，先将Java面向对象的概念点出，以免使读者落入程序语言的丛林里。然后再介绍Java 1.3API对象结构化的类库，认识其所提供包、类的功能概述。  </li>
</ul>
<h2 id="本篇包括：-1"><a href="#本篇包括：-1" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第4章  面向对象程序设计基本概念<br>第5章  Java 1.3 API 简介 </p>
<h2 id="第三篇-Java语言基础"><a href="#第三篇-Java语言基础" class="headerlink" title="第三篇  Java语言基础"></a>第三篇  Java语言基础</h2><ul>
<li>Java语言是由C/C++所演变，去芜存菁并重新设计的语言。采用Unicode编码，并有其特有的标识符与关键字。而数据的类型，也是有原生类型与参考类型之别。本篇各章主要根据Java Language Specification (Second Edition)，＜此规格书可由 <a href="http://www.java.sun.com" target="_blank" rel="noopener">www.java.sun.com</a> 自由下载 ＞，挑选最主要的三部分来作编写架构。 </li>
</ul>
<h2 id="本篇包括：-2"><a href="#本篇包括：-2" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第6章  语汇结构<br>第7章  类型、数值、变量<br>第8章  控制结构 </p>
<h2 id="第四篇-面向对象程序设计（二）"><a href="#第四篇-面向对象程序设计（二）" class="headerlink" title="第四篇  面向对象程序设计（二）"></a>第四篇  面向对象程序设计（二）</h2><ul>
<li>有了第二与第三篇的基础后，再来以实际的程序范例来看Java的面向对象，就会对Java的面向对象精神有清楚的认识。</li>
</ul>
<h2 id="本篇包括：-3"><a href="#本篇包括：-3" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第9章    类、接口、包<br>第10章  方法与异常处理 </p>
<h2 id="第五篇-Java图形用户界面程序"><a href="#第五篇-Java图形用户界面程序" class="headerlink" title="第五篇  Java图形用户界面程序"></a>第五篇  Java图形用户界面程序</h2><ul>
<li>图形用户界面的程序是现代程序设计的一大重点。而Java API所提供的图形界面包AWT及SWING，也是图形界面的一大进步，因为它们成功打破了各家操作系统图形界面的屏障，使程序设计师不必疲于修改要适用于各家平台的程序。而SWING更踏在AWT的肩膀上，进一步提供更强大、多元、弹性的功能。  </li>
</ul>
<h2 id="本篇包括：-4"><a href="#本篇包括：-4" class="headerlink" title="本篇包括："></a>本篇包括：</h2><p>第11章  Java GUI概论<br>第12章  Java版面配置<br>第13章  事件处理<br>第14章  Applet与JApplet<br>第15章  Swing初级</p>
<h2 id="学习建议："><a href="#学习建议：" class="headerlink" title="学习建议："></a>学习建议：</h2><blockquote>
<p>对较无程序设计基础的初学者 </p>
</blockquote>
<p>可依照本书安排次序循序渐进学习。尤其对没碰过C或 C++的人，更需要摸清每章的各部分。若本书不够清楚，请再参考别的书籍作比照，这样才能打好基础。</p>
<blockquote>
<p>对有C/C++程序设计经验者 </p>
</blockquote>
<p>若您有C/C++的语法基础，可先略过第三篇Java语言基础部分。但可能您还不清楚Java的设计理念及其面向对象程序设计原理，所以还是建议您从第一篇开始（除了第三篇外）按部就班地学习。待有Java语言基础部分不懂之处，再去查看即可。</p>
<h2 id="第一篇-Java入门导论"><a href="#第一篇-Java入门导论" class="headerlink" title="第一篇  Java入门导论"></a>第一篇  Java入门导论</h2><p>第1章  Java 概说<br>第2章  Java的世界<br>第3章  先来一杯Java吧 </p>
<h2 id="第1章-Java-概说"><a href="#第1章-Java-概说" class="headerlink" title="第1章  Java 概说"></a>第1章  Java 概说</h2><blockquote>
<p>Java的发展历史 </p>
</blockquote>
<p>Java的发展历史，要从1990年开始追溯起。<br>当时Sun Microsystem公司为了发展消费性电子产品而进行了一个名为Green的项目计划。<br>这个计划的负责人是James Gosling。<br>起初他以C++来写一种内嵌式软件，可以放在烤面包机或PAD等小型电子消费设备里，使得机器更聪明，更具有人工智能。<br>但后来他发现C++并不适合这类的任务！因为C++常会有使系统失效的程序错误，尤其是内存管理，C++是采用直接参考（direct reference）的方式，需要程序设计师记录并管理内存资源。<br>这造成设计师们极大的负担，并可能产生许多bugs。<br>若是一台烤面包机上的程序有错误，可能会使烤面包机烧坏了，甚至更严重会有爆炸产生！ </p>
<p>所以为了解决所遇到的问题，Gosling最后决定要发展一种新的语言，来解决C++的潜在性危险问题，这个语言名叫Oak。<br>它保留了大部分与C++相似的语法，但却把些较具危险性的功能加以改进，像内存资源管理，便由语言本身来管理，以减少程序设计师的负担及错误的产生。<br>Oak是一种可移植性（portable）语言，也就是一种平台独立（platform-independent）的语言，能够在各种芯片上运行。<br>这样子各家厂商就可降低研发成本，直接把应用程序应用在自家的产品上。 </p>
<h2 id="Java与Internet"><a href="#Java与Internet" class="headerlink" title="Java与Internet"></a>Java与Internet</h2><p>时间到了1994年，Oak的技术已日趋成熟，这时刚好网络也正开始蓬勃发展。<br>而Oak研发小组发现Oak很适合作为一种网络程序语言。<br>因此发展了一个能与Oak相配合的浏览器——WebRunner，后更名为HotJava，它证明了Oak是一种能在网络上发展的程序语言。<br>后来，因为Oak这个商标已被注册走了，工程师们便想到以手中常享用的咖啡(Java)来重新命名，并于Sun World 95中被发表出来。<br>从此以后，Java就随着网络的快速发展，而成了一个程序语言的明日之星。</p>
<h2 id="Java平台"><a href="#Java平台" class="headerlink" title="Java平台"></a>Java平台</h2><p>“网络即计算机”，是Sun企业的格言。<br>所以在设计上，Java即是以网络为运作范畴，并且是架设在各种硬件环境上的一种纯软件平台(platform)。<br>它与一般与硬件有关的各式操作系统（Operating System，如Windows，MacOS）或称操作平台不同。<br>一般所谓的平台是指撰写程序时所依赖的API(Application Program Interface)，通常都预先定义在计算机中的操作系统上。<br>因此在Java之前，程序设计师就只能借助所在环境的API写单一操作系统的程序。<br>若要改成另一操作系统版本的程序，就需要花许多的转换功夫，或者根本不可能。<br>但Java平台，虽然不算是一种操作系统（不过现在已有JavaOS的出现），却提供了甚至比现今各操作系统更深、更广的API。<br>Java平台包括Java虚拟机器（Java Virtual Machine,JVM）以及Java API。</p>
<h2 id="Java平台的版本"><a href="#Java平台的版本" class="headerlink" title="Java平台的版本"></a>Java平台的版本</h2><p>目前Java平台有3种的版本，以因应各种需求：  </p>
<ul>
<li>JAVATM 2 PLATFORM,STANDARD EDITION（标准版）</li>
<li>JAVATM 2 PLATFORM,ENTERPRISE EDITION（企业版） </li>
<li>JavaTM 2 Platform, Micro Edition (J2METM) （小型家电版）  </li>
</ul>
<p>借助这些平台版本，使得Java程序能在各式大小型机器及操作系统上运行，达成所谓程序可移植性、跨平台的目标。<br>因着Java平台的这些特性，使微软倍感威胁。<br>微软现今所展的.Net，便是视Java平台为强力竞争对手之一。 </p>
<h2 id="Java平台运作原理"><a href="#Java平台运作原理" class="headerlink" title="Java平台运作原理"></a>Java平台运作原理</h2><p>Java平台是一种新的计算机计算运作方式，植基于网络的能力与程序能“撰写一次，到处运行”（write once,run anywhere）的技术。<br>借着Java技术，人们可以使用多种的上网工具来达到互相沟通的目的。<br>像现今流行的新一代手机、PDA、可视电话，智能卡（smart cart）等先进设备等，也都能彼此沟通。<br>而非仅限于台式计算机或笔记本电脑而已。<br>当然能达到这些目的，主要就是通过前面所说的Java API、Java VM 与Java语言等技术的配合。</p>
<h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h2><p>Java语言，是一个新一代的高级（high-level）、通用目的（general-purpose）、面向对象（objec-oriented）的程序语言。</p>
<p>其语法与C或C++类似，但在组织结构上却相当的不同。</p>
<p>它是一个完全面向对象的程序语言，程序的基本处理单位：类（class）及API的组织，均以对象的观点来处理及架构起来的。</p>
<p>不仅如此，它在被设计的时候也倾向于是一种具生产力的语言（production language）,而非只是研究性语言（research language）。</p>
<p>所以当我们学习运用Java语言的时候，便能很快地感受到它的便利与强大功能。</p>
<h2 id="Java语言的特性"><a href="#Java语言的特性" class="headerlink" title="Java语言的特性"></a>Java语言的特性</h2><p>面向对象程序语言<br>简单（simple）<br>强固（robust）<br>安全（security）<br>平台独立（platform-independent） </p>
<p>多任务线程（multithreading）<br>动态（dynamic）<br>分布式计算(distributed computing)<br>运行效率（performance）<br>内存管理与资源回收(garbage collection) </p>
<h2 id="Java-与C-C-的差异"><a href="#Java-与C-C-的差异" class="headerlink" title="Java 与C/C++的差异"></a>Java 与C/C++的差异</h2><p>C/C++<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream.h&gt;</span><br><span class="line">public :</span><br><span class="line">unsigned int aData=10;</span><br><span class="line">class PrintOut&#123;</span><br><span class="line">void printData()&#123;</span><br><span class="line">cout&lt;&lt;”Data:”+aData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">PrintOut po;</span><br><span class="line">po.printData();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class Test&#123;</span><br><span class="line">public int aData=10;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">Test test=new Test();</span><br><span class="line">test.printData();</span><br><span class="line">&#125;</span><br><span class="line">void printData()&#123;</span><br><span class="line">System.out.println(&quot;Data:&quot;+this.aData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Java-与C-C-的差异-1"><a href="#Java-与C-C-的差异-1" class="headerlink" title="Java 与C/C++的差异"></a>Java 与C/C++的差异</h2><p>舍去功能<br>新增功能<br>取代改进功能 </p>
<h2 id="Java-程序的种类"><a href="#Java-程序的种类" class="headerlink" title="Java 程序的种类"></a>Java 程序的种类</h2><p>Java是一种网络程序语言，它能写出包含前端(Applet)、本地（Application）及后端（Servlets）的程序。虽然这三者的结构不同，但基本的语法都一样，所以能彼此沟通，构造出一个所谓的平台。</p>
<p>现在又加上了JSP(Java Server Pages)作为服务器端的加强，使得开发网络程序更快速。Java平台也更完整。</p>
<h2 id="Applet"><a href="#Applet" class="headerlink" title="Applet"></a>Applet</h2><p>Applet是一种可嵌入于Web文件中的一种小型程序。</p>
<p>通常其程序因网络传输速度关系都很短小。</p>
<p>但在应用上却常常比Application有用，一般都是通过浏览器来观看Applet。<br>(数据来源：<a href="http://www.thejmaker.com" target="_blank" rel="noopener">www.thejmaker.com</a>) </p>
<h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>Application（应用程序）是在命令列环境运行的程序。</p>
<p>程序中由main()方法作为程序起点，运行顺序由程序本身来控制。但Applet却是由浏览器来控管。选择用Applet还是Application来写作，要视所欲表达内容及传输机制而定。</p>
<p>通常Applet较需图形用户界面（GUI,Graphical User Interface），而Application较不需要。但因GUI的便利，许多Application也都用GUI来增进用户的便利，右图便是一个连接数据库的应用程序。(数据来源：<a href="http://www.svcon.com" target="_blank" rel="noopener">www.svcon.com</a>) </p>
<h2 id="Servlets"><a href="#Servlets" class="headerlink" title="Servlets"></a>Servlets</h2><p>Servlets是应用在服务器端的应用程序，可提供各种服务器服务。例如数据查询或动态产生聊天室，月历等，右图是由一个网站流量统计的Servelets所产生的画面。<br>(数据来源：<a href="http://www.mycgiserver.com" target="_blank" rel="noopener">http://www.mycgiserver.com</a>) </p>
<h2 id="第一讲-JAVA语言概述"><a href="#第一讲-JAVA语言概述" class="headerlink" title="第一讲 JAVA语言概述"></a>第一讲 JAVA语言概述</h2><h2 id="本讲要点"><a href="#本讲要点" class="headerlink" title="本讲要点"></a>本讲要点</h2><h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><p>什么是Java？<br>我们的学习目标<br>学习方法指导<br>学习资料推荐</p>
<h2 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h2><p>Java语言的特点<br>Java语言程序分类<br>Java程序开发过程<br>Java虚拟机</p>
<h2 id="什么是Java-？"><a href="#什么是Java-？" class="headerlink" title="什么是Java ？"></a>什么是Java ？</h2><p>一种编程语言</p>
<ul>
<li>面向对象的程序设计语言，提供了编译、运行、调试工具。</li>
<li>1991年Sun公司的 “绿色项目” Oak语言产生(Java) 项目失败，但Java活了下来(1995年发布第一个版本JDK1.0)。</li>
</ul>
<p>一种软件平台</p>
<ul>
<li>平台是程序运行的硬件或软件环境，Java平台与大多数其它平台不同，是基于其它软件或硬件的纯软件平台。</li>
<li>JVM：Java虚拟机，是Java平台的基础</li>
<li>Java API：Java应用程序接口，Java API是软件组件的集合，它们提供了很多有用的功能，如图形用户界面（GUI）。</li>
</ul>
<p>随着应用范围越来越广，Java演化出三个不同领域的应用平台</p>
<ul>
<li>J2SE：Java2 Platform， Standard Edition：标准版，桌面系统和低端服务</li>
<li>J2EE：Java2 Platform， Enterprise Edition：企业版，企业级应用</li>
<li>J2ME：Java2 Platform ，Micro Edition：小型版，嵌入式应用开发<br>与.net简单比较</li>
</ul>
<h2 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h2><h2 id="最终目标：Java软件工程师"><a href="#最终目标：Java软件工程师" class="headerlink" title="最终目标：Java软件工程师"></a>最终目标：Java软件工程师</h2><p>Java语法、J2se平台基础、面向对象编程思想和方法（Java基础）<br>Java Web开发（简单应用）<br>J2ee企业开发（企业级应用）、J2me（嵌入式应用）<br>辅助技术：Struts设计模式、JavaScript、XML、SQL语言<br>开发工具：JDK、JCreater、Eclipes、JBuilder</p>
<h2 id="近期目标"><a href="#近期目标" class="headerlink" title="近期目标"></a>近期目标</h2><p>在校期间，掌握Java Web应用</p>
<h2 id="本学期目标"><a href="#本学期目标" class="headerlink" title="本学期目标"></a>本学期目标</h2><p>本学期， Java语法、J2se平台基础、面向对象编程思想和方法，培养自学能力。</p>
<h2 id="学习方法指导"><a href="#学习方法指导" class="headerlink" title="学习方法指导"></a>学习方法指导</h2><h2 id="奠定Java语法基础"><a href="#奠定Java语法基础" class="headerlink" title="奠定Java语法基础"></a>奠定Java语法基础</h2><p>学习Java的第一步是用Java语言来编写程序，学习Java语言的第一步，就是熟悉其语法的使用。</p>
<h2 id="注意思考和总结"><a href="#注意思考和总结" class="headerlink" title="注意思考和总结"></a>注意思考和总结</h2><p>在学习的过程中，最好能够了解Java的底层机制，而不是仅仅停留在表层，不是抄书上的例子运行出结果就可以。即便对一个简单的例子也要有耐心去琢磨、调试、改动。 </p>
<h2 id="动手写代码"><a href="#动手写代码" class="headerlink" title="动手写代码"></a>动手写代码</h2><p>在学习的过程中一定要动手做、写代码，而不是抱一本书看看就行。很多东西和体会必须自己动手才能真正属于自己。 </p>
<p>在学到一定阶段后，试用学过的东西做些什么。</p>
<h2 id="培养自学能力"><a href="#培养自学能力" class="headerlink" title="培养自学能力"></a>培养自学能力</h2><p>Java API文档</p>
<ul>
<li>英文地址：<a href="http://java.sun.com/j2se/1.5.0/docs/api/" target="_blank" rel="noopener">http://java.sun.com/j2se/1.5.0/docs/api/</a></li>
<li>中文：网上搜索下载</li>
</ul>
<p>充分利用网络学习资源</p>
<ul>
<li>使用搜索引擎</li>
<li>加入论坛参与讨论</li>
</ul>
<h2 id="学习资料推荐"><a href="#学习资料推荐" class="headerlink" title="学习资料推荐"></a>学习资料推荐</h2><h2 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h2><p>（1）《Java学习笔记》，良葛格著， 清华大学出版社，2006.8。</p>
<p>（2）《Java编程基础、应用与实例》，［韩］徐明浩 著 武传海译，人民邮电出版社，2005.10。</p>
<p>（3）《Java编程思想》第3版 ，（美）埃克尔（Eckel,B.） 著 陈昊鹏 等译, 机械工业出版社，2005.5。</p>
<p>（4）《Java就业培训教程》, 张孝祥 编著， 清华大学出版社,2003.9。</p>
<h2 id="网络学习资源"><a href="#网络学习资源" class="headerlink" title="网络学习资源"></a>网络学习资源</h2><p>（1）Java中国开发网–<a href="http://bbs.cjsdn.net/" target="_blank" rel="noopener">http://bbs.cjsdn.net/</a><br>（2）中文JAVA技术网–<a href="http://www.cn-java.com/" target="_blank" rel="noopener">http://www.cn-java.com/</a><br>（3）天新网 - 软件开发 - Java开发–<a href="http://dev.21tx.com/java/" target="_blank" rel="noopener">http://dev.21tx.com/java/</a><br>（4）视频教程《Java无难事视频教程》孙鑫<a href="http://www.enet.com.cn/eschool/zhuanti/java/" target="_blank" rel="noopener">http://www.enet.com.cn/eschool/zhuanti/java/</a><br>（5）ChinaJavaWorld.com技术论坛<a href="http://bbs.chinajavaworld.com/index.jspa" target="_blank" rel="noopener">http://bbs.chinajavaworld.com/index.jspa</a><br>（6）赛迪网技术社区 <a href="http://bbs.java.ccidnet.com/index.php" target="_blank" rel="noopener">http://bbs.java.ccidnet.com/index.php</a><br>（7）SUN中国技术社区 <a href="http://gceclub.sun.com.cn/" target="_blank" rel="noopener">http://gceclub.sun.com.cn/</a></p>
<h2 id="JAVA语言的特点"><a href="#JAVA语言的特点" class="headerlink" title="JAVA语言的特点"></a>JAVA语言的特点</h2><h2 id="简单、面向对象、与平台无关……"><a href="#简单、面向对象、与平台无关……" class="headerlink" title="简单、面向对象、与平台无关……"></a>简单、面向对象、与平台无关……</h2><ul>
<li><p>简单<br>风格类似于C++，易上手；<br>抛弃了C++中容易引发程序错误的一些特性，如指针、结构、枚举以及内存管理等；<br>Java提供了丰富的类库，可以帮助我们很方便的开发Java程序。</p>
</li>
<li><p>面向对象<br>面向对象可以说是Java最重要的特性，所以它支持继承、重载、多态等面向对象的特性。Java语言的设计是完全面向对象的，它不支持类似C语言那样的面向过程的程序设计技术。</p>
</li>
<li><p>分布式程序设计语言<br>面向网络的语言，编写网络应用程序</p>
</li>
<li><p>与平台无关、可移植性<br>“一次写入，到处运行”</p>
</li>
<li><p>健壮、安全、高性能、多线程、动态性等等</p>
</li>
</ul>
<h2 id="Java与C及C-的比较"><a href="#Java与C及C-的比较" class="headerlink" title="Java与C及C++的比较"></a>Java与C及C++的比较</h2><p>边学边比</p>
<h2 id="Java语言程序分类"><a href="#Java语言程序分类" class="headerlink" title="Java语言程序分类"></a>Java语言程序分类</h2><p>应用程序(Applicatiion)<br>可通过JVM独立运行的程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Hello</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println (&quot;hello world!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小程序(Applet)<br>必须嵌入到网页，由支持JVM的浏览器解释运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.*;</span><br><span class="line">import java.applet.*;</span><br><span class="line">public class AppletHello extends Applet</span><br><span class="line">&#123;</span><br><span class="line">	public void paint(Graphics g)</span><br><span class="line">	&#123;</span><br><span class="line">		g.drawString(&quot;hello,world!&quot;,20,20);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java程序开发过程"><a href="#Java程序开发过程" class="headerlink" title="Java程序开发过程"></a>Java程序开发过程</h2><h2 id="开发程序前，进行开发环境配置"><a href="#开发程序前，进行开发环境配置" class="headerlink" title="开发程序前，进行开发环境配置"></a>开发程序前，进行开发环境配置</h2><ul>
<li>安装JDK</li>
<li>选择安装开发工具<br>JDK＋记事本等文本编辑工具，可以直接使用JDK环境<br>JCreater、JBuilder、EClipes等集成开发环境</li>
</ul>
<h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><p>编写程序源文件</p>
<ul>
<li>源文件类型名为.java</li>
</ul>
<p>编译生成字节码文件</p>
<ul>
<li>生成的字节码文件类型名为.class</li>
</ul>
<p>运行</p>
<ul>
<li>应用程序运行：通过Java虚拟机独立运行程序</li>
<li>小应用程序运行：嵌入浏览器中运行</li>
</ul>
<h2 id="下载安装JDK5-0-可以下载最新版"><a href="#下载安装JDK5-0-可以下载最新版" class="headerlink" title="下载安装JDK5.0(可以下载最新版)"></a>下载安装JDK5.0(可以下载最新版)</h2><p>JDK5.0 (J2SDK1.5)</p>
<ul>
<li>从SUN公司网站下载(jdk-1_5_0_11-windows-i586-p.exe)<br><a href="http://java.sun.com/javase/downloads/index_jdk5.jsp" target="_blank" rel="noopener">http://java.sun.com/javase/downloads/index_jdk5.jsp</a></li>
<li>安装:根据提示安装</li>
</ul>
<p>JDK安装目录结构简介</p>
<ul>
<li>bin<br>javac: Java编译器，用来将java程序编译成字节码文件.class。<br>java:   Java解释器，执行已经转换成字节码的java应用程序。<br>appletviewer : Java虚拟浏览器， 用来解释嵌到网页中的java小应用程序。</li>
<li>lib:Java类库</li>
<li>Jre\lib：Java核心类库</li>
</ul>
<h2 id="JDK环境下程序编译与运行"><a href="#JDK环境下程序编译与运行" class="headerlink" title="JDK环境下程序编译与运行"></a>JDK环境下程序编译与运行</h2><h2 id="编写Java应用程序源文件"><a href="#编写Java应用程序源文件" class="headerlink" title="编写Java应用程序源文件"></a>编写Java应用程序源文件</h2><p>在D盘创建工作目录exam1(不是必须的)<br>在工作目录下，使用记事体程序编写文件名为HelloWorld.java<br>输入程序代码</p>
<h2 id="准备编译和运行程序（环境配置）"><a href="#准备编译和运行程序（环境配置）" class="headerlink" title="准备编译和运行程序（环境配置）"></a>准备编译和运行程序（环境配置）</h2><p>开始运行(cmd)，打开命令窗口<br>输入set path=”c:\program files\java\jdk1.5.0_11\bin”并回车，设置Java命令的搜索路径<br>输入d:并回车，将当前盘转至D盘<br>输入cd exam1并回车，当前目录转至我们的工作目录</p>
<h2 id="编译成字节码文件"><a href="#编译成字节码文件" class="headerlink" title="编译成字节码文件"></a>编译成字节码文件</h2><p>输入javac HelloWorld.java并回车，将源文件编译成字节码文件</p>
<h2 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h2><p>输入java HelloWorld并回车，执行程序</p>
<h2 id="Applet程序的运行"><a href="#Applet程序的运行" class="headerlink" title="Applet程序的运行"></a>Applet程序的运行</h2><p>编写源程序AppletHello.java<br>内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.*;</span><br><span class="line">import java.applet.*;</span><br><span class="line">public class AppletHello extends Applet</span><br><span class="line">&#123;</span><br><span class="line">	public void paint(Graphics g)</span><br><span class="line">	&#123;</span><br><span class="line">		g.drawString(&quot;hello,world!&quot;,20,20);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译为字节码文件AppletHello.class<br>运行<br>编写网页文件hello.html，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;applet code=&quot;AppletHello&quot; height=&quot;50&quot; width=&quot;200&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/applet&gt;</span><br></pre></td></tr></table></figure>
<p>用IE直接打开hello.html或者执行appletviewer  hello.html</p>
<h2 id="使用集成开发环境开发Java程序"><a href="#使用集成开发环境开发Java程序" class="headerlink" title="使用集成开发环境开发Java程序"></a>使用集成开发环境开发Java程序</h2><h2 id="集成开发工具简介"><a href="#集成开发工具简介" class="headerlink" title="集成开发工具简介"></a>集成开发工具简介</h2><ul>
<li>UltraEdit、EditPlus：文本编辑器，适用于初学者，只能编辑，编译和运行需要借助java命令。</li>
<li>Jcreater：功能较为强大，可以编辑、编译、调试运行。初学者使用的工具。</li>
<li>JBuilder：功能强大的集成开发工具，一般用于商业开发中，不适用于初学者。</li>
<li>Eclipes：功能强大的集成开发工具，免费，也常用于商业开发，不适用于初学者。</li>
</ul>
<h2 id="使用Jcreater编写Java应用程序"><a href="#使用Jcreater编写Java应用程序" class="headerlink" title="使用Jcreater编写Java应用程序"></a>使用Jcreater编写Java应用程序</h2><p>编辑<br>编译<br>运行</p>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><h2 id="JVM-Java-Virtual-Machine"><a href="#JVM-Java-Virtual-Machine" class="headerlink" title="JVM(Java Virtual Machine)"></a>JVM(Java Virtual Machine)</h2><ul>
<li>是一种利用软件方法来实现硬件功能的虚拟计算机。</li>
<li>是Java跨平台的保证</li>
<li>JVM的实现－Java运行时系统<br>嵌入Java运行时系统的应用程序，可以执行Java字节码文件</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>课程介绍<br>什么是Java?<br>学习目标与学习方法<br>Java语言简介<br>特点<br>程序分类<br>程序开发过程</p>
<h2 id="技能训练一-Java入门"><a href="#技能训练一-Java入门" class="headerlink" title="技能训练一 Java入门"></a>技能训练一 Java入门</h2><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>通过本次训练，使学生了解Java编程环境，掌握Java程序开发过程。</p>
<h2 id="训练内容"><a href="#训练内容" class="headerlink" title="训练内容"></a>训练内容</h2><p>1、编写一个简单的Java应用程序（源文件Hello.java），该程序在命令行窗口输出两行文字：“我叫XXX，来自XX班”、“我的爱好是XXX”。<br>2、写出在实训过程中涉及到的知识点及难点,遇到的问题和解决的办法，有哪些收获。<br>3、实验后的练习<br>（1）编译器如何提示丢失大括号的错误？<br>（2）编译器如何提示将System写成system的错误？<br>（3）编译器如何提示丢失行尾分号的错误？<br>（4）编译器如何提示程序文件名与类名不同的错误？</p>
<h2 id="技能训练二-熟悉Java语言开发过程"><a href="#技能训练二-熟悉Java语言开发过程" class="headerlink" title="技能训练二 熟悉Java语言开发过程"></a>技能训练二 熟悉Java语言开发过程</h2><h2 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h2><ul>
<li>使学生掌握Java开发环境的安装与配置，学会下载安装JDK开发工具包，掌握使用JDK环境开发Java程序的过程，掌握集成开发工具软件下载、安装和使用。</li>
</ul>
<h2 id="训练内容-1"><a href="#训练内容-1" class="headerlink" title="训练内容"></a>训练内容</h2><p>1、操作</p>
<ul>
<li>从Sun公司网站下载JDK5.0的标准版，并安装</li>
<li>使用记事本编写Java应用程序、Java小程序</li>
<li>使用javac命令编译，并检查生成的字节码文件</li>
<li>运行Java应用程序</li>
<li>编写小程序的嵌入网页文件，并运行</li>
</ul>
<p>2、总结实训过程中涉及到的知识点及难点,遇到的问题和解决的办法，有哪些收获</p>
<h2 id="JAVA-程序设计"><a href="#JAVA-程序设计" class="headerlink" title="JAVA  程序设计"></a>JAVA  程序设计</h2><p>课程的性质、任务</p>
<p>本课程是软件、网络技术专业的一门专业基础课程，是该专业理论与实践紧密结合的一门必修课，课程的任务是使学生掌握Java程序设计语言，理解面向对象的程序设计的思路和方法。</p>
<p>培养学生的编程能力。本课程的主要知识点群包括面向对象技术、异常处理、多线程、输入输出流、图形用户界面（GUI）设计、Applet开发、网络通信以及数据库使用等。</p>
<h2 id="第1讲-基本要求"><a href="#第1讲-基本要求" class="headerlink" title="第1讲    基本要求"></a>第1讲    基本要求</h2><p>了解Java的发展历史及基本特点<br>掌握Java虚拟机的概念<br>掌握Java2 SDK的开发环境的建立<br>掌握 Java Applet, Java Application的Java应用种类及运行操作</p>
<h2 id="实验一-JDK开发工具"><a href="#实验一-JDK开发工具" class="headerlink" title="实验一  JDK开发工具"></a>实验一  JDK开发工具</h2><ul>
<li>内容：从网上下载JDK工具、帮助文档并安装，编写一个小程序 </li>
<li>要求：掌握从网上下载JDK工具、帮助文档并安装、会使用 JDK运行程序 </li>
</ul>
<h2 id="第1章-Java语言概述"><a href="#第1章-Java语言概述" class="headerlink" title="第1章  Java语言概述"></a>第1章  Java语言概述</h2><p>1.1  Java的发展历史<br>1.2  Java的特点<br>1.3  Java程序的开发过程与运行环境<br>实训一  安装与熟悉Java开发工具<br>习题一 </p>
<h2 id="1-1-Java的发展历史"><a href="#1-1-Java的发展历史" class="headerlink" title="1.1  Java的发展历史"></a>1.1  Java的发展历史</h2><p>Java的产生</p>
<p>1995年5月，Sun公司在“SunWorld95”大会上推出了Java语言。Java语言作为一种网络编程语言，随着国际互联网的飞速发展，很快得到了广泛的支持和实际的应用。</p>
<p>了解内容：Java语言最初并不是为互联网设计的，它来自于Sun公司的一个叫“Green”的项目，目的是为家用消费电子产品开发一个分布式代码系统，这样用户可以把E-mail发给电冰箱、电视机等家用电器，对它们进行控制和信息交流。该项目小组开始准备采用C++，但他们很快意识到C++太复杂，安全性差，最后基于C++开发了一种新的语言Oak(Java的前身)。</p>
<p>Oak是一种用于网络的精巧而安全的语言，Sun公司曾以此投标一个交互式电视项目，但败于SGI，使得Oak几乎夭折。</p>
<p>Mark Ardreesen开发的Mosaic和Netscape启发了Oak项目组成员，他们用Java编制了HotJava浏览器，得到了Sun公司首席执行官Scott McNealy的支持，Java得以进军互联网。</p>
<p>目前通常所说的Java有三层含义：<br>首先是指一种编程语言；<br>其次是一种开发环境；<br>再者是一种应用环境。</p>
<h2 id="Java的现状"><a href="#Java的现状" class="headerlink" title="Java的现状"></a>Java的现状</h2><p>Java作为新一代面向对象的程序设计语言，特别适合于Internet应用程序开发，它的平台无关性使Java作为软件开发的一种革命性技术地位已被确立。</p>
<p>计算机产业的许多大公司购买了Java的许可证，包括IBM、Microsoft、Apple、Oracle等。</p>
<p>Java开发工具软件日渐丰富，如Borland公司的JBuilder、Sun公司的JavaWorkshop、IBM的VisualAge、微软公司的Visual J++。</p>
<p>数据库厂商如Sybase、Versant、Oracle都在开发CGI接口，支持HTML和Java。</p>
<h2 id="按照Java的应用领域"><a href="#按照Java的应用领域" class="headerlink" title="按照Java的应用领域"></a>按照Java的应用领域</h2><p>Sun公司将Java分为三个版本：</p>
<p>(1)  J2SE(Java 2 Platform，Standard Edition)。<br>J2SE含有基本的Java2 SDK工具和运行时API，开发者可以用来编写、部署和运行Java应用程序以及Applet(在Web浏览器(如IE)中运行的Java小程序)。</p>
<p>(2)  J2EE(Java 2 Platform，Enterprise Edition)。J2EE建立在J2SE的基础上，它是JSP(Java Server Page)、Servlet、EJB、JTS(Java Transaction Service)、Java mail以及JMS(Java Message Service)等多项技术的混合体，主要用于开发分布式、服务器端多层结构的应用系统，如电子商务网站。</p>
<p>(3)  J2ME(Java 2 Platform，Micro Edition)。它主要用于开发电子产品，如移动电话、数字机顶盒、汽车导航系统等。</p>
<h2 id="Java-的-特-点"><a href="#Java-的-特-点" class="headerlink" title="Java 的 特 点"></a>Java 的 特 点</h2><p> Java语言从诞生到得到很广泛的应用，只经过了短短的几年，这与它的特点是分不开的。</p>
<p> Java作者写了一个非常有影响的“白皮书”，来解释设计目标和已取得的成果。“白皮书”是按下列11个特征来定义的：</p>
<p>●  简单的；<br>●  面向对象的；<br>●  分布式的；<br>●  健壮的(Robust)；<br>●  安全的；<br>●  中立结构的；<br>●  可移植的；<br>●  解释型的；<br>●  高效的；<br>●  多线程的；<br>●  动态的。</p>
<h2 id="结构中立"><a href="#结构中立" class="headerlink" title="结构中立"></a>结构中立</h2><p>Java语言编译器产生的二进制代码是一种与具体机器指令无关的指令集合，只要有Java运行时系统存在，编译后的代码便可在许多处理器上运行。</p>
<p>Java运行时系统被称为Java虚拟机(Java Virtual Machine，JVM)，Java编译器产生的代码由Java虚拟机解释执行，如图1.1所示。由此，Java语言实现了平台独立性，“一次编写，随处运行(Write once，Run anywhere)”。</p>
<p>Java编译器产生的二进制代码称为字节码(Byte Code)，字节码与任何具体计算机结构都无关。实际上，这并不是一个新想法，多年前的UCSD Pascal系统就在一个商业产品中做了同样的努力，不过，Java解决了这种技术存在的一个主要缺点，即与通常高级语言采用的编译为机器指令相比，采用这种方式程序执行效率相差很多。</p>
<p>同体系结构无关的特性使得Java应用程序可以在配备了Java虚拟机的任何计算机系统上运行，这成为Java应用软件便于移植的良好基础。</p>
<p>另外，Java系统的基本数据类型不依赖于具体实现，在任何硬件平台上均保持一致。而通常的高级语言数据类型是与平台相关的，如C语言在Windows 3.1中整数(int)为16位，在Windows 95中整数为32位，在DECAlpha中整数为64位，在Intel486中整数为32位。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象可以说是Java最重要的特性，Java语言的设计完全是面向对象的，它不支持类似C语言那样的面向过程的程序设计技术。Java支持静态和动态风格的代码继承及重用。。</p>
<p>Java语言程序的基本单位是类class，一个完整的Java语言程序一般由多个类构成。</p>
<p>Java语言运行环境还提供了功能强大的类库(或称为应用程序接口API)，可以帮助应用程序很容易地实现一些复杂的功能。</p>
<h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><p>Java语言的简单性主要体现在以下三个方面：<br>(1)  Java的风格类似于C++，因而C++程序员是非常熟悉的。从某种意义上讲，Java语言是C及C++语言的一个变种，因此，C++程序员可以很快掌握Java编程技术。<br>(2)  Java摒弃了C++中容易引发程序错误的地方，如指针、内存管理、运算符重载等。<br>(3)  Java提供了丰富的类库</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>Java包括一个支持HTTP和FTP等基于TCP/IP协议的类库。</p>
<p>因此，Java应用程序访问网络上的对象很容易，其访问方式与访问本地文件系统几乎完全相同。为分布环境尤其是Internet提供动态内容无疑是一项非常宏伟的任务，但Java的语法特性却使得程序员可以很容易地实现这项目标。</p>
<h2 id="健壮"><a href="#健壮" class="headerlink" title="健壮"></a>健壮</h2><p>Java致力于检查程序在编译和运行时的错误。</p>
<p>类型检查帮助检查出许多开发早期出现的错误。Java自已操纵内存，减少了内存出错的可能性。Java还实现了真数组，避免了覆盖数据的可能。这些功能特征大大缩短了开发Java应用程序的周期。Java提供null指针检测、数组边界检测、异常出口和字节代码校验。</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>Java的安全性可从两个方面得到保证：<br>一方面，在Java语言里，指针和释放内存等C++功能被删除，避免了非法内存操作；<br>另一方面，当用Java来创建浏览器时，语言功能和浏览器本身提供的功能会结合起来，使它更安全。</p>
<blockquote>
<p>Java语言程序在机器上执行前，要经过多次测试。它经过代码校验，检查代码段的格式，检测指针操作、对象操作是否错误等。</p>
</blockquote>
<blockquote>
<p>如果字节码通过代码校验后，没有返回错误，则表示代码没有堆栈上溢出和下溢出，所有操作代码参数类型都是正确的，没有发生非法数据转换，如将整数转换成指针，访问对象操作是合法的。</p>
</blockquote>
<p>通过校验的代码由类装载器(ClassLoader)装载执行。类装载器通过将本机类与网络资源类的名称分开来保持安全性。因为装入类时要经过检查，所以避免了特洛伊木马现象的出现。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Java提供的多线程功能使得在一个程序里可同时执行多个小任务。多线程带来的更大的好处是更好的交互性能和实时控制性能。</p>
<p>Java是第一个支持多线程的程序设计语言，而传统的程序设计语言要实现多线程必须调用操作系统提供的有关编程接口。当然，Java虚拟机本身并不实现多线程机制，多线程的实现最终还取决于系统本身(UNIX、Windows等).</p>
<h2 id="Java程序的开发过程与运行环境"><a href="#Java程序的开发过程与运行环境" class="headerlink" title="Java程序的开发过程与运行环境"></a>Java程序的开发过程与运行环境</h2><h2 id="Java程序的开发过程"><a href="#Java程序的开发过程" class="headerlink" title="Java程序的开发过程"></a>Java程序的开发过程</h2><p>Java程序的开发过程与其他高级语言相似。</p>
<blockquote>
<p>首先编写程序，然后采用文本编辑软件输入源程序，再使用Java语言编译器进行编译，生成字节码文件。</p>
</blockquote>
<p>Java虚拟机直接执行字节码文件，没有连接生成独立的可执行文件的过程，Java类库代码也不像C/C++的函数库或类库那样需要连接到执行文件中去。</p>
<blockquote>
<p>Java语言最基本的开发环境是由Sun公司免费提供的JDK(Java Development Kit)，它的开发环境比较简单，使用命令行编译源代码，编译调试程序都不是很方便。</p>
</blockquote>
<blockquote>
<p>Java语言的集成开发工具，集源代码的编辑、编译以及调试于一体，而且这些开发工具可以帮助程序员生成应用程序框架，减少程序员的重复劳动，提高软件开发的效率。常见的集成开发工具有Microsoft公司的Visual J++、Borland公司的Jbuilder、IBM公司的VisualAge for Java等。</p>
</blockquote>
<h2 id="Application与Applet"><a href="#Application与Applet" class="headerlink" title="Application与Applet"></a>Application与Applet</h2><p>Java程序主要有Java应用程序(Java Application)和Applet两种。下面首先给出两个最简单的Java程序，从中可以了解Java语言程序的基本结构。</p>
<p>【程序1.1】  最简单的Java应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* HelloWorldApp.java */</span><br><span class="line"> </span><br><span class="line">class HelloWorldApp &#123;</span><br><span class="line">  /**</span><br><span class="line">  * 传统的 &quot;Hello World!&quot; 程序</span><br><span class="line">  **/</span><br><span class="line">  public static void main (String args[]) &#123;</span><br><span class="line">    // 输出到标准输出设备</span><br><span class="line">    System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序1.1是一个Java Application，它的功能很简单，向标准输出设备输出字符串“Hello World!”，运行该程序后可以在显示器上看到该字符串。</p>
<p>从程序1.1中首先看到的是注释语句，Java语言的注释语句与C/C++语言中的注释语句类似，有两种基本形式：</p>
<p>(1) 以/<em>开始，以</em>/结束。其中的所有字符在编译时被忽略。<br>(2) 行注释。以//开始到本行结束。</p>
<p>程序1.1定义了一个类HelloWorldApp，其中定义了一个方法main，方法类似于C语言的函数。</p>
<p>main方法是程序的入口点，Java应用程序从main方法开始执行，main方法执行结束则该程序退出运行。因此，如果一个程序由多个类构成，只能有一个类有main方法。</p>
<p>程序1.1使用了Java API完成字符串的输出功能，System.out为标准输出流对象，相当于C语言中的标准输出文件，println为其方法成员。println方法的功能为输出括号中的字符串或其他类型的数据并换行。类似的还有方法print，它与println的区别是输出数据后不换行。</p>
<p>与C语言中标准输入文件对应，Java语言中也有标准输入流System.in，不过它的功能与C语言标准输入文件相比较弱，Java语言只提供了从标准输入设备读入字符的方法，而没有提供读入其他类型数据的方法。如果希望直接从键盘输入一个整数或实数，必须用程序将从键盘输入的字符串转换为所需的类型。</p>
<p>Java Applet的执行环境与Java应用程序不同，Applet不是独立的应用程序，它是嵌入在HTML文件中使用的，程序被放置在Web服务器上，下载到客户端后，由Web浏览器(如微软的Internet Explorer)执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【程序1.2】  最简单的Java Applet。</span><br><span class="line">import java.applet.Applet;</span><br><span class="line">import java.awt.Graphics;</span><br><span class="line">public class HelloWorld extends Applet&#123;</span><br><span class="line">	public void paint(Graphics g)</span><br><span class="line">	&#123;</span><br><span class="line">		g.drawString (&quot;你好，Java世界！&quot;，2，20);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序1.2是一个最简单的Java Applet，下面是一个发布程序1.2的HTML文件的内容，请读者注意其中斜黑体的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;我的第一个Java Applet程序&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;p&gt;&lt;applet code=HelloWorld.class width=300 height=200&gt;&lt;/applet&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>将上述HTML文件和程序1.2编译得到的字节码文件HelloWorld.class放在Web服务器的同一个目录下，当使用Web浏览器浏览该HTML文件时，浏览器将下载HelloWorld.class，然后执行。</p>
<p>因为执行环境与Java Application不同，Applet的程序结构与Java Application也有所不同，当然它们有一点是共同的：都是由若干个类组成的。</p>
<blockquote>
<p>程序1.2的第1行相当于C语言中的#inlcude，表示该Applet程序需要引用Java的Applet类。</p>
</blockquote>
<p>不过，Java编译器的处理方法不同于C语言，它并不将该文件读入，而且它引用的是已经编译过的Java字节码文件。在编译阶段，Java编译器将从该字节码文件中读取有关Applet类的信息，检验程序中对Applet的使用是否正确。程序1.2编译生成的HelloWorld.class文件中也不包含Applet类的代码。</p>
<blockquote>
<p>第2行的作用与第1行类似，由于程序中用java.awt.Graphics类的功能来输出字符串，因此引入该类。</p>
</blockquote>
<blockquote>
<p>第3行开始定义HelloWorld类，注意后面的extends Applet，这是Java类继承语法。一个Applet程序可以由多个类构成，其中只有一个类继承于Applet类，这是Applet程序的入口。</p>
</blockquote>
<p>Applet的执行与Java Application不同，从程序中看不到像Application中main方法那样的一个明显的执行流程。</p>
<p>实际上这些都已经在Applet中实现了，Applet在执行时一直等待用户的输入或其他的一些事件(如关闭浏览器)，根据不同的事件执行不同的功能。</p>
<p>在编写Applet时需要做的就是提供各种事件的处理程序， 例如程序1.2类HelloWorld中定义了方法paint，该方法在Applet需要绘制界面时被调用。</p>
<p>Applet类中定义了paint方法的调用形式，它有一个Graphics类的对象作参数，通过它可以在Applet的界面上绘制图形和文字。程序1.2调用drawString方法来输出一个字符串：<br>g.drawString (“你好，Java世界！”，2，20);</p>
<p>drawString方法有三个参数：</p>
<ul>
<li>第一个是要输出的字符串；</li>
<li>第二、三个是输出位置，分别为x、y轴的值。</li>
</ul>
<p>图1.2是程序1.2在IE 6.0中执行的画面。</p>
<h2 id="JDK的安装与使用"><a href="#JDK的安装与使用" class="headerlink" title="JDK的安装与使用"></a>JDK的安装与使用</h2><p>JDK(Java Development Kit )是最基本的Java程序开发工具，可以从Java官方站点<br><a href="http://java.sun.com" target="_blank" rel="noopener">http://java.sun.com</a> 下载。目前该站点提供的正式版本是Java2 SDK 1.4.2，支持的平台有Windows、Linux、Solaris SPARC和Solaris x86，用户可选择合适的版本下载。</p>
<p>J2SE的下载页面为<a href="http://java.sun.com/j2se/1.4.2/download.html，" target="_blank" rel="noopener">http://java.sun.com/j2se/1.4.2/download.html，</a> 如图1.3所示，它提供了带集成开发环境和不带集成开发环境两种版本。</p>
<p>下面介绍Windows 98平台下不含集成开发环境的Java2 SDK 1.4.2的安装和使用。</p>
<p>1) 安装<br>运行下载的可执行文件，出现画面，选择“I accept the terms in the license agreement”，然后单击“Next”按钮，显示选择安装的项目。</p>
<p>如果不需安装演示程序和类库的源代码，可去掉安装项目中的“Demos”和“Source Code”。如果需要修改JDK安装的目录，点击“Change”按钮选择。最后单击“Next”按钮，进入画面，确定是否为系统当前已安装的Web浏览器安装了Java虚拟机插件。单击“Next”按钮开始复制文件和配置，最后画面，单击“Finish”按钮结束安装。</p>
<h2 id="JDK的使用"><a href="#JDK的使用" class="headerlink" title="JDK的使用"></a>JDK的使用</h2><p>JDK使用命令行方式进行编译。要调试Java程序，首先要使用文本编辑器输入保存Java源程序，然后编译执行。</p>
<h3 id="第一步：编辑源程序。"><a href="#第一步：编辑源程序。" class="headerlink" title="第一步：编辑源程序。"></a>第一步：编辑源程序。</h3><p>使用纯文本的编辑软件，如Windows 98的记事本(Notepad.exe)或MS-DOS的edit.exe。保存文件时注意文件名应与程序中的类名相同，程序1.1的文件名为HelloWorldApp.java(注意大小写)。</p>
<h3 id="第二步：编译源程序。"><a href="#第二步：编译源程序。" class="headerlink" title="第二步：编译源程序。"></a>第二步：编译源程序。</h3><p>在DOS命令提示符下执行(注意大小写)<br>javac HelloWorldApp.java </p>
<p>如果正常的话，将生成HelloWorldApp.class文件。</p>
<h3 id="第三步：运行程序。在DOS命令提示符下执行-注意大小写"><a href="#第三步：运行程序。在DOS命令提示符下执行-注意大小写" class="headerlink" title="第三步：运行程序。在DOS命令提示符下执行(注意大小写)"></a>第三步：运行程序。在DOS命令提示符下执行(注意大小写)</h3><p>java HelloWorldApp<br>注意不要输入文件的扩展名class。</p>
<h2 id="用JDK编译运行Java"><a href="#用JDK编译运行Java" class="headerlink" title="用JDK编译运行Java"></a>用JDK编译运行Java</h2><blockquote>
<p>Applet过程与编译运行Java应用程序类似，只是最后运行程序的方式不同。</p>
</blockquote>
<p>Java Applet可以在支持Java Applet的Web浏览器中运行，也可以使用JDK提供的appletviewer.exe。在DOS命令行中输入<br>appletviewer Page1.htm<br>这里，Page1.htm为程序1.2中的HTML文件。</p>
<h3 id="Visual-J-6-0的使用"><a href="#Visual-J-6-0的使用" class="headerlink" title="Visual J++ 6.0的使用"></a>Visual J++ 6.0的使用</h3><blockquote>
<p>Visual J++ 6.0是微软公司可视化集成开发环境Visual Studio 6.0的一个组成部分，Visual Studio是运行于Windows环境下的一个集成工具集，包括Visual C++、Visual J++和Visual InterDev等。</p>
</blockquote>
<p>Visual J++通过解决方案(Solution)和项目(Project)来组织程序。一个解决方案中可包含多个项目，每个项目相当于一个完整的程序，而解决方案相当于一个完整的应用系统。解决方案不可单独创建，在新建一个项目时会自动创建一个解决方案。图1.11是使用Visual J++调试程序1.2的画面，Visual J++创建了一个解决方案ch1-2，该解决方案包含一个项目ch1-2，而该项目由两个文件构成：HelloWorld.java和Page1.htm。</p>
<p>Visual J++ 6.0集成开发环境的功能很强大，限于篇幅，本书不详细介绍其使用方法，仅简单介绍如何使用Visual J++ 6.0调试Java应用程序和Java Applet。</p>
<p>1．用Visual J++调试Java应用程序</p>
<p>调试Java应用程序时，首先应为要调试的应用程序创建一个项目，在File菜单下选择“New Project”，弹出图1.12所示的对话框。在左边的树形列表中选择“Visual J++ Projects”→“Applications”，然后在右侧的列表中选择“Console Application”，在对话框下部的Name编辑框中输入项目名，在Location编辑框中输入项目文件存放的目录或单击“Browse”按钮选择一个目录。最后单击“打开”按钮，Visual J++将创建新项目。</p>
<p>对于Java应用程序，Visual J++自动创建了一个文件Class1.java，并给出了类的声明和main方法的声明，用户可在此基础上修改。</p>
<p>首先在解决方案窗口中展开该项目，然后在Class1.java文件名上单击鼠标右键，选择“Rename”，如图1.13所示，修改文件名。对于程序1.1应将文件名修改为HelloWorldApp.java，然后双击文件名打开源程序编辑窗口修改程序。</p>
<p>源程序输入完成后，选择Debug菜单的子功能即可执行程序。第一次执行可能会出现图1.14所示的对话框，原因是在创建该项目时，设定执行的类为Class1。单击“确定”按钮会出现图1.15所示的对话框，再单击“OK”按钮就可以，此时设定执行的类已改为HelloWorldApp。该窗口也可以通过“Project”菜单的子功能激活，然后修改要执行的类。</p>
<p>当然，如果源程序有错误，程序将不能正常编译执行，错误信息会显示在Task List窗口上。</p>
<p>选择File菜单的子功能Close All可以关闭当前打开的所有项目，Save All可保存当前项目的信息。Visual J++中解决方案保存的文件的扩展名为.sln，项目保存的文件的扩展名为.vjp，可以在以后再次打开。</p>
<p>用Visual J++调试Java Applet</p>
<p>用Visual J++调试Java Applet的步骤与调试Java应用程序基本相同，也需要先创建一个项目。在选择项目类型时，首先在左边的树形列表中选择Web Pages，然后在右边选择Applet on HTML。</p>
<p>Visual J++为新项目生成两个文件：Applet1.java和Page1.htm。Applet1.java提供了一个比较复杂的Applet程序的框架，对于程序1.2这样的Applet，可以将原来的代码删除。与Java应用程序类似，也应保持文件名与类名的一致。Page1.htm是Visual J++提供的一个HTML文档，用于在Web浏览器中调试Applet。</p>
<p>Visual J++提供了两种调试运行Applet的方法，可以在项目的Properties对话框中选择。选择运行HTML文件将使用Web浏览器，而选择运行Java类将使用微软公司提供的与appletviewer相似的WJView.exe。</p>
<h2 id="实训一-安装与熟悉Java开发工具"><a href="#实训一-安装与熟悉Java开发工具" class="headerlink" title="实训一  安装与熟悉Java开发工具"></a>实训一  安装与熟悉Java开发工具</h2><p>JDK开发工具</p>
<p>一、实训目的</p>
<ol>
<li>学习从网络下载JDK开发工具与帮助文档。</li>
<li>学习安装JDK开发工具及其文档。</li>
<li>掌握Java Appllcation程序的开发过程并编写一个Java Application程序。</li>
<li>掌握Java Applet程序的开发过程并编写一个Java Applet程序。</li>
<li>学习编写简单的HTML文件，配合Java Applet使用。</li>
<li>学习使用JDK的帮助文档。</li>
</ol>
<p>二、实训内容</p>
<p>1．从网络下载JDK开发工具与帮助文档。</p>
<p>(1)访问 <a href="http://java.sun.com，" target="_blank" rel="noopener">http://java.sun.com，</a> 浏览JDK下载页面,J2SE v 1.4.2的下载页面为 <a href="http://java.sun.com/j2se/1.4.2/download.html" target="_blank" rel="noopener">http://java.sun.com/j2se/1.4.2/download.html</a> 也可以通过访问其他国内外的免费FTP站点或从CD-ROM光盘中下载得到JDK开发工具。 </p>
<p>(2) 选择适合本地实验计算机平台的软件版本，运行Windows 95 / 98的计算机，应选择“Windows Installation”版本的JDK开发工具，即单击图1.18所示的链接。</p>
<p>单击此链接后，所示的网页，点击指定的链接。所示的页面中单击             按钮接受有关软件下载的协议，单击下载链接，如果采用Internet Explorer则出现所示保存文件的提示，单击            按钮，在所示的对话框中选择保存的目录。</p>
<p>(3) 按同样的方法下载JDK的帮助文档。</p>
<p>安装JDK开发工具与帮助文档。</p>
<p>(1) 运行下载的可执行文件，按照1.3节介绍的步骤安装JDK。<br>(2) 为方便运行Java编译器，设置环境变量Path。对于Windows 95/98，修改计算机的C:\AUTOEXEC.BAT文件时应在文件末增加一句：<br>set  Path=%Path%;C:\j2sdk1.4.2\bin<br>这里，C:\j2sdk1.4.2为JDK的安装目录。</p>
<blockquote>
<p>对于Windows XP及Windows 2000等平台，在控制面板中选择系统，在系统属性对话框中单击按钮。然后在“系统变量”列表中选择“Path”，然后单击按钮，在出现的对话框中仿照上面的set命令将C:\j2se1.4.2\bin加入到Path环境变量中。</p>
</blockquote>
<p>使用解压缩工具Winzip将JDK帮助文档j2sdk-1_4_2-doc.zip文件解压，该压缩文件包含一组以HTML文件形式组织的帮助文件，把它们保存在本地的一个目录下，例如保存在C:\j2sdk1.4.2\document\目录下。</p>
<h2 id="编写并运行一个Java-Application程序"><a href="#编写并运行一个Java-Application程序" class="headerlink" title="编写并运行一个Java Application程序"></a>编写并运行一个Java Application程序</h2><p>(1) 打开一个纯文本编辑器，例如Windows记事本NotePad.exe或DOS下的edit.exe。</p>
<p>(2) 键入1.2节中的程序1.1。</p>
<p>(3) 检查无误后(注意大小写准确)把文件保存起来，命名为HelloWorldApp.java，可以创建一个目录，如C:\Java\prog1_1，保存这个文件。</p>
<p>(4) 进入DOS命令行方式，用cd命令进入(3)中创建的目录，运行Java编译器：<br>javac HelloWorldApp.java</p>
<p>(5) 如果JDK安装正确、程序输入无误且保存的文件名正确，运行编译器没有任何输出；否则，会输出错误信息，一般的错误都是由于拼写失误引起的。运行dir命令查看是否已在相同目录下生成一个名为HelloWorldApp.class的文件。</p>
<p>(6) 利用Java解释器运行这个Java Application程序，并查看运行结果：java HelloWorldApp</p>
<h2 id="编写并编译一个Java-Applet程序。"><a href="#编写并编译一个Java-Applet程序。" class="headerlink" title="编写并编译一个Java Applet程序。"></a>编写并编译一个Java Applet程序。</h2><p>(1) 打开一个纯文本编辑器。<br>(2) 键入1.2节的程序1.2。<br>(3) 创建一个目录，保存文件，命名为HelloWorld.java。<br>(4) 进入DOS命令行方式，在保存有上述Java文件的目录下运行Java编译器：<br>javac HelloWorld.java<br>(5) 如果程序输入无误且保存的文件名正确，运行编译器将没有任何输出；否则，会输出错误信息。运行dir命令查看是否已在相同目录下生成—个名为HelloWorld.class的文件。</p>
<h2 id="编写配合Applet的HTML文件。"><a href="#编写配合Applet的HTML文件。" class="headerlink" title="编写配合Applet的HTML文件。"></a>编写配合Applet的HTML文件。</h2><p>(1) 打开一个纯文本编辑器。<br>(2) 键入如下的HTML程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;我的第一个Java Applet程序&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;p&gt;&lt;applet code=HelloWorld.class width=300 height=200&gt;&lt;/applet&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>(3) 检查无误后把文件命名为Page1.htm，保存在与文件HelloWorld.java同一目录下。<br>(4) 直接双击这个HTML文件的图标，或者打开Web浏览器(例如IE)，在地址栏中键入这个HTML文件的全路径名，查看Applet在浏览器中的运行结果。<br>(5) 利用模拟的Applet运行环境解释运行这个Java Applet程序并观察运行结果。进入DOS环境，在程序所在目录下运行下面的命令：<br>appletviewer Page1.htm</p>
<h2 id="使用JDK帮助文档。"><a href="#使用JDK帮助文档。" class="headerlink" title="使用JDK帮助文档。"></a>使用JDK帮助文档。</h2><p>在Windows中打开JDK文档目录，双击index.html文件，或者在Web浏览器的地址栏中输入这个文件的全路径名，打开这个文件对应的网页，查阅相关内容。<br>B．Visual J++ 6.0集成开发环境</p>
<p>一、实训目的</p>
<ol>
<li>学习安装Visual J++ 6.0集成开发环境。</li>
<li>掌握集成开发环境(IDE)的概念，了解并学习使用Visual J++开发环境的基本构成和功能。</li>
<li>了解“项目”的概念，掌握利用Visual J++开发并编译运行一个Java Application的过程。</li>
<li>了解“可视化开发”的概念，掌握利用Visual J++的向导开发一个Java Applet的过程。</li>
<li>给出Java Applet和Java Application例子，调试程序、修改程序功能。 </li>
</ol>
<p>二、实训内容<br>1．安装Visual J++ 6.0。<br>Visual J++ 6.0集成开发环境可以从CD-ROM光盘上安装，也可以从网络上利用共享目录安装，整个安装过程是自动完成的，用户只要给出安装到本机的目录、选择安装选件(通常选择“典型安装”)即可。</p>
<p>2．编写并运行第一个Java Application程序。<br>Visual J++是以“项目”(Project)来组织应用开发的。一个完整的应用通常由若干个源程序文件和辅助性文件构成，同时，为了保证开发的连续性，开发工具通常还会记录用户的桌面安排和其他种种设置。Visual J++中所有这些与一个应用开发任务相关的文件被放在一个目录中，称为一个Project。</p>
<p>(1) 新建—个空项目(Empty Project)。通过Windows 95/98“开始”菜单的“程序”选项选择“Microsoft Visual J++ 6.0”，打开Visual J++开发环境，出现“New Project”窗口(见图1.12)。<br>选中图标左边区域的“Visual J++ Projects”一项，右边的图标变成一个“Empty Project”，如图1.27所示，选中该图标。然后在对话框下方的“Location”一栏输入新建项目所在的目录，在“Name”一栏中输入新建项目的名称，然后单击“打开”按钮。系统将在指定目录中为这个项目生成一个指定名称的子目录，以保存这项目中的所有文件。</p>
<p>(2) 加入并编辑Java Application源程序。选中位于屏幕右上方的窗口“Project Explorer”，选中项目名，用鼠标右键单击项目名前的的图标，选择弹出菜单的“Add”菜单项的“Add Class”子菜单项所示的对话框。</p>
<p>第二个图标“ClassMain”，然后在“Name”栏中输入类名HelloWorldApp.java，点击“打开”按钮，系统将创建一个名为HelloWorldApp.java的源代码文件，将其加入当前项目并打开编辑这个源代码文件的窗口，其中包含系统自动生成的几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldApp</span><br><span class="line">              &#123;</span><br><span class="line">		       public static void main(String[] args)</span><br><span class="line">		            &#123;</span><br><span class="line">	             &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<p>按照程序1.1修改该文件，然后选择File菜单下的“Save HelloWorldApp”子菜单保存该文件。</p>
<p>(3) 编译并运行Java Application程序。选择“Build”菜单的“Build”选项编译该程序，屏幕最下方的状态条将显示“Solution update succeeded”，表示编译成功。选择“Debug”菜单的“start”选项即可运行此程序。程序第一次运行时，系统需要了解这个项目的有关属性。</p>
<p>由于程序是采用字符界面，因此以系统将打开一个字符界面的窗口，在其中运行该程序。这个字符界面的窗口将在程序运行完毕后自动关闭，读者可能来不及查看运行结果。为解决这个问题，可将光标定位到main方法结束的大括号处，然后选择“Debug”菜单的“Run to cursor”运行程序，程序运行到光标所在处后暂停，此时可切换到程序的字符界面窗口查看，然后再选择“Debug”菜单的“start”选项继续。</p>
<h2 id="编写并调试一个Java-Applet程序"><a href="#编写并调试一个Java-Applet程序" class="headerlink" title="编写并调试一个Java Applet程序"></a>编写并调试一个Java Applet程序</h2><p>(1) 新建Applet项目。按照1.3.4节介绍的步骤创建一个Applet项目。<br>(2) 编辑Applet源代码。按照程序1.2的清单修改Applet1.java文件。<br>(3) 修改Applet1.java文件名。 将文件名中的Applet1改为类名HelloWorld</p>
<p>修改HTML文档。在Project Explorer窗口中双击Page1.htm文件打开编辑窗口，用鼠标单击Applet显示区。然后，所示的Properties窗口中将code属性修改为HelloWorld.class，可同时修改height、width属性，调整Applet在浏览器中显示区域的大小。</p>
<p>HTML文档的编辑窗口有三页视图：第一页Design，可以利用屏幕左边Toolbox窗口中的HTML工具可视化地加入一些图形界面组件，如文本区域、按钮等(注意：这些组件是加入到HTML文件中，不是Applet中)；第二页Source，显示HTML的具体代码，其中蓝色的区域是HTML中所嵌入的Applet的显示效果；第三页QuickView，显示整个HTML在浏览器中的显示效果。</p>
<p>如果想以文本方式编辑HTML文档，可选择第二页视图，选中代表Applet的矩形区域，单击鼠标右键，在弹出的菜单中选择“Always View As Text”菜单项。</p>
<p>(5) 运行Applet程序。</p>
<h3 id="使用Visual-J-的调试功能。"><a href="#使用Visual-J-的调试功能。" class="headerlink" title="使用Visual J++的调试功能。"></a>使用Visual J++的调试功能。</h3><p>Visual J++的集成环境的调试功能很强大，开发人员启动调试功能后，可以介入程序的运行过程，能够分解、控制程序的运行或使程序在指定条件下运行，并随时查看运行的中间结果，极大地方便了开发人员，也提高了开发效率。</p>
<p>(1) 打开已有项目。选择File菜单的“Close All”菜单项关闭当前的项目及其中的所有文件，如果该项目修改后尚未保存，则系统将询问“是否保存当前项目中修改过的文件”，此时选择“Yes”。</p>
<p>选择File菜单的“Open Project”菜单项，打开“Open Project”对话框，找到HelloWorldApp应用程序所在的目录，选择所列出的文件(共列出两个文件，分别为 .sln文件和 .vjp文件，可选择其中任意一个)，点击“打开”按钮关闭对话框，系统打开前面创建的Java Application项目。</p>
<p>(2) 修改源代码。打开HelloWorldApp.java源程序编辑窗口，将程序修改为下面的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* HelloWorldApp.java */	</span><br><span class="line">import java.lang.System;</span><br><span class="line">	</span><br><span class="line">class HelloWorldApp &#123;</span><br><span class="line"> /**</span><br><span class="line"> * Traditional &quot;Hello World!&quot; program.</span><br><span class="line"> **/</span><br><span class="line"> public static void main (String args[]) &#123;</span><br><span class="line">	 char c;</span><br><span class="line">	 try&#123;</span><br><span class="line">		 c = System.in.read();</span><br><span class="line">		// 输出到标准输出设备</span><br><span class="line">		System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">	 &#125;catch(IOException e)&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>排除编译错误。选择Build菜单的Build选项，系统下方的状态条将提示“Solution failed”，表示出现了编译错误。错误内容显示在屏幕下方的TaskList窗口中。</p>
<p>该程序共有三个编译错误，双击第一行错误信息，光标将停留在源程序编辑窗口中发生该错误的那一行。产生这个错误是由于System.in.read方法的返回值为int类型，不能直接赋给char类型的变量c。将这行语句改为</p>
<p>c = (char)System.in.read();</p>
<p>从错误提示信息可以看出，第二个错误与第三个错误实际上都是由IOException这个标识符引起的。上面的程序使用了Java语言的异常处理机制，IOException是为Java类库提供的一个异常类，该程序中未引入该类，因此产生错误。在程序头部加上下面的语句即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br></pre></td></tr></table></figure></p>
<p>再次编译，系统显示“Solution update Succeeded”，表明错误已排除。</p>
<p>调试。排除了编译错误不等于程序就一定正确，如果程序里还包含了一些逻辑错误，则需要深入程序内部，动态地控制程序的运行过程，观察各种中间现象和中间结果。</p>
<p>调试一个程序所用的命令都在Debug菜单中，也可以使用专用的Debug工具条。选择View菜单的Toolbar菜单项，在打开的子菜单中选择Debug，系统将显示debug工具条.</p>
<p>在源代码编辑窗口中把光标移到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这一行，点击Debug工具条中的“运行到光标”(Run to cursor)按钮，程序将运行，输入一个字符换行后程序在指定行之前停止，源代码窗口中该指定行左边出现一个黄色的箭头。同时，系统将在屏幕下方打开观察程序内各变量取值的窗口和Watch窗口(如果未出现，可以点击Debug工具条上的对应按钮)，选择变量取值窗口的第二页Locals，可以观察到程序中局部变量的取值情况。</p>
<p>单步运行是调试的重要手段，单步运行时用户每发出一个单步命令，程序从当前位置开始运行一个语句。Debug菜单条中有三个单步运行按钮，它们是“Step Into”、  “Step Over”和“Step Out”，分别代表跟踪当前语句中的方法调用、不跟踪方法调用一次执行完当前语句和运行完当前循环并跳出。</p>
<p>Watch窗口用于在调试过程中观察指定变量的值，可在“Name”栏中输入变量名并回车，如果需要观察多个变量的值，可重复上述过程。</p>
<p>调试程序常用的另一种手段是设置断点，当程序运行到断点时，回到集成环境。可以观察变量的值，然后继续执行。</p>
<h2 id="习-题-一"><a href="#习-题-一" class="headerlink" title="习  题  一"></a>习  题  一</h2><h2 id="1．编译型语言与解释型语言是如何划分的"><a href="#1．编译型语言与解释型语言是如何划分的" class="headerlink" title="1．编译型语言与解释型语言是如何划分的?"></a>1．编译型语言与解释型语言是如何划分的?</h2><p>答：编译型语言在程序执行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序的时候，就不用再进行翻译了。</p>
<p> 解释型语言，是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。</p>
<p> C/C++ 等都是编译型语言，而Java，C#等都是解释型语言。</p>
<p> 虽然Java程序在运行之前也有一个编译过程，但是并不是将程序编译成机器语言，而是将它编译成字节码（可以理解为一个中间语言）。</p>
<p> 在运行的时候，由JVM将字节码再翻译成机器语言。</p>
<p> 注：脚本语言一般都有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。JAVASCRIPT,ASP,PHP,PERL,Nuva都是脚本语言。C/C++编译、链接后，可形成独立执行的exe文件。</p>
<p> 4.脚本语言是一种解释性的语言,例如vbscript,javascript,installshield script,ActionScript等等,它不象c\c++等可以编译成二进制代码,以可执行文件的形式存在.</p>
<p> 脚本语言不需要编译，可以直接用，由解释器来负责解释。 </p>
<p> 5.脚本语言一般都是以文本形式存在,类似于一种命令. </p>
<p> 举个例子说,如果你建立了一个程序,叫aaa.exe,可以打开.aa为扩展名的文件.<br> 你为.aa文件的编写指定了一套规则(语法),当别人编写了.aa文件后,你的程序用这种规则来理解编写人的意图,并作出回应.那么,这一套规则就是脚本语言</p>
<h3 id="百度来源答案："><a href="#百度来源答案：" class="headerlink" title="百度来源答案："></a>百度来源答案：</h3><p>编译型语言与解释型语言</p>
<p>计算机是不能理解高级语言的，更不能直接执行高级语言，它只能直接理解机器语言，所以使用任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言，也就是机器码。</p>
<p>而这种转换的方式有两种：</p>
<p>1）编译</p>
<p>2）解释</p>
<p>由此高级语言也分为编译型语言和解释型语言。</p>
<h3 id="编译型语言："><a href="#编译型语言：" class="headerlink" title="编译型语言："></a>编译型语言：</h3><p>使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。</p>
<p>特点：</p>
<p>在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。</p>
<p>总结：</p>
<p>1）一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</p>
<p>2）与特定平台相关，一般无法移植到其他平台；</p>
<p>3）现有的C、C++、Objective等都属于编译型语言。</p>
<h3 id="解释型语言："><a href="#解释型语言：" class="headerlink" title="解释型语言："></a>解释型语言：</h3><p>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。</p>
<p>特点：</p>
<p>解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。</p>
<p>总结：</p>
<p>1）解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</p>
<p>2）只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</p>
<p>3）Python等属于解释型语言。</p>
<h2 id="Java属于哪种类型语言"><a href="#Java属于哪种类型语言" class="headerlink" title="Java属于哪种类型语言?"></a>Java属于哪种类型语言?</h2><p>来源百度：</p>
<p>Java是一种计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。</p>
<p>Java不同于一般的编译语言和直译语言。它首先将源代码编译成字节码，然后依赖各种不同平台上的虚拟机来解释执行字节码，从而实现了“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。</p>
<h2 id="Java程序的编译和解释有何特点"><a href="#Java程序的编译和解释有何特点" class="headerlink" title="Java程序的编译和解释有何特点?"></a>Java程序的编译和解释有何特点?</h2><p>编译执行和解释执行是不同语言之间的特性，所有的java都是编译执行的。 如果不是编译执行，其实已经完全不用java的编译器。那么只是一个使用java语法的另一种语言而已。</p>
<p>编译执行是指把代码先编译成机器码。然后按顺序运行，如果编译中有任何异常，都无法继续运行。java的编译就是把java转换成class。<br>而解释执行则是运行到哪一行代码就执行哪一行代码。如果其他代码有错误但没有运行到，一般不会影响。 </p>
<p>比较起来，编译执行速度要快的多。而解释执行则在于比较灵活。可以动态修改。甚至可以在代码运行到指定语句之前，修改该代码。</p>
<p>1、java编译生成的字节码，在所有操作系统都是一样，故其有这样的特点：<br>write once, run anywhere.其意思：只需要一次编码，就可以在任何环境下运行。</p>
<p>2、不同的操作系统，其java虚拟机是不一样的。虚拟机将java字节代码转换对应操作系统的相关指令，保证其正常运行。</p>
<p>3、java 系统支持所有的硬件的平台，不存在你提及的问题，你可以放心使用。</p>
<p>4、解释器在java虚拟机中，编译器在JDK或JRE 中。</p>
<p>5、java虚拟机就是常说的java 运行环境，其缩写是 JRE，安装在操作系统下的一个目录中，这个目录在安装时可以由你自行指定，就像你安装其它应用软件一样。JDK中包含了JRE，还有开发环境，如编译器，帮助文档生成器，以及系统API的jar库文件等。</p>
<h2 id="这些特点对于Java成为Internet上的编程语言有什么影响"><a href="#这些特点对于Java成为Internet上的编程语言有什么影响" class="headerlink" title="这些特点对于Java成为Internet上的编程语言有什么影响?"></a>这些特点对于Java成为Internet上的编程语言有什么影响?</h2><p>Java编程语言并不是为Internet、www而设计的，它还可以用来编写独立的应用， Java编程是一种面向对象语言，Java语言类似于C++语言。Java程序需要编译，它被放置在Internet服务器上，当用户访问服务器时，Java程序被下载到本地的用户机上，由浏览器解释运行。实际上有两种Java程序：一种Java应用程序是一个完整的程序，如Web浏览器。另一种Java小应用程序是运行于Web浏览器中的一个程序。</p>
<p>Java程序和它的浏览器HotJava，提供了可让你的浏览器运行程序的方法。你能从你的浏览器里直接播放声音，你还能播放页面里的动画，Java还能告诉你的浏览器怎样处理新的类型文件。当我们能在2400 baud线上传输视频图象时，HotJava将能显示这些视频。</p>
<p>Java在电子商务方面的应用和特性</p>
<p>电子商务要求程序代码具有基本的要求：安全、可靠、同时要求能与运行于不同平台的机器的全世界客户开展业务。Java以</p>
<p>其强安全性、平台无关性、硬件结构无关性、语言简洁同时面向对象，在网络编程语言中占据无可比拟的优势，成为实现电子商务系统的首选语言。</p>
<p>在桌面应用上，尽管Java在桌面GUI方面尚有不尽如人意之处，但仍然有很多开发者用来开发运行在多种操作系统平台上的</p>
<p>桌面应用。具体应用在如下几个领域:</p>
<ol>
<li>行业和企业信息化</li>
</ol>
<p>由于Sun、IBM、Oracle、BEA等国际厂商相继推出各种基于Java技术的应用服务器以及各种应用软件，带动了Java在金融电信、制造等领域日益广泛的应用。如清华大学计算机系利用Java、XML和Web技术研制开发了多个软件平台，东方科技的Tong Web、金碟的Apusic、中创的Inforweb 等J2EE应用服务器及和佳ERP和宝信ERP等ERP产品，已在许多企业得到应用。</p>
<ol start="2">
<li>电子政务及办公自动化</li>
</ol>
<p>东方科技、金碟、中创等开发的J2EE应用服务器在电子政务及办公自动化中也得到应用: 如金碟的Apusic在民政部、广东省市工商局应用; 东软电子政务架构EAP平台在社会保险、公检法、税务系统得到应用; 中创的Inforweb等Infor系列中间件产品在国家海事局、山东省政府及中国建设银行、民生银行等金融系统应用; 无锡永中科技基于Java平台开发的国产化集成办公软件Office”也已在一些省市政府部门得到应用。</p>
<ol start="3">
<li>嵌入式设备及消费类电子产品</li>
</ol>
<p>无线手持设备、通信终端、医疗设备、信息家电(如数字电视、机顶盒、电冰箱)、汽车电子设备等是今年以来比较热门的Java应用领域。在这方面的应用有中国联通CDMA 1X网络中基于Java技术的无线数据增值服务——UniJa</p>
<p>来源：<a href="http://www.sohu.com/a/155169478_445013" target="_blank" rel="noopener">http://www.sohu.com/a/155169478_445013</a></p>
<h2 id="2．JDK的编译命令是什么"><a href="#2．JDK的编译命令是什么" class="headerlink" title="2．JDK的编译命令是什么?"></a>2．JDK的编译命令是什么?</h2><p>1、window+R 2、在窗口里输入 cmd 3、进入你放java的文件目录下 4、javac 文件名.java (这个是编译) 5、java 文件名 (执行)  前提是你装了JDK才能编译和执行！！！</p>
<h2 id="如果编译结果报告说找不到要编译的源代码，通常会是哪些错误"><a href="#如果编译结果报告说找不到要编译的源代码，通常会是哪些错误" class="headerlink" title="如果编译结果报告说找不到要编译的源代码，通常会是哪些错误?"></a>如果编译结果报告说找不到要编译的源代码，通常会是哪些错误?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=C:\Program Files\Java\jdk1.8.0_40</span><br><span class="line">PATH=%JAVA_HOME%\bin;</span><br><span class="line">CLASSPATH=.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre></td></tr></table></figure>
<h2 id="3．运行编译好的字节码文件使用什么命令-什么是JIT-什么是JVM"><a href="#3．运行编译好的字节码文件使用什么命令-什么是JIT-什么是JVM" class="headerlink" title="3．运行编译好的字节码文件使用什么命令? 什么是JIT? 什么是JVM?"></a>3．运行编译好的字节码文件使用什么命令? 什么是JIT? 什么是JVM?</h2><p>javac针对.java文件，编译源代码为字节码文件<br>java针对.class文件，JVM解释执行程序</p>
<h3 id="什么是JIT"><a href="#什么是JIT" class="headerlink" title="什么是JIT"></a>什么是JIT</h3><p>1、动态编译（dynamic compilation）指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫静态编译（static compilation）。</p>
<p>2、JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。JIT编译一词后来被泛化，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别。<br>3、自适应动态编译（adaptive dynamic compilation）也是一种动态编译，但它通常执行的时机比JIT编译迟，先让程序“以某种式”先运行起来，收集一些信息之后再做动态编译。这样的编译可以更加优化。</p>
<p>来源：<a href="https://blog.csdn.net/sunxianghuang/article/details/52094859" target="_blank" rel="noopener">https://blog.csdn.net/sunxianghuang/article/details/52094859</a></p>
<p>来源：<a href="https://baike.baidu.com/item/JVM/2902369?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/JVM/2902369?fr=aladdin</a></p>
<p>JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
<p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>byte://1字节有符号整数的补码<br>short://2字节有符号整数的补码<br>int://4字节有符号整数的补码<br>long://8字节有符号整数的补码<br>float://4字节IEEE754单精度浮点数<br>double://8字节IEEE754双精度浮点数<br>char://2字节无符号Unicode字符</p>
<p>其它数据类型<br>object//对一个Javaobject（对象）的4字节引用<br>returnAddress//4字节，用于jsr/ret/jsr-w/ret-w指令</p>
<h3 id="JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是："><a href="#JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是：" class="headerlink" title="JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是："></a>JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是：</h3><p>JVM 指令系统<br>JVM 寄存器<br>JVM 栈结构<br>JVM 碎片回收堆<br>JVM 存储区</p>
<h3 id="JVM执行程序的过程-："><a href="#JVM执行程序的过程-：" class="headerlink" title="JVM执行程序的过程 ："></a>JVM执行程序的过程 ：</h3><p>I.加载.class文件<br>II.管理并分配内存<br>III.执行垃圾收集</p>
<p>JRE（java运行时环境）包含JVM的java程序的运行环境</p>
<p>JVM是Java程序运行的容器,但是他同时也是操作系统的一个进程,因此他也有他自己的运行的生命周期,也有自己的代码和数据空间。</p>
<p>JVM在整个jdk中处于最底层,负责与操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也叫虚拟计算机.</p>
<p>操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境。</p>
<p>1.创建JVM装载环境和配置<br>2.装载JVM.dll<br>3.初始化JVM.dll并挂接到JNIENV(JNI调用接口)实例<br>4.调用JNIEnv实例装载并处理class类。 </p>
<h2 id="4．Java程序分为哪两大类？它们之间有哪些差别"><a href="#4．Java程序分为哪两大类？它们之间有哪些差别" class="headerlink" title="4．Java程序分为哪两大类？它们之间有哪些差别?"></a>4．Java程序分为哪两大类？它们之间有哪些差别?</h2><p>Application和Applet是两个概念，前者指的是一个完整程序，后者指的是一个小程序，作为一个完整程序他具有一定的独立性，玩过手机游戏都知道一个手机游戏对应一个jar文件，这个jar文件就相当于一个Application，你运行游戏只需要选中它运行即可，不需要先启动另外一个程序后才能启动它。</p>
<p>而Applet则需要先启动浏览器后才能运行它。Applet因为小可以被看作一个软件组件，他可以作为一个动态网站的一个组成部分，Applet的主要用途是完成复杂的逻辑，这个是在JAVASCRIPT等脚本语言和JSP和ASP等动态网页技术还没出现时负责动态的显示数据的作用，类似微软的ActiveX组件。</p>
<h3 id="在JAVA领域有三个“let”："><a href="#在JAVA领域有三个“let”：" class="headerlink" title="在JAVA领域有三个“let”："></a>在JAVA领域有三个“let”：</h3><p>MIDlet：移动设备应用程序<br>Servlet:服务器程序<br>Applet:浏览器小程序</p>
<p>来源：<a href="https://zhidao.baidu.com/question/2265873673648119708.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/2265873673648119708.html</a></p>
<h2 id="5．Java程序中有哪几种注释方式？"><a href="#5．Java程序中有哪几种注释方式？" class="headerlink" title="5．Java程序中有哪几种注释方式？"></a>5．Java程序中有哪几种注释方式？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//…… 单行注释</span><br><span class="line">/*……*/ 多行注释</span><br><span class="line">/**......*/用来做文档的注释</span><br></pre></td></tr></table></figure>
<h2 id="6．分别编写Applet和Application，在屏幕上生成如下图案："><a href="#6．分别编写Applet和Application，在屏幕上生成如下图案：" class="headerlink" title="6．分别编写Applet和Application，在屏幕上生成如下图案："></a>6．分别编写Applet和Application，在屏幕上生成如下图案：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">**</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure>
<p>略</p>
<h2 id="第二章-结构化程序设计"><a href="#第二章-结构化程序设计" class="headerlink" title="第二章     结构化程序设计"></a>第二章     结构化程序设计</h2><h2 id="回顾—Java开发环境的建立"><a href="#回顾—Java开发环境的建立" class="headerlink" title="回顾—Java开发环境的建立"></a>回顾—Java开发环境的建立</h2><p>1)    下载J2SE安装程序<br>2)    运行J2SE安装程序，安装J2SE<br>3)    设置环境变量：<br>运行路径(path)<br>类路径(classpath)<br>4)下载J2SE的在线帮助文档</p>
<h2 id="回顾—Java程序设计步骤"><a href="#回顾—Java程序设计步骤" class="headerlink" title="回顾—Java程序设计步骤"></a>回顾—Java程序设计步骤</h2><p>打开文本编辑器<br>编辑Java应用程序<br>保存Java源程序<br>使用javac命令编译源程序<br>使用java命令运行Java程序</p>
<h2 id="回顾—Java应用程序"><a href="#回顾—Java应用程序" class="headerlink" title="回顾—Java应用程序"></a>回顾—Java应用程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldApp</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;      </span><br><span class="line">          System.out.println(“Hello World!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑存盘：文件名和公共类名(用public声明)要一致 HelloWorldApp.java<br>编译程序：javac HelloWorldApp.java<br>运行程序：java HelloWorldApp<br>运行结果：Hello World!</p>
<h2 id="教学目标"><a href="#教学目标" class="headerlink" title="教学目标"></a>教学目标</h2><h3 id="掌握Java中基本数据类型"><a href="#掌握Java中基本数据类型" class="headerlink" title="掌握Java中基本数据类型"></a>掌握Java中基本数据类型</h3><p>来源：<a href="https://blog.csdn.net/hs2201056/article/details/58680629" target="_blank" rel="noopener">https://blog.csdn.net/hs2201056/article/details/58680629</a></p>
<p>1.布尔型—–boolean，boolean 类型所占存储空间的大小没有明确指定，其取值为true或false,其默认值为false。</p>
<p>2.字节型—-byte，byte 类型所占存储空间大小为1个字节，其取值为-128——127，其默认值为0。</p>
<p>3.整型——int，int类型所占存储空间大小为4个字节，其取值为-2^31——2^31-1，其默认值为0。</p>
<p>4.短整型—–short，short类型所占存储空间大小为2个字节，其取值为-2^15——2^15-1，其默认值为0。</p>
<p>5.长整型—–long，long类型所占存储空间大小为8个字节，其取值为-2^63——2^63-1，其默认值为0。</p>
<p>6.字符型—–char，char类型所占存储空间大小为2个字节，其默认值为\u0000。</p>
<p>7.单精度浮点型—–float，float类型所占存储空间大小为4个字节，其取值为-2^128——2^128，其默认值为0.0F。</p>
<p>8.双精度浮点型—–double，double类型所占存储空间大小为8个字节，其取值为-2^1024——2^1024，其默认值为0.0D。</p>
<p>掌握Java中各种运算符的使用<br>掌握Java的控制结构<br>理解结构化程序设计方法</p>
<h2 id="教学重难点"><a href="#教学重难点" class="headerlink" title="教学重难点"></a>教学重难点</h2><p>重点<br>Java的基本数据类型<br>Java的控制结构</p>
<p>难点<br>Java程序控制结构</p>
<h2 id="Java的标示符和关键字"><a href="#Java的标示符和关键字" class="headerlink" title="Java的标示符和关键字"></a>Java的标示符和关键字</h2><h3 id="标识符可以用来标识变量名、类名、类中的方法名和文件名等"><a href="#标识符可以用来标识变量名、类名、类中的方法名和文件名等" class="headerlink" title="标识符可以用来标识变量名、类名、类中的方法名和文件名等."></a>标识符可以用来标识变量名、类名、类中的方法名和文件名等.</h3><ul>
<li>标识符组成: (1) 字母, (2)数字, (3)下划线“_” 和 (4)美元符号“$”; </li>
<li>首字符必须是(1) 字母, (2)下划线“_” 和 (3)美元符号“$”;</li>
<li>所有标识符是区分大小写的;</li>
<li>除去关键字、false、true和null;</li>
</ul>
<h3 id="具有特殊含义的字符序列"><a href="#具有特殊含义的字符序列" class="headerlink" title="具有特殊含义的字符序列"></a>具有特殊含义的字符序列</h3><p>例如： public、 static和class<br>具有特殊用途，不能作为变量名、方法名和类名</p>
<h2 id="Java的关键字"><a href="#Java的关键字" class="headerlink" title="Java的关键字"></a>Java的关键字</h2><p>abstract continue for new switch<br>assert default goto package synchronized<br>boolean do if private this<br>break double implements protected throw<br>byte else import public throws<br>case extends int short try<br>char final interface static void<br>class finally long strictfp volatile<br>const float native super while</p>
<h2 id="Java的数据类型"><a href="#Java的数据类型" class="headerlink" title="Java的数据类型"></a>Java的数据类型</h2><p>数据类型：</p>
<ol>
<li><p>基本数据类型：<br>布尔（boolean）:</p>
<p>数据类型：<br>定点类型：<br> 字符（char）<br> 字节（byte）<br> 短整数（short）<br> 整数（int）<br> 长整数（long）</p>
<p>浮点类型：<br> 单精度（float）<br> 双精度浮点数（double）</p>
</li>
<li><p>引用数据类型：<br>类或枚举或接口<br>数据</p>
</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>变量在计算机内部对应着一个存储单元，而且总是具有某种数据类型：基本数据类型或引用数据类型</p>
</li>
<li><p>变量总是具有与其数据类型相对应的值</p>
</li>
<li><p>每个变量均具有: 名字、类型、一定大小的存储单元以及值</p>
</li>
</ul>
<p>变量名对应内存的位置</p>
<h2 id="Java变量必须属于某种类型"><a href="#Java变量必须属于某种类型" class="headerlink" title="Java变量必须属于某种类型"></a>Java变量必须属于某种类型</h2><p>变量值也必须与变量类型相匹配<br>例如:<br>int studentNumber;       // 声明单个变量<br>double velocity, distance;     // 声明多个变量<br>studentNumber=30;    // 给变量赋以整数30<br>int studentNumber=30;// 声明变量，并赋初值</p>
<h2 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h2><p>int sum = 0;<br>String s = “Hello World!”;</p>
<h2 id="Java直接量（常量）"><a href="#Java直接量（常量）" class="headerlink" title="Java直接量（常量）"></a>Java直接量（常量）</h2><p>Java直接量包括基本数据类型直接量、字符串(String)直接量和null </p>
<p>布尔(boolean)直接量只有两个：true 和 false</p>
<p>‘c’,  ‘\u0061’, ‘\u0051’ 和 ‘\u005a’ 是char直接量.</p>
<p>34是int直接量</p>
<p>1.5, 45.6, 76.4E8和-32.0是double直接量</p>
<p>34L是long直接量. </p>
<p>1.5F, 45.6f, 76.4E8F和-32.0F是float直接量</p>
<p>“Hello World!”是String直接量</p>
<p>null是引用数据类型的直接量</p>
<p>任意引用数据类型的直接量(null)</p>
<h2 id="Java转义字符"><a href="#Java转义字符" class="headerlink" title="Java转义字符"></a>Java转义字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&apos;\b&apos; (退格)</span><br><span class="line">&apos;\f&apos; (换页)</span><br><span class="line">&apos;\n&apos; (换行)</span><br><span class="line">&apos;\r&apos; (回车)</span><br><span class="line">&apos;\t&apos; (水平制表符(到下一个tab位置))</span><br><span class="line">&apos;\&apos; &apos; (单引号)</span><br><span class="line">&apos;\&quot; &apos; (双引号) </span><br><span class="line">&apos;\\&apos; (反斜杠)</span><br></pre></td></tr></table></figure>
<h2 id="Java运算符"><a href="#Java运算符" class="headerlink" title="Java运算符"></a>Java运算符</h2><p>算术运算符<br>关系运算符<br>布尔逻辑运算符<br>位运算符<br>赋值类运算符<br>条件运算符<br>其他运算符</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符包括：+, -, *, /, ++, –, %</p>
<ul>
<li>没有指数运算<br>  Math.pow(2.0, 3.0);  // 2.03.0</li>
<li>整数除法：截去余数<br>  7 / 5 结果为 1</li>
<li>取模：返回余数<br>  7 % 5 结果为 2</li>
</ul>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>六个关系运算符: &lt;、 &gt;、&lt;=、&gt;=、== 和 !=</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &gt; 2;                           // false</span><br><span class="line">3.5 != 1;                       // true </span><br><span class="line">51.5 &gt;= 23.0;    		// true</span><br><span class="line">540 &lt;= 654;            	// true</span><br><span class="line">24 == 3*8;                   // true</span><br><span class="line">boolean test1=(10 &lt; 10);       // test1= false;</span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>六个布尔逻辑运算符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> &amp; 	(逻辑 与 AND)</span><br><span class="line"> |   	(逻辑 或 OR)</span><br><span class="line"> ^  	(逻辑 异或 XOR )</span><br><span class="line"> !	 (逻辑 非 NOT)</span><br><span class="line"></span><br><span class="line">单目运算符, 即只有一个操作数</span><br><span class="line"></span><br><span class="line"> &amp;&amp; 	(条件 与 AND) </span><br><span class="line"> || 	(条件 或 OR)</span><br></pre></td></tr></table></figure></p>
<h2 id="短路规则-amp-amp-和"><a href="#短路规则-amp-amp-和" class="headerlink" title="短路规则 ( &amp;&amp;和|| )"></a>短路规则 ( &amp;&amp;和|| )</h2><p>如果从第一个操作数可以推断出表达式结果，就不再计算第二个操作数<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((x == 2) &amp;&amp; (y != 2))</span><br><span class="line">System.out.println(&quot;两个条件都为 true.&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算-amp-和"><a href="#逻辑运算-amp-和" class="headerlink" title="逻辑运算( &amp;和| )"></a>逻辑运算( &amp;和| )</h2><p>两个操作数均会被运算 (即不采用短路规则)<br>用不用短路规则，副作用不同<br>例如, </p>
<blockquote>
<p>(birthday == true) | (++age &gt;= 65)</p>
</blockquote>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符“? :”的表达式形式为“op1 ? op2 : op3”<br>op1:布尔表达式<br>例如:</p>
<blockquote>
<p>int k= ( (i&gt;=0) ? 1 : -1);</p>
</blockquote>
<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><ul>
<li><p>顺序结构<br>Java最基本的结构</p>
</li>
<li><p>选择结构<br>三种类型:  if、if/else和switch </p>
</li>
<li><p>循环结构<br>三种类型:  for、while和do/while</p>
</li>
</ul>
<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><p>if-else语句的格式是:<br>if (布尔表达式)<br>    语句1或语句块1<br>else<br>    语句2或语句块2</p>
<p>例：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> if (grade&gt;60)</span><br><span class="line">System.out.println(&quot;Passed!&quot;);</span><br><span class="line"> else</span><br><span class="line">System.out.println(&quot;Failed!&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h3><p>格式:<br>    for (表达式1;表达式2;表达式3)<br>    语句或语句块</p>
<h3 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h3><p>while循环语句格式为：</p>
<p>while (布尔表达式)<br>    语句或语句块</p>
<p>当条件(布尔表达式)为true ，则不断地执行语句或语句块</p>
<ul>
<li>“while” 循环中止条件是布尔表达式变为false</li>
<li>如果布尔表达式一开始就为false，则不执行循环体</li>
</ul>
<h2 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h2><p>1,从“最简单”的基本结构出发<br>2，任何一个矩形都能分解成两个顺行的矩形<br>3，任何一个矩形都可以用前的控制结构替换<br>4,2,3，可以不断地进行下去，直接完成程序设计</p>
<p>学习目的</p>
<p>主要讨论: 标识符数据类型运算符与表达式流程控制语句 </p>
<p>主要目的是对程序中所使用的各类符号及其使用规则有一个基本认识,建立程序设计的基本概念,初步掌握简单程序设计方法.</p>
<p>基本要求</p>
<p>掌握标识符的命名规则和常用关键字,运算符及注释符.<br>重点掌握常量,变量,数据类型的基本概念.<br>重点掌握各类运算符在复合表达式中的运算优先顺序.<br>掌握Java基本语法，能够编写简单的Java application和Java Applet程序.</p>
<h2 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h2><p>2.1  一个简单的例子<br>2.2  标识符<br>2.3  数据类型<br>2.4  运算符与表达式<br>2.5  流程控制语句 </p>
<p>实训二  结构化程序设计<br>习题二    </p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>Sun公司在开发Java语言时是以C/C++语言为基础进行的，因此，Java语言的基本语法，如变量声明、方法调用中的参数传递、运算符、流程控制结构等，都与C/C++语言非常相似。</p>
<p>下面首先给出一个简单的程序，通过该程序读者可以对Java语言的基本语法有一个大致的了解。</p>
<p>【程序2.1】  Fibonacci数列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Fibonacci &#123;</span><br><span class="line">	//输出Fibonacci数列中值小于50的值</span><br><span class="line">	public static void main(String []args) &#123;</span><br><span class="line">		int lo = 1;</span><br><span class="line">		int hi = 1;</span><br><span class="line">        System.out.println(lo);</span><br><span class="line">       while(hi &lt; 50)&#123;</span><br><span class="line">        System.out.println(hi);</span><br><span class="line">			hi = lo + hi;</span><br><span class="line">			lo = hi - lo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序输出Fibonacci数列，从中可以看出Java语言与C语言的相似性，不过Java在继承C语言语法时很多方面都有所改进，学习时应特别注意。</p>
<h2 id="标-识-符"><a href="#标-识-符" class="headerlink" title="标  识  符"></a>标  识  符</h2><p>Java字符集</p>
<p>与C语言或其他传统的高级程序设计语言不同，Java语言的基本符号采用Unicode字符集，而不是ASCII字符集，以方便支持多语种。</p>
<p>在Unicode字符集中，字母不仅仅限于英语，还包括其他语言的字符，包括汉字。Unicode字符集采用16位编码，一个字符在内存中占用两个字节。虽然现有的多数程序使用ASCII编码，但在运行前都被转换为Unicode字符。</p>
<h3 id="标识符构成规则"><a href="#标识符构成规则" class="headerlink" title="标识符构成规则"></a>标识符构成规则</h3><p>标识符是变量、类、方法、标号及其他各种用户自定义对象的命名。Java语言的标识符可以由字母、数字、下划线或$符号组成，以字母、下划线或$符开头，区分大小写，对标识符的长度没有特别限定。</p>
<p>Unicode字符集中的字母包括英文字母以及序号大于十六进制数0xC0的字符，因此可以使用汉字作标识符。以下都是合法的Java语言标识符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量1，$Str，_var1，myVar</span><br></pre></td></tr></table></figure>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>与大多数程序设计语言一样，Java语言也有一些系统保留的标识符，称为关键字或保留字。</p>
<p>目前Java语言用到的关键字有：</p>
<p>abstract、boolean、break、byte、byvalue、case、catch、char、class、continue、default、do、double、else、extends、final、finally、float、for、if、implements、import、inner、instanceof、int、interface、long、native、new、null、package、private、protected、public、return、short、static、super、switch、synchronized、this、throw、throws、transient、try、var、volatile、void、while。</p>
<p>cast、const、future、generic、goto、operator、outer、rest等也被列为系统保留字，但目前的Java规范并未用到。另外，在Visual J++中true和false也作为关键字使用。</p>
<h2 id="数-据-类-型"><a href="#数-据-类-型" class="headerlink" title="数 据 类 型"></a>数 据 类 型</h2><p>Java语言的数据类型与C语言有相似之处，但对C语言的数据类型作了一定的简化。C中的一些数据类型在Java语言中不再支持，如结构体、枚举类型、共用体、指针等，但增加了布尔类型。Java语言在对数据的类型检查方面总的来说要比C语言更严格。</p>
<p>Java语言支持的数据类型包括简单数据类型，如整型、实型、字符型、布尔型，以及复合数据类型类与接口。下面首先介绍简单数据类型。</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>Java语言的整型分为byte、short、int、long四种</p>
<p>与C语言相似，Java语言中的数据也分为常量和变量，常量在程序执行的过程中其值不可改变，而变量的值可以改变。</p>
<h3 id="Java语言中的常量分为两种："><a href="#Java语言中的常量分为两种：" class="headerlink" title="Java语言中的常量分为两种："></a>Java语言中的常量分为两种：</h3><p>一种称为直接量，其字面代表了该常量的值；</p>
<p>另一种用标识符表示，定义方法与变量的定义类似，只是需要用关键字final修饰，表示该数据在执行过程中不可修改，Java语言编译器会作相应的检查，如果发现程序中有改变该常量值的语句，编译器将指出错误。</p>
<p>Java语言中的整型直接量可以用十进制、八进制和十六进制表示。</p>
<p>十进制表示方法最为常见，如：123、-780。</p>
<p>在书写十进制常量时，注意不能以0为打头字符，因为Java语言中以0开始的整型常量被当作八进制处理，例如：017、-0234，都是八进制表示的整型常量。</p>
<p>八进制数据使用的数字字符只能是0～7，不能出现8、9。</p>
<p>十六进制整型常量以0x或0X开始，例如：0x123、0X1AB，十六进制数据使用的数字字符是0～9和A～F(或a~f)。</p>
<p>整型常量中，byte、short、int表示方法相同，而长整型(long)常量必须在数后加字母L或l，表示该数是长整型，例如：0L、306l。<br>整型变量的定义与C语言相似 ，例如：</p>
<p>byte b; //指定变量b为byte型<br>short s; //指定变量s为short型<br>int i; //指定变量i为int型<br>long l; //指定变量l为long型</p>
<p>Java语言中的变量与C/C++程序一样，也必须先定义后才能使用，同样，它们也有各自的作用域。</p>
<p>Java语言中的变量定义有两种形式：</p>
<p>一种是类的成员；</p>
<p>另一种是局部变量，在方法或复合语句(由大括号括起的若干语句)中定义，分别在所定义的方法或复合语句中起作用，与C语言的局部变量类似。</p>
<p>变量定义的时候可以赋初值，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int k=20;</span><br><span class="line">long x=200L,y=150L;</span><br></pre></td></tr></table></figure>
<p>用标识符定义常量的方法与变量的定义方法相似，用标识符定义常量时必须赋初值。例如：</p>
<p>final int IntVar=200;</p>
<p>有些教材将用这种方法定义的常量称为final变量或只读变量。</p>
<h2 id="实型"><a href="#实型" class="headerlink" title="实型"></a>实型</h2><p>Java语言的实型数据分为<br>单精度实数(float)和双精度实数(double)两种，<br>分别为32位和64位IEEE754-1985标准浮点数。</p>
<p>与C语言相同，Java的实型常量有两种表示形式：</p>
<p>(1) 十进制数形式。</p>
<p>十进制数形式由数字和小数点组成，且必须有小数点，如0.123、.123、123.、123.0。</p>
<p>(2) 科学计数法形式。</p>
<p>如：123e3或123E3，其中e或E之前必须有数字，且e或E后面的指数必须为整数。</p>
<p>实型常量缺省为double型，如果希望声明某个实型常量为float型，则要在数字后加f或F，如12.3F，它在机器中占4个字节，精度较低。</p>
<p>实型变量的定义与C语言类似，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float f=2.3f;  //指定变量f为float型</span><br><span class="line">double d=2.3;  //指定变量d为double型</span><br></pre></td></tr></table></figure>
<p>Java语言对数据类型的检查比C语言更严格，不允许用双精度的常量初始化单精度变量，因此下面的变量定义语句是错误的：</p>
<blockquote>
<p>float f=1.23;</p>
</blockquote>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p>Java语言使用Unicode字符集，因此其字符型数据在内存中占用2个字节，共16位，其范围为0～65 535。</p>
<p>字符常量是用单引号括起来的一个字符，如’a’、’A’。另外，与C语言相同，Java语言也使用转义字符，以反斜杠()开头，其后的字符转变为另外的含义。</p>
<p>字符型的类型标识符为char，下面是字符型变量的定义的例子：</p>
<p>char c=’a’；//指定变量c为char型，且赋初值为’a’<br>与C语言不同，Java语言不允许将字符型变量用作整型，因为Java不提供无符号整数类型，但可与整型进行混合运算。例如：<br>int i=’A’;<br>是非法的，而下面的语句是合法的：<br>int i=3;<br>i=i+’0’;</p>
<p>与C相同，Java语言用双引号(“)括起一串字符表示字符串常量，如”This is a string.\n”。但不同的是，Java中的字符串常量是作为字符串类String的一个对象来处理的，而不是一个字符数组。</p>
<h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>与C语言不同，Java语言引入了布尔类型用以表示关系运算和逻辑运算的结果，布尔型数据只有两个值true和false。</p>
<p>布尔型变量用关键字boolean定义，例如：</p>
<p>boolean b=true；//定义b为布尔型变量，且初值为true<br>布尔型数据不可作为整型数据使用，不同于C语言中的0和非0。Java语言中应该使用布尔型数据的地方，不可使用其他类型的数据。</p>
<h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2><p>概述</p>
<p>运算符是指明对操作数所进行的运算的符号。按操作数的数目来分，可以有单目运算符、双目运算符和三目运算符，它们分别对应于一个、两个和三个操作数。Java语言中的运算符按照功能来分有下面几类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1) 算术运算符：+，-，*，/，%，++，- -；</span><br><span class="line">(2) 关系运算符：＞，＜，＞=，＜=，= =，!= ；</span><br><span class="line">(3) 布尔逻辑运算符：!，&amp;&amp;，||，&amp;，|；</span><br><span class="line">(4) 位运算符：＞＞，＜＜，＞＞＞，&amp;，|，^，～；</span><br><span class="line">(5) 赋值运算符：=，复合赋值运算符如+=；</span><br><span class="line">(6) 条件运算符：?: ；</span><br><span class="line">(7) 其他运算符：包括分量运算符，下标运算符[]，实例运算符instanceof，内存分配运算符new，强制类型转换运算符(类型)，方法调用运算符()等。</span><br><span class="line"></span><br><span class="line">Java程序通过各种不同的运算符与操作数连接起来构成的表达式完成各种运算。</span><br></pre></td></tr></table></figure></p>
<h2 id="算术运算符-1"><a href="#算术运算符-1" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符是最基本的运算符，Java语言的算术运算符与C语言的算术运算符非常相似。</p>
<p>Java语言中算术运算符的优先级和结合性与C语言相同。</p>
<p>Java语言对运算符+的功能进行了扩展，使它能够进行字符串的连接，如“abc”+“de”,得到串“abcde”。</p>
<p>另外，与C语言不同，取模运算符%操作数可以为浮点数，如37.2%10=7.2。</p>
<h3 id="其他需要注意的几点与C语言相同："><a href="#其他需要注意的几点与C语言相同：" class="headerlink" title="其他需要注意的几点与C语言相同："></a>其他需要注意的几点与C语言相同：</h3><p>(1) 除法运算。当两个运算对象均为整型数据时，作整除运算。</p>
<p>(2)  i++与++i的区别。</p>
<p>i++在使用i之后，使i的值加1，因此执行完i++后，整个表达式的值为原来i的值，而i的值加1。</p>
<p>++i在使用i之前，使i的值加1，因此执行完++i后，整个表达式和i的值均为i原来的值加1。</p>
<p>i–与–i的运算方式与++运算符相似。<br>++、–运算符只能对变量进行操作。</p>
<p>【程序2.2】  算术运算符的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ArithmaticOp&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">	int a=5+4;	//a=9</span><br><span class="line">	int b=a*2;	//b=18</span><br><span class="line">	int c=b/4;	//c=4</span><br><span class="line">	int d=b-c;	//d=14</span><br><span class="line">	int e=-d;		//e=-14</span><br><span class="line">	int f=e%4;	//f=-2</span><br><span class="line">	double g=18.4;</span><br><span class="line">	double h=g%4;	//h=2.4</span><br><span class="line">	int i=3;	</span><br><span class="line">	int j=i++;		//i=4,j=3</span><br><span class="line">	int k=++i;	//i=5,k=5</span><br><span class="line">	System.out.println(&quot;a=&quot;+a);</span><br><span class="line">	System.out.println(&quot;b=&quot;+b);</span><br><span class="line">	System.out.println(&quot;c=&quot;+c);</span><br><span class="line">	System.out.println(&quot;d=&quot;+d);</span><br><span class="line">	System.out.println(&quot;e=&quot;+e);</span><br><span class="line">	System.out.println(&quot;f=&quot;+f);</span><br><span class="line">	System.out.println(&quot;g=&quot;+g);</span><br><span class="line">	System.out.println(&quot;h=&quot;+h);</span><br><span class="line">	System.out.println(&quot;i=&quot;+i);</span><br><span class="line">	System.out.println(&quot;j=&quot;+j);</span><br><span class="line">	System.out.println(&quot;k=&quot;+k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>与C语言一样，Java语言将赋值作为一种运算符处理。赋值运算的功能是将一个数据或表达式的值赋给一个变量。赋值运算符是双目运算符，左边的操作数必须是变量。</p>
<p>Java语言的赋值运算符可以分为两种：<br>基本赋值运算符和复合赋值运算符。</p>
<p>所有赋值运算符的优先级都相同，与其他运算符相比，赋值运算符的优先级最低。</p>
<p>基本赋值运算符是最简单的赋值运算符，格式为</p>
<blockquote>
<p>变量名=表达式</p>
</blockquote>
<p>先计算表达式，再将结果赋给变量，整个赋值表达式的值为赋值后变量的值。使用赋值运算符时，应尽量使变量和表达式的数据类型一致，否则，先将表达式的值转换为变量的数据类型再赋值。</p>
<p>复合赋值运算符是在基本运算符的基础上加上另一个运算符，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x*=a-b</span><br></pre></td></tr></table></figure>
<p>这个表达式与下面的表达式等价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=x*(a-b)</span><br></pre></td></tr></table></figure>
<p>先计算复合赋值运算符右边的表达式，然后在变量与该表达式的值进行指定的运算后将结果赋给变量。</p>
<p>常见的双目算术运算符如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+、-、*、/、%</span><br></pre></td></tr></table></figure></p>
<p>以及下面将介绍的位运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;、&lt;&lt;、&amp;、|、^</span><br></pre></td></tr></table></figure></p>
<p>等都可以构成复合赋值运算符。</p>
<h2 id="关系运算符-1"><a href="#关系运算符-1" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符用来比较两个值，Java语言关系运算的结果为布尔类型的值true或false，而不是C / C++中的1或0。</p>
<h2 id="逻辑运算符-1"><a href="#逻辑运算符-1" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>Java语言的逻辑运算符只能对布尔型的数据进行运算</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在编程时，经常会出现不同类型的数据进行混合运算的情况，运算前应将不同类型的数据转换为相同类型。</p>
<h3 id="类型转换有两种方法："><a href="#类型转换有两种方法：" class="headerlink" title="类型转换有两种方法："></a>类型转换有两种方法：</h3><p>自动类型转换和强制类型转换。</p>
<p>整型、实型、字符型等数据混合运算时，Java语言编译器可以对它们进行自动类型转换。转换规则类似于C语言，从低级数据类型转换为高级数据类型：</p>
<p>(1)  (byte或short) op int→int；<br>(2)  (byte或short或int) op long→long；<br>(3)  (byte或short或int或long) op float→float；<br>(4)  (byte或short或int或long或float) op double→double；<br>(5)  char op int→int。</p>
<p>这里箭头左边表示参与运算的数据类型，op为运算符(如加、减、乘、除等)，右边表示转换后进行运算的数据类型。</p>
<h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p>(1) 布尔型数据的使用；<br>(2) Java语言不再使用goto语句；<br>(3) 带标号的break和continue。</p>
<h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><p>分支语句提供了一种控制机制，使得程序可以根据指定的条件选择执行部分语句或跳过某些语句不执行。</p>
<p>Java语言提供了两种分支语句：if-else、switch。</p>
<h2 id="条件语句if-else"><a href="#条件语句if-else" class="headerlink" title="条件语句if-else"></a>条件语句if-else</h2><p>if-else语句<br>根据判定条件的真假来执行两种操作中的一种，格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式)</span><br><span class="line">语句1</span><br><span class="line">[ else</span><br><span class="line">语句2]</span><br><span class="line">其中，else子句是任选的，可以不出现。</span><br></pre></td></tr></table></figure>
<p>【程序2.5】  判断某一年是否为闰年。<br>闰年的条件是符合下面二者之一：<br>①能被4整除，但不能被100整除；<br>②能被4整除，又能被100整除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class LeapYear&#123;</span><br><span class="line">	public static void main(String args[])&#123;</span><br><span class="line">		int year=2003;</span><br><span class="line">		boolean leap;</span><br><span class="line">		if(year%4!=0)</span><br><span class="line">			leap=false;</span><br><span class="line">		else if(year%100!=0)</span><br><span class="line">leap=true;</span><br><span class="line">		else if(year%400!=0)</span><br><span class="line">			leap=false;</span><br><span class="line">		else</span><br><span class="line">			leap=true;</span><br><span class="line">		if(leap)</span><br><span class="line">			System.out.println(year+&quot; is a leap year.&quot;);</span><br><span class="line">		else </span><br><span class="line">			System.out.println(year+&quot;is not a leap year.&quot;);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多分支语句switch"><a href="#多分支语句switch" class="headerlink" title="多分支语句switch"></a>多分支语句switch</h2><p>switch语句根据指定表达式的值来执行多个操作中的一个，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch (表达式)&#123;</span><br><span class="line">case  值1：语句段1；</span><br><span class="line">case  值2：语句段2 </span><br><span class="line">case 值N：语句段N</span><br><span class="line">[default：语句段N+1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句的作用是反复执行一段代码，直到满足终止循环的条件为止。Java中提供的循环语句有while语句、do-while语句和for语句.</p>
<p>1．while语句<br>while语句实现“当型”循环，格式为<br>while (布尔表达式)循环体</p>
<h2 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h2><p>do-while语句实现“直到型”循环，格式为：</p>
<p>do<br>循环体<br>while (布尔表达式);</p>
<p>do-while语句首先执行循环体，然后计算布尔表达式。如果布尔表达式的值为true，则重复上述过程，直到布尔表达式的结果为false。与while语句不同的是，do-while语句的循环体至少执行一次。</p>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>for语句也用来实现“当型”循环，它的一般格式为：</p>
<p>for (初始化表达式;布尔表达式;增量表达式)<br>循环体</p>
<p>for语句首先计算初始化表达式，然后判断布尔表达式的值是否为true，如果为true，则执行循环体中的语句，最后计算增量表达式。完成一次循环后，重新判断终止条件。</p>
<h2 id="结构化程序设计-1"><a href="#结构化程序设计-1" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h2><p>一、实训目的<br>1．理解定义变量的作用并掌握其方法。<br>2．掌握各种基本数据类型及其运算。<br>3．掌握表达式的使用和各种运算符的优先级控制。<br>4．掌握结构化程序设计的分支结构。<br>5．学习用if-else语句实现单分支。<br>6．学习用if-else语句和switch语句实现多分支。<br>7．掌握结构化程序设计的循环结构。<br>8．学习使用while语句、do-while语句和for语句实现循环。<br>9．学习控制循环终止条件，包括循环的正常退出和使用continue语句和break语句。</p>
<p>二、实训内容<br>1．使用if-else语句判断并输出今天是星期几。<br>提示：用Date类获取有关的信息，首先引入Date类：<br>import java.Util.Date;<br>然后创建一个Date类对象，并获取信息：<br>Date day=new Date();<br>int today = day.getDay()；//0表示为星期天，1表示为星期一……<br>2．使用switch语句完成上面的功能。<br>3．编写Java应用程序，找出所有的水仙花数并输出。水仙花数是三位数，它的各位数字的立方和等于这个三位数本身，例如371＝33+73+13，371就是一个水仙花数，请分别用while循环和for循环实现。<br>4．编写Java应用程序，找出所有符合下列条件的a、b、c：a、b、c为三个200～300之间的整数，其和为452。</p>
<h2 id="JAVA语言基本语法"><a href="#JAVA语言基本语法" class="headerlink" title="JAVA语言基本语法"></a>JAVA语言基本语法</h2><p>标识符、关键字和数据类型</p>
<h3 id="温故"><a href="#温故" class="headerlink" title="温故"></a>温故</h3><h3 id="Java程序开发过程-1"><a href="#Java程序开发过程-1" class="headerlink" title="Java程序开发过程"></a>Java程序开发过程</h3><p>编写Java源文件（可用文本编辑工具），文件名与类名相同<br>编译生成字节码文件（.class）(javac.exe命令)<br>解释执行字节码文件中的类（java.exe命令）</p>
<h3 id="环境变量的设置（path、classpath）"><a href="#环境变量的设置（path、classpath）" class="headerlink" title="环境变量的设置（path、classpath）"></a>环境变量的设置（path、classpath）</h3><ul>
<li>Win2000</li>
<li>命令窗口</li>
</ul>
<h3 id="Java程序的种类"><a href="#Java程序的种类" class="headerlink" title="Java程序的种类"></a>Java程序的种类</h3><ul>
<li>Application应用程序</li>
<li>Applet小程序</li>
</ul>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>集成开发环境:Jcreater<br>一个Applet小程序<br>标识符<br>关键字<br>数据类型</p>
<h2 id="Jcreater-pro"><a href="#Jcreater-pro" class="headerlink" title="Jcreater pro"></a>Jcreater pro</h2><p>一个类似于TC的Java集成开发环境<br>可以方便地编写java源文件<br>可以方便地编译、运行Java程序<br>Jcreater不是免费的软件<br>安装时，可以先安装SDK，然后再安装Jcreater<br>使用时注意：<br>创建文件时，注意只需创建java文件，不用创建java项目，注意文件的命名和文件的保存路径。</p>
<h2 id="Applet小程序的开发过程"><a href="#Applet小程序的开发过程" class="headerlink" title="Applet小程序的开发过程"></a>Applet小程序的开发过程</h2><p>编写源文件（Applet源程序）<br>编译生成字节码文件（.class）<br>编写html文件，将字节码文件嵌入其中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;applet code=“Boy.class”  height=&quot;120&quot; width=&quot;300&quot;&gt;&lt;/applet&gt;</span><br></pre></td></tr></table></figure></p>
<p>用浏览器打开html文件，即可自动调用Applet小程序并解释执行。<br>或是appletviewer调用html文件</p>
<h2 id="Java的Applet小程序"><a href="#Java的Applet小程序" class="headerlink" title="Java的Applet小程序"></a>Java的Applet小程序</h2><p>一个Java Applet程序也由若干个类组成，最简单的为一个类。<br>一个Applet小程序不需要main方法，但是必须有一个主类是Applet的子类。<br>如果要在窗口中绘制文字、图像，paint()方法是必要的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.applet.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">public class BoyApplet extends Applet//从Applet类继承而来</span><br><span class="line">&#123;</span><br><span class="line">	public void paint(Graphics g)//paint方法用来绘制屏幕</span><br><span class="line">	&#123;</span><br><span class="line">		g.setColor(Color.red);//设置文字颜色为红色</span><br><span class="line">		g.drawString(&quot;我一边喝着咖啡，一边学Java呢&quot;,5,30);</span><br><span class="line">		g.setColor(Color.blue);//设置文字颜色为兰色</span><br><span class="line">		g.drawString(&quot;我学得很认真！&quot;,10,50);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>分隔符：注释、空白、普通<br>注释符（软件编码规范中说：“可读性第一，效率第二”，注释一般占程序代码的20%-50%）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//  ：单行注释</span><br><span class="line">/*  */  ：多行注释</span><br><span class="line">/**   */：文档注释，可被解释成程序的正式文档</span><br></pre></td></tr></table></figure>
<p>空白：空格、回车、制表</p>
<h2 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h2><p>java中的包、类、方法、参数、变量等的名字</p>
<p>由大小写字母、数字、下划线、美元$组成，但不能以数字开头。<br>不能是Java中的关键字。</p>
<p>这里的字母也包括世界上任何国家的“字母表”中的字符，比如汉字、日文等。不建议使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：Inner$1、123、java hello、user_name、user-name</span><br></pre></td></tr></table></figure>
<h2 id="关键字、标识符的命名习惯"><a href="#关键字、标识符的命名习惯" class="headerlink" title="关键字、标识符的命名习惯"></a>关键字、标识符的命名习惯</h2><h2 id="关键字全部小写"><a href="#关键字全部小写" class="headerlink" title="关键字全部小写"></a>关键字全部小写</h2><p>具有专门的意义和用途，不能当作一般的标识符使用，这些标识符称为保留字(reserved word)（P11）</p>
<h2 id="标识符命名习惯"><a href="#标识符命名习惯" class="headerlink" title="标识符命名习惯"></a>标识符命名习惯</h2><p>类、接口名：每个词的首字母都要大写<br>方法、变量名：首字母要小写，其它单词首字母要大写<br>常量：字母全部大写，单词之间用下划线分隔<br>观察一个java程序，识别哪个标识符是类或接口名，哪个标识符是变量或方法名。</p>
<h2 id="Java语言的数据类型"><a href="#Java语言的数据类型" class="headerlink" title="Java语言的数据类型"></a>Java语言的数据类型</h2><p>数据类型概述<br> 基本数据类型<br>  数值<br>  整数：byte、short、int、long：8，16，32，64<br>  浮点：float、double：32，64<br>  字符：char：16<br>  逻辑：boolean：1<br> 引用数据类型：类、数组、接口</p>
<h2 id="数据类型—常量数据及变量声明"><a href="#数据类型—常量数据及变量声明" class="headerlink" title="数据类型—常量数据及变量声明"></a>数据类型—常量数据及变量声明</h2><p>常量数据</p>
<ul>
<li>整型： 23(十进制)、 0X63(十六进制) 、063(八进制)</li>
<li>长整型：25L</li>
<li>浮点常量：小数常量默认为是double型的，float类型后一定要加f(F)，34d、34.0是double类型常量，34f、34.0f是float类型常量。</li>
<li>逻辑常量：true、false</li>
<li>字符常量：’a’  ‘8’  ‘\n’  ‘我’ 都是字符常量（16进制表示的字符）占用两个字节，采用国际编码标准—Unicode码。</li>
<li>字符串常量：”a”  “dkdkdk\n” 。</li>
<li>null常量：表示对象的引用为空</li>
</ul>
<p>变量声明</p>
<ul>
<li>类型  变量名1[,变量名2][=变量初始值]；</li>
</ul>
<h2 id="基本数据类型的转换"><a href="#基本数据类型的转换" class="headerlink" title="基本数据类型的转换"></a>基本数据类型的转换</h2><h2 id="自动类型转换，表达式类型的自动提升"><a href="#自动类型转换，表达式类型的自动提升" class="headerlink" title="自动类型转换，表达式类型的自动提升"></a>自动类型转换，表达式类型的自动提升</h2><p>整形、实型、字符型数据可以进行混合运算。运算时，不同类型的数据先转化为同一类型，字符型会转换为数值型，然后进行运算。</p>
<ul>
<li>表达式的类型为存储长度最大，精度最高的数据类型。</li>
<li>当把级别低的表达式的值赋给级别高的变量时，系统会自动完成数据类型的转换。而级别高的表达式的值不能直接赋给级别低的变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：float f;  f=34*12;f=f+23.5;</span><br></pre></td></tr></table></figure>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>一般情况下，当精度高的类型向精度低的类型转换时，要明确指明，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double k=6;</span><br><span class="line">float b=(float)k;</span><br></pre></td></tr></table></figure></p>
<h2 id="JSP技术"><a href="#JSP技术" class="headerlink" title="JSP技术"></a>JSP技术</h2><p>Java Server Pages<br>基于Java Servlet以及整个Java体系的Web开发技术，利用这一技术可以创建安全、跨平台的动态网站。</p>
<h2 id="Java基本数据类型"><a href="#Java基本数据类型" class="headerlink" title="Java基本数据类型"></a>Java基本数据类型</h2><p>训练目的</p>
<p>本次技能训练的目的是让学生掌握开发Applet小程序的过程。熟悉Java的数据类型、运算符和表达式，能熟练运用它们编写程序解决一定的问题。</p>
<p>训练内容及要求</p>
<p>1、编写、编译、运行一个java applet小程序，使用绿色字显示“你好，Java！我是XXX！”。<br>2、写出System.out.print()和System.out.println()的区别。<br>3、写出在实训过程遇到的问题和解决的办法，有哪些收获。</p>
<p>指导</p>
<p>（1）启动Jcreater，创建源文件（注意文件名与类名一致）保存到自己的工作目录中。<br>（2）使用训练Jcreater的菜单命令编译源文件。生成字节码文件。<br>（3）使用Jcreater创建一个html文件，并保存至自己的工作目录中，其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Applet code=”BoyApplet.class” width=”300” height=”300”&gt;&lt;/Applet&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中BoyApplet.class要用你自己生成的字节码文件名代替。<br>（4）用浏览器打开html文件，观察运行效果。 </p>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><h3 id="了解类和对象的基本概念"><a href="#了解类和对象的基本概念" class="headerlink" title="了解类和对象的基本概念"></a>了解类和对象的基本概念</h3><p>来源：<a href="https://baike.baidu.com/item/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1394902?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1394902?fr=aladdin</a></p>
<p>类和对象（class）是两种以计算机为载体的计算机语言的合称。对象是对客观事物的抽象，类是对对象的抽象。类是一种抽象的数据类型。</p>
<p>它们的关系是，对象是类的实例，类是对象的模板。对象是通过new className产生的，用来调用类的方法;类的构造方法 。</p>
<h3 id="声明定义"><a href="#声明定义" class="headerlink" title="声明定义"></a>声明定义</h3><p>类，对象的定义</p>
<p>类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。</p>
<p>类是一种对数据的分装，我们可以理解为Java中的代码。</p>
<p>对象是具有类类型的变量。</p>
<blockquote>
<p>类和对象是面向对象编程技术中的最基本的概念。</p>
</blockquote>
<h2 id="类类型的声明"><a href="#类类型的声明" class="headerlink" title="类类型的声明"></a>类类型的声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class 类名</span><br><span class="line">&#123;</span><br><span class="line">    public：</span><br><span class="line">    公用的数据和成员函数</span><br><span class="line">    protected：</span><br><span class="line">    保护的数据和成员函数</span><br><span class="line">    private：</span><br><span class="line">    私有的数据和成员函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义对象方法"><a href="#定义对象方法" class="headerlink" title="定义对象方法"></a>定义对象方法</h2><p>1.先声明类类型，然后再定义对象<br>举例：Student stud1,stud2; //Student是已经声明的类类型<br>2.在声明类类型的同时定义对象 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Student//声明类类型</span><br><span class="line">&#123;</span><br><span class="line">    public://先声明公用部分</span><br><span class="line">    void display()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;″num:″&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;″name:″&lt;&lt;name&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;″sex:″&lt;&lt;sex&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    private://后声明私有部分</span><br><span class="line">    int num;</span><br><span class="line">    char name[20];</span><br><span class="line">    char sex;</span><br><span class="line">&#125;</span><br><span class="line">stud1，stud2;//定义了两个Student类的对象</span><br><span class="line">//在定义Student类的同时，定义了两个Student类的对象。</span><br></pre></td></tr></table></figure>
<p>3.不出现类名，直接定义对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> class//无类名</span><br><span class="line">&#123;</span><br><span class="line">    private://声明以下部分为私有的</span><br><span class="line">    ┆</span><br><span class="line">    public://声明以下部分为公用的</span><br><span class="line">    ┆</span><br><span class="line">&#125;</span><br><span class="line">stud1，stud2;//定义了两个无类名的类对象</span><br></pre></td></tr></table></figure>
<p>掌握类的定义方法<br>掌握对象的初始化<br>掌握类的成员函数的定义</p>
<h2 id="回顾—类的定义"><a href="#回顾—类的定义" class="headerlink" title="回顾—类的定义"></a>回顾—类的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[类的修饰字] class 类名称 [extends 父类名称][implements 接口名称列表]</span><br><span class="line">&#123;  </span><br><span class="line">    变量定义及初始化；</span><br><span class="line">    方法定义及方法体；</span><br><span class="line">&#125;</span><br><span class="line">类体，其中定义了该类中所有的变量和该类所支持的方法，称为成员变量和成员方法。</span><br></pre></td></tr></table></figure>
<h2 id="回顾—类的成员函数定义语法规范"><a href="#回顾—类的成员函数定义语法规范" class="headerlink" title="回顾—类的成员函数定义语法规范"></a>回顾—类的成员函数定义语法规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[方法修饰字] 返回类型  方法名称(参数1,参数2,…) [throws exceptionList]</span><br><span class="line">&#123;</span><br><span class="line">     …(statements;)    //方法体：方法的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[public | protected | private ] [static] [final | abstract] [native] [synchronized]</p>
<blockquote>
<p>返回类型可以是任意的Java数据类型，当一个方法不需要返回值时，返回类型为void。</p>
</blockquote>
<p>参数的类型可以是简单数据类型，也可以是引用数据类型（数组、类或接口），参数传递方式是值传递。</p>
<p>方法体是对方法的实现。它包括局部变量的声明以及所有合法的Java指令。局部变量的作用域只在该方法内部。</p>
<h2 id="回顾—对象的初始化"><a href="#回顾—对象的初始化" class="headerlink" title="回顾—对象的初始化"></a>回顾—对象的初始化</h2><p>（1）对象的生成<br>   通过new操作符生成一个对象；例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car demoCar;</span><br><span class="line">demoCar = new Car();</span><br></pre></td></tr></table></figure>
<p>（2）对象的构造过程</p>
<ul>
<li>为对象开辟空间，并对对象的成员变量进行缺省的初始化；</li>
<li>对成员变量进行指定的初始化；</li>
<li>调用构造方法。</li>
</ul>
<h2 id="教学内容和目标"><a href="#教学内容和目标" class="headerlink" title="教学内容和目标"></a>教学内容和目标</h2><p>掌握类的封装性</p>
<p>掌握类的继承性</p>
<h2 id="教学重难点-1"><a href="#教学重难点-1" class="headerlink" title="教学重难点"></a>教学重难点</h2><p>重点</p>
<ul>
<li>不同访问修饰符的应用</li>
<li>Java中类继承的定义</li>
</ul>
<p>难点</p>
<ul>
<li>类的继承特性</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>“包”是由一组类和接口所组成的具有一定功能的集合</p>
<p>简单地说，将一组功能相关的类和接口打包起来形成的整体，就是包</p>
<p>两个类如果名字相同，只要所属的包不同，Java就会认为它们是不同的类</p>
<h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>在定义类或接口的源文件开始加入“package”关键字和包名，就将类或接口放到包里了</p>
<p>如果两个java源文件的开头都有相同的包名，则意味着这两个源文件中的所有类和接口都属于同一个包</p>
<h2 id="访问包中的类"><a href="#访问包中的类" class="headerlink" title="访问包中的类"></a>访问包中的类</h2><p>访问公开类的方法<br>(1) 用类的全名（包名+类名）访问；<br>(2) 导入包中的某个类；<br>(3) 导入包中的所有类。<br>如果某个类只访问一次，那么可以直接使用类的全名，形式是“包名.类名”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用“import”关键字导入一个类：</span><br><span class="line">	import PackageName.ClassName;</span><br><span class="line"></span><br><span class="line">一次性导入所有类的方法：</span><br><span class="line">		import PackageName.*;</span><br></pre></td></tr></table></figure>
<h2 id="管理Java的包"><a href="#管理Java的包" class="headerlink" title="管理Java的包"></a>管理Java的包</h2><p>Java系统建议的文件存储方式就是按照包名将源文件和二进制代码文件分级存放<br>将源文件放到与包名相同的路径下，包名对应子目录名</p>
<h2 id="使用Java的包"><a href="#使用Java的包" class="headerlink" title="使用Java的包"></a>使用Java的包</h2><p>设定Rectangle.java放在“graphics”子目录下<br>编译源文件的命令如下：<br>javac graphics\Rectangle.java</p>
<p>执行程序时，用小圆点“.”分隔包名和类：<br>java graphics.Rectangle</p>
<h2 id="CLASSPATH参数"><a href="#CLASSPATH参数" class="headerlink" title="CLASSPATH参数"></a>CLASSPATH参数</h2><p>如果你的Java包都放在一个固定的目录下，轻易不会改变它，那么你可以在操作系统中设置“CLASSPATH”环境变量</p>
<p>编译和运行Java程序时，不需要指定包路径参数，系统会自动从环境变量中读取</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装把对象的所有组成部分组合在一起</p>
<p>封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。</p>
<h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><p>封装性与访问级控制<br>类的一个优势在于类可以保护它的成员变量和成员函数不会被其它对象随意访问到<br>在Java程序里，可以为成员变量和函数设定四级访问级：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private</span><br><span class="line">protected</span><br><span class="line">public</span><br><span class="line">default（缺省）</span><br></pre></td></tr></table></figure>
<h2 id="访问控制级别"><a href="#访问控制级别" class="headerlink" title="访问控制级别"></a>访问控制级别</h2><p>private（私有级）</p>
<ul>
<li>private是最严格的访问控制级</li>
<li>私有变量只能在它所在的类内部被访问到</li>
<li>它用于定义只在类内部使用的成员变量</li>
<li>成员变量，如果从外界随意改变它的值可能会造成不稳定的情况</li>
<li>成员函数，如果从外界调用，可能会危害到对象的状态或程序的运行</li>
</ul>
<p>protected（保护级）</p>
<ul>
<li>被定为保护级的成员可以被它所属的类、所属类的子类，以及处于同一个包里的其它类访问到</li>
<li>如果一个成员变量或成员函数可以被它的子类或相关的类访问，而不能被无关类访问的话，就可以用保护级</li>
<li>保护级就像家庭秘密，可以让家庭成员知道，也不介意让几个亲密朋友知道，但你不想让任何外人知道</li>
</ul>
<p>public（公开级）</p>
<ul>
<li>公开级是限制最少的访问级，任何类，不管它在哪个包里，都能够访问公开级的成员</li>
<li>公开级使用最方便，实际使用得也最多</li>
<li>需要注意的是：对于成员变量或成员函数，只有当你确认外界的类访问甚至修改它不会造成不希望的后果时，才使用公开级</li>
<li>公开级类似于公开张贴的信息，其中没有个人或家庭隐私，你不介意任何人知道</li>
</ul>
<p>default（缺省级）</p>
<ul>
<li>包访问级是成员的缺省访问级</li>
<li>如果没有定义访问级，那么它就是包访问级</li>
<li>权限：可以被属于同一个包的其它类所访问，但不能被其它包的类所访问</li>
<li>如果这个类的子类在其它包，则子类不能继承和访问父类中包访问级的成员</li>
<li>这一访问级假设在同一个包里的其它类都是可信任的朋友，但子类反而不能信任</li>
</ul>
<h2 id="类成员封装性总结"><a href="#类成员封装性总结" class="headerlink" title="类成员封装性总结"></a>类成员封装性总结</h2><p>public 同一个类，同一个包，子类，所有类<br>protected 同一个类，同一个包，子类<br>default 同一个类，同一个包<br>private 同一个类 </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承性是面向对象程序设计语言的另一基本特征，通过继承可以实现代码的复用。继承而得到的类为子类，被继承的类为父类，父类包括所有直接或间接被继承的类。Java中不支持多重继承。通过在类的声明中加入extends子句来创建一个类的子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SubClass extends SuperClass</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类可以继承父类中访问权限设定为public、 protected、 default的成员变量和方法，但是不能继承访问权限为private的成员变量和方法。</p>
<p>一个类可以从另一个类中继承它的成员变量和函数，前者称为子类，后者称为父类。类的这种特点称为继承性</p>
<p>类的继承通过extends关键字来说明，extends关键字跟在类名称后面，形式如下：</p>
<p>class SubClass extends FatherClass { … }<br>其中SubClass是子类名，FatherClass是父类名</p>
<p>子类是作为另一个类的扩充或修正而定义的一个类。</p>
<h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><p>类的继承性的特点</p>
<ul>
<li>在Java中，一个类只能有一个父类</li>
<li>Java只支持单继承，而不支持多重继承</li>
<li>单继承的类子代相承，会形成一棵继承树，结构较为清晰</li>
<li>多重继承会形成一张复杂的继承网，结构复杂，容易出错</li>
<li>如果需要多重继承，Java提供了一种接口技术，可以部分地实现多重继承的功能</li>
</ul>
<p>在Java中定义的所有类都直接或间接地是Object类的子类。以Object类为根，所有Java类形成一棵类继承树</p>
<h2 id="类的继承性的特点"><a href="#类的继承性的特点" class="headerlink" title="类的继承性的特点"></a>类的继承性的特点</h2><p>子类可以继承的部分：<br>(1) 父类中公开级的成员；<br>(2) 父类中保护级的成员；<br>(3) 如果子类和父类在同一个包里，则子类继承父类中缺省的包访问级的成员；</p>
<p>子类不能继承的部分：<br>(1) 父类中私有级的成员；<br>(2) 如果不在同一个包里，则缺省级的成员；<br>(3) 同名的成员函数或成员变量；</p>
<h2 id="构造函数的继承特点"><a href="#构造函数的继承特点" class="headerlink" title="构造函数的继承特点"></a>构造函数的继承特点</h2><p>父类相当于一个硬球，子类则是在球外的包装<br>构造对象时显然应当先构造最内部的硬球，也就是最顶端的父类<br>之后再从里往外一层层地构造外包装，直到最后整个对象都构造起来<br>如果父类的构造函数有参数，那么就需要用super关键字，它指代父类</p>
<p>何时选择继承?<br>一个很好的经验：“B是一个A吗?”<br>如果是则让B做A的子类.</p>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>3.1  面向对象的基本思想和基本概念<br>3.2  案例<br>3.3  类的声明与对象的创建<br>3.4  继承<br>3.5  包的使用<br>3.6  编程实例<br>实训三  面向对象程序设计<br>习题三 </p>
<h2 id="面向对象的基本思想和基本概念"><a href="#面向对象的基本思想和基本概念" class="headerlink" title="面向对象的基本思想和基本概念"></a>面向对象的基本思想和基本概念</h2><p>大部分传统的高级程序设计语言(如C语言)都是过程化的语言，在软件开发的过程中采用自顶向下逐步细化的方法将整个程序描述为一个过程。对于小型的系统，这种方法是可行的，但是当系统规模很大，复杂度很高时，用过程化方法描述变得十分困难，面向对象的软件开发方法可以很好地解决这个问题。</p>
<p>目前，面向对象的方法在软件开发工作中得到了广泛的应用，越来越多的软件开发工具开始支持面向对象的开发方法。Java语言就是一种面向对象的程序设计语言，要充分利用Java语言的特性首先应该理解面向对象的基本思想。</p>
<h2 id="面向对象的基本思想"><a href="#面向对象的基本思想" class="headerlink" title="面向对象的基本思想"></a>面向对象的基本思想</h2><p>面向对象的基本思想认为系统是由若干个对象构成的，每个对象都有各自的内部状态和运动规律，不同对象之间通过消息传送相互作用和联系。</p>
<p>采用对象的观点看待所要解决的问题，并将其抽象为系统是极其自然与简单的，因为它符合人类的思维习惯，使得应用系统更容易理解。同时，由于应用系统是由相互独立的对象构成的，使得系统的修改可以局部化，因此系统更易于维护。 </p>
<p>例如，对于一个企业的管理信息系统，将整个系统描述成一个过程是难以想像的，但可以分别描述各个部门的特性及工作流程，然后描述部门之间的联系。这里各个部门就是组成企业的对象，当然，在描述每个部门特性时可以采用同样的方法。</p>
<h2 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h2><p>对象是面向对象方法中的一个重要概念。</p>
<blockquote>
<p>所谓对象，是指客观世界中事物在计算机领域中的抽象，用一组数据和施加于该组数据上的一组操作(行为)来描述。</p>
</blockquote>
<p>对象的描述通常由三个部分组成：</p>
<p>(1) 私有的数据结构。用于描述对象的内部状态。<br>(2) 处理，称为操作或方法。它是施加于数据结构之上的。<br>(3) 接口。这是对象可被共享的部分，消息通过接口调用相应的操作。接口规定哪些操作是允许的，它不提供操作是如何实现的信息。</p>
<p>实际上，采用面向对象方法进行系统分析与设计时要描述的并不是一个个具体的对象。对于一个具体的系统而言，可能存在很多具有相同特征的对象，而且通常系统中对象的数目是不确定的。例如，对于一个学籍管理系统，存在许多学生对象，它们具有相同的结构特征和行为特征，只是表示内部状态的数据值不同。为了描述这种相同结构特征和行为特征的对象，面向对象方法引入了类的概念。这一点与人们在认识客观世界的事物时所采取的分类思想相同。人们在认识事物时总是将具有相同特征的事物归为一类，属于某类的一个事物具有该类事物的共同特征。</p>
<p>类是对一组具有相同特征的对象的抽象描述，所有这些对象都是这个类的实例。对于学籍管理系统，学生是一个类，而一个具体的学生则是学生类的一个实例。一个类的不同实例具有相同的操作或行为的集合和相同的信息结构或属性的定义，但属性值可以不同；不同的实例具有不同的对象标识。对于学生类中的每一个对象，描述它们所使用的数据结构相同，但是值不同。在程序设计语言中，类是一种数据类型，而对象是该类型的变量，变量名即是某个具体对象的标识。</p>
<p>因此，一个类的定义至少包含以下两个方面的描述：<br>(1) 该类所有实例的属性或结构的定义。<br>(2) 该类所有实例的操作(或行为)的定义。</p>
<p>类是构成Java语言程序的基本单位，一个完整的Java程序是由若干个类构成的，每个类由若干数据和方法构成，一个类的定义包含属性(数据)和方法(行为)两部分内容。</p>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>人们在对客观世界的事物进行描述时，经常采取分类的方法。类是有层次的，即某个大类的事物可能分为若干小类，而这些小类可能又分为若干个更小的类。</p>
<p>面向对象思想采纳了事物分类的层次思想，在描述类的时候，某些类之间具有结构和行为的共性。例如，描述教师与学生时均需描述姓名、年龄、身高、体重等属性，将这些共性抽取出来，形成一个单独的类——人，用于描述教师类和学生类的共性。类人的结构特征和行为特征可以被多个相关的类共享，教师类和学生类继承了类人的结构和行为特征。</p>
<p>Java语言支持类的继承，可以从一个类中派生出一个新的类，原来的类称为超类或父类，新类称为超类的子类或派生类。子类的对象具有超类对象的特征，同时又有其自身特有的特征。子类又可以派生出新的子类，子类的子类也称为派生类。</p>
<p>利用类之间的继承关系，可以简化类的描述，提高软件代码的可重用性。在设计一个新类时，不必从头设计编写全部的代码，可以通过从已有的具有类似特性的类中派生出一个类，继承原有类中的部分特性，再加上所需的新特性。</p>
<p>另外，人们在对客观世界的事物进行分类时，一个事物可能属于多个类，具有多个类的特性。例如，一个黑人学生，他既属于学生类，又属于黑人类。这种情形在面向对象方法中称为多继承，即一个类同时从多个类中派生出来，此时类的层次结构是网状的。</p>
<p>Java语言为了不使语法过于复杂，不支持多继承，只允许子类有一个超类，称为单继承。不过，Java语言提供了接口机制，可以在一定程度上模拟多继承。</p>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>多态性是面向对象系统的又一重要特性。所谓多态，即一个名词可具有多种语义，如一个方法名有多种功能，或者相同的接口有多种实现方法。</p>
<p>在Java语言中，多态性通过方法的重载、覆盖和接口来实现。</p>
<p>方法的重载是指多个方法具有相同的名称，但各个方法的参数表不同，即参数的类型和参数的数量不同。</p>
<p>覆盖是指在类的派生过程中，子类与超类的方法不仅名称相同，参数也完全相同，但它们的功能不同，这时子类中的方法覆盖了超类中同名的方法。</p>
<p>接口实际上是一种特殊的类，只给出方法的名称、参数和返回值的类型，方法的具体实现在实现该接口的类中给出。</p>
<blockquote>
<p>多态性使得方法的调用更加容易、灵活和方便。</p>
</blockquote>
<h2 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h2><p>封装是一种信息隐藏技术，对象内部对用户是隐藏的，不可直接访问；用户只能见到对象封装界面上的信息，通过对象的外部接口访问对象。</p>
<blockquote>
<p>用户向对象发送消息后，对象根据收到的消息调用内部方法作出响应。</p>
</blockquote>
<p>封装的目的在于将对象的使用者和对象的设计者分开，使用者无需知道对象内部实现的细节，只需知道对象接收的消息即可。</p>
<p>Java语言通过类来实现封装，类中定义的属性和方法分为私有的和公有的，私有属性和方法不能在对象的外部访问，只能由类内的方法访问。</p>
<p>而在对象的外部，只能访问对象的公有属性和方法，只需要知道公有属性的数据类型和名字以及公有方法的原型，至于这些方法是如何实现的对象外部并不需要知道。</p>
<p>这就像人们在使用电视机时只需要通过遥控器来操作即可，至于电视机内部细节用户则无需知道，这里遥控器上的按钮实际上就是电视机的外部接口。</p>
<blockquote>
<p>对象的封装特性可以提高模块之间的独立性，使得系统易于调试和维护。</p>
</blockquote>
<h2 id="类的声明与对象的创建"><a href="#类的声明与对象的创建" class="headerlink" title="类的声明与对象的创建"></a>类的声明与对象的创建</h2><p>类声明的基本语法</p>
<p>1．类的声明</p>
<p>Java语言类声明的完整语法很复杂，下面先介绍最简单的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">    类体</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>  类中定义的变量和方法都是类的成员，Java语言对类成员的访问有一定的权限限制。在定义属性和方法时，可以指定访问权限，Java中访问权限有private、protected和public。</p>
<h2 id="变量成员的定义"><a href="#变量成员的定义" class="headerlink" title="变量成员的定义"></a>变量成员的定义</h2><p>变量成员的定义形式类似于C语言中的变量定义，ComplexRoot类的变量成员a、b和disc。</p>
<p>变量成员定义的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[final] [private|protected|public] 类型 属性名[=初值];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>final为可选项，用final修饰的成员变量为常量。在程序中不能改变常量的值，常量必须在定义时初始化。</p>
</blockquote>
<p>成员变量初始化的方法与C语言相似，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line"> int x=0,y=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成员变量的类型可以是Java语言中的任意数据类型，包括简单类型、数组、类和接口。在类中，成员变量名应该是唯一的。</p>
</blockquote>
<h2 id="方法成员的定义"><a href="#方法成员的定义" class="headerlink" title="方法成员的定义"></a>方法成员的定义</h2><p>方法成员的定义形式与C语言的函数定义类似，基本形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[private|protected|public] 返回值类型 方法名([形式参数表])</span><br><span class="line">   &#123;</span><br><span class="line">       方法体    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> int func(int a，int b)</span><br><span class="line">  &#123;</span><br><span class="line">      if(a&gt;b)</span><br><span class="line">	return a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的定义是错误的，当a&lt;=b时该方法在执行时没有确切的返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)  return 表达式;  或 return(表达式);</span><br><span class="line">(2)  return;。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一种形式用于有返回值的情况，第二种形式用于无返回值的情况。对于第一种情况，return后的表达式类型应与声明的返回值类型一致，否则会产生编译错误。</p>
</blockquote>
<p>Java语言中的方法可以有参数也可以没有参数，参数类型可以是简单数据类型，如整型、实型、字符型、布尔型，也可以是复合类型，如数组、自定义类的对象。</p>
<blockquote>
<p>方法被调用时，必须给定实际参数，实际参数的类型应与形式参数的类型一致。对于简单类型数据，实际参数传递给形式参数时采用值传递，这一点与C语言相同；如果参数为复合类型，则传递引用，此时实参、形参为同一对象。</p>
</blockquote>
<h3 id="参数传递的方法。"><a href="#参数传递的方法。" class="headerlink" title="参数传递的方法。"></a>参数传递的方法。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">	private int b;</span><br><span class="line">	int Getb()&#123;return b;&#125;</span><br><span class="line">	void Setb(int j)&#123;b=j;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MethodParm</span><br><span class="line">&#123;</span><br><span class="line">	void Method1(int Parm1,B Parm2)</span><br><span class="line">	&#123;</span><br><span class="line">Parm1=Parm1+10;</span><br><span class="line">		Parm2.Setb(20);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int a=10;</span><br><span class="line">		B b=new B();</span><br><span class="line">		b.Setb(10);</span><br><span class="line">		MethodParm obj=new MethodParm();</span><br><span class="line">obj.Method1(a,b);</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b.Getb());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果为</span><br><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>如果局部变量或形式参数与变量成员同名，在该方法体中直接使用变量名则是对局部变量或形式参数的访问。如果需要访问变量成员，可通过关键字this来访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public ComplexRoot(double a,double b,double disc)</span><br><span class="line">&#123;</span><br><span class="line">	                   this.a=a;</span><br><span class="line">             	this.b=b;</span><br><span class="line">            	this.disc=disc;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里，this.a访问当前对象的成员a，而赋值运算符后的a表示形式参数表中的a。</p>
</blockquote>
<p>类的构造方法与对象的初始化</p>
<p>类定义了一类对象的特性，每一个对象都是相应类的实例。定义一个类后，就可以定义对象，然后访问对象的方法和变量成员了。</p>
<p>1．new运算符</p>
<p>Java语言使用new运算符创建对象。</p>
<blockquote>
<p>Equation e=new Equation(1,2,1);</p>
</blockquote>
<p>创建了一个Equation类的对象，也可以写为下面的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Equation e;</span><br><span class="line">e=new Equation(1,2,1);</span><br></pre></td></tr></table></figure></p>
<p>即首先声明一个Equation类对象的引用e，与定义简单数据类型变量不同，这里尚未创建Equation类的对象。变量名e只是程序中访问对象的一条途径，并不是对象本身，执行下面的语句后e、e1表示同一个对象：</p>
<blockquote>
<p>Equation e1=e;</p>
</blockquote>
<p>这一点与C/C++语言不同，Java语言将这类数据类型称为引用类型，与C/C++中的指针相似。引用类型变量在未赋值前，其值为null。</p>
<p>定义对象引用后，用new运算符完成对象的创建工作，分配存储空间，并对其初始化。new运算符创建对象的一般方法为：</p>
<blockquote>
<p>变量名=new 类名([构造方法实参表]);</p>
</blockquote>
<p>类名可以是系统预定义的类，也可以是自定义的类。括号中是传递给构造方法的实参，用于初始化该对象。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法是一种特殊的方法，创建对象时被自动调用。与一般的方法不同，它没有返回值类型的说明，方法体中也不可以用return语句带回返回值。构造方法的方法名与类名相同</p>
<blockquote>
<p>OneRoot o=new OneRoot(a,b);</p>
</blockquote>
<p>其中，a、b为传递给构造方法的参数。<br>Java语言允许一个类有多个构造方法，只要这些方法的参数形式不同即可。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">int x,y;</span><br><span class="line">Point(int x,int y)&#123;this.x=x;this.y=y;&#125;</span><br><span class="line">Point()&#123;x=y=0;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的语句在创建Point类对象时分别调用不同的构造方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p1=new Point(10,10);</span><br><span class="line">Point p2=new Point();</span><br></pre></td></tr></table></figure></p>
<p>在构造方法中可以通过this关键字调用该类中其他的构造方法。例如，上面的例子可改写为下面的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Point&#123;</span><br><span class="line">  int x,y;</span><br><span class="line">   Point(int x,int y)&#123;this.x=x;this.y=y;&#125;</span><br><span class="line">   Point()&#123;this(0,0);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个构造方法调用了第一个构造方法，this后面括号中内容为传递给第一个构造方法的实参。如果该构造方法中还有其他的语句，应保证将this语句放在最前面。</p>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>Java语言提供了三种初始化对象的方法，除了上面介绍的构造方法外，还可以采用下面两种方法：</p>
<p>(1) 定义变量成员时赋初值；<br>(2) 在类体中的初始化程序块。</p>
<h2 id="对象的初始化。"><a href="#对象的初始化。" class="headerlink" title="对象的初始化。"></a>对象的初始化。</h2><p>//ch3_3.java  对象的初始化方法演示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	int x=5;</span><br><span class="line">	&#123;	//初始化程序块开始</span><br><span class="line">		System.out.println(x);</span><br><span class="line">		x=6;</span><br><span class="line">		System.out.println(x);</span><br><span class="line">	&#125;	//初始化程序块结束</span><br><span class="line">	A(int i)</span><br><span class="line">	&#123;</span><br><span class="line">x=i;</span><br><span class="line">		System.out.println(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class InitDemo</span><br><span class="line">&#123;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		A a=new A(7);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> 程序运行结果为：</span><br><span class="line">   5</span><br><span class="line">   6</span><br><span class="line">   7</span><br></pre></td></tr></table></figure></p>
<h2 id="对象的清除"><a href="#对象的清除" class="headerlink" title="对象的清除"></a>对象的清除</h2><p>与C/C++语言不同，Java语言中对象的清除是自动进行的，当系统内存用尽或用户在程序中调用System.gc时，Java运行系统启动垃圾收集机制，自动回收不再使用的对象。垃圾收集器可以自动判断哪些对象不再使用，例如，程序片断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a=new A();</span><br><span class="line">a=new A();</span><br></pre></td></tr></table></figure>
<p>在内存中创建了两个A类对象，执行该程序片断之后，第一次创建的A类对象在程序中无法再访问，Java垃圾收集器将自动收回该对象占用的空间。对不再使用的对象，程序中可以将对该对象的引用赋值为null，以释放资源。</p>
<p>Java语言允许用户为每个类定义一个特殊的方法finalize()，当垃圾收集器清除该类对象时将调用该方法，如果用户有一些特殊的清除工作可安排在finalize方法中。</p>
<p>但是，用户无法预测finalize()方法被调用的时间，即使调用System.gc强制启动垃圾收集，也可能因为其他任务的优先级高于垃圾收集任务，而不能立即启动。因此，一些与时间相关的代码不应加入到finalize()方法中。</p>
<h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><p>在对象创建之后，就可以使用该对象了，可以访问对象的变量成员和方法成员。访问成员的基本语法形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.变量成员名</span><br><span class="line">对象名.方法成员名([实际参数表])</span><br></pre></td></tr></table></figure></p>
<p>public 类内，子类，包内其他类，其他包内的类<br>private 类内<br>protected 类内，子类，包内其他类<br>friendly 类内，子类，包内其他类 </p>
<p>成员访问权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//ch3_4 成员访问权限演示 VistMember.java</span><br><span class="line">class A&#123;</span><br><span class="line">	private int PrivateMember=0;</span><br><span class="line">	public int PublicMember=0;</span><br><span class="line">	int FriendMember=0;</span><br><span class="line">	void Copy(A AObject)</span><br><span class="line">	&#123;</span><br><span class="line">        PrivateMember=AObject.PrivateMember;//访问同类对象的private成员</span><br><span class="line">		PublicMember=AObject.PublicMember;//访问同类对象的public成员</span><br><span class="line">		FriendMember=AObject.FriendMember;//访问同类对象的friendly成员</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B&#123;</span><br><span class="line">	private int PrivateMember=0;</span><br><span class="line">	public int PublicMember=0;</span><br><span class="line">	int FriendMember=0;</span><br><span class="line">	void CopyA(A AObject)</span><br><span class="line">&#123;</span><br><span class="line">		PrivateMember=AObject.PrivateMember;</span><br><span class="line">//错误，访问另一个类对象的private成员</span><br><span class="line">		PublicMember=AObject.PublicMember;</span><br><span class="line">//访问另一个对象的public成员</span><br><span class="line">		FriendMember=AObject.FriendMember;</span><br><span class="line">//访问另一个对象的friendly成员</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">public class VistMember</span><br><span class="line">&#123;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		A aobj=new A();</span><br><span class="line">		aobj.PublicMember = 20;</span><br><span class="line">		aobj.FriendMember = 30;</span><br><span class="line">		A aobj2=new A();</span><br><span class="line">		aobj2.Copy(aobj);</span><br><span class="line">		B bobj=new B();</span><br><span class="line">		bobj.CopyA(aobj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java语言引入了一个与对象有关的运算符instanceof，用来测试一个指定的对象是否是指定类的实例，若是，则返回true；否则，返回false。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(obj1 instanceof Class1)&#123;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>obj1为对象名，Class1为类名，若obj1为Class1类的对象，则执行大括号中的语句。</p>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>从前面的介绍可以知道，对象创建之后，Java程序通过对象调用方法成员，在方法中使用变量成员名访问当前对象的成员。不过，在前面的例子中，有一个例外的情况，就是main方法，它是程序执行的入口点，Java程序开始执行时，并没有创建它所在类的对象。</p>
<p>main方法与其他方法的不同之处在于定义时前面有修饰符static，它是一个静态方法。Java语言允许用static修饰符定义静态的变量成员和方法成员。</p>
<h2 id="静态变量成员"><a href="#静态变量成员" class="headerlink" title="静态变量成员"></a>静态变量成员</h2><p>静态的变量成员通常称为类变量，而非静态的变量成员称为实例变量。Java语言在创建对象时不为静态变量成员分配空间，而只为非静态变量成员分配空间。因此，静态变量成员不依赖某一个具体的对象，即使没有创建一个它所属类的对象，它也是存在的，只要该类的代码装入，则该静态变量就是存在的，就可以使用。</p>
<p>因为静态变量成员不依赖于具体的对象，在访问时可以不像非静态变量成员那样通过对象访问。静态变量成员的访问方法为</p>
<blockquote>
<p>类名.静态变量成员名</p>
</blockquote>
<h3 id="对象计数器。"><a href="#对象计数器。" class="headerlink" title="对象计数器。"></a>对象计数器。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//ch3_5 静态变量的作用 NumberOfClass.java</span><br><span class="line">class MyClass&#123;</span><br><span class="line">	static int count=0;</span><br><span class="line">	public MyClass()&#123;count++;&#125;</span><br><span class="line">	public void output()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;You have got &quot;+count+&quot; objects of MyClass&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class NumberOfClass</span><br><span class="line">&#123;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		MyClass c1,c2,c3,c4;</span><br><span class="line">		c1=new MyClass();</span><br><span class="line">		c1.output();</span><br><span class="line">		c2=new MyClass();</span><br><span class="line">		c2.output();</span><br><span class="line">		c3=new MyClass();</span><br><span class="line">		c3.output();</span><br><span class="line">		c4=new MyClass();</span><br><span class="line">		c4.output();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">程序运行结果为：</span><br><span class="line">You have got 1 objects of MyClass</span><br><span class="line">You have got 2 objects of MyClass</span><br><span class="line">You have got 3 objects of MyClass</span><br><span class="line">You have got 4 objects of MyClass</span><br></pre></td></tr></table></figure>
<p>前面例子中多次使用了System.out.println方法来输出数据，其中System为Java系统预定义的类，out为System类的静态变量成员。程序中使用它向标准输出设备输出数据，无需创建System类对象即可直接使用。而在C/C++语言中类似的功能是通过系统预定义的全局变量来实现的，例如C语言中的文件指针stdout、C++的流对象cout，而Java语言不允许定义全局变量，所有变量都必须在类中定义。</p>
<h2 id="静态变量的使用。"><a href="#静态变量的使用。" class="headerlink" title="静态变量的使用。"></a>静态变量的使用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//ch3_6 静态变量的使用</span><br><span class="line">public class Class1 &#123;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;The maximum integer is &quot;+Integer.MAX_VALUE );</span><br><span class="line">		System.out.println(&quot;The minimum integer is &quot;+Integer.MIN_VALUE );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态方法成员"><a href="#静态方法成员" class="headerlink" title="静态方法成员"></a>静态方法成员</h2><p>静态方法与静态变量类似，不依赖于具体的对象，在调用时直接通过类名来调用：</p>
<blockquote>
<p>类名.静态方法名([方法的参数表])</p>
</blockquote>
<p>正如前面所说，main方法不依赖于任何对象直接被调用，因此必须将其定义为静态方法。</p>
<p>静态方法在调用时不通过对象调用，因此在定义静态方法时，在方法体中不能使用this，因为对静态方法来说，不存在当前对象，同样也不能直接访问所在类的非静态变量成员及方法成员。</p>
<p>静态方法的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//ch3_7 StaticMethod.java</span><br><span class="line">import java.math.*;</span><br><span class="line">public class StaticMethod</span><br><span class="line">&#123;</span><br><span class="line">	double Radius;</span><br><span class="line">	StaticMethod(double r)</span><br><span class="line">	&#123;</span><br><span class="line">		Radius=r;</span><br><span class="line">	&#125;</span><br><span class="line">	static double CircleArea(double r)</span><br><span class="line">	&#123;</span><br><span class="line">		return Math.PI*r*r;</span><br><span class="line">	&#125;</span><br><span class="line">	double Area()</span><br><span class="line">	&#123;</span><br><span class="line">		return Math.PI*Radius*Radius;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">        System.out.println(&quot;Area=&quot;+CircleArea(2.0));	</span><br><span class="line">               //直接访问静态方法成员</span><br><span class="line">		StaticMethod obj=new StaticMethod(2.0);</span><br><span class="line">		System.out.println(&quot;Area=&quot;+obj.Area());	</span><br><span class="line">              //通过对象访问非静态方法成员</span><br><span class="line">            	&#125;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类内方法的重载"><a href="#类内方法的重载" class="headerlink" title="类内方法的重载"></a>类内方法的重载</h2><p>Java语言允许一个类有多个同名的方法成员，这些同名的方法具有不同形式的参数，在调用时只需带入不同的实参,Java编译器就可以根据实参的类型确定调用哪一个方法成员</p>
<p>类内方法重载一个最常见的例子就是前面使用的System.out.println方法，在前面的程序中用它来输出整型数据、实型数据、字符串等。下面是重载的println方法的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void println()</span><br><span class="line">public void println(boolean x)</span><br><span class="line">public void println(char x)</span><br><span class="line">public void println(int x)</span><br><span class="line">public void println(long x)</span><br><span class="line">public void println(float x)</span><br><span class="line">public void println(double x)</span><br><span class="line">public void println(char x[])</span><br><span class="line">public void println(String x)</span><br><span class="line">public void println(Object x)</span><br></pre></td></tr></table></figure>
<p>方法重载为程序调用带来了方便，用户无需为不同类型的数据选择输出方式，只需使用同一个方法即可实现不同类型数据的输出。</p>
<p>Java编译器对重载方法匹配时首先根据实参类型寻找形参类型与其完全匹配的方法，如果找不到，则按如下原则对实参作类型转换：</p>
<p>(1) 对于简单类型，按照byte、short、int、long、float、double的顺序进行转换；<br>(2) 如果实参为布尔型，不进行转换；<br>(3) 如果实参为复合数据类型，可以将子类对象转换为超类对象。</p>
<p>如果按以上原则对实参进行类型转换仍然找不到匹配的重载方法，则认为是错误。</p>
<p>程序3.8演示了方法重载中参数匹配的方法，OverLoad类有两个同名的方法成员max，main方法中多次调用了max。</p>
<p>第一次调用，两个实参为int类型，匹配第一个max方法；<br>第二次调用，两个实参为double类型，匹配第二个max方法；<br>最后一次调用，第一个实参为int类型，第二个实参为double类型，没有参数类型完全匹配的max方法，Java编译器将第一个实参转换为double类型后与第二个max匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">【程序3.8】  类内方法重载。</span><br><span class="line">//ch3_8 类内方法重载演示 OverLoad.java</span><br><span class="line">public class OverLoad</span><br><span class="line">&#123;</span><br><span class="line">	int ix,iy;</span><br><span class="line">	double dx,dy;</span><br><span class="line">	OverLoad(int ix,int iy,double dx,double dy)</span><br><span class="line">	&#123;</span><br><span class="line">        this.ix=ix;</span><br><span class="line">		this.iy=iy;</span><br><span class="line">		this.dx=dx;</span><br><span class="line">		this.dy=dy;</span><br><span class="line">&#125;</span><br><span class="line">	int max(int a,int b)</span><br><span class="line">	&#123;</span><br><span class="line">		if(a&gt;b)</span><br><span class="line">			return a;</span><br><span class="line">		else</span><br><span class="line">			return b;</span><br><span class="line">	&#125;</span><br><span class="line">	double max(double a,double b)</span><br><span class="line">	&#123;</span><br><span class="line">        if(a&gt;b)</span><br><span class="line">			return a;</span><br><span class="line">		else</span><br><span class="line">			return b;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		OverLoad obj=new OverLoad(3,4,5.0,6.0);</span><br><span class="line">        System.out.println</span><br><span class="line">             (&quot;the max integer is &quot;+obj.max(obj.ix,obj.iy));</span><br><span class="line">		System.out.println</span><br><span class="line">             (&quot;the max double is &quot;+obj.max(obj.dx,obj.dy));</span><br><span class="line">System.out.println(&quot;The max is &quot;+</span><br><span class="line">obj.max(obj.max(obj.ix,obj.iy),obj.max(obj.dx,obj.dy)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果为：</span><br><span class="line">the max integer is 4</span><br><span class="line">the max double is 6.0</span><br><span class="line">The max is 6.0</span><br></pre></td></tr></table></figure>
<p>使用方法重载还应注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(1)  Java编译器对实参进行类型转换时，应注意避免二义性。例如下面的程序片段：</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">   void m(int a,double b)</span><br><span class="line">  &#123; </span><br><span class="line">   &#125;</span><br><span class="line">  void m(double a,int b)</span><br><span class="line">    &#123;</span><br><span class="line">&#125;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		A obj=new A();</span><br><span class="line">		obj.m(2,3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类A定义了两个同名方法m，在main方法中调用时两个实参为int类型，由于没有参数类型完全匹配的重载方法，因此Java编译器尝试对实参类型进行转换，这时有两种转换途径：将第一个实参转换为double类型与第二个m匹配，或者将第二个参数转换为double类型与第一个m匹配。Java编译器无法确定选择哪一种转换途径，这是不允许的。</p>
<p>类内方法重载时，不允许参数表完全一致，而只是返回值类型不同。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">void m(int a,int b)</span><br><span class="line">&#123; </span><br><span class="line">  &#125;</span><br><span class="line">   int m(int a,int b)</span><br><span class="line">   &#123; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Java语言定义了专门的字符串类型String，它是一种复合类型，一个字符串变量就是一个String类的对象，而C语言中的字符串只是一块连续的存储空间，用于存储若干个字符类型的数据。</p>
<p>创建String类对象<br>String类对象的创建与其他类型对象创建的方法是相同的，例如：</p>
<blockquote>
<p>String str=new String(“This is a string”);</p>
</blockquote>
<p>String类的构造方法有多个，常用的形式有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String()</span><br><span class="line">public String(String value)</span><br><span class="line">public String(char value[])</span><br></pre></td></tr></table></figure></p>
<p>由于字符串类型在程序设计中经常会用到，因而Java语言还提供了一种简便的方法来初始化String对象。例如：</p>
<blockquote>
<p>String str=”This is a string”;</p>
</blockquote>
<p>另外，在程序中大部分需要使用String类对象的地方可以直接使用字符串常量。例如：</p>
<blockquote>
<p>System.out.println(“This is a string”);</p>
</blockquote>
<p>这里，Java语言用字符串常量”This is a string”构造一个String类对象，然后将该对象作为实参传递给println方法。</p>
<h2 id="获取字符串的信息"><a href="#获取字符串的信息" class="headerlink" title="获取字符串的信息"></a>获取字符串的信息</h2><p>创建了String对象后，就可以通过调用String类的方法成员来对字符串进行各种操作或者获取有关字符串的信息了。例如，通过调用length方法可以获得字符串的长度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;A String Object&quot;;</span><br><span class="line">int len=str.length();</span><br></pre></td></tr></table></figure></p>
<p>startsWith方法可以判断一个字符串的前缀是否为指定的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;Java String&quot;;</span><br><span class="line">boolean result=str.startsWith(&quot;Java&quot;);	//result=true</span><br></pre></td></tr></table></figure></p>
<p>endsWith用于确定字符串是否以给定的字符串结尾：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;This is a string&quot;;</span><br><span class="line">boolean result=str.endsWith(&quot;String&quot;);	//result=false</span><br><span class="line">boolean result=str.endsWith(&quot;string&quot;);	//result=true</span><br></pre></td></tr></table></figure></p>
<p>如果需要比较两个字符串的值是否相等，可以使用equals方法，也可以直接使用关系运算符==。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String firstName=&quot;Nancy&quot;;</span><br><span class="line">if(firstName.equals(&quot;Nancy&quot;))&#123;</span><br><span class="line">              //条件满足，执行此程序段</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure></p>
<p>equals方法区分大小写，如果不区分大小写比较两个字符串是否相等，可以使用方法equalsIgnoreCae。</p>
<p>字符串的操作</p>
<p>String类还提供了一些方法用于从字符串中抽取字符串的某些部分，如一个字符或一个子串，下面介绍一些常用的方法。</p>
<p>charAt用于抽取指定位置的字符，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;Java string&quot;;</span><br><span class="line">char c=str.charAt(3);	//c=&apos;a&apos;</span><br></pre></td></tr></table></figure></p>
<p>该方法的参数为希望抽取的字符所在的位置，这里位置是从0开始计数的。</p>
<p>subString用于提取字符串中从某个位置开始的若干个字符，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;Tom and Jerry&quot;;</span><br><span class="line">String str1=str.subString(4);	//str1=&quot;and Jerry&quot;</span><br><span class="line">String str2=str.subString(4,7);	//str2=&quot;and&quot;</span><br></pre></td></tr></table></figure></p>
<p>对字符串的操作(如合并字符串、替换字符)，String类也提供了一些方法，例如：replace方法可以将字符串中的一个字符替换为另一个字符，concat方法可以合并两个字符串。</p>
<p>replace方法有两个字符类型的参数，第一个为原来的字符，第二个为替换用的字符。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;java&quot;;</span><br><span class="line">String str1=str.replace(&apos;a&apos;, &apos;A&apos;); //str1=&quot;jAvA&quot;;</span><br></pre></td></tr></table></figure></p>
<p>concat方法有一个参数，为需要合并的字符串。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;First&quot;;</span><br><span class="line">String str1=str.concat(&quot;Program&quot;);   //str1=&quot;First Program&quot;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是：String类对象创建后，字符串的值是不能改变的，replace、concat方法并不改变原来字符串的值，而是创建了一个新的String类对象作为返回值。如果希望字符串在创建后值可以改变，应使用StringBuffer类。</p>
<p>Java语言中可以直接使用+运算连接两个字符串，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;First&quot;;</span><br><span class="line">String str1=str+&quot; Program&quot;; //str1=&quot;First Program&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串与其他类型数据的转换"><a href="#字符串与其他类型数据的转换" class="headerlink" title="字符串与其他类型数据的转换"></a>字符串与其他类型数据的转换</h2><p>程序设计中经常需要将字符串转换为整型或实型数据，例如，从键盘输入一个整数，只能先读入字符串，然后将其转换为整数，因为System.in.read方法只提供了读取字符的方法；同样，反向的转换也经常会用到，例如，在Java Applet中将数据转换为字符串后输出。Java语言中这样的转换都可以通过简单数据类型的包装类来实现。</p>
<h2 id="String类的使用。"><a href="#String类的使用。" class="headerlink" title="String类的使用。"></a>String类的使用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//ch3_9 StringClass.java</span><br><span class="line">public class StringClass</span><br><span class="line">&#123;</span><br><span class="line">	String myString=&quot;1&quot;;	</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		StringClass myObj = new StringClass();</span><br><span class="line">		myObj.stringModifier(myObj.myString);</span><br><span class="line">           StringClass myObj = new StringClass();</span><br><span class="line">		myObj.stringModifier(myObj.myString);</span><br><span class="line">System.out.println(&quot; &quot;+myObj.myString);			</span><br><span class="line">	&#125;</span><br><span class="line">	void stringModifier(String theString)</span><br><span class="line">	&#123;</span><br><span class="line">		theString = theString+&quot;2&quot;;</span><br><span class="line">		System.out.print(theString);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">程序的运行结果为</span><br><span class="line">12 1</span><br></pre></td></tr></table></figure>
<p>Java语言为每一个简单数据类型定义了一个类(如 int 对应 Integer， float 对应 Float)，称为包装类(Wrapper Class)。 </p>
<p>包装类为与该类型相关的方法和变量提供一个归属，如字符串转换和值域常量。</p>
<p>如果需要将简单类型变量转换为字符串，可以首先创建一个包装类对象，然后调用该对象的toString方法即可。例如：</p>
<p>String IntStr = new Integer(123).toString();<br>String DoubleStr = new Double(123.456D).toString();</p>
<p>实际上，Java语言中的每一个对象都有一个 toString() 方法。例如：</p>
<p>Date day = new Date();<br> //Date为Java类库中处理日期的类<br>System.out.println(day);<br>这里的输出语句相当于<br>System.out.println(day.toString());</p>
<p>前面提到，Java语言对+运算符的功能进行了扩展，可以允许字符串与int、float等类型的数据连接，实际上这里使用了包装类，例如：</p>
<p>String str=””+5;<br>相当于：<br>String str=””+(new Interger(5).toString());<br>即两个 String 的相加。</p>
<p>包装类的另一种构造方法以字符串作参数，可以使用该构造方法创建包装类对象，将字符串转换为简单类型数据。例如：</p>
<p>int intNumber = new Integer (“10”).intValue();<br>boolean con = new Boolean (“true”).booleanValue();</p>
<p>这里，Boolean为boolean类型的包装类，常用的包装类还有：Character包装char，Byte包装byte，Long包装long。</p>
<p>从包装类型对象获取基本类型值的方法为typeValue，其中type为相应的数据类型。例如：intValue获取int值，charValue获取char值，doubleValue获取double值。</p>
<p>另外，String类还提供了静态的方法valueOf，可以用来将基本类型的值转换为字符串。valueOf有多种形式，分别用于转换不同类型的数据，例如：</p>
<p>●  public static String valueOf(boolean b)；<br>●  public static String valueOf(char c)；<br>●  public static String valueOf(int i)；<br>●  public static String valueOf(long l)；<br>●  public static String valueOf(float f)；<br>●  public static String valueOf(double d)。</p>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><blockquote>
<p>String类是字符串常量，对象创建后值不可更改。</p>
</blockquote>
<p>而StringBuffer是字符串变量，它的对象是可以扩充和修改的。StringBuffer类的构造函数主要有以下几种形式：</p>
<p>●  public StringBuffer()：创建一个空的StringBuffer类的对象。<br>●  public StringBuffer( int length )：创建一个长度为参数length 的StringBuffer类的对象。<br>●  public StringBuffer( String str )：用一个已存在的字符串常量来创建StringBuffer类的对象。</p>
<h2 id="StringBuffer类的主要方法有："><a href="#StringBuffer类的主要方法有：" class="headerlink" title="StringBuffer类的主要方法有："></a>StringBuffer类的主要方法有：</h2><p>●  public String toString()：转换为String类对象并返回。由于很多类的方法需要String类的对象，如Graphics类的方法drawString，经常要将StringBuffer类的对象转换为String类的对象。</p>
<p>●  public StringBuffer append( boolean b )。<br>●  public StringBuffer append( char c )。<br>●  public StringBuffer append( int i)。<br>●  public StringBuffer append( long l )。<br>●  public StringBuffer append( float f )。<br>●  public StringBuffer append( double d )。 </p>
<p>以上六种方法可分别将boolean、char、int、long、float和double 六种类型的变量追加到StringBuffer类的对象的后面。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double d=123.4567;</span><br><span class="line">StringBuffer sb=new StringBuffer();</span><br><span class="line"></span><br><span class="line">sb.append(true);</span><br><span class="line">sb.append(&apos;c&apos;).append(d).append(99);</span><br><span class="line">//sb的值为truec123.456799</span><br></pre></td></tr></table></figure></p>
<p>●  public StringBuffer append( String str )：将字符串常量str追加到StringBuffer类的对象的后面。<br>●  public StringBuffer append( char str[] )：将字符数组str追加到StringBuffer类的对象的后面。<br>●  public StringBuffer append( char str[], int offset, int len )：将字符数组str从第offset个开始取len个字符，追加到StringBuffer类的对象的后面。</p>
<p>●  public StringBuffer insert( int offset, boolean b )。<br>●  public StringBuffer insert( int offset, char c )。<br>●  public StringBuffer insert( int offset, int i )。<br>●  public StringBuffer insert( int offset, long l )。<br>●  public StringBuffer insert( int offset, float f )。<br>●  public StringBuffer insert( int offset, double d )。<br>●  public StringBuffer insert( int offset, String str )。<br>●  public StringBuffer insert( int offset, char str[] )。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>与其他程序设计语言一样，Java语言也支持数组。数组是一组类型相同的有序数据，数组中的每个元素具有相同的数组名，通过下标来唯一地确定数组中的元素。</p>
<h3 id="一维数组定义"><a href="#一维数组定义" class="headerlink" title="一维数组定义"></a>一维数组定义</h3><p> 一维数组定义形式为<br>type arrayName[];</p>
<p>其中，类型(type)可以为Java中的任意数据类型，包括简单类型和复合类型；数组名arrayName为一个合法的标识符，[]指明该变量是一个数组类型变量，可以写在数组名后，也可以写在数组名前。例如：</p>
<p>int []intArray;</p>
<p>为一个整型数组分配3个int型整数所占据的内存空间。这两部分也可以合在一起，定义数组时直接为其分配空间，格式如下：</p>
<p>type arrayName = new type[arraySize];<br>例如：<br>int intArray[]=new int[3];</p>
<p>引用数组元素</p>
<p>定义数组并为其分配了内存空间后，就可以引用数组中的每一个元素了。数组元素的引用方式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayName[index]</span><br><span class="line">其中：index为数组下标，它可以为int类型常量或表达式，如a[3]，b[i](i为整型)，c[6*i]等。</span><br></pre></td></tr></table></figure></p>
<p>Java语言数组的下标从0开始，一直到数组的长度减1，数组的长度可以通过属性length获得。对于上面例子中的数组intArray来说，它有3个元素，分别为intArray[0]、intArray[1]和intArray[2]。</p>
<h2 id="数组的使用。"><a href="#数组的使用。" class="headerlink" title="数组的使用。"></a>数组的使用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//ch3_10 ArrayTest.java</span><br><span class="line">public class ArrayTest&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">int i;</span><br><span class="line">int a[]=new int[5];</span><br><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">	  a[i]=i;</span><br><span class="line">System.out.println(&quot;数组长度为：&quot;+a.length);</span><br><span class="line">for(i=0;i&lt;=a.length;i++)</span><br><span class="line">	  System.out.println(&quot;a[&quot;+i+&quot;]=&quot;+a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">使用Visual J++ 6.0调试该程序后，首先输出结果如下：</span><br><span class="line">数组长度为：5</span><br><span class="line">a[0]=0</span><br><span class="line">a[1]=1</span><br><span class="line">a[2]=2</span><br><span class="line">a[3]=3</span><br><span class="line">a[4]=4</span><br></pre></td></tr></table></figure>
<h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>可以按照上述的例子对数组元素进行赋值，也可以在定义数组的同时进行初始化。<br>例如：<br>int a[]={1,2,3,4,5};<br>用逗号(,)分隔数组的各个元素，系统自动为数组分配一定空间，无需再使用new分配空间。</p>
<h3 id="数组举例"><a href="#数组举例" class="headerlink" title="数组举例"></a>数组举例</h3><p>下面看几个使用一维数组的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">【程序3.11】  用数组计算Fibonacci数列。</span><br><span class="line">  //ch3_11 Fibonacci.java</span><br><span class="line">  public class Fibonacci&#123;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">int i;</span><br><span class="line">int f[]=new int[10];</span><br><span class="line">f[0]=f[1]=1;</span><br><span class="line">for(i=2;i&lt;10;i++)</span><br><span class="line">f[i]=f[i-1]+f[i-2];</span><br><span class="line">for(i=1;i&lt;=10;i++)</span><br><span class="line">System.out.println(&quot;F[&quot;+i+&quot;]=&quot;+f[i-1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="冒泡法排序。"><a href="#冒泡法排序。" class="headerlink" title="冒泡法排序。"></a>冒泡法排序。</h2><p>对给定数组的元素从小到大排列，采用冒泡法排序，相邻的两个元素进行比较，并把小的元素交到前面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> //ch3_12 BubbleSort.java</span><br><span class="line">  public class BubbleSort&#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   int i,j;</span><br><span class="line">   int intArray[]=&#123;20,1, -11,80,25&#125;;</span><br><span class="line"></span><br><span class="line">   int l=intArray.length;</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;l-1;i++)</span><br><span class="line">		for(j=0;j&lt;l-i-1;j++)</span><br><span class="line">			if(intArray[j]&gt;intArray[j+1])&#123;</span><br><span class="line">				int t=intArray[j];</span><br><span class="line">				intArray[j]=intArray[j+1];</span><br><span class="line">				intArray[j+1]=t;</span><br><span class="line">			&#125;</span><br><span class="line">	for(i=0;i&lt;l;i++)</span><br><span class="line">		System.out.println(intArray[i]+&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果为：</span><br><span class="line">-11</span><br><span class="line">1</span><br><span class="line">20</span><br><span class="line">25</span><br><span class="line">80</span><br></pre></td></tr></table></figure></p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>Java语言将多维数组看作数组的数组。例如，二维数组可以看成一个特殊的一维数组，其每个元素又是一个一维数组。下面简单介绍一下二维数组的使用。</p>
<p>二维数组的定义方式为<br> type arrayName[][];<br>例如：<br>int intArray[][];</p>
<p>(1) 直接为每一维分配空间，如<br>int a[][]=new int[2][3];<br>(2) 从最高维开始，分别为每一维分配空间。如：<br>int a[][]=new int[2][];<br>a[0]=new int[3];<br>a[1]=new int[4];</p>
<h2 id="继-承"><a href="#继-承" class="headerlink" title="继    承"></a>继    承</h2><p>继承的基本语法</p>
<p>利用继承性可以提高代码的可重用性，提高软件开发的生产率。Java语言支持继承机制，在定义类时通过关键字extends指定超类的名称即可。</p>
<p> 1．子类的定义</p>
<p>子类定义的基本语法形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 子类名 extends 超类名&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java语言不支持多继承，因此超类名只有一个。子类继承超类的特性，也可以通过定义新的成员修改超类的特性或增加新的特性。 </p>
<p> Java语言在为子类对象分配空间时，不仅为子类中新定义的成员分配空间，同时也为超类中定义的成员(包括public、protected、private以及friendly成员)分配空间，在一定程度上可以认为一个子类对象内部包含一个超类对象。</p>
<p>Java语言允许将一个子类对象作为超类对象使用，当需要时可以进行隐含的类型转换。例如，若将一个方法的形式参数定义为超类对象，则在调用时可以将子类对象作为实际参数。Java语言中的各种类型的对象都可以当作Object类的对象使用，Object类中定义了Java语言对象的基本特性，例如前面用到的toString方法。如果在定义一个类时没有用extends关键字指定超类，则该类的超类为Object。</p>
<blockquote>
<p>超类中定义的成员根据其权限的不同在该类中的访问权限也不同</p>
</blockquote>
<p>子类在定义新的成员时，允许新成员与超类成员同名。对于同名变量成员，超类中的相应成员被隐藏。对于同名方法成员，如果参数形式相同且返回值类型相同，则超类中该方法成员被隐藏；如果参数形式不同，则调用时根据实参类型决定调用哪一个方法成员，与类内方法重载相同。Java语言不允许子类与超类方法同名，而参数形式相同但返回值类型不同。</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>如果程序中需要访问被隐藏的同名超类成员，可以使用关键字super，super指代当前对象中在超类中定义的那一部分。</p>
<p>用super访问超类同名变量成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">		int i;</span><br><span class="line">	public Test()&#123;i=10;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test1 extends Test</span><br><span class="line">&#123;</span><br><span class="line">		double i;</span><br><span class="line">	public Test1()&#123;i=12.345678;&#125;</span><br><span class="line">	public void print()</span><br><span class="line">	&#123;</span><br><span class="line">        System.out.println(&quot;i of sub class &quot;+i);	</span><br><span class="line">             //访问子类成员i</span><br><span class="line">		System.out.println(&quot;i of super class &quot;+super.i);	</span><br><span class="line">         //访问超类成员i</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		Test1 t1=new Test1();</span><br><span class="line">		t1.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="子类对象的构造"><a href="#子类对象的构造" class="headerlink" title="子类对象的构造"></a>子类对象的构造</h2><p>子类对象在创建时需要调用超类的构造方法来构造超类中定义的那部分成员，如果在子类中不特别声明，则调用超类的不带参数的构造方法。</p>
<p>如果超类没有不带参数的构造方法，必须在子类的构造方法中用super关键字指定如何调用超类的构造方法。先看下面的程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">	int a;</span><br><span class="line">	A(int a)&#123;</span><br><span class="line">		this.a=a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">	int b;</span><br><span class="line">	B(int b)&#123;</span><br><span class="line">		this.b=b;</span><br><span class="line">System.out.println(&quot;Class B&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Class1 &#123;</span><br><span class="line">	public static void main (String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">	B b=new B(10);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="final方法与final类"><a href="#final方法与final类" class="headerlink" title="final方法与final类"></a>final方法与final类</h2><p>通过在子类中定义与超类同名的方法成员，覆盖超类的方法成员，改变了超类原有的特征。有时可能程序员不希望子类修改超类原有的特性，这时可以将对应的方法定义为最终(final)方法，子类不再可以覆盖该方法。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    final void Method1()</span><br><span class="line">    &#123;System.out.println(&quot;This is a final method&quot;);&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当从A类派生子类时，子类不可以定义与Method1形式相同的方法。</p>
</blockquote>
<p>关键字final也可以用来修饰类的定义，将一个类定义为最终类，则不再可以从该类派生出子类。基本语法形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final class 类名&#123;</span><br><span class="line">   //成员定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abstract class Root&#123;</span><br><span class="line">public Root(double a,double b,double disc)</span><br><span class="line">	&#123;</span><br><span class="line">		this.a=a;		this.b=b;  this.disc=disc;</span><br><span class="line">	&#125;</span><br><span class="line">	abstract void Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，第一个abstract表示定义一个抽象类，第二个abstract表示Print方法为抽象方法。如果一个类包含有抽象方法，该类必须声明为抽象类。</p>
<p>抽象方法在定义时无需给出方法体，只要给出方法的返回值类型和形式参数表即可。程序中不可创建抽象类对象，必须从抽象类派生出子类，在子类中实现所有抽象的方法后才可以创建子类的对象。如果子类没有实现超类中所有抽象方法，则子类也必须定义为抽象类。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java语言不支持多继承，但通过接口可以实现部分多继承的功能。</p>
<p>接口的定义</p>
<p>接口与抽象类相似，也表达一个抽象的概念。接口中的所有方法都是抽象的，每一个都没有方法体。另外，接口只可以定义static final变量成员。</p>
<p>接口用关键字interface来定义，基本的语法形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 &#123;</span><br><span class="line">              //成员定义</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></p>
<p>接口中所有方法都是抽象的，不要使用abstract。下面是一个简单的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Printable &#123;</span><br><span class="line">            public void Print();</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>接口的实现与继承类似，不过接口实现时使用关键字implements而不是extends。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class IntClass implements Printable&#123;</span><br><span class="line">             int a;</span><br><span class="line">            IntClass(int a)&#123;this.a=a;&#125;</span><br><span class="line">            public void Print()&#123;System.out.println(a);&#125;</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></p>
<p>该类实现了上面定义的Printable接口。</p>
<p>当类实现特殊接口时，必须先定义该接口定义的所有抽象方法，然后才可以在该类的任何对象上调用接口的方法。与抽象类相似，允许使用接口名作为复合变量的类型，在运行时根据对象的实际类型决定调用哪个类中定义的方法，这个过程通常称为动态联编。</p>
<p>例如：<br>Printable obj=new IntClass(10);<br>obj.Print();</p>
<p>可以用instanceof运算符来判断某对象的类是否实现了特定的接口。</p>
<blockquote>
<p>一个类可以实现多个接口，多个接口名在implements后面一一列出，以逗号分隔。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">public class MyApplet extends Applet implements Runnable, MouseListener&#123; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口的派生"><a href="#接口的派生" class="headerlink" title="接口的派生"></a>接口的派生</h2><p>定义接口时也可以从已有的接口派生，新的接口包含了原来接口的所有成员。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface PrintName extends Printable&#123;</span><br><span class="line">            public String ClassName();</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="程序举例"><a href="#程序举例" class="headerlink" title="程序举例"></a>程序举例</h2><p>下面看一个完整的例子，该例演示了如何定义接口、实现接口和使用接口定义的方法。</p>
<p>接口的使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Shape&#123;</span><br><span class="line">	static double pi=3.14159;</span><br><span class="line">    public double area();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Circle implements Shape&#123;</span><br><span class="line">	double Radius;</span><br><span class="line">	Circle(double r)&#123;</span><br><span class="line">		Radius=r;</span><br><span class="line">	&#125;</span><br><span class="line"> public double area()&#123;</span><br><span class="line">	return pi*Radius*Radius;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ch3_19 &#123;</span><br><span class="line"> public static void main(String argv[])</span><br><span class="line">	&#123;</span><br><span class="line">		Shape s=new Circle(2.0);</span><br><span class="line">		System.out.println(&quot;Area is &quot;+s.area());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包-的-使-用"><a href="#包-的-使-用" class="headerlink" title="包 的 使 用"></a>包 的 使 用</h2><p>包的概念</p>
<p>Java程序编译后每一个类和接口都生成一个独立的class文件。对于一个大型程序，由于类和接口的数量很大，如果将它们全放在一起，往往显得杂乱无章，难于管理。Java语言提供了一种解决该问题的方法：将类和接口放在不同的包中。</p>
<p>一个包由一组类和接口组成，包内还可以有子包，类似于目录(文件夹)中可以有若干文件和子目录(子文件夹)一样。实际上，Java系统就是使用文件夹来存放包的，一个包对应一个文件夹，文件夹下有若干个class文件和子文件夹。</p>
<p>当要使用其他包内的类时，可以使用import语句引入其他包内的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里，java为包名，math为java包内的子包，*表示该包中所有类，该语句引入了java.math包中的所有类。</span><br></pre></td></tr></table></figure>
<p>ava包是Sun公司使用Java语言开发的类的集合，是随Java运行系统提供的，Java语言的很多功能依赖于该包中的类。</p>
<p>目前的Java虚拟机通常将java包以一种压缩文件的形式存储在特定的目录中。java包中的子包lang是自动引入的，无需使用import语句引入该包，前面提到的String、StringBuffer、Sytem等类均在该包中定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import也可以引入特定的类，只要用类名取代上面例子里的*即可。</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.Graphics;</span><br></pre></td></tr></table></figure></p>
<p>包的使用可以避免名字冲突，每一个类和接口的名字都包含在某个包中，不同的包中可以有同名的类和接口。</p>
<p>在程序中使用同名类时，可以加上包名以免引起歧义，例如java.awt.Button表示java.awt包中的Button类，此时无需使用import语句引入该类。</p>
<p>另外还应注意：使用import语句引入某个包中的所有类时并不包括该包的子包中的类。</p>
<h2 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h2><p>Java语言规定只能使用其他包中公有(public)的类和接口，即在定义该类时使用了public修饰符</p>
<h2 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h2><p>如果希望将程序中不同的类放在多个不同的包中，可以首先在程序的当前目录中创建相应的子目录，然后将相应的源文件放入对应的文件夹，分别编译，同时应在源文件前面加上相应的包定义语句。</p>
<h2 id="实训三-面向对象程序设计"><a href="#实训三-面向对象程序设计" class="headerlink" title="实训三  面向对象程序设计"></a>实训三  面向对象程序设计</h2><p>一、实训目的<br>1．掌握定义类、创建对象、使用类与对象的方法。<br>2．掌握类及其成员的修饰符的使用。<br>3．掌握如何定义和调用方法。<br>4．掌握形式参数定义，形式参数与实际参数的关系。<br>5．掌握静态变量与非静态变量、局部变量的使用以及静态方法与非静态方法的使用。<br>6．掌握构造方法的使用。<br>7．掌握字符串类、数组的使用。<br>8．掌握继承和重载的概念与实现方法。<br>9．掌握如何从已有类中派生子类。<br>10．掌握方法的覆盖和重载。<br>11．掌握定义包和接口的方法。<br>12．掌握多文件、多类程序编译和发布的方法。</p>
<p>二、实训内容</p>
<p>1．定义并使用一个新类(使用Visual J++完成本任务请参考第1章有关内容)。<br>(1) 使用纯文本编辑软件输入下面这个源程序，保存为Birthday.java。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Birthday </span><br><span class="line">&#123;</span><br><span class="line">public String year;</span><br><span class="line">public String month;</span><br><span class="line">public String day;</span><br><span class="line"></span><br><span class="line">public Birthday()</span><br><span class="line">&#123;</span><br><span class="line">year=&quot;0000&quot;;</span><br><span class="line">month=&quot;00&quot;;</span><br><span class="line">day=&quot;00&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Birthday(String y,String m,String d)</span><br><span class="line">&#123;</span><br><span class="line">year=y;</span><br><span class="line">month=m;</span><br><span class="line">day=d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getBirthday()</span><br><span class="line">&#123;</span><br><span class="line">String fullbirthday=month+&quot;/&quot;+day+&quot;/&quot;+year;</span><br><span class="line">return fullbirthday;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2) 编译这个程序，如果顺利完成，将在当前目录下生成一个名为Birthday.class的文件。<br>(3) 输入以下源程序，保存为useBirthday.java。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">           public class useBirthday </span><br><span class="line">           &#123;</span><br><span class="line">           public static void main(String argv[])</span><br><span class="line">            &#123;</span><br><span class="line">           Birthday birthday1=new Birthday();</span><br><span class="line">           Birthday birthday2=new Birthday(&quot;1949&quot;,&quot;10&quot;,&quot;01&quot;);</span><br><span class="line">          System.out.println(birthday1.getBirthday());</span><br><span class="line">          System.out.println(birthday2.getBirthday());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(4) 编译useBirthday.java后，执行以下命令运行程序：<br>java useBirthday</p>
<p>2．定义一个类Myclass，包含一个整型属性data和封装这两个属性的两个方法getData()和setData()。然后编写一个使用上面定义的类Myclass的Java Applet程序，实现数据的访问和输出。</p>
<p>3．编写一个类实现复数的运算。复数类Complex的属性有：<br>mReal：实部，代表复数的实数部分；<br>mImage：虚部，代表复数的虚数部分。</p>
<p>复数类Complex的方法有：</p>
<p>Complex(double r，double i)：构造函数，创建复数对象的同时完成复数的实部、虚部的初始化，r为实部的初值，i为虚部的初值。</p>
<p>getReal()：获得复数对象的实部。<br>getImage()：获得复数对象的虚部。</p>
<p>setReal(double d)：将当前复数对象的实部设置为给定的形式参数的值。<br>setReal(String s)：将当前复数对象的实部设置为给定的形式参数字符串字面所代表的值。</p>
<h2 id="习-题-三"><a href="#习-题-三" class="headerlink" title="习  题  三"></a>习  题  三</h2><p>1．类及类成员的访问控制符有哪些?</p>
<p>答：来源网络</p>
<p>public：<br>可以在任何地方进行访问，不受任何约束；<br>protected:<br>可被子类访问，不管是同一个包还是不同包<br>同一个包中非子类需要通过对象访问<br>private：<br>只能够被本类中的其它成员访问，而不能从类的外部进行访问<br>缺省：称为friendly，可被同一包的所有的类访问<br>final:<br>final修饰的类表示这个类不可被继承，被称为最终类<br>Static:<br>不能用来修饰类,可以用来修饰变量，用static修饰的变量称为静态变量，可以直接通过 类名.变量名<br>来调用</p>
<p>2．为什么说构造方法是一种特殊的方法? 特殊在哪里? 构造方法什么时候执行? </p>
<p>在java语言 中，构造函数又称构造方法。特殊性在于，与普通方法的区别是，他与类名相同，不返回结果也不加void返回值。构造函数的作用是初始化对象，即在创建对象时被系统调用（与普通方法不同，程序不能显示调用构造函数）。构造函数还能够被重载，即可以传入参数，当程序中包含有带参的构造函数时，系统将不会再提供的无参构造函数。</p>
<p>3．下面的关键字哪些是类及其成员的修饰符?<br>(1)  public      (2)  synchronized      (3)  class      (4)  void<br>(5)  private      (6)  protected        (7)  friendly      (8)  double</p>
<p>4．静态变量成员有什么特点? 类对象可以访问或修改静态变量成员吗？</p>
<p>1.特点一:静态变量的值是共享。比如说A类中有个静态变量V_A，A类创建了两个实例a，b。如果给实例a的变量V_A赋值，如a.V_A=1。那么这时候查看实例b的V_A变量的值也为1，也就是说A对象实例化的两个类共享同一个变量值，而且静态变量<br>2.特点二:不需要对象实例化就可以使用。比如A类中的静态变量V_A可以用A.V_A的形式使用</p>
<p>一、static变量有什么作用呢？<br>（1） 在函数体内，值维持不变，具有“记忆”功能；<br>（2）在模块内（但在函数体外），不能被模块外的其他函数访问；<br>（3）只在一个源文件中有效，不能被其他源文件使用。</p>
<p>引申：static变量只初始化一次 </p>
<p>5．对象初始化有哪几种方法? 写出它们的执行顺序。</p>
<p>1、构造器<br>创建对象时初始化，比较常见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">classA&#123;</span><br><span class="line">publicA()</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">public</span><br></pre></td></tr></table></figure>
<p>2、初始化块<br>较少见，用于有特殊要求的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java 创建对象的四种方式、java对象初始化顺序<br>java创建对象的几种方式：</p>
<p>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。</p>
<p>其中：<br>(1)和(2)都会明确的显式的调用构造函数 ；</p>
<p>(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；</p>
<p>(4)是从文件中还原类的对象，也不会调用构造函数。</p>
<p>对象的初始化顺序：</p>
<p>（1）类加载之后，按从上到下（从父类到子类）执行被static修饰的语句；</p>
<p>（2）当static语句执行完之后,再执行main方法；</p>
<p>（3）如果有语句new了自身的对象，将从上到下执行构造代码块、构造器（两者可以说绑定在一起）。</p>
<p>3、方法<br>即Setter方法，虽然方便（不必在创建对象时一次性初始化），但是可能引发空指针异常。</p>
<p>6．抽象类有什么作用? 接口与抽象类有什么区别？</p>
<p>接口和抽象类有什么区别?</p>
<p>你选择使用接口和抽象类的依据是什么？</p>
<p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。</p>
<p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。</p>
<p>人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.</p>
<p>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 </p>
<p>第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。<br>第二点． 接口可以多继承，抽象类不行<br>第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。<br>第四点． 接口中基本数据类型为static 而抽类象不是的。 </p>
<p>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。<br>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的</p>
<p>所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。</p>
<p>7．抽象方法有什么特点? 抽象方法的方法体在何处定义?</p>
<p>抽象方法一般都定义在父类里面,但这个父类也必须是抽象的,它的特点是没有方法体,只有方法名如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class A&#123;</span><br><span class="line">  public abstract void print();//print()方法没有方法体;</span><br><span class="line">&#125;</span><br><span class="line">//类B 继承A,类B 必须实现父类A中的抽象方法print()</span><br><span class="line">class B extends A&#123;</span><br><span class="line">  public void print()&#123;</span><br><span class="line">   //方法体....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>抽象方法的好处就在于能让子类做一些特定的事</p>
<p>8．为什么定义fianl变量成员时往往声明为static的？</p>
<p>Java中常量为什么定义为public static final </p>
<p>final关键字定义常量，就使得他在被定义后无法再对此进行赋值。而有时候定义的常量是个随机数，这时为了保证不使每次初始化后常量改变，就需要加static了。在同一个对象中是不需要的。被static修饰的变量可以不通过对象用类名直接访问，且只被分配一次内存，节约内存。实质上，就是一个全局变量。static定义的类。。。不知道你指的是不是类中的静态方法。方法的话，和变量一样，可以用类名直接调用，但是不能直接访问这个类除静态外的变量和方法。如果是静态类的话，普通类是不支持声明为静态类的，只有内部类才可以。能直接作为一个普通类使用，不需要实例外部类。作用就很多了，它可以在他所属类创建之前就被访问，最常用的例子就是main方法了。他会独立于该类的任何对象。java虚拟机的加载的顺序为，先加载静态成员变量，然后是静态代码块；同等级的才按照前后顺序依次加载。</p>
<p>final是常量，这个是不占有存储空间的，只能通过对象来引用。<br>static是类成员（区别于对象成员），可以通过类（推荐）和对象来引用。只要你的类加载了，则你的类中static成员就一直可以使用。而final只能存活到对象销毁之前。<br>还有一种是 static final，这个是静态类成员变量，也不占内存。其他和static一样。</p>
<p>9．下面哪些访问控制修饰符的使用是合法的：<br>(1)  public class MyClass{…}<br>(2)  public protected int IntegerValue;<br>(3)  friendly float FloatValue;<br>(4)  String s;<br>10．final修饰符和abstract可以同时使用吗？为什么？</p>
<p>关键字final和abstract是否可以同时做类的修饰符，为什么？ </p>
<p>不可以的。<br>解释：final的类不能被重写和继承，而abstract的类是抽象类，本身没有实现，只能通过子类来实现，也就是说必须被继承。所以说它们是没法同时做修饰符的。</p>
<p>不可以。final修饰类代表该类不能有子类，abstract修饰的类为抽象类，抽象类就是给其他类继承的。明显存在矛盾</p>
<p>final关键字的用法：</p>
<p>   1、final关键字修饰变量（成员变量和局部变量的区别，引用变量和基本数据类型的区别）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2、final可以修饰方法</span><br><span class="line">3、final修饰类</span><br></pre></td></tr></table></figure></p>
<p>其中final修饰方法跟继承有关，而且不能被子类重写；</p>
<p>fianl修身类是不能被继承的；而且要注意：fianl修饰基本数据类型的成员变量必须赋值，否则编译器报错。并且fianl修饰的成员变量一旦赋值就不可改变。</p>
<p>abstract 关键字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abstract要注意一下几点：</span><br><span class="line"></span><br><span class="line">1.对于方法来说，加了abstract就没有意义了。</span><br><span class="line">2.有抽象方法的类一定是抽象类，抽象类不一定有抽象方法。然而方法中用了abstract，那本身就成了抽象类。</span><br><span class="line"></span><br><span class="line">    例如：public abstract class Shape&#123;&#125;  // 表示抽象类。</span><br><span class="line"></span><br><span class="line">3.抽象类不允许被实例化。</span><br><span class="line"></span><br><span class="line">4.抽象类有构造方法，子类可以通过shper调用父类的构造方法，对从父类的属性进行初始化。</span><br><span class="line"></span><br><span class="line">5.抽象关键字不可以与fianl关键字一起使用，因为abstract要求子类一定要重写父类的方法，但fianl不允许重写。</span><br><span class="line"></span><br><span class="line">6.抽象关键字不恶意和private关键字一起使用，因为private是私有的，不能被继承的内容代表根本不存在</span><br><span class="line"></span><br><span class="line">7.关键字不能与static一起使用，static是静态修饰符，代表不需要实例化对象，直接类名就可以调用，如果是抽象方法，没有方法实现调用方法会出错，所以不能一起使用。</span><br><span class="line"></span><br><span class="line">8.构造方法不允许被继承，也没有重写，不能用abstract修饰。</span><br><span class="line"></span><br><span class="line">注意：用abstract修饰的方法没有方法执行体，因为不行有任何内容；而且abstract修饰的方法在子类中必须重写，抽象类不能够被实例化，可子类创建对象进行调用。</span><br></pre></td></tr></table></figure></p>
<h2 id="类的定义和对象使用"><a href="#类的定义和对象使用" class="headerlink" title="类的定义和对象使用"></a>类的定义和对象使用</h2><p>Java程序的开发过程<br>数据类型<br>运算符和表达式<br>语句</p>
<h3 id="面向对象编程的基本概念"><a href="#面向对象编程的基本概念" class="headerlink" title="面向对象编程的基本概念"></a>面向对象编程的基本概念</h3><p>类的定义</p>
<ul>
<li>类首部</li>
<li>类体</li>
</ul>
<ol>
<li>成员变量</li>
<li>成员方法</li>
</ol>
<p>对象的创建与使用</p>
<ul>
<li>创建对象</li>
<li>使用对象</li>
</ul>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><h2 id="面向对象编程的基本概念-1"><a href="#面向对象编程的基本概念-1" class="headerlink" title="面向对象编程的基本概念"></a>面向对象编程的基本概念</h2><p>类和对象</p>
<ul>
<li>类是 定义对象的 模板，用来描述一类事物的 共有 属性 和 功能 。</li>
<li>对象 是 一个具体的 事物。</li>
</ul>
<p>例：<br>汽车类—某辆汽车<br>学生类—某个学生<br>窗口类—某个具体的窗口</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><ul>
<li><p>类的定义 可以是 分层次 的，低层的类 具有 高层类的 属性 和 方法 ，称高层类为 父类 ，低层类 为 子类。 子类 使用父类中定义的 方法和变量 时，就像它们属于子类本身一样。</p>
</li>
<li><p>可以简化编程的过程，有利于代码的复用。 子类除了拥有 父类的方法和变量 之外，也可以 定义自己 方法和变量 。</p>
</li>
</ul>
<p>哺乳动物：胎生，能用母乳喂养幼仔。<br>猫：胎生，能用母乳喂养幼仔。会捉老鼠。</p>
<h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><p>类 是 Java语言中的一种 复合数据类型 ，是组成Java程序的 基本要素 。Java的类 具有两种基本成分： 数据和行为（状态和方法）。类的这两种 成分 被封装在类体中，与外界隔开。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>类首 [修饰符]  class 类名 [extends父类名]</p>
<p>类体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	[类成员变量声明；]</span><br><span class="line">	[类方法声明]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最简单的类定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class  A</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类的修饰符有：<br>public、abstract、final……</p>
<blockquote>
<p>extends  父类名：表示所定义的类由“父类”继承而来。</p>
</blockquote>
<blockquote>
<p>implements 接口列表：该类对指定接口进行实现。</p>
</blockquote>
<h2 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h2><p>成员变量：是类的数据成分，在类体中直接定义，定义格式如下：</p>
<blockquote>
<p>[修饰符]    变量类型  成员变量名列表；</p>
</blockquote>
<p>成员变量的定义可以在定义前加修饰符：public、private、protected、final、static等，用来标识变量的使用范围和性质。</p>
<blockquote>
<p>局部变量：在方法体内定义的变量和方法的参数是局部变量。</p>
</blockquote>
<ol>
<li><p>变量类型可以是基本数据类型，也可以是引用数据类型，如：数组、类类型。</p>
</li>
<li><p>成员变量在整个类的内部有效，局部变量只在定义它的方法内有效。</p>
</li>
<li><p>局部变量名可以和成员变量名重名，此时局部变量会隐藏成员变量，如果想在该方法内部使用成员变量，使用关键字this。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class People</span><br><span class="line">&#123;</span><br><span class="line">	float hight,weight;</span><br><span class="line">	String head,ear,mouth; </span><br><span class="line">	void speak(String s)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>成员方法是类的行为成分，声明格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]   返回值类型   方法名（[形参列表]） </span><br><span class="line">&#123;</span><br><span class="line">	[方法体]</span><br><span class="line">	[return  表达式；]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>修饰符：public 、 private、protected、static、final……</li>
<li>如果方法没有返回值，则使用void关键字。如果有返回值类型，则方法体中必须有return语句，并且表达式类型与方法类型一致。</li>
<li>形式参数列表的形式如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型名   形参名1，类型名   形参名2，……</span><br><span class="line">如：public void out(int x,int y,float f)</span><br><span class="line">	&#123;System.out.println(“x=”+x+”y=”+y+”f=”+f); &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Triangle&#123;</span><br><span class="line">	float sideA,sideB,sideC,lengthSum;</span><br><span class="line">	void setSide(float sideA,float sideB,float sideC)&#123;</span><br><span class="line">		this.sideA=sideA;</span><br><span class="line">		this.sideB=sideB;</span><br><span class="line">		this.sideC=sideC;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的定义–例1"><a href="#类的定义–例1" class="headerlink" title="类的定义–例1"></a>类的定义–例1</h2><p>定义描述“人”的类：<br>成员变量：姓名、性别、年龄；<br>成员方法：唱歌，跳舞，输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	String name,sex;</span><br><span class="line">	int age;</span><br><span class="line">	void sing()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;I can sing!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	void dance()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;I can dance!&quot;);</span><br><span class="line">	&#125; </span><br><span class="line">	void out()//成员变量的操作只能放在方法中</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;name:&quot;+name);</span><br><span class="line">		System.out.println(&quot;age:&quot;+age);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：一个类中可以没有main方法，此时它不是Java的application应用程序，也就是不能被Java虚拟机直接调用。</p>
<h2 id="类的定义–例2梯形"><a href="#类的定义–例2梯形" class="headerlink" title="类的定义–例2梯形"></a>类的定义–例2梯形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">梯形类：</span><br><span class="line">class Ladder</span><br><span class="line">&#123;</span><br><span class="line">	float a,b,h;</span><br><span class="line">	void setH(float h)</span><br><span class="line">	&#123;</span><br><span class="line">		this.h=h;</span><br><span class="line">	&#125;</span><br><span class="line">	float calculatArea()</span><br><span class="line">	&#123;</span><br><span class="line">		return   (a+b)*h/2;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h2><p>如何调用类中定义的成员变量和成员方法，在Java中类只有实例化为对象后才能被使用(注：main方法为特殊方法，由系统调用) ，对象的使用“分三步走”：</p>
<p>1、声明对象<br>    类名  对象名；</p>
<p>2、分配内存（对象的实例化）<br>    对象名=new 类构造方法名（[实参表]）；</p>
<p>3、使用对象（对象的成员变量及方法的访问）<br>    对象名.方法名、对象名.成员变量名</p>
<p>声明和初始化可以合并：<br>类名  对象名=new 类的构造方法名（ [实参表] ）；<br>说明：<br>构造方法名与类名相同，如果一个类中未定义构造方法，系统自动定义。</p>
<h3 id="使用对象—例3"><a href="#使用对象—例3" class="headerlink" title="使用对象—例3"></a>使用对象—例3</h3><p>方法一：在同一个类中使用对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		Person p;</span><br><span class="line">		p=new Person();</span><br><span class="line">		p.name=&quot;zhangsan&quot;;</span><br><span class="line">		p.age=20;	</span><br><span class="line">		p.sing();</span><br><span class="line">		p.out();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用对象—例4"><a href="#使用对象—例4" class="headerlink" title="使用对象—例4"></a>使用对象—例4</h3><p>方法二：在不同类中使用对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">&#125;</span><br><span class="line">class  PersonTest</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		Person p;</span><br><span class="line">		p=new Person();</span><br><span class="line">		p.name=&quot;zhangsan&quot;;</span><br><span class="line">		p.age=20;	</span><br><span class="line">		p.sing();</span><br><span class="line">		p.out();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用对象—例5-梯形"><a href="#使用对象—例5-梯形" class="headerlink" title="使用对象—例5 梯形"></a>使用对象—例5 梯形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">	float area;</span><br><span class="line">	Ladder ladder=new Ladder();</span><br><span class="line">	ladder.a=10.0f;</span><br><span class="line">	ladder.b=20.0f;</span><br><span class="line">	ladder.setH(5f);</span><br><span class="line">	area=ladder.calculatArea();</span><br><span class="line">	System.out.println(&quot;area=&quot;+area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象的内存模型"><a href="#对象的内存模型" class="headerlink" title="对象的内存模型"></a>对象的内存模型</h2><p>引用数据类型 与 引用变量：引用数据类型（数组、类）声明的变量为 引用变量 ，引用变量本身 并不存放数据 ，而只是 存放数据的地址  。 </p>
<blockquote>
<p>Java的内存分配 — Java把内存划分成两种： 栈内存、堆内存</p>
</blockquote>
<p>Person p;<br>声明对象p时，</p>
<p>在栈内存中分配空间，用来存放一个地址，此时地址未指向任何数据。</p>
<p>p=new Person();时，</p>
<p>首先在堆内存中为对象分配存储空间，并对各成员变量进行初始化，数值型为0，布尔型为false，引用型为null；然后 取得这个存储空间的地址（引用），将其“交给”引用变量p，以后对这个对象的操作全由p去控制。</p>
<blockquote>
<p>多次使用new便会创建多个不同的对象。</p>
</blockquote>
<p>在方法中定义的一些基本类型的变量和引用变量都是在方法的栈内存中分配。当在一段代码块（也就是一对{}之间）定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后， Java会自动释放为该变量分配的内存空间，以前所讲的变量分配都是在栈内存中存放的。</p>
<h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Person()</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(“我是构造方法，已被调用！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们并没有调用对象的Person()方法，但是它却被执行了。<br>这个方法就是构造方法</p>
<h2 id="构造方法的说明"><a href="#构造方法的说明" class="headerlink" title="构造方法的说明"></a>构造方法的说明</h2><p>说明形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [构造方法修饰符] 方法名（[形式参数列表]）</span><br><span class="line">&#123;方法体&#125;</span><br></pre></td></tr></table></figure></p>
<p>⑴构造方法的名字与类的名字相同</p>
<p>⑵构造方法没有返回类型</p>
<p>(千万不要将返回值类型声明为void。也不能在方法内部使用return返回一个值。)</p>
<p>一般将构造方法声明为公共的public型。</p>
<p>⑶构造方法对对象的创建是必须的。</p>
<p>实际上Java语言为每一个类提供了一个默认的构造方法，也就是说，每个类都有构造方法。</p>
<p>如果不定义一个构造方法，Java语言将调用它提供的默认的构造方法对一个新的对象进行初始化。</p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>在一个类中可以定义同名的方法，但是 参数的类型和个数 不能完全相同，</p>
<p>同名的方法可以有不同的方法体从而完成不同的任务，</p>
<p>当调用方法时，系统会自动调用与实际参数类型和个数相匹配的的那一个方法，</p>
<p>这就是方法的重载。</p>
<p>在面向对象编程中，这种同一个名字可以有不同解释的现象称为多态。</p>
<h2 id="类与对象-1"><a href="#类与对象-1" class="headerlink" title="类与对象"></a>类与对象</h2><p>方法的重载、static、包</p>
<p>类的定义</p>
<ul>
<li>成员变量说明</li>
<li>成员方法说明</li>
</ul>
<p>对象的创建和使用</p>
<ul>
<li>创建对象</li>
<li>通过对象引用成员变量和成员方法</li>
</ul>
<p>构造方法</p>
<ul>
<li>构造方法与一般成员方法的区别</li>
</ul>
<p>方法的重载</p>
<ul>
<li>成员方法的重载</li>
<li>构造方法的重载</li>
</ul>
<blockquote>
<p>static变量和static方法</p>
</blockquote>
<p>包</p>
<ul>
<li>package命令</li>
<li>import命令</li>
</ul>
<h2 id="方法的重载-1"><a href="#方法的重载-1" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>在一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同，即或者是参数的个数不同，或者是参数的类型不同。</p>
<p>同名的方法可以有不同的方法体从而完成不同的任务，当调用方法时，系统会根据调用方法的实际参数类型和个数自动调用相应的方法，这就是方法的重载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Heshang</span><br><span class="line">&#123;</span><br><span class="line">	void dashui(String s)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println (s+&quot;挑水喝&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	void dashui(String s1,String s2)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println (s1+&quot;和&quot;+s2+&quot;抬水喝&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	void dashui(String s1,String s2,String s3)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println (s1+&quot; &quot;+s2+&quot; &quot;+s3+&quot;没水喝&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    	Heshang h=new Heshang();</span><br><span class="line">    	h.dashui(&quot;孙悟空&quot;);</span><br><span class="line">    	h.dashui(&quot;孙悟空&quot;,&quot;猪八戒&quot;);</span><br><span class="line">    	h.dashui(&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造方法的重载"><a href="#构造方法的重载" class="headerlink" title="构造方法的重载"></a>构造方法的重载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">	String name;int age;float height,weight;</span><br><span class="line">	public Person()</span><br><span class="line">	&#123;</span><br><span class="line">		age=18;</span><br><span class="line">		name=&quot;无名&quot;;		</span><br><span class="line">	&#125;</span><br><span class="line">	public Person(String name)</span><br><span class="line">	&#123;</span><br><span class="line">		this.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">	public Person(String name,int age,float height,float weight)</span><br><span class="line">	&#123;</span><br><span class="line">		this.name=name;</span><br><span class="line">		this.age=age;</span><br><span class="line">		this.height=height;</span><br><span class="line">		this.weight=weight;</span><br><span class="line">	&#125;</span><br><span class="line">	void out()//成员变量的操作只能放在方法中</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(“姓名:”+name+“ 年龄:”+age+“岁”+</span><br><span class="line">		&quot; 身高:&quot;	+height+&quot;米&quot;+&quot; 体重:&quot;+weight+&quot;斤&quot;);</span><br><span class="line">		System.out.println ();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class PersonTest</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		Person p1,p2,p3;</span><br><span class="line">		p1=new Person();</span><br><span class="line">		p2=new Person(&quot;孙悟空&quot;);</span><br><span class="line">		p3=new Person(&quot;猪八戒&quot;,300,2.8f,380);</span><br><span class="line">		p1.out();p2.out();p3.out();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象变量的赋值"><a href="#对象变量的赋值" class="headerlink" title="对象变量的赋值"></a>对象变量的赋值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class PersonTest</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		Person p1,p2,p3;</span><br><span class="line">		p1=new Person();</span><br><span class="line">		p2=new Person(&quot;孙悟空&quot;);</span><br><span class="line">		p3=new Person(&quot;猪八戒&quot;,300,2.8f,380);</span><br><span class="line">		p1=p2;</span><br><span class="line">		p1.name= “唐僧”;p1.age=50;</span><br><span class="line">		 p1.out(); p2.out(); p3.out();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象变量的赋值，只是对象中保存的地址发生的变化，而并未改变对象的状态。<br>如果一个对象没有任何变量引用它，则它成为垃圾内存。</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>静态变量/静态方法：对于成员变量/成员方法的声明，可以在类型的前面加修饰符“static”，称之为静态变量/静态方法。</p>
<p>类变量/类方法和实例变量/实例方法：静态变量/静态方法属于类而不属于类的某个实例，可直接由类名来调用（类名·变量名/类名·方法名），因此也叫类变量/类方法；</p>
<p>非静态的成员变量/方法必须实例化后通过对象名来调用（对象名·变量名/对象名·方法），因此称为实例变量/实例方法。</p>
<p>说明：类变量和类方法也可以通过实例调用。</p>
<p>类变量，它属于类所有，且在所有的实例中都共享同一个内存空间；</p>
<p>实例变量，对于每一个实例，这个变量都拥有独自的内存空间。</p>
<p>类方法，在类加载时分配方法入口地址，因此可被类直接调用。</p>
<p>实例方法，只有创建类的对象，才会分配方法入口地址，并只能通过对象调用方法。</p>
<p>main()方法是静态的，因此java虚拟机在执行main方法时不需创建main方法所在类的实例就可以直接调用。</p>
<h2 id="类变量-类方法、实例变量-实例方法"><a href="#类变量-类方法、实例变量-实例方法" class="headerlink" title="类变量/类方法、实例变量/实例方法"></a>类变量/类方法、实例变量/实例方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class StaticDemo</span><br><span class="line">&#123;</span><br><span class="line">    static int x;</span><br><span class="line">    int y;</span><br><span class="line">    public static int getX()</span><br><span class="line">    &#123;</span><br><span class="line">	return x;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void setX(int newX)</span><br><span class="line">    &#123;</span><br><span class="line">	x=newX;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getY()</span><br><span class="line">    &#123;</span><br><span class="line">	return y;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setY(int newY)</span><br><span class="line">    &#123;</span><br><span class="line">	y=newY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存模型分析"><a href="#内存模型分析" class="headerlink" title="内存模型分析"></a>内存模型分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ShowDemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;静态变量 x=&quot;+StaticDemo.getX());</span><br><span class="line">        StaticDemo a=new StaticDemo();</span><br><span class="line">        StaticDemo b=new StaticDemo();</span><br><span class="line">        a.setX(10);</span><br><span class="line">        a.setY(20);</span><br><span class="line">        b.setX(30);</span><br><span class="line">        b.setY(40);</span><br><span class="line">        System.out.println(&quot;静态变量 a.x=&quot;+a.getX());</span><br><span class="line">        System.out.println(&quot;实例变量 a.y=&quot;+a.getY());</span><br><span class="line">        System.out.println(&quot;静态变量 b.x=&quot;+b.getX());</span><br><span class="line">        System.out.println(&quot;实例变量 b.y=&quot;+b.getY());</span><br><span class="line">        System.out.println(&quot;静态变量 x=&quot;+StaticDemo.getX());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="static应用注意事项"><a href="#static应用注意事项" class="headerlink" title="static应用注意事项"></a>static应用注意事项</h2><p>总结（静态成员在使用时应该注意）：</p>
<p>1、静态方法中只能直接调用同类中其他静态成员，而不能调用非静态成员。反之，则可以。<br>2、静态成员的引用直接通过类名引用，也可以通过该类的对象来引用。<br>3、静态方法中不能使用super和this变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例3：</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    static int i=10;</span><br><span class="line">    String s=&quot;hello world!&quot;;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">	System.out.println(&quot;i=&quot;+i);</span><br><span class="line">       //	System.out.println(&quot;s=&quot;+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this关键字只能用在实例方法或构造方法中，代表使用该方法的当前的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void setAge(int age)</span><br><span class="line">&#123;</span><br><span class="line">	this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">	Person p1,p2,p3;</span><br><span class="line">	p1=new Person();</span><br><span class="line">	p2=new Person(&quot;孙悟空&quot;);</span><br><span class="line">	p3=new Person(&quot;猪八戒&quot;,300,2.8f,380);</span><br><span class="line">	p1.setAge(18);p2.setAge(19);p3.setAge(20);</span><br><span class="line">	p1.out();p2.out();p3.out();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h2><p>为了便于管理大型软件系统中数目众多的类，解决类命名冲突的问题，java引入了包。<br>Java中的包与文件系统的目录层次结构是一一对应的。一个包中可以包含子包，包名与子包名间用“·”分隔。<br>Java提供的类和接口是按不同的用途分别放在不同的包中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.applet</span><br><span class="line">java.awt</span><br><span class="line">java.lang</span><br><span class="line">java.io</span><br><span class="line">java.net</span><br><span class="line">java.util</span><br></pre></td></tr></table></figure></p>
<h2 id="package-语句"><a href="#package-语句" class="headerlink" title="package 语句"></a>package 语句</h2><p>功能：创建包<br>格式：package 包名[.子包名[…]];<br>要求：此语句必须放在整个源程序第一条语句<br>例：package  p;//(在当前目录下创建一个p包)<br>      package  a.b;//（在当前目录下创建a，在a下再创建b）<br>注意：嵌套的包名之间以圆点分隔（“.”）。如果源文件中省略了package语句，则文件中定义的类隐含在一个无名包中，这个无名包就是源文件所在的位置。</p>
<blockquote>
<p>引入java包中的类和接口import语句</p>
</blockquote>
<p>一般情况下import语句紧跟在package语句之后<br>功能：将其他包中的类引入到当前程序中。<br>格式：import  带包层次结构的类名;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">1、引入包时，类名可以使用通配符“*”，表示包模块中某个层次的类全引入进来。</span><br><span class="line">例：	import  java.io.*;</span><br><span class="line">	import java.awt.Graphics;</span><br><span class="line">2、java会自动引入lang包下的所有类和接口。</span><br><span class="line">3、前缀包名法：不用import语句也可以引入其他包中的类和接口。</span><br></pre></td></tr></table></figure>
<h2 id="类与对象-2"><a href="#类与对象-2" class="headerlink" title="类与对象"></a>类与对象</h2><blockquote>
<p>访问权限、类的继承、对象的上转型</p>
</blockquote>
<p>访问权限</p>
<p>私有变量和私有方法（private关键字）<br>共有变量和共有方法(public关键字)<br>保护变量和保护方法(protected关键字)</p>
<p>友好变量和友好方法<br>public类与友好类</p>
<p>类的继承（重点）</p>
<p>创建子类<br>子类的继承性</p>
<blockquote>
<p>成员变量的隐藏和方法的重写</p>
</blockquote>
<p>final类和final方法</p>
<p>对象的上转型对象<br>多态性</p>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>用一个类创建一个对象后，通过对象可以访问这个类的成员变量和成员方法，但这种访问是有一定限制的。</p>
<p>这种限制取决于在声明变量和成员方法时使用的修饰符：public、private、protected、友好（未使用修饰符）。</p>
<h3 id="private变量和方法"><a href="#private变量和方法" class="headerlink" title="private变量和方法"></a>private变量和方法</h3><p>访问权限最小，只能在同一个类中被访问。</p>
<ul>
<li>同一个类的方法中直接访问。</li>
<li>同一个类的对象也可以引用本类的私有成员。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Tom</span><br><span class="line">&#123;</span><br><span class="line">	private  float weight;</span><br><span class="line">	private static String name;</span><br><span class="line"></span><br><span class="line">	private void out()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println (name+&quot;体重：&quot;+weight+&quot;斤&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">    	Tom.name=&quot;汤姆猫&quot;;</span><br><span class="line">	Tom cat=new Tom();</span><br><span class="line">    	cat.weight=20; //或cat.setWeight(20);</span><br><span class="line">    	cat.out();    	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类中的私有成员不能在另一个类中引用<br>私有的类变量和类方法也只能在本类中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Jerry</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">    	Tom.name=&quot;汤姆猫&quot;;//非法使用类变量</span><br><span class="line">	Tom cat=new Tom();</span><br><span class="line">    	cat.weight=20;//非法引用变量weight</span><br><span class="line">	cat.setWeight(20);//合法地调用方法setWeight()</span><br><span class="line">    	cat.out();//非法调用方法out()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="public变量和方法"><a href="#public变量和方法" class="headerlink" title="public变量和方法"></a>public变量和方法</h2><p>访问权限最大，可以在不同类、不同包的类中访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package p1;</span><br><span class="line">public class Area</span><br><span class="line">&#123;</span><br><span class="line">	public float getArea(float r)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(&quot;方法一：&quot;);</span><br><span class="line">		return 3.14f*r*r;</span><br><span class="line">	&#125;</span><br><span class="line">	public double getArea(float x,int y)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(&quot;方法二：&quot;);</span><br><span class="line">		return x*y;</span><br><span class="line">	&#125;</span><br><span class="line">	public float getArea(int x,float y)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(&quot;方法三：&quot;);</span><br><span class="line">		return x*y;</span><br><span class="line">	&#125;</span><br><span class="line">	public double getArea(float x,float y,float z)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(&quot;方法四：&quot;);</span><br><span class="line">		return (x+x+y*y+z*z)*2.0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package p2;</span><br><span class="line">import p1.Area;</span><br><span class="line">class AreaTest</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">&#123;</span><br><span class="line">    	Area a=new Area();</span><br><span class="line">    	System.out.println (a.getArea(2.0f));</span><br><span class="line">    	System.out.println (a.getArea(12,2.7f));</span><br><span class="line">    	System.out.println (a.getArea(2.7f,12));</span><br><span class="line">    	System.out.println (a.getArea(2.0f,10,20));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="友好变量和方法"><a href="#友好变量和方法" class="headerlink" title="友好变量和方法"></a>友好变量和方法</h2><p>不使用修饰符：public、private、protected，即缺省这些修饰符的情况。<br>比private权限级别高一级<br>友好成员只能被同类或同包中的不同类引用。</p>
<h2 id="protected变量和方法"><a href="#protected变量和方法" class="headerlink" title="protected变量和方法"></a>protected变量和方法</h2><p>比友好成员高一级，比public低一级。<br>不能在不同包的类中被引用。<br>如果不同包中的类是本类的子类，则子类的对象可以引用本类的受保护成员。</p>
<h3 id="方法的访问控制"><a href="#方法的访问控制" class="headerlink" title="方法的访问控制"></a>方法的访问控制</h3><p>同类 public    protected 友好 private</p>
<p>同包不同类 public protected 友好</p>
<p>不同包子类 public protected</p>
<p>通用 public </p>
<h3 id="public类和友好类"><a href="#public类和友好类" class="headerlink" title="public类和友好类"></a>public类和友好类</h3><p>如果定义类时，使用public修饰，则该类为公共类。可以在不同的包中被其他类使用。<br>如果未使用修饰符，则为友好类。只能被同包里的类使用。</p>
<h2 id="类的继承-1"><a href="#类的继承-1" class="headerlink" title="类的继承"></a>类的继承</h2><p>继承：由已有类创建新类的机制。新类继承已有类的成员，并可根据需要增加自己新的成员。已有类称为父类，新类称为已有类的子类。</p>
<p>Java不支持多继承，一个子类只能有一个父类，但一个父类可以派生出若干个子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Person</span><br><span class="line">&#123;</span><br><span class="line">     String name;</span><br><span class="line">     int age;</span><br><span class="line">     public void setAge(int age)</span><br><span class="line">     &#123;</span><br><span class="line">	this.age=age;</span><br><span class="line">     &#125;</span><br><span class="line">     public void out()</span><br><span class="line">     &#123;</span><br><span class="line">     	System.out.println(&quot;姓名:&quot;+name+&quot; 年龄:&quot;+age+&quot;岁&quot;);		</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Student extends Person</span><br><span class="line">&#123;</span><br><span class="line">     int java,flash;</span><br><span class="line">     void learn()</span><br><span class="line">     &#123;</span><br><span class="line">          System.out.println (name+&quot; is learning!&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     void outStudent()</span><br><span class="line">     &#123;</span><br><span class="line">	System.out.println (&quot;java:&quot;+java+</span><br><span class="line">	&quot;\tflash:&quot;+flash);</span><br><span class="line">     &#125;</span><br><span class="line">     public static void main(String[]args)</span><br><span class="line">     &#123;</span><br><span class="line">    	Student s=new Student();</span><br><span class="line">    	s.name=&quot;孙悟空&quot;;</span><br><span class="line">    	s.age=500;s.java=80;s.flash=85;</span><br><span class="line">    	s.learn();</span><br><span class="line">    	s.outStudent();s.out();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的继承性"><a href="#类的继承性" class="headerlink" title="类的继承性"></a>类的继承性</h2><p>子类和父类在同一包中<br>子类可继承其父类中非私有成员（不是private的成员）<br>子类和父类不在同一包中<br>子类只能继承受保护的和共有成员（public、protected）</p>
<h2 id="成员变量的隐藏和方法的重写"><a href="#成员变量的隐藏和方法的重写" class="headerlink" title="成员变量的隐藏和方法的重写"></a>成员变量的隐藏和方法的重写</h2><p>成员变量的隐藏：如果在子类中定义了与父类中同名的变量，父类的这个变量将被隐藏。</p>
<p>方法的重写：如果子类中定义了与父类同名、同类型、相同参数的方法，则称子类覆盖了父类的方法。</p>
<p>这是子类的一种“变异”，子类可以根据需要把从父类继承来的方法进行改造。<br>比如：在student类中重新声明变量age和方法out()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    	Student s=new Student();</span><br><span class="line">    	s.name=&quot;孙悟空&quot;;</span><br><span class="line">    	s.age=500;</span><br><span class="line">	s.java=80;</span><br><span class="line">	s.flash=85;</span><br><span class="line">    	s.learn();</span><br><span class="line">    	s.out();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="super变量"><a href="#super变量" class="headerlink" title="super变量"></a>super变量</h2><p>特殊变量super，提供了对父类的访问。</p>
<p>1、可以使用super访问父类被子类隐藏的变量或覆盖的方法。<br>如：在student类中改写out方法时，可以使用super.out();来调用父类中对name和age的输出。调用父类的变量super.name。</p>
<p>2、可能通过Super([参数表])来高用父类的构造方法。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。<br>如：在Person类中只定义带参数的构造方法，如何定义子类Student的构造方法？？？？？？？</p>
<h2 id="final类和final成员"><a href="#final类和final成员" class="headerlink" title="final类和final成员"></a>final类和final成员</h2><p>final类：不能派生子类。<br>final变量，其值不能在程序运行过程中改变，是常量。<br>final方法，不能被子类方法重写。</p>
<h2 id="对象的上转型对象"><a href="#对象的上转型对象" class="headerlink" title="对象的上转型对象"></a>对象的上转型对象</h2><p>父类的变量能否引用子类的对象？能。</p>
<p>子类的变量能否引用父类的对象？不能。</p>
<p>父类的变量称为子类对象的上转型对象。</p>
<p>Person  p;<br>p=new Student();</p>
<p>Student s;<br>s=new Student();</p>
<p>p=s;</p>
<h2 id="上转型对象操作说明"><a href="#上转型对象操作说明" class="headerlink" title="上转型对象操作说明"></a>上转型对象操作说明</h2><p>上转型对象不能操作子类新增成员<br>上转型对象可以操作从父类继承的成员，或在子类中重写的父类成员。<br>上转型对象在被改写的成员时，调用子类成员，而非父类成员。<br>上转型对象通过强制类型转换成为子类对象。</p>
<h2 id="多态性-1"><a href="#多态性-1" class="headerlink" title="多态性"></a>多态性</h2><p>在程序中同一符号或名字在不同情况下具有不同解释的现象称为多态性。表现在两方面：<br>方法的重载。</p>
<p>对象的上转型对象。子类可以改写父类的方法，而上转型对象（父类的对象）可以调用改写后的方法。不同的子类可能改写的内容不同。比如：动物类中的cry()方法，在子类“猫”中可以改写为“喵喵”，而在子类“狗”中可以改定为“汪汪”。猫类的和狗类的上转型对象在调用cry()方法时是各不相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">访问权限</span><br><span class="line">种类，级别顺序</span><br><span class="line">子类</span><br><span class="line">子类继承</span><br><span class="line">成员的隐藏和重写</span><br><span class="line">对象的上转型对象</span><br><span class="line">多态性</span><br></pre></td></tr></table></figure>
<h3 id="类的继承-2"><a href="#类的继承-2" class="headerlink" title="类的继承"></a>类的继承</h3><p>相关知识点<br>子类的构造方法与父类构造方法之间的关系：子类构造方法的第一条语句隐含调用父类的构造方法—super();<br>子类继承父类中的非private成员（在同一个包中）<br>子类继承父类中的非private与非友好成员（不同的包中）<br>子类中的成员与父类中成员相同，则隐藏父类成员<br>父类的对象变量（对象的上转型对象）可以引用子类的对象</p>
<h2 id="抽象类与抽象方法-1"><a href="#抽象类与抽象方法-1" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h2><ul>
<li>类的多态</li>
<li>抽象方法与抽象类</li>
</ul>
<h2 id="多态性-2"><a href="#多态性-2" class="headerlink" title="多态性"></a>多态性</h2><p>在程序中同一符号或名字在不同情况下具有不同解释的现象称为多态性。表现在两方面：<br>方法的重载。</p>
<p>对象的上转型对象。子类可以改写父类的方法，而上转型对象（父类的对象）可以调用改写后的方法。不同的子类可能改写的内容不同。比如：动物类中的cry()方法，在子类“猫”中可以改写为“喵喵”，而在子类“狗”中可以改定为“汪汪”。猫类的和狗类的上转型对象在调用cry()方法时是各不相同的。</p>
<h2 id="抽象方法与抽象类"><a href="#抽象方法与抽象类" class="headerlink" title="抽象方法与抽象类"></a>抽象方法与抽象类</h2><p>用关键字abstract修饰的类就是抽象类。</p>
<p>没有方法体的方法，且首部用关键字abstract修饰，就是抽象方法。声明抽象方法的格式：</p>
<blockquote>
<p>[修饰符…]abstract 返回值类型 方法名([形参列表]); </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AAnimal		</span><br><span class="line">&#123;</span><br><span class="line">	public String  name;</span><br><span class="line">	public int age;</span><br><span class="line">	public void print()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;名字:&quot;+name);</span><br><span class="line">		System.out.println(&quot;大小:&quot;+age);</span><br><span class="line">	&#125;</span><br><span class="line">	public abstract void run();</span><br><span class="line">	public abstract void cry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象方法与抽象类使用说明</p>
<p>含有抽象方法的类必须定义为抽象类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AAnimal		//错误</span><br><span class="line">&#123;</span><br><span class="line">	public String  name;</span><br><span class="line">	public int age;</span><br><span class="line">	public void print()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;名字:&quot;+name);</span><br><span class="line">		System.out.println(&quot;大小:&quot;+age);</span><br><span class="line">	&#125;</span><br><span class="line">	public abstract void run();</span><br><span class="line">	public abstract void cry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能由抽象类直接创建对象。它只能做为父类使用，<br>由它派生的子类必须实现抽象类中所有的抽象方法，<br>才能创建对象。</p>
<p>抽象方法的实现：<br>子类重写父类的抽象方法，<br>增加方法体，<br>使之成为一个非抽象方法。<br>可以空实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    	AAnimal a;</span><br><span class="line">    	a=new AAnimal();	//错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Dog extends AAnimal</span><br><span class="line">&#123;</span><br><span class="line">	String type;</span><br><span class="line">	public Dog()</span><br><span class="line">	&#123;</span><br><span class="line">		type=&quot;宠物狗&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()&#123;	&#125;</span><br><span class="line">	public void cry()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println (&quot;汪汪叫&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    	Dog a;</span><br><span class="line">    	a=new Dog();</span><br><span class="line">    	a.name=&quot;欢欢&quot;;a.age=2;</span><br><span class="line">    	a.print();</span><br><span class="line">    	a.cry();</span><br><span class="line">    	System.out.println (&quot;这是一只&quot;+a.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子类没有实现抽象基类(父类)中所有的抽象方法，则子类也必须定义成一个抽象类。即：抽象的子类也必须使用修饰符：abstract</p>
<p>可以将没有任何抽象方法的类声明为abstract，避免由这个类直接创建任何的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">abstract  class Dog extends AAnimal</span><br><span class="line">&#123;</span><br><span class="line">	String type;</span><br><span class="line">	public Dog()</span><br><span class="line">	&#123;</span><br><span class="line">		type=&quot;宠物狗&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	//public void run()&#123;	&#125;</span><br><span class="line">	public void cry()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println (&quot;汪汪叫&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Bird extends AnimalClass//定义鸟类继承动物类</span><br><span class="line">&#123;</span><br><span class="line">	public Bird()//构造方法初始化</span><br><span class="line">	&#123;</span><br><span class="line">		name=&quot;麻雀&quot;;</span><br><span class="line">		age=3;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()//实现父类的抽象方法</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;会飞&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void cry()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println (&quot;叽叽喳喳&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>用abstract关键字来修饰一个类时，这个类叫做抽象类；用abstract来修饰一个方法时，该方法叫做抽象方法。</p>
<p>abstract类必须被继承，abstract方法必须被重写。</p>
<p>抽象类不能被实例化（直接创建对象）。</p>
<p>抽象方法只需声明，而不需实现（无方法体）。</p>
<h2 id="接口及应用"><a href="#接口及应用" class="headerlink" title="接口及应用"></a>接口及应用</h2><p>接口的基本概念<br>接口定义<br>接口实现<br>接口应用举例<br>理解接口<br>Jar文件（略）</p>
<h2 id="接口的概念"><a href="#接口的概念" class="headerlink" title="接口的概念"></a>接口的概念</h2><p>在《Thinking in Java》一书中，作者对接口有这样的描述：“接口（interface）比抽象（abstract）的概念更进了一步。你可以把一个接口看成是一个纯的抽象类。”</p>
<p>为什么使用接口？</p>
<p>1、Java中不允许类的多继承，但在解决实际问题过程中，仅仅依靠单一继承在很多情况下都不能将问题的复杂性表述完整。</p>
<p>通过接口可以实现多继承。</p>
<p>如：Father类有playFootball()，Mother类有sing()，如果采用类的继承来产生一个Son类，则它只能从一个类中继承。要么继承Father，要么继承Mother。</p>
<p>2、接口在面向对象的设计与编程中应用非常广泛，特别是实现 软件模块间的连接 方面有着巨大的优势。</p>
<h2 id="接口的声明-及注意事项"><a href="#接口的声明-及注意事项" class="headerlink" title="接口的声明  及注意事项"></a>接口的声明  及注意事项</h2><p>如果一个抽象类中所有的方法都是抽象的，就可以将这个类用另外一种方式来定义，也就是接口定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[public] interface 接口名 [extends  父接口名列表]</span><br><span class="line">&#123;</span><br><span class="line">	数据类型   常量名=常数;</span><br><span class="line">	返回值  方法名([参数列表]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>几点说明：</p>
<p>1、interface是接口的关键字，定义接口和定义类相似。并被编译为class文件。<br>2、接口的访问控制符只有public，如果使用public修饰符，则可以被所有类和接口使用，且接口名与文件名相同。如果不使用public，则接口只能被同一个包中的类和接口使用。<br>3、接口中所有的方法都是public abstract 即公共的抽象方法。4、接口中可以有数据成员，这些数据成员默认都是public static final即公共类常量。</p>
<h2 id="接口声明实例"><a href="#接口声明实例" class="headerlink" title="接口声明实例"></a>接口声明实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//Father.java  文件名</span><br><span class="line">public interface  Father//父亲会踢球</span><br><span class="line">&#123;</span><br><span class="line">	public abstract void playFootball ();</span><br><span class="line">&#125;</span><br><span class="line">//Mother.java   文件名</span><br><span class="line">public interface Mother//母亲爱唱歌</span><br><span class="line">&#123;</span><br><span class="line">	public abstract void sing();</span><br><span class="line">&#125;</span><br><span class="line">//Flyable.java  能飞的动物</span><br><span class="line">public interface Flyable </span><br><span class="line">&#123;</span><br><span class="line">	void fly();</span><br><span class="line">&#125;</span><br><span class="line">//Talkable.java 能说话的动物</span><br><span class="line">public interface Talkable </span><br><span class="line">&#123;</span><br><span class="line">	void talk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口的实现与多继承"><a href="#接口的实现与多继承" class="headerlink" title="接口的实现与多继承"></a>接口的实现与多继承</h2><p>接口的实现通过类来完成，在定义类时使用“implements  接口名列表”短语，并在类体中实现接口中的抽象方法。接口和实现类之间的关系实质上是继承的关系<br>1、一个类可以实现多个接口，从而实现多继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SmartChild implements Father,Mother</span><br><span class="line">&#123;</span><br><span class="line">	public void playFootball()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;我会踢足球！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void sing()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;我会唱歌！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args)	</span><br><span class="line">	&#123;</span><br><span class="line">		SmartChild child=new SmartChild();</span><br><span class="line">		child.playFootball();</span><br><span class="line">		child.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类实现接口时的注意事项"><a href="#类实现接口时的注意事项" class="headerlink" title="类实现接口时的注意事项"></a>类实现接口时的注意事项</h2><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>在类声明部分，用implements关键字指明该类将要实现哪些接口。<br>实现接口的类必须在类体中给出所有方法的实现，否则该类应该声明为抽象类。<br>接口中的方法都是public的，所以实现方法时也必须加上public，否则编译报错。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>一个接口可以继承另一个接口<br>Java中不允许类的多继承，但允许接口的多继承<br>在java中一个类可以实现多个接口<br>一个类在继承另一个类的同时，可以实现多个接口。</p>
<h3 id="将小程序改为应用程序"><a href="#将小程序改为应用程序" class="headerlink" title="将小程序改为应用程序"></a>将小程序改为应用程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Computable</span><br><span class="line">&#123;</span><br><span class="line">	final int MAX=100;</span><br><span class="line">	void speak(String s);</span><br><span class="line">	int f(int x);</span><br><span class="line">	float g(float x,float y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class China implements Computable</span><br><span class="line">&#123;</span><br><span class="line">	int xuehao;</span><br><span class="line">	public int f(int x)</span><br><span class="line">	&#123;</span><br><span class="line">		int sum=0;</span><br><span class="line">		for (int i = 1; i&lt;=x; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum+=i;</span><br><span class="line">		&#125;</span><br><span class="line">		return sum;</span><br><span class="line">	&#125;</span><br><span class="line">	public float g(float x,float y)</span><br><span class="line">	&#123;</span><br><span class="line">		return 6;</span><br><span class="line">	&#125;</span><br><span class="line">	public void speak(String s)</span><br><span class="line">	&#123;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口应用实例—程序模块间的连接"><a href="#接口应用实例—程序模块间的连接" class="headerlink" title="接口应用实例—程序模块间的连接"></a>接口应用实例—程序模块间的连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//PCI接口，可看成一种标准</span><br><span class="line">interface PCI  </span><br><span class="line">&#123;</span><br><span class="line">	void setName(String s);</span><br><span class="line">	void run();	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//符合PCI接口标准的网卡，即实现了PCI</span><br><span class="line">class NetworkCard implements PCI  </span><br><span class="line">&#123;</span><br><span class="line">	String name;</span><br><span class="line">	public NetworkCard()</span><br><span class="line">	&#123;</span><br><span class="line">		name=&quot;D-Link&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String s)//实现接口中的抽象方法</span><br><span class="line">	&#123;</span><br><span class="line">		name=s;</span><br><span class="line">	&#125;</span><br><span class="line">	public void run()//实现接口中的抽象方法</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(name+&quot;网卡已开始工作！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结</p>
<p>1、接口的概念：如果一个方法中的所有方法都是抽象的，则可以以接口的形式进行定义。<br>2、接口定义：使用interface关键字进行定义，数据成员隐含修饰符：public static final，方法隐含修饰符：public  abstract<br>3、接口实现：通过类来实现，使用implements短语。<br>4、接口应用。</p>
<h2 id="时间、日期和Math类"><a href="#时间、日期和Math类" class="headerlink" title="时间、日期和Math类"></a>时间、日期和Math类</h2><p>数组<br>声明数组：int  [] a; 或 int  a[];</p>
<p>数组创建：a=new int[10];</p>
<p>数组静态初始化：int[]a={1,0,2,3,4,5,5,7,4,12};</p>
<p>数组元素引用：a[0]…a[9]</p>
<p>字符串</p>
<p>String类<br>String构造方法<br>String类的成员方法：length()、equals()等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串与数值类型转换</span><br><span class="line">Date类</span><br><span class="line">SimpleDateFormat类</span><br><span class="line">Calendar类</span><br><span class="line">Math类</span><br><span class="line">AWT工具集简介</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lang包中类</span><br><span class="line">- Integer类—parseInt()</span><br><span class="line">- Float类—parseFloat()</span><br><span class="line">- Double类—parseDouble()</span><br><span class="line">- 将字符串转换为数值时，字符串必须是合法数值格式的字符串，否则会产生转换异常。</span><br><span class="line"></span><br><span class="line">数值转换为字符串</span><br><span class="line">- String.value(3.14159)</span><br><span class="line">- 3.14159+&quot;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="Date、SimpleDateFormat类"><a href="#Date、SimpleDateFormat类" class="headerlink" title="Date、SimpleDateFormat类"></a>Date、SimpleDateFormat类</h2><p>Date  d=new Date();获取系统日期某个瞬间。<br>SimpleDateFormat类：对日期进行格式化。format()方法可以对指定日期进行格式化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.text.*;</span><br><span class="line">class E1</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    	Date d=new Date();</span><br><span class="line">    	SimpleDateFormat sdf=</span><br><span class="line">    	new SimpleDateFormat(&quot;yyyy年MMMdd日HH时mm分&quot;);</span><br><span class="line">    	System.out.println (sdf.format(d));</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><p>该类的静态方法getInstance()可获取当前系统日历：Calendar d=Calendar.getInstance();</p>
<p>通过该类提供的get(int  field)方法来获取日历中各字段的值。field应该使用该类的相关常量字段。</p>
<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>常用方法参考javaAPI文档<br>猜数游戏<br>JOptionPane中的showInputDialog()方法。</p>
<h3 id="猜数游戏"><a href="#猜数游戏" class="headerlink" title="猜数游戏"></a>猜数游戏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import javax.swing.*;</span><br><span class="line">class E3</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    int num,count=0;</span><br><span class="line">    num=(int)(Math.random()*20+1);</span><br><span class="line">    int i=Integer.parseInt(JOptionPane.showInputDialog(&quot;请输入你猜1-20的数&quot;));</span><br><span class="line">   while(i!=num&amp;&amp;count&lt;=6)</span><br><span class="line">    &#123;</span><br><span class="line">    count++;</span><br><span class="line">    if (i&gt;num)</span><br><span class="line">        i=Integer.parseInt(JOptionPane.showInputDialog(&quot;第&quot;+count+&quot;次！太大了，请重新输入&quot;));</span><br><span class="line">    else</span><br><span class="line">        i=Integer.parseInt(JOptionPane.showInputDialog(&quot;第&quot;+count+&quot;次！太小了，请重新输入&quot;));    		</span><br><span class="line">    &#125;</span><br><span class="line">    if(i==num)</span><br><span class="line">   &#123;</span><br><span class="line">    	JOptionPane.showMessageDialog(null,&quot;猜对了&quot;);</span><br><span class="line">    	System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Java-的GUI概述"><a href="#Java-的GUI概述" class="headerlink" title="Java 的GUI概述"></a>Java 的GUI概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、图形用户界面GUI（Graphics User Interface)，就是应用程序提供给用户操作的图形界面，包括窗口、菜单、按钮、工具栏和其他各种界面元素。</span><br><span class="line">2、在Java里有两个包为GUI设计提供了丰富的功能：awt(abstract windows toolkit)包和Swing包。</span><br><span class="line">3、awt是java的早期版本，组件种类有限，只提供基本的GUI设计工具。</span><br><span class="line">4、Swing包是SUN公司对早期版本的改进版本，它不仅包括AWT中所有部件，并且提供了更加丰富的部件和功能，它足以完全实现GUI设计所需的一切功能。</span><br><span class="line">5、Swing会用到AWT中许多知识，掌握了AWT，也就基本掌握了Swing。</span><br></pre></td></tr></table></figure>
<h2 id="初识awt实例"><a href="#初识awt实例" class="headerlink" title="初识awt实例"></a>初识awt实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.awt.*;//引用awt包中的组件类</span><br><span class="line">public class TestFrame</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">	&#123;//产生一个具有标题栏的框架窗口</span><br><span class="line">		Frame f=new Frame(“我的框架窗口”); </span><br><span class="line">		Pane p=new Pane();//创建一个面板</span><br><span class="line">		p.add(new Button(“确定”));//向面板中填加按钮</span><br><span class="line">		f.add(p);//向窗口中填加面板</span><br><span class="line">		f.setSize(300,300);//设置窗口的大小</span><br><span class="line">		f.show();//显示窗口</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图形用户界面程序中可以使用各种各样的图形界面元素，如文本框、按钮、列表框、对话框等，我们将这些图形用户界面元素称为GUI组件。</p>
<p>ATW为各种GUI组件提供了对应的Java组件类，这些组件类都是java.awt.Component的直接或间接的子类。</p>
<h2 id="GUI组件分类"><a href="#GUI组件分类" class="headerlink" title="GUI组件分类"></a>GUI组件分类</h2><p>在AWT的概念中，窗口系统中所显示的各种对象都统称为“GUI组件”（Component）。组件有基本组件和容器组件之分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、顾名思义，基本组件是不可再分割的组件，基本组件各自都有它们特定的功能。基本组件是构成图形用户界面的基本元素。</span><br><span class="line">2、容器组件是用来包含其他组件的，故称之为容器（container）。用户可以把各种组件放入到容器中，也可以把容器放到另一个容器中，从而形成具有层次的组件结构。 </span><br><span class="line">3、AWT提供了的容器类有：Frame类、Dia1og类和Panel类。除了AWT提供的容器外，Applet类也是一个容器，它是Panel类的一个子类。</span><br></pre></td></tr></table></figure>
<h2 id="AWT-标准组件图示"><a href="#AWT-标准组件图示" class="headerlink" title="AWT 标准组件图示"></a>AWT 标准组件图示</h2><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Button 按钮</span><br><span class="line">Checkbox 复选框</span><br><span class="line">CheckboxGroup 单选框</span><br><span class="line">Choice 下拉式列表</span><br><span class="line">List 列表</span><br><span class="line">Menu 菜单</span><br><span class="line">TextField 文本框</span><br><span class="line">Label 标签</span><br><span class="line">Canvas 画布</span><br><span class="line">TextArea 多行文本框</span><br><span class="line">ScrollBar 滚动条</span><br></pre></td></tr></table></figure>
<h2 id="Applet小程序编写及运行"><a href="#Applet小程序编写及运行" class="headerlink" title="Applet小程序编写及运行"></a>Applet小程序编写及运行</h2><p>Java有两种类型的程序：应用程序(application)、小应用程序(applet)。 </p>
<p>Java应用程序只有一个程序入口—main方法，通过JVM调用执行，小应用程序是嵌入到网页中由浏览器调用执行的，其中不必包含main方法。</p>
<p>回忆一下小应用程序的书写格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.applet.*;</span><br><span class="line"> public class MyApplet extends Applet</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>每个小应用程序中必须有一个主类，冠以public，并且从Applet类继承。<br>小应用程序的运行：<br>将小应用程序源文件编译成字节码文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编写html文件，使用&lt;applet&gt; 标签将字节码文件嵌入其中</span><br><span class="line">用浏览器打开html文件或者用appletviewer小程序浏览器。</span><br></pre></td></tr></table></figure>
<h3 id="身手"><a href="#身手" class="headerlink" title="身手"></a>身手</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java.applet.Applet;</span><br><span class="line">import java.awt.*;</span><br><span class="line">public class Test extends Applet</span><br><span class="line">&#123;</span><br><span class="line">	public void paint(Graphics g)</span><br><span class="line">	&#123;</span><br><span class="line">		g.drawOval(10,10,100,100);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- test.html文件--&gt;</span><br><span class="line">&lt;applet code=Test height=120 width=400&gt;&lt;/applet&gt;</span><br></pre></td></tr></table></figure>
<p>任何与绘图有关的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.awt.Graphics，Graphics类的对象不是由new产生的，</span><br></pre></td></tr></table></figure>
<p>一般由系统直接将生好的Graphics对象当作方法的参数，交给程序设计者去处理.例如: public void  paint(Graphics g)，每一个GUI组件都有paint方法，利用Graphics对象可以在组件中绘制图像或字符串。</p>
<h2 id="Html标签"><a href="#Html标签" class="headerlink" title="Html标签"></a>Html标签</h2><p>基本形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;applet code=Test height=120 width=400&gt;&lt;/applet&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Applet 属性&gt;</span><br><span class="line">Code：指出要加载的类名，直接写类名，则要求类与html文件在同一路径下。</span><br><span class="line">Height、width：指出applet显示区的高和宽</span><br></pre></td></tr></table></figure>
<p>字符串转换为数值<br>获取系统当前日期及时间<br>Math类的静态方法<br>AWT包简介<br>Applet 类简单</p>
<p>首先通过JavaAPI文档，学习以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javax.swing包中的类JOptionPane中的showInputDialog()方法</span><br><span class="line">java.lang包中的Integer类中的parseInt()方法</span><br><span class="line">java.util包中的Date类</span><br><span class="line">java.text包中的SimpleDateFormat类</span><br><span class="line">java.lang包中的Math类中的random()方法</span><br></pre></td></tr></table></figure>
<h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><p>类的定义<br>类的封装特性<br>类的继承特性<br>类的多态特性</p>
<h2 id="回顾—类的定义-1"><a href="#回顾—类的定义-1" class="headerlink" title="回顾—类的定义"></a>回顾—类的定义</h2><p>类的严格定义及修饰字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[类的修饰字] class 类名称 [extends 父类名称][implements 接口名称列表]</span><br><span class="line"> &#123;  </span><br><span class="line"></span><br><span class="line">       变量定义及初始化；</span><br><span class="line"></span><br><span class="line">       方法定义及方法体；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类体，其中定义了该类中所有的变量和该类所支持的方法，称为成员变量和成员方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类的修饰字：  [public] [abstract | final]</span><br><span class="line">                          缺省方式为 package</span><br></pre></td></tr></table></figure>
<h2 id="回顾—封装性"><a href="#回顾—封装性" class="headerlink" title="回顾—封装性"></a>回顾—封装性</h2><p>封装性与访问级控制<br>类的一个优势在于类可以保护它的成员变量和成员函数不会被其它对象随意访问到<br>在Java程序里，可以为成员变量和函数设定四级访问级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private</span><br><span class="line">protected</span><br><span class="line">public</span><br><span class="line">default（缺省）</span><br></pre></td></tr></table></figure>
<h2 id="回顾—继承"><a href="#回顾—继承" class="headerlink" title="回顾—继承"></a>回顾—继承</h2><p>继承性是面向对象程序设计语言的另一基本特征，通过继承可以实现代码的复用。</p>
<p>继承而得到的类为子类，被继承的类为父类，父类包括所有直接或间接被继承的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java中不支持多重继承。通过在类的声明中加入extends子句来创建一个类的子类</span><br><span class="line"></span><br><span class="line">class SubClass extends SuperClass</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回顾—类的多态性"><a href="#回顾—类的多态性" class="headerlink" title="回顾—类的多态性"></a>回顾—类的多态性</h2><p>多态是指在一棵继承树中的类可以有多个同名但不同方法体以及不同形参的方法。两种情况</p>
<p>覆盖</p>
<p>重载</p>
<h2 id="掌握数组的定义和使用"><a href="#掌握数组的定义和使用" class="headerlink" title="掌握数组的定义和使用"></a>掌握数组的定义和使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java数组类的定义和使用</span><br><span class="line">难点</span><br><span class="line">多维数组的定义和使用</span><br></pre></td></tr></table></figure>
<h2 id="Java中的数组"><a href="#Java中的数组" class="headerlink" title="Java中的数组"></a>Java中的数组</h2><p>数组的特点</p>
<p>数组：可以容纳很多同类型的数据的结构<br>数组中存放的每个数据称为数组的一个元素，元素的数量称为数组的长度<br>在Java语言中，数组的长度是在数组创立时就固定了的，以后不能更改</p>
<h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一维数组变量的声明格式有如下两种:</span><br><span class="line">(1)数组元素的数据类型[ ]      变量名;</span><br><span class="line">(2)数组元素的数据类型     变量名[ ];</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">int [ ]  c; </span><br><span class="line">String[ ]  names; </span><br><span class="line">int  c[ ]; </span><br><span class="line">String  names[ ];</span><br></pre></td></tr></table></figure>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>Java数组实际上也是对象，所以可通过new 关键字来创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[ ] c; 		      // 声明</span><br><span class="line">c = new int[12];     // 创建对象，并分配内存</span><br><span class="line"></span><br><span class="line">声明时不必指定数组的大小</span><br><span class="line">上面的两个语句可以简化成一个语句</span><br><span class="line"></span><br><span class="line">int[ ] c = new int[12];</span><br></pre></td></tr></table></figure>
<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>基本数据类型的元素初始化为0值或false</p>
<p>非基本数据类型的元素初始化为null </p>
<p>可以采用循环结构初始化数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double[ ] squares; </span><br><span class="line">squares = new double[100]; </span><br><span class="line">for (int i=0; i &lt; squares.length; i++)</span><br><span class="line">&#123; </span><br><span class="line">    squares[i] = i*i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过初始化语句创建数组"><a href="#通过初始化语句创建数组" class="headerlink" title="通过初始化语句创建数组"></a>通过初始化语句创建数组</h2><p>Java语言允许通过数组的初始化语句创建数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[ ] n = &#123; 10, 20, 30, 40, 50 &#125;;</span><br></pre></td></tr></table></figure>
<p>上面语句创建了一个含有五个元素的数组</p>
<p>下标值分别为0, 1, 2, 3, 4</p>
<p>这时不需要运算符new</p>
<h2 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h2><p>当定义了一个数组，并用运算符new为它分配了内存空间后，就可以引用数组中的每一个元素了。元素的引用方式为</p>
<p>arrayName[index]</p>
<p>index为数组下标，可以是整型常数或表达式，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：arrayName[1], arrayName[i], arrayName[6*i]等。</span><br></pre></td></tr></table></figure>
<p>下标是0序的，即从0开始，一直到数组长度减1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int[ ] c = new int[12];</span><br><span class="line"></span><br><span class="line">c 是数组名</span><br><span class="line"></span><br><span class="line">如何获得数组的长度?</span><br><span class="line">c.length</span><br><span class="line"></span><br><span class="line">第一个数组元素的下标为0 </span><br><span class="line">使用数组可以通过数组名与下标</span><br><span class="line"></span><br><span class="line">每个数组元素类似于普通的变量</span><br><span class="line">c[ 0 ] = 3;</span><br><span class="line">c[ 0 ] += 5;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<p>当通过循环遍历数组时<br>下标永远不要低于0<br>下标永远要比数组元素个数小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当数组下标出错，Java 产生 ArrayIndexOutOfBoundsException</span><br></pre></td></tr></table></figure>
<h2 id="多维数组-1"><a href="#多维数组-1" class="headerlink" title="多维数组"></a>多维数组</h2><p>最常用的多维数组是二维数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[ ][ ] a = new int[3][4];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class J_FillArray</span><br><span class="line">&#123;</span><br><span class="line">    public static void main (String args[])</span><br><span class="line">    &#123; </span><br><span class="line">        int[ ][ ] matrix = new int[4][5]; </span><br><span class="line">        for (int row=0; row &lt; 4; row++)</span><br><span class="line">        &#123; </span><br><span class="line">            for (int col=0; col &lt; 5; col++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix[row][col] = row + col; </span><br><span class="line">            &#125; // 内部for循环结束</span><br><span class="line">        &#125; // 外部for循环结束</span><br><span class="line">    &#125; // 方法main结束</span><br><span class="line">&#125; // 类J_FillArray结束</span><br></pre></td></tr></table></figure>
<p>通过初始化语句创建数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double[ ][ ] c =</span><br><span class="line">    &#123; </span><br><span class="line">       &#123;1.0, 2.0, 3.0, 4.0&#125;, </span><br><span class="line">       &#123;0.0, 1.0, 0.0, 0.0&#125;, </span><br><span class="line">       &#123;0.0, 0.0, 1.0, 0.0&#125; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Java的多维数组实际上是<br>数组的数组<br>即创建以数组为元素的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">意味着: 二维数组的每一行可以具有不同的列数</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a[ ][ ];</span><br><span class="line">a = new int[ 3 ][ ];            // allocate rows</span><br><span class="line">a[ 0 ] = new int[ 3 ];         // allocate row 0</span><br><span class="line">a[ 1 ] = new int[ 2 ];         // allocate row 1</span><br><span class="line">a.length                 行数</span><br><span class="line">a[ i ].length            第i行列数</span><br></pre></td></tr></table></figure>
<p>要点</p>
<h2 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串"></a>数组与字符串</h2><p>接口及接口声明</p>
<p>interface<br>接口中的方法都是：public abstract<br>接口中的数据都是：public static final<br>接口可以直接多继承：extends 父接口列表</p>
<p>接口实现</p>
<p>在类中实现接口：implements 接口名列表<br>在类中要改写接口中的所有抽象方法<br>一个类可以实现多个接口<br>一个类可以从父类继承的同时实现接口</p>
<p>接口应用</p>
<p>只关心功能的有无，不关心功能的具体实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组的概念</span><br><span class="line">数组声明</span><br><span class="line">数组创建</span><br><span class="line">数组元素引用</span><br><span class="line">数组元素初始化</span><br><span class="line">字符串说明及初始化</span><br><span class="line">字符串处理</span><br></pre></td></tr></table></figure>
<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><p>数组是相同类型的数据元素按顺序组成的一种复合数据类型。数组中的每个元素通过数组名加下标进行引用。数组分为一维数组和多维数组。</p>
<p>数组的特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)一个数组中所有的元素应该是同一类型；</span><br><span class="line">(2)数组中的元素是有顺序的；</span><br><span class="line">(3)数组中的一个元素通过数组名和数组下标来确定。</span><br></pre></td></tr></table></figure>
<p>数组的使用过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)声明数组</span><br><span class="line">(2)创建数组</span><br><span class="line">(3)使用数组元素</span><br></pre></td></tr></table></figure></p>
<h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h2><p>一维数组声明的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型    数组名[ ]；或 类型[ ] 数组名；</span><br><span class="line">数组名为Java标识符。“[ ]”部分指明该变量是一个数组类型变量。其中不能有元素个数说明。</span><br></pre></td></tr></table></figure>
<p>二维数组声明格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型 数组名[] []；或 类型 [] []数组名；</span><br><span class="line">类型 []数组名[]；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如：	int a[];或 int[]a;</span><br><span class="line">	String[]args;或 String args[]</span><br><span class="line">	int a[][];或int [][]a;或 int []a[];</span><br><span class="line">	Person p[];</span><br></pre></td></tr></table></figure>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>创建数组—为数组分配内存空间。<br>格式：数组名=new 类型[元素个数];<br>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int []num;int myTwo[][];</span><br><span class="line">num=new int[3];</span><br><span class="line">myTwo=new int[2][3];</span><br><span class="line">myTwo=new int[2][];</span><br></pre></td></tr></table></figure>
<p>声明和创建数组可以合并</p>
<blockquote>
<p>类型  数组名[]=new 类型[元素个数];</p>
</blockquote>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int []num=new int[3];</span><br></pre></td></tr></table></figure>
<p>创建数组时，自动为数组元素初始化。</p>
<h2 id="数组元素的使用"><a href="#数组元素的使用" class="headerlink" title="数组元素的使用"></a>数组元素的使用</h2><p>数组元素的标识：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标]</span><br><span class="line">下标使用范围从0开始到（元素个数-1）为止。</span><br><span class="line">其中下标为非负的整型常数或表达式，其数据类型只能为byte,short,int, 而不能为long。</span><br><span class="line">数组名[下标1][下标2]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class ArrayTest</span><br><span class="line">&#123;</span><br><span class="line">	int arr[];</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">    	&#123;</span><br><span class="line">    		ArrayTest a=new ArrayTest();</span><br><span class="line">    		a.arr=new int[3];</span><br><span class="line">    		a.arr[0]=3;</span><br><span class="line">    		a.arr[1]=4;</span><br><span class="line">    		a.arr[2]=5;</span><br><span class="line">    		for (int i = 0; i&lt;3; i++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			System.out.println (a.arr[i]);</span><br><span class="line">    		&#125;</span><br><span class="line">   	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组初始化-1"><a href="#数组初始化-1" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>new分配内存时自动初始化数组</p>
<p>通常在创建数组时，Java会使每个数组元素初始化为一个默认值。在许多情况下，并不希望数组的初值为默认值，此时，就需要用赋值语句来对数组进行初始化。</p>
<p>静态初始化：声明数组时直接赋初值(不需要new)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr1[]=&#123;2,4,6,8&#125;;</span><br><span class="line">char [] arr2=&#123;‘字’,‘符’,‘数’,‘组’&#125;;</span><br><span class="line">String []arr3=&#123;&quot;how &quot;,&quot;are &quot;,&quot;you!&quot;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>元素个数由{}中给出的元素个数来确定</p>
<p>二维数组初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr3[][]=&#123;&#123;1,2,3,4&#125;,&#123;2,3,4&#125;,&#123;5,3&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>思考和验证：这时可用数组元素有哪些呢？</p>
<h2 id="使用数组注意事项"><a href="#使用数组注意事项" class="headerlink" title="使用数组注意事项"></a>使用数组注意事项</h2><p>定义数组：无论用什么方式定义数组，都不能指定长度，int  a[5];是错误的</p>
<p>使用数组中的元素：必须对数组引用变量赋一个有效的数组对象（通过new产生或是用{ }静态初始化产生）后，才可以引用数组中的每个元素。</p>
<p>获取数组的长度：<br>数组名.length</p>
<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><p>Java使用java.lang包中的类String来声明和创建一个字符串变量，因此字符串变量是类类型的变量，是一个对象。（要求理解）</p>
<p>字符串常量<br>声明字符串变量</p>
<p>创建字符串（要求掌握）</p>
<p>可以将一个字符串常量直接赋值给字符串变量，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s;s=&quot;we are student!&quot;;</span><br></pre></td></tr></table></figure>
<p>也可以使用String类的构造方法来创建字符串，如：</p>
<blockquote>
<p>String s;s=new String(“we are student!”);</p>
</blockquote>
<p>String类的构造方法</p>
<p>获取字符串长度：String对象的length()方法。</p>
<blockquote>
<p>String s=”你好”;s.length()值为2。</p>
</blockquote>
<p>例：字符串的声明与创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class StringTest</span><br><span class="line">&#123;</span><br><span class="line">	String name;</span><br><span class="line">	String sex;</span><br><span class="line">	void out()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println (&quot;name:&quot;+name);</span><br><span class="line">		System.out.println (&quot;sex:&quot;+sex);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">   	 &#123;</span><br><span class="line">    		StringTest st=new StringTest();</span><br><span class="line">    		char ch[]=&#123;&apos;b&apos;,&apos;o&apos;,&apos;y&apos;&#125;;</span><br><span class="line">    		st.name=new String(&quot;Rose&quot;);</span><br><span class="line">    		st.sex=new String(ch1);</span><br><span class="line">    		st.out();</span><br><span class="line">    	</span><br><span class="line">   	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>==：比较两个字符串是不是同一个对象<br>equals()方法：比较两个字符串的内容是否相同<br>比较方法：s1.equals(s2)，s1和s2分别是两上字符串变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    	StringTest st=new StringTest();</span><br><span class="line">    	char ch[]=&#123;&apos;b&apos;,&apos;o&apos;,&apos;y&apos;&#125;;</span><br><span class="line">    	st.name=new String(&quot;Rose&quot;);</span><br><span class="line">    	if(st.name==&quot;Rose&quot;)</span><br><span class="line">    		System.out.println (&quot;yes&quot;);</span><br><span class="line">    	else</span><br><span class="line">    		System.out.println (&quot;no&quot;);</span><br><span class="line">    	st.sex=new String(ch);</span><br><span class="line">    	st.out();</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><p>equalsIgnoreCase()<br>返回值类型：boolean<br>忽略大小写比较</p>
<p>startWith()、endWith()<br>返回值类型：boolean<br>检查字符串前缀、后缀是否为指定字符串</p>
<p>compareTo(String s)<br>返回值类型：int<br>按字典序比较当前字符串与s的大小，返回值&gt;0、=0、&lt;0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Sort</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">    	String a[]=&#123;&quot;boy&quot;,&quot;apple&quot;,&quot;Applet&quot;,&quot;girl&quot;,&quot;Hat&quot;&#125;;</span><br><span class="line">    	for (int i=0;i&lt;a.length-1;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		for(int j=i+1;j&lt;a.length;j++)</span><br><span class="line">    		&#123;</span><br><span class="line">    			if(a[j].compareTo(a[i])&lt;0)</span><br><span class="line">    			&#123;</span><br><span class="line">    				String temp=a[i];</span><br><span class="line">    				a[i]=a[j];</span><br><span class="line">    				a[j]=temp;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	for (int i = 0; i&lt;a.length; i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		System.out.print(&quot;  &quot;+a[i]);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>检索:indexOf()<br>截取:substring()<br>替换:replace()</p>
<h2 id="字符串与数值转换"><a href="#字符串与数值转换" class="headerlink" title="字符串与数值转换"></a>字符串与数值转换</h2><p>字符串转为整数</p>
<p>Integer类中的parseInt()方法<br>parseByte()、parseShort()、parseLong()</p>
<p>字符串转换为float或double型</p>
<p>Float类中的parseFloat()方法<br>Double类中的parseDouble()方法</p>
<p>数值转换为字符串</p>
<p>String类中的valueOf()方法</p>
<p>对象的字符串表示</p>
<p>对象的toString()方法</p>
<p>StringTokenizer类分析字符串</p>
<p>Character类</p>
<p>字符串与字符、字节数组</p>
<h2 id="面向对象程序设计-1"><a href="#面向对象程序设计-1" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p>回顾—类的定义</p>
<p>类的严格定义及修饰字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[类的修饰字] class 类名称 [extends 父类名称][implements 接口名称列表]</span><br><span class="line"> &#123;  </span><br><span class="line">       变量定义及初始化；</span><br><span class="line">       方法定义及方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类体，其中定义了该类中所有的变量和该类所支持的方法，称为成员变量和成员方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类的修饰字：  [public] [abstract | final]</span><br><span class="line"></span><br><span class="line">缺省方式为 package</span><br></pre></td></tr></table></figure>
<h2 id="类的成员函数定义语法规范"><a href="#类的成员函数定义语法规范" class="headerlink" title="类的成员函数定义语法规范"></a>类的成员函数定义语法规范</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[方法修饰字] 返回类型  方法名称(参数1,参数2,…) [throws exceptionList]</span><br><span class="line">&#123;</span><br><span class="line">(statements;)    //方法体：方法的内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[public | protected | private ] [static] [final | abstract] [native] [synchronized]</p>
</blockquote>
<p>返回类型可以是任意的Java数据类型，当一个方法不需要返回值时，返回类型为void。</p>
<p>参数的类型可以是简单数据类型，也可以是引用数据类型（数组、类或接口），参数传递方式是值传递。</p>
<p>方法体是对方法的实现。它包括局部变量的声明以及所有合法的Java指令。局部变量的作用域只在该方法内部。</p>
<h2 id="回顾—对象的初始化-1"><a href="#回顾—对象的初始化-1" class="headerlink" title="回顾—对象的初始化"></a>回顾—对象的初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（1）对象的生成</span><br><span class="line">   通过new操作符生成一个对象；例如：</span><br><span class="line">	Car    demoCar;</span><br><span class="line">	demoCar = new Car();</span><br><span class="line">（2）对象的构造过程</span><br><span class="line"> 为对象开辟空间，并对对象的成员变量进行缺省的初始化；</span><br><span class="line"> 对成员变量进行指定的初始化；</span><br><span class="line"> 调用构造方法。</span><br></pre></td></tr></table></figure>
<p>重点<br>不同访问修饰符的应用<br>Java中类继承的定义<br>难点<br>类的继承特性</p>
<h2 id="包-1"><a href="#包-1" class="headerlink" title="包"></a>包</h2><p>“包”是由一组类和接口所组成的具有一定功能的集合<br>简单地说，将一组功能相关的类和接口打包起来形成的整体，就是包<br>两个类如果名字相同，只要所属的包不同，Java就会认为它们是不同的类</p>
<h2 id="创建包-1"><a href="#创建包-1" class="headerlink" title="创建包"></a>创建包</h2><p>在定义类或接口的源文件开始加入“package”关键字和包名，就将类或接口放到包里了<br>如果两个java源文件的开头都有相同的包名，则意味着这两个源文件中的所有类和接口都属于同一个包</p>
<h2 id="访问包中的类-1"><a href="#访问包中的类-1" class="headerlink" title="访问包中的类"></a>访问包中的类</h2><p>访问公开类的方法<br>(1) 用类的全名（包名+类名）访问；<br>(2) 导入包中的某个类；<br>(3) 导入包中的所有类。<br>如果某个类只访问一次，那么可以直接使用类的全名，形式是“包名.类名”</p>
<p>用“import”关键字导入一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import PackageName.ClassName;</span><br></pre></td></tr></table></figure></p>
<p>一次性导入所有类的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import PackageName.*;</span><br></pre></td></tr></table></figure></p>
<h2 id="管理Java的包-1"><a href="#管理Java的包-1" class="headerlink" title="管理Java的包"></a>管理Java的包</h2><p>Java系统建议的文件存储方式就是按照包名将源文件和二进制代码文件分级存放<br>将源文件放到与包名相同的路径下，包名对应子目录名</p>
<h2 id="使用Java的包-1"><a href="#使用Java的包-1" class="headerlink" title="使用Java的包"></a>使用Java的包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设定Rectangle.java放在“graphics”子目录下</span><br><span class="line">编译源文件的命令如下：</span><br><span class="line">javac graphics\Rectangle.java</span><br><span class="line">执行程序时，用小圆点“.”分隔包名和类：</span><br><span class="line">java graphics.Rectangle</span><br></pre></td></tr></table></figure>
<h2 id="CLASSPATH参数-1"><a href="#CLASSPATH参数-1" class="headerlink" title="CLASSPATH参数"></a>CLASSPATH参数</h2><p>如果你的Java包都放在一个固定的目录下，轻易不会改变它，那么你可以在操作系统中设置“CLASSPATH”环境变量<br>编译和运行Java程序时，不需要指定包路径参数，系统会自动从环境变量中读取</p>
<h2 id="封装-2"><a href="#封装-2" class="headerlink" title="封装"></a>封装</h2><p>封装把对象的所有组成部分组合在一起</p>
<p>封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。</p>
<h2 id="封装性-1"><a href="#封装性-1" class="headerlink" title="封装性"></a>封装性</h2><p>封装性与访问级控制<br>类的一个优势在于类可以保护它的成员变量和成员函数不会被其它对象随意访问到<br>在Java程序里，可以为成员变量和函数设定四级访问级：<br>private<br>protected<br>public<br>default（缺省）</p>
<h2 id="访问控制级别-1"><a href="#访问控制级别-1" class="headerlink" title="访问控制级别"></a>访问控制级别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private（私有级）</span><br><span class="line">private是最严格的访问控制级</span><br><span class="line">私有变量只能在它所在的类内部被访问到</span><br><span class="line">它用于定义只在类内部使用的成员变量</span><br><span class="line">成员变量，如果从外界随意改变它的值可能会造成不稳定的情况</span><br><span class="line">成员函数，如果从外界调用，可能会危害到对象的状态或程序的运行</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected（保护级）</span><br><span class="line">被定为保护级的成员可以被它所属的类、所属类的子类，以及处于同一个包里的其它类访问到</span><br><span class="line">如果一个成员变量或成员函数可以被它的子类或相关的类访问，而不能被无关类访问的话，就可以用保护级</span><br><span class="line">保护级就像家庭秘密，可以让家庭成员知道，也不介意让几个亲密朋友知道，但你不想让任何外人知道</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public（公开级）</span><br><span class="line">公开级是限制最少的访问级，任何类，不管它在哪个包里，都能够访问公开级的成员</span><br><span class="line">公开级使用最方便，实际使用得也最多</span><br><span class="line">需要注意的是：对于成员变量或成员函数，只有当你确认外界的类访问甚至修改它不会造成不希望的后果时，才使用公开级</span><br><span class="line">公开级类似于公开张贴的信息，其中没有个人或家庭隐私，你不介意任何人知道</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default（缺省级）</span><br><span class="line">包访问级是成员的缺省访问级</span><br><span class="line">如果没有定义访问级，那么它就是包访问级</span><br><span class="line">权限：可以被属于同一个包的其它类所访问，但不能被其它包的类所访问</span><br><span class="line">如果这个类的子类在其它包，则子类不能继承和访问父类中包访问级的成员</span><br><span class="line">这一访问级假设在同一个包里的其它类都是可信任的朋友，但子类反而不能信任</span><br></pre></td></tr></table></figure>
<h2 id="类成员封装性总结-1"><a href="#类成员封装性总结-1" class="headerlink" title="类成员封装性总结"></a>类成员封装性总结</h2><h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><p>继承性是面向对象程序设计语言的另一基本特征，通过继承可以实现代码的复用。继承而得到的类为子类，被继承的类为父类，父类包括所有直接或间接被继承的类。Java中不支持多重继承。通过在类的声明中加入extends子句来创建一个类的子类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class SubClass extends SuperClass</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类可以继承父类中访问权限设定为public、 protected、 default的成员变量和方法，但是不能继承访问权限为private的成员变量和方法。<br>一个类可以从另一个类中继承它的成员变量和函数，前者称为子类，后者称为父类。类的这种特点称为继承性</p>
<h2 id="继承-2"><a href="#继承-2" class="headerlink" title="继承"></a>继承</h2><p>类的继承通过extends关键字来说明，extends关键字跟在类名称后面，形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class SubClass extends FatherClass &#123;  &#125;</span><br></pre></td></tr></table></figure>
<p>其中SubClass是子类名，FatherClass是父类名</p>
<h2 id="继承的特点-1"><a href="#继承的特点-1" class="headerlink" title="继承的特点"></a>继承的特点</h2><p>类的继承性的特点<br>在Java中，一个类只能有一个父类<br>Java只支持单继承，而不支持多重继承<br>单继承的类子代相承，会形成一棵继承树，结构较为清晰<br>多重继承会形成一张复杂的继承网，结构复杂，容易出错<br>如果需要多重继承，Java提供了一种接口技术，可以部分地实现多重继承的功能</p>
<p>类的继承性的特点<br>在Java中定义的所有类都直接或间接地是Object类的子类。以Object类为根，所有Java类形成一棵类继承树</p>
<h2 id="类的继承性的特点-1"><a href="#类的继承性的特点-1" class="headerlink" title="类的继承性的特点"></a>类的继承性的特点</h2><p>子类可以继承的部分：<br>(1) 父类中公开级的成员；<br>(2) 父类中保护级的成员；<br>(3) 如果子类和父类在同一个包里，则子类继承父类中缺省的包访问级的成员；</p>
<p>子类不能继承的部分：<br>(1) 父类中私有级的成员；<br>(2) 如果不在同一个包里，则缺省级的成员；<br>(3) 同名的成员函数或成员变量；</p>
<h2 id="构造函数的继承特点-1"><a href="#构造函数的继承特点-1" class="headerlink" title="构造函数的继承特点"></a>构造函数的继承特点</h2><p>构造函数是比较特殊的一类<br>在继承时，构造函数不会被继承，也不会被覆盖<br>父类和子类的构造函数依然是独立存在，并且分别发挥着作用</p>
<p>父类相当于一个硬球，子类则是在球外的包装<br>构造对象时显然应当先构造最内部的硬球，也就是最顶端的父类<br>之后再从里往外一层层地构造外包装，直到最后整个对象都构造起来<br>如果父类的构造函数有参数，那么就需要用super关键字，它指代父类</p>
<h2 id="类与对象-3"><a href="#类与对象-3" class="headerlink" title="类与对象"></a>类与对象</h2><p>3.1  面向对象的基本思想和基本概念<br>3.2  案例<br>3.3  类的声明与对象的创建<br>3.4  继承<br>3.5  包的使用<br>3.6  编程实例<br>实训三  面向对象程序设计<br>习题三 </p>
<h2 id="面向对象的基本思想和基本概念-1"><a href="#面向对象的基本思想和基本概念-1" class="headerlink" title="面向对象的基本思想和基本概念"></a>面向对象的基本思想和基本概念</h2><p>大部分传统的高级程序设计语言(如C语言)都是过程化的语言，在软件开发的过程中采用自顶向下逐步细化的方法将整个程序描述为一个过程。对于小型的系统，这种方法是可行的，但是当系统规模很大，复杂度很高时，用过程化方法描述变得十分困难，面向对象的软件开发方法可以很好地解决这个问题。</p>
<p>目前，面向对象的方法在软件开发工作中得到了广泛的应用，越来越多的软件开发工具开始支持面向对象的开发方法。Java语言就是一种面向对象的程序设计语言，要充分利用Java语言的特性首先应该理解面向对象的基本思想。</p>
<h2 id="面向对象的基本思想-1"><a href="#面向对象的基本思想-1" class="headerlink" title="面向对象的基本思想"></a>面向对象的基本思想</h2><p>面向对象的基本思想认为系统是由若干个对象构成的，每个对象都有各自的内部状态和运动规律，不同对象之间通过消息传送相互作用和联系。</p>
<p>采用对象的观点看待所要解决的问题，并将其抽象为系统是极其自然与简单的，因为它符合人类的思维习惯，使得应用系统更容易理解。同时，由于应用系统是由相互独立的对象构成的，使得系统的修改可以局部化，因此系统更易于维护。 </p>
<p> 例如，对于一个企业的管理信息系统，将整个系统描述成一个过程是难以想像的，但可以分别描述各个部门的特性及工作流程，然后描述部门之间的联系。这里各个部门就是组成企业的对象，当然，在描述每个部门特性时可以采用同样的方法。</p>
<h2 id="对象与类-1"><a href="#对象与类-1" class="headerlink" title="对象与类"></a>对象与类</h2><p>对象是面向对象方法中的一个重要概念。所谓对象，是指客观世界中事物在计算机领域中的抽象，用一组数据和施加于该组数据上的一组操作(行为)来描述。</p>
<p>对象的描述通常由三个部分组成：</p>
<p>(1) 私有的数据结构。<br>用于描述对象的内部状态。<br>(2) 处理，称为操作或方法。<br>它是施加于数据结构之上的。<br>(3) 接口。<br>这是对象可被共享的部分，消息通过接口调用相应的操作。接口规定哪些操作是允许的，它不提供操作是如何实现的信息。</p>
<p>实际上，采用面向对象方法进行系统分析与设计时要描述的并不是一个个具体的对象。对于一个具体的系统而言，可能存在很多具有相同特征的对象，而且通常系统中对象的数目是不确定的。</p>
<p>例如，对于一个学籍管理系统，存在许多学生对象，它们具有相同的结构特征和行为特征，只是表示内部状态的数据值不同。为了描述这种相同结构特征和行为特征的对象，面向对象方法引入了类的概念。这一点与人们在认识客观世界的事物时所采取的分类思想相同。人们在认识事物时总是将具有相同特征的事物归为一类，属于某类的一个事物具有该类事物的共同特征。</p>
<p>类是对一组具有相同特征的对象的抽象描述，所有这些对象都是这个类的实例。对于学籍管理系统，学生是一个类，而一个具体的学生则是学生类的一个实例。一个类的不同实例具有相同的操作或行为的集合和相同的信息结构或属性的定义，但属性值可以不同；不同的实例具有不同的对象标识。对于学生类中的每一个对象，描述它们所使用的数据结构相同，但是值不同。在程序设计语言中，类是一种数据类型，而对象是该类型的变量，变量名即是某个具体对象的标识。</p>
<p>因此，一个类的定义至少包含以下两个方面的描述：</p>
<p>(1) 该类所有实例的属性或结构的定义。<br>(2) 该类所有实例的操作(或行为)的定义。</p>
<p>类是构成Java语言程序的基本单位，一个完整的Java程序是由若干个类构成的，每个类由若干数据和方法构成，一个类的定义包含属性(数据)和方法(行为)两部分内容。</p>
<h2 id="继承性-1"><a href="#继承性-1" class="headerlink" title="继承性"></a>继承性</h2><p>人们在对客观世界的事物进行描述时，经常采取分类的方法。类是有层次的，即某个大类的事物可能分为若干小类，而这些小类可能又分为若干个更小的类。</p>
<p>面向对象思想采纳了事物分类的层次思想，在描述类的时候，某些类之间具有结构和行为的共性。例如，描述教师与学生时均需描述姓名、年龄、身高、体重等属性，将这些共性抽取出来，形成一个单独的类——人，用于描述教师类和学生类的共性。类人的结构特征和行为特征可以被多个相关的类共享，教师类和学生类继承了类人的结构和行为特征。</p>
<p>Java语言支持类的继承，可以从一个类中派生出一个新的类，原来的类称为超类或父类，新类称为超类的子类或派生类。子类的对象具有超类对象的特征，同时又有其自身特有的特征。子类又可以派生出新的子类，子类的子类也称为派生类。</p>
<p>利用类之间的继承关系，可以简化类的描述，提高软件代码的可重用性。在设计一个新类时，不必从头设计编写全部的代码，可以通过从已有的具有类似特性的类中派生出一个类，继承原有类中的部分特性，再加上所需的新特性。</p>
<p>另外，人们在对客观世界的事物进行分类时，一个事物可能属于多个类，具有多个类的特性。例如，一个黑人学生，他既属于学生类，又属于黑人类。这种情形在面向对象方法中称为多继承，即一个类同时从多个类中派生出来，此时类的层次结构是网状的。</p>
<p>Java语言为了不使语法过于复杂，不支持多继承，只允许子类有一个超类，称为单继承。不过，Java语言提供了接口机制，可以在一定程度上模拟多继承。</p>
<h2 id="多态性-3"><a href="#多态性-3" class="headerlink" title="多态性"></a>多态性</h2><p>多态性是面向对象系统的又一重要特性。所谓多态，即一个名词可具有多种语义，如一个方法名有多种功能，或者相同的接口有多种实现方法。</p>
<p>在Java语言中，多态性通过方法的重载、覆盖和接口来实现。<br>方法的重载是指多个方法具有相同的名称 ，但各个方法的参数表不同，即参数的类型和参数的数量不同。</p>
<p>覆盖是指在类的派生过程中，子类与超类的方法不仅名称相同，参数也完全相同，但它们的功能不同，这时子类中的方法覆盖了超类中同名的方法。</p>
<p>接口实际上是一种特殊的类，只给出方法的名称、参数和返回值的类型，方法的具体实现在实现该接口的类中给出。</p>
<h2 id="封装-3"><a href="#封装-3" class="headerlink" title="封装"></a>封装</h2><p>封装是一种信息隐藏技术，对象内部对用户是隐藏的，不可直接访问；用户只能见到对象封装界面上的信息，通过对象的外部接口访问对象。用户向对象发送消息后，对象根据收到的消息调用内部方法作出响应。封装的目的在于将对象的使用者和对象的设计者分开，使用者无需知道对象内部实现的细节，只需知道对象接收的消息即可。</p>
<p>Java语言通过类来实现封装，类中定义的属性和方法分为私有的和公有的，私有属性和方法不能在对象的外部访问，只能由类内的方法访问。而在对象的外部，只能访问对象的公有属性和方法，只需要知道公有属性的数据类型和名字以及公有方法的原型，至于这些方法是如何实现的对象外部并不需要知道。这就像人们在使用电视机时只需要通过遥控器来操作即可，至于电视机内部细节用户则无需知道，这里遥控器上的按钮实际上就是电视机的外部接口。</p>
<p>对象的封装特性可以提高模块之间的独立性，使得系统易于调试和维护。</p>
<h2 id="类的声明与对象的创建-1"><a href="#类的声明与对象的创建-1" class="headerlink" title="类的声明与对象的创建"></a>类的声明与对象的创建</h2><p>类声明的基本语法</p>
<p>1．类的声明<br>Java语言类声明的完整语法很复杂，下面先介绍最简单的形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名&#123;</span><br><span class="line">类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="java的课程体系"><a href="#java的课程体系" class="headerlink" title="java的课程体系"></a>java的课程体系</h2><p>Java语法基础<br>Java面向对象的编程<br>Java的高级编程接口：4个专题<br>Java图形GUI编程<br>多线程编程<br>I/O编程<br>网络编程</p>
<h3 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h3><p>了解java的产生与发展<br>理解java语言的特性<br>理解java虚拟机jvm的特性和功能<br>理解字节码和垃圾收集的概念<br>列举出在java平台上实现代码安全的方法<br>知道在java中定义类，包，applets和applications<br>掌握编码，编译，运行java应用程序的步骤<br>安装，搭建java开发运行环境<br>第一个java程序<br>带包的java程序<br>JVM搜索类的顺序和类加载<br>CLASSPATH的应用<br>常用的java命令</p>
<h3 id="Java的产生与发展"><a href="#Java的产生与发展" class="headerlink" title="Java的产生与发展"></a>Java的产生与发展</h3><p>Java的产生</p>
<p>Sun公司的Green项目<br>基于c++开发的Oak语言<br>Mosaic和Netscape到JavaHot浏览器<br>Internet的蓬勃发展推动了java的发展(Applet)<br>Java(爪哇)  名字的由来</p>
<p>Java的发展</p>
<p>Java的现状<br>纯面向对象的语言<br>平台无关性，一次编写，到处运行<br>适合于基于Internet应用程序开发<br>Java的地位确立<br>IT产业很多大公司购买了java的许可证<br>众多软件开发商已支持java软件产品<br>Intranet是企业信息系统最佳的解决方案，java发挥了不可替代的作用<br>Java的发展与其分支<br>95.5.23 Oak改名为java<br>98.12. java1.2，后来改名为java2<br>陆续出现了java1.3,java1.4<br>2004.12 java1.5版本推出   命名为java5.0<br>后来陆续出现java6.0,java7.0</p>
<h3 id="Java的产生与发展-1"><a href="#Java的产生与发展-1" class="headerlink" title="Java的产生与发展"></a>Java的产生与发展</h3><p>Java的发展与其分支<br>java在今天已形成了庞大的体系,经过十年发展,已有了3个平台标准<br>三大技术平台都提供了相应的开发工具包(SDK:SoftWare Development Kits)</p>
<p>java SE –标准版应用平台<br>java EE–企业级应用平台<br>java ME—微型版应用平台：应用在存储,运算很小的受限的平台</p>
<h2 id="Java语言的特性-1"><a href="#Java语言的特性-1" class="headerlink" title="Java语言的特性"></a>Java语言的特性</h2><p>什么是java?<br>程序设计语言；开发环境；应用环境；部署环境<br>Java的特性<br>提供更简单的方式写程序<br>无指针，无需做内存管理<br>提供庞大的类库，纯粹面向对象设计<br>支持静态和动态的代码继承和重用<br>提供一个可解释执行的环境<br>支持任何开发平台<br>只写一次，到处使用<br>支持多线程<br>支持动态升级<br>以上特性如何实现<br>Java虚拟机：JVM<br>垃圾收集：Garbage Collection<br>代码安全：Code Security<br>字节码文件：Verifying</p>
<p>JVM与跨平台性:<br>一次编写，到处运行：不同操作系统,不同数据库,不同的服务器<br>数据类型也可以实现跨平台<br>Java虚拟机的作用<br>程序的开发及运行方式<br>Java的工作方式：先编译后解释</p>
<h2 id="Java是先编译后解释执行"><a href="#Java是先编译后解释执行" class="headerlink" title="Java是先编译后解释执行"></a>Java是先编译后解释执行</h2><p>Java源文件先通过编译生成一个字节码文件bytecode<br>字节码不与当前OS相关，结构中立的，是二进制文件。任何平台编译生成的字节码都是一样的。<br>字节码文件不能直接执行，必须需要JVM的支撑才能运行<br>JVM是sun开发的，字节码的结构也是sun定义的,他们之间有很好的接口<br>JVM存在的意义实际上就是屏蔽掉底层平台的差异，为上层结构中立的字节码统一运行的环境，而JVM会将字节码转化成相应的底层平台的机器码执行<br>java解释器功能是用JVM来实现的，java的解释器是在jvm中运行的</p>
<h2 id="JVM的作用："><a href="#JVM的作用：" class="headerlink" title="JVM的作用："></a>JVM的作用：</h2><p>对下是屏蔽掉了底层平台的差异，对于上层的字节码而言不需要关心它运行在什么平台上，由JVM去把底层平台的差异屏蔽掉<br>对上为结构中立的字节码提供了统一的运行环境，实现了字节码的跨平台</p>
<h2 id="Java的垃圾收集器"><a href="#Java的垃圾收集器" class="headerlink" title="Java的垃圾收集器"></a>Java的垃圾收集器</h2><p>Java的垃圾收集解除了程序员分配存储器的责任，它提供了一种系统级线程以便跟踪每一存储器的分配情况。在Java虚拟机的空闲周期，垃圾收集线程检查并释放那些可被释放的存储器。<br>内存泄漏<br>垃圾收集线程<br>垃圾收集调用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.System.gc()/java.lang.Runtime.gc()</span><br></pre></td></tr></table></figure>
<p>Java代码的安全性</p>
<h2 id="字节码的作用"><a href="#字节码的作用" class="headerlink" title="字节码的作用"></a>字节码的作用</h2><p>字节码的结构是JVM特定指定的<br>字节码不会破坏，篡改系统<br>禁止运行时堆栈溢出  防止蠕虫病毒袭击<br>参数类型正确<br>类型转换正确</p>
<p>安装，搭建java开发运行环境</p>
<p>官方网站下载JDK</p>
<blockquote>
<p>官方网站：<code>http://java.sun.com</code></p>
</blockquote>
<blockquote>
<p>不同系统平台，JDK不一样，选择适合于自己平台的JDK</p>
</blockquote>
<h2 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h2><p>Windows直接安装运行jdk的可执行exe文件<br>Linux系统将JDK文件压缩包解压后放入opt目录，配置初始化文件的环境变量<br>Windows下JDK安装后，会有2个文件夹生成<br>JDK：java开发工具软件包，它包含了java的编译，调试，运行整个环境和包含了整个类库的软件包<br>JRE：java运行环境<br>JDK,JRE和JVM</p>
<p>JDK，JRE和JVM</p>
<p>jre是jdk的子集，在一套完整的jdk中就包含了jre<br>jre只负责运行一个编译好的java程序（字节码文件bytecode）<br>jdk它可以去编译，调试，运行整个操作过程都支持<br>在jre内部有一个软件组件jvm就是java虚拟机</p>
<h2 id="JDK的结构简介"><a href="#JDK的结构简介" class="headerlink" title="JDK的结构简介"></a>JDK的结构简介</h2><p>bin目录：java开发调试的命令,  exe文件,连接库文件，编译器等等<br>编译一个java文件：javac；运行一个字节码文件：java<br>jre目录：jdk中自带的jre<br>src压缩文件：放置的是jdk类库的源码文件，按包结构组织的<br>demo:：java代码的演示实例文件<br>include：用于编译本地方法的文件<br>docs：html格式的类库文档<br>lib：类库文件<br>Java程序开发环境配置<br>在windows平台：autoexec.bat文件；使用对话框(右击我的电脑／属性／高级／环境变量／系统或用户的环境变量)操作<br>Unix平台需要分shell：csh $HOME/.cshrc   bsh/ksh  $HOME/.profile<br>环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME：保存jdk的安装目录</span><br><span class="line">windows : set  JAVA_HOME=c:\programfiles\java\jdk1.5.0_09</span><br><span class="line">csh: setenv JAVA_HOME  /opt/jdk1.5.0_09</span><br><span class="line">bsh/ksh: JAVA_HOME=/opt/jdk1.5.0_09</span><br><span class="line">CLASSPATH：系统搜索字节码（类文件.class）文件的搜索路径。设置系统在查找字节码文件时，它的搜索路径。</span><br><span class="line">windows: set CLASSPATH=.; %JAVA_HOME%\jre\lib\rt.jar;</span><br><span class="line">csh: setenv CLASSPATH  .:$JAVA_HOME/jre/lib/rt.jar</span><br><span class="line">bsh/ksh:  CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar</span><br></pre></td></tr></table></figure>
<p>PATH：设置命令的搜索路径，在执行命令时，操作系统就会在PATH设置的路径去查找命令的可执行文件。<br>设置path不能覆盖原有的，可以使用特殊符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">windows：%PATH%;  Linux：$PATH:</span><br><span class="line">windows: set PATH=%PATH%;%JAVA_HOME%\bin;</span><br><span class="line">csh: setenv PATH $PATH:$JAVA_HOME/bin</span><br><span class="line">bsh/ksh: PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>Linux系统使用bsh/ksh时则需要export  JAVA_HOME CLASSPATH PATH 将环境变量设置为全局的<br>编辑，编译，调试，运行一个java程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">写第一个java程序：HelloWorld.java</span><br><span class="line">public class HelloWorld&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		String str=“Hello World!”; </span><br><span class="line">        System.out.println(“The String  is:：”+str);</span><br><span class="line">		System.out.println(&quot;MyAge is: &quot;+age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个程序掌握以下概念<br>一个java源文件中可以定义多个类，但最多只能有一个类用public来修饰，而且该public修饰的类名要与java源文件名一样。</p>
<p>一个java应用程序应该包含一个主方法，而且主方法的签名是固定不变的。主方法定义在哪个类中并不做固定安排。<br>定义的所有的代码中，只看到类的定义。在类中去封装其他变量或方法。</p>
<p>编译HelloWorld.java程序</p>
<p>开始\运行\cmd进入dos,修改当前目录为d:\javacode\day01<br>使用javac HelloWorld.java命令编译<br>编译成功后，到day01程序目录下查看，发现有2个.class文件得出有效结论<br>编译报错则根据错误提示找出错误位置然后修改程序重新编译<br>举例来演示学习错误提示<br>假如将String的S写为小写  ：string str=“HelloWorld!”;<br>假如将out写为out：System.otu.println(“The String  is: “+str);<br>再次编译一下，查看错误提示，必须要会读错误提示<br>分析错误提示，排除错误是基本的能力</p>
<h2 id="包的概念，含义和使用"><a href="#包的概念，含义和使用" class="headerlink" title="包的概念，含义和使用"></a>包的概念，含义和使用</h2><p>运行HelloWorld程序：</p>
<p>包含有主方法的程序才可以运行,没有包含主方法的类是不能运行的<br>开始\运行\cmd进入dos;使用cd d:\javacode\day01进入程序目录<br>使用 java HelloWorld(包含有主方法的类的类名)来运行<br>使用java Student就会报告错误提示没有主方法<br>要求学员做HelloWorld程序并操作演示几种错误情况和调错</p>
<p>带包的java程序<br>包的声明：package day01     package是关键字   day01是包名</p>
<p>包的概念和含义<br>包名的命名符合标识符命名规则即可<br>企业项目开发中,包的命名也有企业规范的如：com.shunshi.abs.model<br>.来隔开每一部分，每一部分都是包结构<br>com.shunshi这个是软件公司网址的url，可以区分确认哪个公司开发的软件产品   com.sun/com.ibm，这样包名不会产生冲突<br>abs是项目名，model是项目中的模块/子模块名<br>写MySecondJava.java程序<br>使用包结构 package com.shunshi.corejava.day01<br>使用包后，如何编译<br>写MySecondJava.java，使用包声明： package corejava.day01;</p>
<blockquote>
<p>编译程序：javac  –d  .   MySecondJava.java</p>
</blockquote>
<h2 id="JVM搜索类的顺序与类加载"><a href="#JVM搜索类的顺序与类加载" class="headerlink" title="JVM搜索类的顺序与类加载"></a>JVM搜索类的顺序与类加载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-d选项的作用：</span><br><span class="line">把编译好的字节码放在你指定的目录下，所以需要指定目录</span><br><span class="line">如果源文件声明了包结构，那么在给定的目录位置下会按照包结构自动创建目录结构，编译好的字节码文件是放在最终的子目录下</span><br></pre></td></tr></table></figure>
<h2 id="为什么使用包？"><a href="#为什么使用包？" class="headerlink" title="为什么使用包？"></a>为什么使用包？</h2><p>企业项目开发中方便管理不同的类<br>用包来分门别类地组织不同模块功能的类<br>使用包的好处：举例：航班机票预定项目</p>
<p>JVM搜索类的顺序与类加载<br>使用包结构编译后，如何运行？<br>使用java，注意：java corejava.day01.MySecondJava<br>如何运行？类加载<br>演示错误情况的发生</p>
<p>直接使用 java MySecondJava  则报告找不到这个类的定义的错误提示<br>为什么找不到？从系统如何去找类来说，与jvm在查找类时的搜索顺序有关系<br>直接进入包结构目录cd corejava\day01,使用java MySecondJava运行，则报告找不到类的定义同时给出错误原因（找到的类与要运行的类不一致）</p>
<h2 id="Java-常用命令"><a href="#Java-常用命令" class="headerlink" title="Java 常用命令"></a>Java 常用命令</h2><p>为什么不一致呢？找到的是带包的，运行的是不带包的<br>CLASSPATH的应用<br>深刻理解java技术体系<br>如何使用第三方的java技术</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>javac 选项  源文件名    编译java 源文件</p>
<p>-d<br>查看javac命令到底有哪些选项，直接使用javac/javac -help命令回车<br>java 选项  类名 [参数]  运行java程序<br>jdb  选项  类名 [参数]   进行debug调试的命令<br>javadoc  选项  包名   源文件名   生成jdk的api形式的程序文档</p>
<p>在java源文件中允许使用文档形式的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释  //注释内容</span><br><span class="line">多行注释 /*注释内容*/  多行注释不能嵌套,但可以嵌套单行注释</span><br><span class="line">文档注释  /**注释内容*/</span><br></pre></td></tr></table></figure>
<p>出现在类的定义，方法的定义，属性的定义之前，用来说明类的含义，方法的含义，属性的含义<br>使用javadoc命令给MySecondJava.java生成文档注释<br>在MySecondJava.java中，类前，主方法前写一些文档注释<br>使用javadoc命令将文件MySecondJava.java中的文档注释抽取出来生成程序文档。javadoc –d .\doc  MySecondJava.java</p>
<h3 id="分析程序文档结构和理解jdk的API文档"><a href="#分析程序文档结构和理解jdk的API文档" class="headerlink" title="分析程序文档结构和理解jdk的API文档"></a>分析程序文档结构和理解jdk的API文档</h3><blockquote>
<p>jar {ctxu}[vfm0Mi] [jar-file] [manifest-file] [-C  directory] files 创建/展开/更新一个jar文件</p>
</blockquote>
<p>jar文件：sun公司定义的一种文件格式，与zip格式相同，可以用普通的解压缩工具解开。jar文件压缩的一般是java的字节码文件,按照包结构组织好的.class文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建jar文件:  将d:\corejava\day01中的1个.class文件打包成一个jar文件</span><br><span class="line">jar   -cvf  first.jar   .\corejava   不与源文件放在一起   </span><br><span class="line">c  代表创建jar文件</span><br><span class="line">v  是可视化即可以看见创建过程和创建详细清单</span><br><span class="line"> f  代表可在后面指定jar文件名</span><br></pre></td></tr></table></figure>
<p>解压生成后jar文件，有corejava和META-INF2个文件夹<br>jar文件有什么作用？<br>将开发的类打包jar文件给客户，客户得到后只需要设置classpath后就可以用了<br>开发一个中间件，将中间件的程序打包成jar<br>打包day01.jar（corejava\day01中的.class）给第三个程序MyThirdJava使用。<br>写MyThirdJava.java程序</p>
<p>知道java的特殊符号<br>熟悉java的标识符<br>掌握java的关键字的使用<br>理解java各数据类型的存储和使用<br>原始数据类型<br>基本数据类型的转换<br>定义类，对象，成员变量和引用变量<br>类的声明<br>类变量与类成员变量<br>创建类的对象实例和使用默认值<br>描述引用变量与类对象的关系<br>掌握表达式和运算符的使用</p>
<h2 id="Java中的特殊符号"><a href="#Java中的特殊符号" class="headerlink" title="Java中的特殊符号"></a>Java中的特殊符号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注释</span><br><span class="line">单行注释：//</span><br><span class="line">多行注释：/* */</span><br><span class="line">		这两种注释只能通过打开源文件来查看，写程序一定要写注释。注释与程序应是2:1</span><br><span class="line">多行注释：/** */</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个注释可以不打开源文件来查看，java中有一个javadoc工具，它的作用是将源文件中的/**  */</span><br></pre></td></tr></table></figure>
<p>注释单独抽出来放在另一个文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如： javadoc –d  .  Hello.java,执行后，会在当前目录下生成一个doc目录，里面文件就可查看注释了。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其他符号</span><br><span class="line">;   一个语句的结束</span><br><span class="line">&#123;   &#125;  一个语句块</span><br><span class="line">空白字符    空格，tab,回车,换行等</span><br></pre></td></tr></table></figure>
<h2 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h2><p>标识符：程序中的组件名字，包括类名，方法的参数名，变量名，方法名，包名等<br>定义标识符的规则：<br>    以_ ,$,字母开头；<br>    只含有_,$,字母，数字;<br>    没有长度限制，不能有空格；<br>    不能使用java的关键字或保留字<br>    大小写敏感</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：_abc √, $ABC √,2A ×,A# ×,For√,顺时 √</span><br><span class="line">Java开发的命名习惯</span><br><span class="line">所有的命名要望文生义，这样才具有良好的可读性</span><br><span class="line">Total，Sum，ShunshiStudent，</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类名，接口名：每个单词的首字母大写，其他字母小写  如类MyFirstJava，Player，Teacher</span><br><span class="line">属性，方法,，局部变量名：第一个单词全小写，从第二个单词开始以后每个单词首字母大写，其他字母小写    如方法 getName()     setDoctorBirthday()</span><br><span class="line">常量：每个单词所有字母全部大写，单词之间用_来连接  java中使用final修饰   final int MARK_GREED=22;</span><br><span class="line">包名：所有字母全部小写  如package com.shunshi.corejava.day01</span><br></pre></td></tr></table></figure>
<h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h2><p>关键字：对Java技术编译器有特殊的含义，可以被编译器识别执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abstract  do  implements  private throw  boolean double import  protected  throws </span><br><span class="line">break  else  instanceof  public  transient  byte   extends  int   return  true </span><br><span class="line">case   false   interface  short    try    catch    final   long     static   void </span><br><span class="line">char   finally   native   super    volatile   class    float    new    switch     while </span><br><span class="line">continue   for    null     synchronized   default    if     package    this</span><br></pre></td></tr></table></figure>
<p>Java关键字特点</p>
<p>java关键字与c++很多相似，只要与c++一样的，它的含义都与c++中的相同<br>有些关键字c++有，而java没有</p>
<p>sizeof 求出某种类型的变量的占内存的大小<br>为什么c++有sizeof？<br>因为不同机器内存占用空间大小不一样 16，32，64位，取决于操作系统平台。<br>为什么Java不需要？<br>因为有JVM。</p>
<p>java中的关键字都是小写的<br>true、false和null为小写，而不是象在C++语言中那样为大写。严格地讲，它们不是关键字。</p>
<h2 id="Java关键字-1"><a href="#Java关键字-1" class="headerlink" title="Java关键字"></a>Java关键字</h2><p>有些关键字java没有取消保留下来，但它自己也不用它也不给程序员用<br>goto和const不是Java编程语言中使用的关键字，而是保留字。<br>什么是保留字？<br>为什么保留下来但不能用?<br>在java中final替代const<br>goto在c++代表无条件跳转，功能很好，但不能经常用，要谨慎。<br>很多建议去掉goto关键字，没有理解goto真正含义。<br>为什么c++到现在都没有删除掉goto?它有一个特殊使命<br>Java中使用break代替goto<br>跳出一层循环 ：break<br>跳出多层循环：break out<br>        out是一个标号，可以跳到out标识处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">break避免滥用goto，把goto功能削弱了，只能跳到外层循环</span><br><span class="line">java中加入新的关键字enum assert</span><br><span class="line">enum：枚举</span><br><span class="line">assert：断言</span><br></pre></td></tr></table></figure>
<h2 id="Java的原始数据类型"><a href="#Java的原始数据类型" class="headerlink" title="Java的原始数据类型"></a>Java的原始数据类型</h2><p>boolean   true/false<br>byte  8位整型  1个字节<br>short 16位整型 2个字节<br>int 32位整型 4个字节<br>long 64位整型 8个字节<br>char 16位 unicode 字符  2个字节<br>double 64位浮点数字型 8个字节<br>float  32位浮点数字型 4个字节</p>
<h3 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h3><p>Java中定义boolean类型<br>boolean b=true;<br>Java中的boolean类型的取值只能是true,false<br>Java中的boolean类型不能与int通用，而在c++中可以<br>C++中,0代表false,非0代表true<br>boolean与int通用好还是不好呢？不好<br>举例说明 c++中的boolean与int通用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">if(0&lt;a&lt;2) cout&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h2 id="Integer-数据类型—byte-short-int-long"><a href="#Integer-数据类型—byte-short-int-long" class="headerlink" title="Integer 数据类型—byte,short,int,long"></a>Integer 数据类型—byte,short,int,long</h2><p>Java中的4种整型类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte: 1个字节 –128(-27)-127(27-1)</span><br><span class="line">short: 2个字节 –32768(-215)-32767(215-1)</span><br><span class="line">int: 4个字节 –2147483648 (-231) -2147483647 (-231-1)</span><br><span class="line">long: 8个字节  –263-263-1</span><br></pre></td></tr></table></figure>
<p> Java的不同整型占用内存空间的大小不一样<br> Java中整型的存储规则与c++一样， 但java整型没有无符号和有符号的区分，这与c++不一样。Java中所有整型都是有符号的，这样就可以求出每个整型能表示的范围。</p>
<p>以byte为例说明<br>Byte是8位整型  1个字节 最多可表示28=256个数  从(-27)-128到127(27-1)<br>为什么是-128-127而不是-127-128呢？与整型数据在内存的存储规则有关<br>整型数据在内存空间中的存储方式<br>    正整数（最高位为0）在内存中是存储原码<br>    负整数（最高位为1）在内存中是存储其补码    补码是不考虑符号情况下原码取反后末位加1。以-5来分析补码<br>分析一些特殊数字：8位全为1则是数字-1，8位全为0则是数字0<br>不考虑符号位最大的数是01111111表示数字127，最小的数10000000表示数字-128</p>
<h2 id="Integer-数据类型在内存的存储方式"><a href="#Integer-数据类型在内存的存储方式" class="headerlink" title="Integer 数据类型在内存的存储方式"></a>Integer 数据类型在内存的存储方式</h2><p>为什么用补码存储负数？方便二进制计算，例如-128+127=-1<br>其他类型的整型在内存的存储方式与byte相同，只是空间更大。其他类型的整型表示数的范围如前面<br> 整型数据表示<br>long类型使用  l或L来表示<br>int的不同进制：十六进制用0x或H表示    8进制用0或O表示   10进制用D或10表示<br>默认类型为int</p>
<h2 id="char数据类型"><a href="#char数据类型" class="headerlink" title="char数据类型"></a>char数据类型</h2><p>char类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> char 字符型为16位， 2个字节，与c++不一样,采用的是unicode编码，unicode编码是统一编码，可包含字母，数字，符号，中文文字等</span><br><span class="line">unicode码是采用16进制表示的 如‘\u0061’</span><br><span class="line">2个字节的unicode编码可以表示216个字符，字符使用单引号‘’来表示</span><br><span class="line">127个ASCII码全可表示 英文字符，控制字符，数字，标点符  </span><br><span class="line">表示其他语言的字符：中文，德语，法语，阿拉伯等</span><br><span class="line">一个char类型本质上是一个整型</span><br></pre></td></tr></table></figure></p>
<p>char与short都是16位的，他们的差别？<br>通过查询unicode编码集可以获取一个整型值对应的unicode字符<br>unicode编码集包含了ASCII码集的<br>在0-127内unicode编码值与ASCII码值一样，表示的字符也一样<br>常见的ASCII码值 ：A:65  a:97  0:48<br>通过unicode码得到码值可以将16进制转换为10进制</p>
<h2 id="String类型简介"><a href="#String类型简介" class="headerlink" title="String类型简介"></a>String类型简介</h2><p>Java中的转义字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\’   ：‘ 单引号     \” ： “双引号    \\ ：\顺斜杠  \n：换行   \t：tab制表符       </span><br><span class="line">\b：退格      \0：‘\u0000’   unicode码值为0的空字符</span><br></pre></td></tr></table></figure>
<p>String类型<br>String类型：字符串类型，它不是java的8种基本类型，是类的类型<br>String是java的一个类，这个类的实例叫做String对象<br>Java中字符串用””双引号来引用<br>Java中的字符串类不是以‘\0’结尾</p>
<p>String类是Java中使用最多的类，它有很多有用的方法，查看jdk的api文档<br>获得String类的对象变量<br>String str1=“Hello”;      String str2=new String(“ World!”);</p>
<p>String可做什么操作<br>使用+号来连接字符串<br>String s1=“12”; int ia=3; int ib=4;<br>System.out.println(s1+ia+ib); System.out.println(ia+ib+s1);<br>char charAt(int)：返回参数int指示位置上的字符<br>System.out.println(str1.charAt(0));<br>String concat(String)：将当前String与参数String连接起来返回新串<br>System.out.println(str1.concat(str2));</p>
<p>boolean contains(charSequence s)：判断一个字符串中是否包含参数的子串<br>String str3=“Hello World!”;    System.out.println(str3.contains(str1));</p>
<p>boolean equals(String)：比较2个字符串内容是否相等,不忽略大小写<br>String s2=“Hello”; String s3=“Hello”; System.out.println(s2.equals(s3));</p>
<p>boolean equalsIgnoreCase(String)：比较2个字符串内容是否相等，忽略大小写<br>String s4=“heLLo”; System.out.println(s4.equals(s3)); System.out.println(s4.equalsIgnoreCase(s3));</p>
<p>int  indexOf(String/char)：获得参数字符/字符串在改字符串中的第一次出现的位置索引，假如找不到则返回-1<br>System.out.println(str3.indexOf(“Wor”)); System.out.println(str3.indexOf(‘o’));</p>
<p>length()：获得字符串的长度<br>System.out.println(str3.length());<br>写TestString.java，演示上面String的功能</p>
<h2 id="浮点型数据类型"><a href="#浮点型数据类型" class="headerlink" title="浮点型数据类型"></a>浮点型数据类型</h2><p>浮点数据类型：２种<br>float：单精度，３２位　４个字节　使用f或者F表示<br>double：双精度　６４位　８个字节　默认类型  使用d或者D表示</p>
<p>浮点数举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float fa=123.4f;√  float fb=123.4;×  默认是double  double直接赋给float精度丢失</span><br><span class="line">float fc=12.5E300F;√  float fd=(float)12.5E301; √</span><br><span class="line">double da=123D;  double db=123.456d;  double dc=123.45e301;</span><br></pre></td></tr></table></figure>
<p>浮点数据类型的存储方式<br>整型存储方式是精确存储<br>浮点存储方式是近似存储：实数范围太大了，实数太多了，无法在内存中对应每一个实数的状态<br>浮点数的近似存储在程序中的问题：写TestFloat.java<br>实型值分母可为0，double d=0.0/0.0; System.out.println(d);编译正确<br>double a=2.0,b=1.91,c=0.09;<br>if(a-b==c) System.out.println(“ok”);else System.out.pringln(“no ok”);<br>结果输出”on ok”。实型数值直接比较相等不安全，不要直接比较相等，但可以比较大小。</p>
<p>假如一定想要2个实型数值比较是否相等，可以考虑比较2个实型数的差是否在一个非常小的范围内<br>想要输出“ok”，则if(Math.abs(a-b-c)&lt;(1e-6)) System.out.println(“ok”);</p>
<h3 id="Math类-1"><a href="#Math类-1" class="headerlink" title="Math类"></a>Math类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lang包下的类，它里面定义了很多方法来实现常用的数学运算</span><br><span class="line">Math类中的方法都是静态的</span><br><span class="line"></span><br><span class="line">Math类中的方法：</span><br><span class="line">abs()：求绝对值</span><br><span class="line">sqrt()：求平方根</span><br><span class="line">pow()：求乘方</span><br><span class="line">cos(),sin(),tan(),ctan()：数学的三角函数运算</span><br><span class="line">random()：获得0-1之间的随机数</span><br><span class="line">在TestFloat.java中测试使用Math类中的方法</span><br><span class="line">Math.abs(-5)</span><br><span class="line">Math.sqrt(9)</span><br><span class="line">Math.pow(2,3)</span><br><span class="line">Math.random()*100：获得0-100之间的随机数</span><br></pre></td></tr></table></figure>
<h2 id="数据类型之间的转换"><a href="#数据类型之间的转换" class="headerlink" title="数据类型之间的转换"></a>数据类型之间的转换</h2><p>数据类型之间的转换分为2种<br>自动类型转换<br>a类型转换为b类型时，a的取值范围是b的取值范围的完全子集 这就是自动类型转换<br>在java的8种基本类型中，除boolean以外，其他7种类型都是可以相互转换的。<br>7种原始类型之间可自动转换结构图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte→short→int→long→float→double</span><br><span class="line">     char</span><br></pre></td></tr></table></figure>
<p>顺着箭头方向可自动转换；逆着箭头方向则是强制转换<br>强制类型转换：只要不能自动转换的，则只能是强制转换<br>整型数据之间的强转：改变数据的符号；改变数值</p>
<blockquote>
<p>int a=0x2aff; byte b=(byte)a;   b为-1</p>
</blockquote>
<p>强制转换的原理：从最低位开始取到目标类型长度为止<br>整型之间的强转是保留二进制低位，去掉高位，需要考虑在内存中如何存储<br>实型强转整型是保留整数，去掉小数，不考虑实型在内存中的如何存储<br>写一个DataTypeTest.java程序演示数据类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">byte+byte会自动提升为int</span><br><span class="line">byte a1=1,a2=2;byte a3=a1+a2;×(精度丢失)</span><br><span class="line">+=不进行类型提升</span><br><span class="line">byte c=3; c=c+3; c+=3;System.out.println(c);</span><br><span class="line">默认整型为int,int，long提升为float有精度丢失</span><br><span class="line">float fa=37; System.out.println(fa); </span><br><span class="line">int ia=(int)fa; System.out.println(ia);</span><br><span class="line">long la=0xffffffffffL;float fb=la;System.out.println(fb);</span><br><span class="line">long lb=(long)fb;  System.out.println(lb);</span><br><span class="line">整型之间的强转</span><br><span class="line">int a=0x2aff; byte b=(byte)a;  System.out.println(b);</span><br><span class="line">float转换为double会有精度丢失</span><br><span class="line">float fe=1234.56f; double de=fe; System.out.println(de);</span><br><span class="line">float ff=(float)de; System.out.println(ff);</span><br><span class="line">整型除法</span><br><span class="line">System.out.println(5/2);</span><br><span class="line">System.out.println((float)5/2);</span><br><span class="line">char与int的转换</span><br><span class="line">char c1=‘A’; int iic=c1;System.out.println(iic);</span><br><span class="line">char c2=99; System.out.println(c2);</span><br></pre></td></tr></table></figure>
<h2 id="Java中的特殊类型——对象"><a href="#Java中的特殊类型——对象" class="headerlink" title="Java中的特殊类型——对象"></a>Java中的特殊类型——对象</h2><p>为什么会有对象?<br>早些时候的编程语言和初级程序员将每个变量看作相互无关的实体。例如，如果一个程序需处理某个日期，则要声明三个单独的整数：int day, month, year;<br>尽管这种作法很容易理解，但它存在两个重大缺陷<br>名称太多，会引起混乱<br>忽略了各个变量之间的联系<br>例如：若程序需同时记录几个日期，则需要三个不同的声明,要记录两个生日, 则要使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int  myBirthDay, myBirthMonth, myBirthYear;</span><br><span class="line">int yourBirthDay, yourBirthMonth, yourBirthYear;</span><br></pre></td></tr></table></figure>
<p>忽视了日、月和年之间的联系并把每个变量都作为一个独立的值，每个变量都是一个独立单元(在本例中为date)的一部分并被相应地处理<br>Java的对象类型<br>为克服上述两种缺陷，Java编程语言使用类来表示这种新类型<br>Java除了８中基本类型，还有一种类类型或者叫做对象类型(或是一个类，或是一个接口)<br>Java的类类型不是表达一个简单的数据，而是表达一个较复杂的数据(复合数据) </p>
<p>例如：描述一个学生，定义一个学生类，它包含学生的相关信息：姓名，性别，年龄，专业<br>创建一个学生类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">	class Student&#123;</span><br><span class="line">		private String name;</span><br><span class="line">		private boolean sex;</span><br><span class="line">		private int age;</span><br><span class="line">		private String major;</span><br><span class="line"></span><br><span class="line">		public Student(String name,boolean sex,int age,String major)&#123;</span><br><span class="line">			this.name=name;</span><br><span class="line">			this.sex=sex;</span><br><span class="line">			this.age=age;</span><br><span class="line">			this.major=major;</span><br><span class="line">		&#125;</span><br><span class="line">		public void setName(String name)&#123;</span><br><span class="line">			this.name=name;</span><br><span class="line">		&#125;</span><br><span class="line">		public void setSex(boolean sex)&#123;</span><br><span class="line">			this.sex=sex;</span><br><span class="line">		&#125;</span><br><span class="line">		public void setAge(int age)&#123;</span><br><span class="line">		this.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setMajor(String major)&#123;</span><br><span class="line">		this.major=major;</span><br><span class="line">	&#125;</span><br><span class="line">	public String  getName()&#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public boolean getSex()&#123;</span><br><span class="line">		return sex;</span><br><span class="line">	&#125;</span><br><span class="line">	public int  getAge()&#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getMajor()&#123;</span><br><span class="line">		return major;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Student就是一个新的类型，就像int,float等一样可以用来定义变量</span><br><span class="line">例如：Student  stu;   声明一个Student的变量stu，则它里面的name,sex,age,major也都隐含声明了，name,sex,age,major称为stu的成员变量。</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>类类型／对象类型的数据的存储方式与基本类型数据存储方式的差别<br>类型创建一个Student对象：<br>Student stu; stu=new Student(“LiDW’,true,22,”computer”);<br>原始类型的声明<br>    int x;x=7; float y=9.9f;<br>把类看作一个类型的话，它的使用其实和基本类型int等一样，只不过赋值是赋的一个复杂的复合类型数据，是new出的对象<br>存储形式的差别<br>int x; x=7; 基本类型声明变量时就已经创建了变量并分配空间，无论它是否已经赋值，赋值只是将值放入已分配的空间<br>Student stu;对象类型声明Student stu;时，在内存空间也给stu分配了空间。<br>那分配了多少空间？Student中所有成员变量的空间大小和吗？<br>不是取决于Student的大小，与Student的大小无关<br>那stu是什么？在java中把stu叫做引用，这个引用与c++中的引用完全不一样<br>Java中的引用与c++的指针相似，java中没有指针，只有引用，它保存的也是一个地址值(内存空间中的Student对象的地址)<br>Java中的引用与c++的指针有差别<br>C++中指针可被程序员操作：int<em> p;  p++,p–,</em>p等等，所以很危险，不安全<br>Java中不允许程序员对引用做操作，只能通过引用访问对象，但不能对引用进行++,–等操作，所以java语言更安全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Java的引用需要多少个字节呢？</span><br><span class="line"></span><br><span class="line">引用无论什么类型都保存的是内存中的地址值</span><br><span class="line">地址值常见的是4个字节，相对来讲很固定的值</span><br><span class="line">地址值的长度严格来讲也取决于不同的机器平台，由机器的寻址空间决定的。例如常用的是32位机器，所以4个字节</span><br><span class="line"></span><br><span class="line">那么stu=new Student(“LiWD”,true,22,”computer”)又干什么？</span><br><span class="line"></span><br><span class="line">在内存空间中又开辟了一个区域专门用来保存该Student对象的数据</span><br><span class="line">赋值语句将开辟的对象空间的地址赋给stu，stu就指向这个对象</span><br><span class="line">综上所述，对象类型的存储方式即需要两个空间：引用空间，对象空间</span><br><span class="line"></span><br><span class="line">Java中的对象与引用的关系：可以打个比方来看看</span><br><span class="line"></span><br><span class="line">对象可以看作是充满氢气的气球，气球中的空气就是对象中的数据，气球我们无法直接拿到</span><br><span class="line">任何时候我们拿到气球都必须通过连接它的一根绳子，这跟绳子就可以看作是引用</span><br><span class="line"></span><br><span class="line">深入理解对象与引用的关系</span><br><span class="line"></span><br><span class="line">同一个气球可不可以有多根绳子连着它？可以  就像双胞胎牵同一个气球</span><br></pre></td></tr></table></figure></p>
<p>Student stu1=new Student(“LiWD”,true,22,”computer”);<br>Student stu2=stu1;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">stu2,stu1保存的是相同的地址值，stu2,stu1指向同一个对象</span><br><span class="line">通过stu1修改了对象Student的数据值后，通过stu2访问的对象也就改了</span><br><span class="line"></span><br><span class="line">### 可不可能一根绳子同时栓着多个气球？不能</span><br><span class="line"></span><br><span class="line">如果一根绳子没有连任何气球，那么对于这个引用的访问有意义吗？没有意义</span><br><span class="line"></span><br><span class="line">Student stu3=null;定义了一个空引用，没有指向任何对象</span><br><span class="line"></span><br><span class="line">假如使用stu3去访问name,age等会报告空指针异常 NullPointerException</span><br><span class="line"></span><br><span class="line">如果某一个气球没有任何绳子栓着，那它怎么办？飞走了</span><br><span class="line"></span><br><span class="line">这个气球就无法访问了，变成垃圾。(垃圾占用空间，但我们无法访问)</span><br><span class="line"></span><br><span class="line">Student stu4=new Student(“LiWD”,true,22,”computer”); stu4=null;</span><br><span class="line"></span><br><span class="line">### Java的垃圾回收机制</span><br><span class="line"></span><br><span class="line">Java不让程序员管理内存</span><br><span class="line"></span><br><span class="line">一个系统级线程专门扫描内存，回收垃圾</span><br><span class="line"></span><br><span class="line">垃圾回收是自动进行的，程序员可以建议但不能控制，程序员调用java.lang.System.gc()来告诉JVM做垃圾回收。程序员建议后，也不一定就回收。</span><br><span class="line"></span><br><span class="line">一般java.lang.System.gc()语句放在前面程序已释放了很多垃圾后，则调用该语句执行的可能性大</span><br><span class="line">Java的垃圾回收并不是马上回收，jvm有一套算法来确定什么时候进行垃圾回收</span><br><span class="line">Java垃圾回收与c++内存释放的比较差异：打个比方</span><br><span class="line">C++内存释放：相当于学校食堂吃饭，吃饭后要将餐盘送到回收处，若你不做则大家会鄙视你。若大家都不做，则长时间就没有餐盘了。</span><br><span class="line">Java垃圾回收：相当于餐馆中吃饭，吃完了，只结帐就走了。餐馆自然有人来回收。无需自己把餐盘送到后台。</span><br><span class="line"></span><br><span class="line">理解对象</span><br><span class="line">对象无处不在;对象彼此联系;对象有属性;对象有方法</span><br><span class="line"></span><br><span class="line">&gt; There are students and a teacher in classroom</span><br><span class="line"></span><br><span class="line">## Java的运算符</span><br><span class="line"></span><br><span class="line">赋值运算符：一个简单的赋值=和11个复合赋值</span><br></pre></td></tr></table></figure></p>
<p>=，*=，/=，%=，+=，-=，&lt;&lt;=(左移位)，&gt;&gt;=(右移位)，&gt;&gt;&gt;=，&amp;=(按位与)，^=(按位异或)，|=(按位或)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">复合赋值运算不会产生自动类型的提升 byte b1=2; b1+=2;√ b1=b1+2;×</span><br><span class="line">比较运算符</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>，&gt;=，&lt;，&lt;=,instanceof(比较类型)，= =，!=<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Java的数据类型中哪些是可用比较运算符来连接的</span><br><span class="line"></span><br><span class="line">算术运算符</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>+,-,*,/,%<br>5/2，   (float)5/2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 移位运算符</span><br><span class="line"></span><br><span class="line">所有的移位运算只能针对整型数据操作</span><br></pre></td></tr></table></figure></p>
<blockquote>
<blockquote>
<p>(右移,右移一位等于除2)，&lt;&lt;(左移,左移一位等于乘2)，&gt;&gt;&gt;(无符号右移)<br>有符号的右移：则移走后最左边高位填补为原来的符号位<br>有符号的左移：则移出去的不管，移进来用0来填补<br>无符号右移：则移出去的不管，移进来都用0填补<br>int a=68; a=a&lt;&lt;34; System.out.println(a); 超出了范围，移出后全为0？实际上不是这样的。a&lt;&lt;34等价于a&lt;&lt;(34%32)<br>int in1=20;System.out.println(in1&gt;&gt;1);  10  System.out.println(in1&gt;&gt;&gt;1); 10<br>int in2=-20;System.out.println(in2&gt;&gt;1); -10  System.out.println(in2&gt;&gt;&gt;1); 很大的数<br> 位运算符<br>&amp;(按位与)，|(按位或)，~(按位求反)，^(按位异或)<br>例：  int a=0x5a2b;  int b=0x7332;   a&amp;b a|b a^b<br>位运算符什么时候用？用来干什么？<br>例：int a=0x8a3d;<br><code>`</code></p>
</blockquote>
</blockquote>
      
    </div>
    
    
    

      <div>
        
          <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        
      </div>

    

      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/微信公众号.jpg" alt="达叔小生 wechat" style="width: 200px; max-width: 100%">
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="达叔小生 微信支付">
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    达叔小生
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://huangguangda.github.io/2018/05/02/1/" title="JAVA语言-985大学">https://huangguangda.github.io/2018/05/02/1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/我的书籍/" rel="tag"><i class="fa fa-tag"></i> 我的书籍</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/01/1/" rel="next" title="Android应用基础知识">
                <i class="fa fa-chevron-left"></i> Android应用基础知识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/03/1/" rel="prev" title="Android工程师初级知识点">
                Android工程师初级知识点 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNTU5OC8xMjEzNA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="达叔小生">
            
              <p class="site-author-name" itemprop="name">达叔小生</p>
              <p class="site-description motion-element" itemprop="description"></p>

            <div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("04/23/1997 00:00:00");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">89</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
                <a title="收藏到书签，偶尔High一下^_^" rel="alternate" class="mw-harlem_shake_slow wobble shake" href="javascript:(function() {
    function c() {
        var e = document.createElement(&quot;link&quot;);
        e.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
        e.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;);
        e.setAttribute(&quot;href&quot;, f);
        e.setAttribute(&quot;class&quot;, l);
        document.body.appendChild(e)
    }
 
    function h() {
        var e = document.getElementsByClassName(l);
        for (var t = 0; t < e.length; t++) {
            document.body.removeChild(e[t])
        }
    }
 
    function p() {
        var e = document.createElement(&quot;div&quot;);
        e.setAttribute(&quot;class&quot;, a);
        document.body.appendChild(e);
        setTimeout(function() {
            document.body.removeChild(e)
        }, 100)
    }
 
    function d(e) {
        return {
            height : e.offsetHeight,
            width : e.offsetWidth
        }
    }
 
    function v(i) {
        var s = d(i);
        return s.height > e && s.height < n && s.width > t && s.width < r
    }
 
    function m(e) {
        var t = e;
        var n = 0;
        while (!!t) {
            n += t.offsetTop;
            t = t.offsetParent
        }
        return n
    }
 
    function g() {
        var e = document.documentElement;
        if (!!window.innerWidth) {
            return window.innerHeight
        } else if (e && !isNaN(e.clientHeight)) {
            return e.clientHeight
        }
        return 0
    }
 
    function y() {
        if (window.pageYOffset) {
            return window.pageYOffset
        }
        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
    }
 
    function E(e) {
        var t = m(e);
        return t >= w && t <= b + w
    }
 
    function S() {
        var e = document.createElement(&quot;audio&quot;);
        e.setAttribute(&quot;class&quot;, l);
        e.src = i;
        e.loop = false;
        e.addEventListener(&quot;canplay&quot;, function() {
            setTimeout(function() {
                x(k)
            }, 500);
            setTimeout(function() {
                N();
                p();
                for (var e = 0; e < O.length; e++) {
                    T(O[e])
                }
            }, 15500)
        }, true);
        e.addEventListener(&quot;ended&quot;, function() {
            N();
            h()
        }, true);
        e.innerHTML = &quot; <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>&quot;;
        document.body.appendChild(e);
        e.play()
    }
 
    function x(e) {
        e.className += &quot; &quot; + s + &quot; &quot; + o
    }
 
    function T(e) {
        e.className += &quot; &quot; + s + &quot; &quot; + u[Math.floor(Math.random() * u.length)]
    }
 
    function N() {
        var e = document.getElementsByClassName(s);
        var t = new RegExp(&quot;\\b&quot; + s + &quot;\\b&quot;);
        for (var n = 0; n < e.length; ) {
            e[n].className = e[n].className.replace(t, &quot;&quot;)
        }
    }
 
    var e = 30;
    var t = 30;
    var n = 350;
    var r = 350;
    var i = &quot;//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3&quot;;
    var s = &quot;mw-harlem_shake_me&quot;;
    var o = &quot;im_first&quot;;
    var u = [&quot;im_drunk&quot;, &quot;im_baked&quot;, &quot;im_trippin&quot;, &quot;im_blown&quot;];
    var a = &quot;mw-strobe_light&quot;;
    var f = &quot;//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css&quot;;
    var l = &quot;mw_added_css&quot;;
    var b = g();
    var w = y();
    var C = document.getElementsByTagName(&quot;*&quot;);
    var k = null;
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            if (E(A)) {
                k = A;
                break
            }
        }
    }
    if (A === null) {
        console.warn(&quot;Could not find a node of the right size. Please try a different page.&quot;);
        return
    }
    c();
    S();
    var O = [];
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            O.push(A)
        }
    }
})()"><i class="fa fa-music"></i> High</a>

            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/huangguangda" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:2397923107@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/c785ece603d1" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-android"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_36232611" target="_blank" title="csdn">
                      
                        <i class="fa fa-fw fa-spinner"></i>csdn</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/186539024/" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-bath"></i>豆瓣</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/da-shu-xiao-sheng/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/5a16e1f3f265da43128096cb" target="_blank" title="掘金">
                      
                        <i class="fa fa-fw fa-google"></i>掘金</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/5507262458/profile?topnav=1&wvr=6" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzI1NTcxOTQ1Nw==&scene=124#wechat_redirect" target="_blank" title="历史">
                      
                        <i class="fa fa-fw fa-apple"></i>历史</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://www.cnblogs.com/dashucoding/" target="_blank" title="博客园">
                      
                        <i class="fa fa-fw fa-facebook"></i>博客园</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://gdone.gitee.io/englishpages/index.html" target="_blank" title="英文简历">
                      
                        <i class="fa fa-fw fa-globe"></i>英文简历</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://gdone.gitee.io/pages/" target="_blank" title="中文简历">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>中文简历</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://gitee.com/GDone/events" target="_blank" title="码云">
                      
                        <i class="fa fa-fw fa-twitter"></i>码云</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://my.oschina.net/xiaomaomi1997/" target="_blank" title="开源中国">
                      
                        <i class="fa fa-fw fa-facebook"></i>开源中国</a>
                  </span>
                
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons">
              </a>
            </div>
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa fa-fw fa-globe"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank">Web前端导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.36zhen.com/t?id=3448" title="前端书籍资料" target="_blank">前端书籍资料</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://ife.baidu.com/" title="百度前端技术学院" target="_blank">百度前端技术学院</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wf.uisdc.com/cn/" title="google前端开发基础" target="_blank">google前端开发基础</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.geekbang.org/" title="极客邦科技" target="_blank">极客邦科技</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://ilxdh.com/" title="龙轩导航" target="_blank">龙轩导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://code.giffox.com/" title="程序员导航" target="_blank">程序员导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://search.chongbuluo.com/" title="快搜" target="_blank">快搜</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.android-doc.com/training/index.html" title="Android中文API" target="_blank">Android中文API</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://developer.android.google.cn/" title="Android Developers" target="_blank">Android Developers</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.freecodecamp.cn/" title="FreeCodeCamp中文社区" target="_blank">FreeCodeCamp中文社区</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://docs.oracle.com/javase/specs/" title="Java SE规范" target="_blank">Java SE规范</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://liuwangshu.cn/" title="刘望舒" target="_blank">刘望舒</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.colabug.com/author/3159ee71c93b3b4a/" title="小楼昨夜又秋风" target="_blank">小楼昨夜又秋风</a>
                  </li>
                
              </ul>

            </div>
          


        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java学习课程——基础篇"><span class="nav-number">1.</span> <span class="nav-text">Java学习课程——基础篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一篇-Java-入门导论"><span class="nav-number">2.</span> <span class="nav-text">第一篇  Java 入门导论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本篇包括："><span class="nav-number">3.</span> <span class="nav-text">本篇包括：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二篇-面向对象程序设计（一）"><span class="nav-number">4.</span> <span class="nav-text">第二篇  面向对象程序设计（一）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本篇包括：-1"><span class="nav-number">5.</span> <span class="nav-text">本篇包括：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三篇-Java语言基础"><span class="nav-number">6.</span> <span class="nav-text">第三篇  Java语言基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本篇包括：-2"><span class="nav-number">7.</span> <span class="nav-text">本篇包括：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四篇-面向对象程序设计（二）"><span class="nav-number">8.</span> <span class="nav-text">第四篇  面向对象程序设计（二）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本篇包括：-3"><span class="nav-number">9.</span> <span class="nav-text">本篇包括：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五篇-Java图形用户界面程序"><span class="nav-number">10.</span> <span class="nav-text">第五篇  Java图形用户界面程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本篇包括：-4"><span class="nav-number">11.</span> <span class="nav-text">本篇包括：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学习建议："><span class="nav-number">12.</span> <span class="nav-text">学习建议：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一篇-Java入门导论"><span class="nav-number">13.</span> <span class="nav-text">第一篇  Java入门导论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第1章-Java-概说"><span class="nav-number">14.</span> <span class="nav-text">第1章  Java 概说</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java与Internet"><span class="nav-number">15.</span> <span class="nav-text">Java与Internet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java平台"><span class="nav-number">16.</span> <span class="nav-text">Java平台</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java平台的版本"><span class="nav-number">17.</span> <span class="nav-text">Java平台的版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java平台运作原理"><span class="nav-number">18.</span> <span class="nav-text">Java平台运作原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java语言"><span class="nav-number">19.</span> <span class="nav-text">Java语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java语言的特性"><span class="nav-number">20.</span> <span class="nav-text">Java语言的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-与C-C-的差异"><span class="nav-number">21.</span> <span class="nav-text">Java 与C/C++的差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-与C-C-的差异-1"><span class="nav-number">22.</span> <span class="nav-text">Java 与C/C++的差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-程序的种类"><span class="nav-number">23.</span> <span class="nav-text">Java 程序的种类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applet"><span class="nav-number">24.</span> <span class="nav-text">Applet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Application"><span class="nav-number">25.</span> <span class="nav-text">Application</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Servlets"><span class="nav-number">26.</span> <span class="nav-text">Servlets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一讲-JAVA语言概述"><span class="nav-number">27.</span> <span class="nav-text">第一讲 JAVA语言概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本讲要点"><span class="nav-number">28.</span> <span class="nav-text">本讲要点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#课程介绍"><span class="nav-number">29.</span> <span class="nav-text">课程介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java语言概述"><span class="nav-number">30.</span> <span class="nav-text">Java语言概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Java-？"><span class="nav-number">31.</span> <span class="nav-text">什么是Java ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学习目标"><span class="nav-number">32.</span> <span class="nav-text">学习目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最终目标：Java软件工程师"><span class="nav-number">33.</span> <span class="nav-text">最终目标：Java软件工程师</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#近期目标"><span class="nav-number">34.</span> <span class="nav-text">近期目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本学期目标"><span class="nav-number">35.</span> <span class="nav-text">本学期目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学习方法指导"><span class="nav-number">36.</span> <span class="nav-text">学习方法指导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#奠定Java语法基础"><span class="nav-number">37.</span> <span class="nav-text">奠定Java语法基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意思考和总结"><span class="nav-number">38.</span> <span class="nav-text">注意思考和总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动手写代码"><span class="nav-number">39.</span> <span class="nav-text">动手写代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#培养自学能力"><span class="nav-number">40.</span> <span class="nav-text">培养自学能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#学习资料推荐"><span class="nav-number">41.</span> <span class="nav-text">学习资料推荐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考书"><span class="nav-number">42.</span> <span class="nav-text">参考书</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络学习资源"><span class="nav-number">43.</span> <span class="nav-text">网络学习资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA语言的特点"><span class="nav-number">44.</span> <span class="nav-text">JAVA语言的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单、面向对象、与平台无关……"><span class="nav-number">45.</span> <span class="nav-text">简单、面向对象、与平台无关……</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java与C及C-的比较"><span class="nav-number">46.</span> <span class="nav-text">Java与C及C++的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java语言程序分类"><span class="nav-number">47.</span> <span class="nav-text">Java语言程序分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java程序开发过程"><span class="nav-number">48.</span> <span class="nav-text">Java程序开发过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发程序前，进行开发环境配置"><span class="nav-number">49.</span> <span class="nav-text">开发程序前，进行开发环境配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发步骤"><span class="nav-number">50.</span> <span class="nav-text">开发步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下载安装JDK5-0-可以下载最新版"><span class="nav-number">51.</span> <span class="nav-text">下载安装JDK5.0(可以下载最新版)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK环境下程序编译与运行"><span class="nav-number">52.</span> <span class="nav-text">JDK环境下程序编译与运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写Java应用程序源文件"><span class="nav-number">53.</span> <span class="nav-text">编写Java应用程序源文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#准备编译和运行程序（环境配置）"><span class="nav-number">54.</span> <span class="nav-text">准备编译和运行程序（环境配置）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译成字节码文件"><span class="nav-number">55.</span> <span class="nav-text">编译成字节码文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行程序"><span class="nav-number">56.</span> <span class="nav-text">执行程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applet程序的运行"><span class="nav-number">57.</span> <span class="nav-text">Applet程序的运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用集成开发环境开发Java程序"><span class="nav-number">58.</span> <span class="nav-text">使用集成开发环境开发Java程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集成开发工具简介"><span class="nav-number">59.</span> <span class="nav-text">集成开发工具简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Jcreater编写Java应用程序"><span class="nav-number">60.</span> <span class="nav-text">使用Jcreater编写Java应用程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java虚拟机"><span class="nav-number">61.</span> <span class="nav-text">Java虚拟机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-Java-Virtual-Machine"><span class="nav-number">62.</span> <span class="nav-text">JVM(Java Virtual Machine)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">63.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#技能训练一-Java入门"><span class="nav-number">64.</span> <span class="nav-text">技能训练一 Java入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目的"><span class="nav-number">65.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#训练内容"><span class="nav-number">66.</span> <span class="nav-text">训练内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#技能训练二-熟悉Java语言开发过程"><span class="nav-number">67.</span> <span class="nav-text">技能训练二 熟悉Java语言开发过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目的-1"><span class="nav-number">68.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#训练内容-1"><span class="nav-number">69.</span> <span class="nav-text">训练内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA-程序设计"><span class="nav-number">70.</span> <span class="nav-text">JAVA  程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第1讲-基本要求"><span class="nav-number">71.</span> <span class="nav-text">第1讲    基本要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验一-JDK开发工具"><span class="nav-number">72.</span> <span class="nav-text">实验一  JDK开发工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第1章-Java语言概述"><span class="nav-number">73.</span> <span class="nav-text">第1章  Java语言概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Java的发展历史"><span class="nav-number">74.</span> <span class="nav-text">1.1  Java的发展历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的现状"><span class="nav-number">75.</span> <span class="nav-text">Java的现状</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按照Java的应用领域"><span class="nav-number">76.</span> <span class="nav-text">按照Java的应用领域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-的-特-点"><span class="nav-number">77.</span> <span class="nav-text">Java 的 特 点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构中立"><span class="nav-number">78.</span> <span class="nav-text">结构中立</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-number">79.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简单"><span class="nav-number">80.</span> <span class="nav-text">简单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式"><span class="nav-number">81.</span> <span class="nav-text">分布式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#健壮"><span class="nav-number">82.</span> <span class="nav-text">健壮</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安全"><span class="nav-number">83.</span> <span class="nav-text">安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">84.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java程序的开发过程与运行环境"><span class="nav-number">85.</span> <span class="nav-text">Java程序的开发过程与运行环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java程序的开发过程"><span class="nav-number">86.</span> <span class="nav-text">Java程序的开发过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Application与Applet"><span class="nav-number">87.</span> <span class="nav-text">Application与Applet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK的安装与使用"><span class="nav-number">88.</span> <span class="nav-text">JDK的安装与使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK的使用"><span class="nav-number">89.</span> <span class="nav-text">JDK的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一步：编辑源程序。"><span class="nav-number">89.1.</span> <span class="nav-text">第一步：编辑源程序。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二步：编译源程序。"><span class="nav-number">89.2.</span> <span class="nav-text">第二步：编译源程序。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三步：运行程序。在DOS命令提示符下执行-注意大小写"><span class="nav-number">89.3.</span> <span class="nav-text">第三步：运行程序。在DOS命令提示符下执行(注意大小写)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用JDK编译运行Java"><span class="nav-number">90.</span> <span class="nav-text">用JDK编译运行Java</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Visual-J-6-0的使用"><span class="nav-number">90.1.</span> <span class="nav-text">Visual J++ 6.0的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实训一-安装与熟悉Java开发工具"><span class="nav-number">91.</span> <span class="nav-text">实训一  安装与熟悉Java开发工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写并运行一个Java-Application程序"><span class="nav-number">92.</span> <span class="nav-text">编写并运行一个Java Application程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写并编译一个Java-Applet程序。"><span class="nav-number">93.</span> <span class="nav-text">编写并编译一个Java Applet程序。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写配合Applet的HTML文件。"><span class="nav-number">94.</span> <span class="nav-text">编写配合Applet的HTML文件。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用JDK帮助文档。"><span class="nav-number">95.</span> <span class="nav-text">使用JDK帮助文档。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写并调试一个Java-Applet程序"><span class="nav-number">96.</span> <span class="nav-text">编写并调试一个Java Applet程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Visual-J-的调试功能。"><span class="nav-number">96.1.</span> <span class="nav-text">使用Visual J++的调试功能。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#习-题-一"><span class="nav-number">97.</span> <span class="nav-text">习  题  一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1．编译型语言与解释型语言是如何划分的"><span class="nav-number">98.</span> <span class="nav-text">1．编译型语言与解释型语言是如何划分的?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#百度来源答案："><span class="nav-number">98.1.</span> <span class="nav-text">百度来源答案：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译型语言："><span class="nav-number">98.2.</span> <span class="nav-text">编译型语言：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解释型语言："><span class="nav-number">98.3.</span> <span class="nav-text">解释型语言：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java属于哪种类型语言"><span class="nav-number">99.</span> <span class="nav-text">Java属于哪种类型语言?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java程序的编译和解释有何特点"><span class="nav-number">100.</span> <span class="nav-text">Java程序的编译和解释有何特点?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#这些特点对于Java成为Internet上的编程语言有什么影响"><span class="nav-number">101.</span> <span class="nav-text">这些特点对于Java成为Internet上的编程语言有什么影响?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2．JDK的编译命令是什么"><span class="nav-number">102.</span> <span class="nav-text">2．JDK的编译命令是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果编译结果报告说找不到要编译的源代码，通常会是哪些错误"><span class="nav-number">103.</span> <span class="nav-text">如果编译结果报告说找不到要编译的源代码，通常会是哪些错误?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3．运行编译好的字节码文件使用什么命令-什么是JIT-什么是JVM"><span class="nav-number">104.</span> <span class="nav-text">3．运行编译好的字节码文件使用什么命令? 什么是JIT? 什么是JVM?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是JIT"><span class="nav-number">104.1.</span> <span class="nav-text">什么是JIT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本数据类型"><span class="nav-number">104.2.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是："><span class="nav-number">104.3.</span> <span class="nav-text">JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM执行程序的过程-："><span class="nav-number">104.4.</span> <span class="nav-text">JVM执行程序的过程 ：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4．Java程序分为哪两大类？它们之间有哪些差别"><span class="nav-number">105.</span> <span class="nav-text">4．Java程序分为哪两大类？它们之间有哪些差别?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在JAVA领域有三个“let”："><span class="nav-number">105.1.</span> <span class="nav-text">在JAVA领域有三个“let”：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5．Java程序中有哪几种注释方式？"><span class="nav-number">106.</span> <span class="nav-text">5．Java程序中有哪几种注释方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6．分别编写Applet和Application，在屏幕上生成如下图案："><span class="nav-number">107.</span> <span class="nav-text">6．分别编写Applet和Application，在屏幕上生成如下图案：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-结构化程序设计"><span class="nav-number">108.</span> <span class="nav-text">第二章     结构化程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—Java开发环境的建立"><span class="nav-number">109.</span> <span class="nav-text">回顾—Java开发环境的建立</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—Java程序设计步骤"><span class="nav-number">110.</span> <span class="nav-text">回顾—Java程序设计步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—Java应用程序"><span class="nav-number">111.</span> <span class="nav-text">回顾—Java应用程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#教学目标"><span class="nav-number">112.</span> <span class="nav-text">教学目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#掌握Java中基本数据类型"><span class="nav-number">112.1.</span> <span class="nav-text">掌握Java中基本数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#教学重难点"><span class="nav-number">113.</span> <span class="nav-text">教学重难点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的标示符和关键字"><span class="nav-number">114.</span> <span class="nav-text">Java的标示符和关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标识符可以用来标识变量名、类名、类中的方法名和文件名等"><span class="nav-number">114.1.</span> <span class="nav-text">标识符可以用来标识变量名、类名、类中的方法名和文件名等.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具有特殊含义的字符序列"><span class="nav-number">114.2.</span> <span class="nav-text">具有特殊含义的字符序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的关键字"><span class="nav-number">115.</span> <span class="nav-text">Java的关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的数据类型"><span class="nav-number">116.</span> <span class="nav-text">Java的数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">117.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java变量必须属于某种类型"><span class="nav-number">118.</span> <span class="nav-text">Java变量必须属于某种类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java变量"><span class="nav-number">119.</span> <span class="nav-text">Java变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java直接量（常量）"><span class="nav-number">120.</span> <span class="nav-text">Java直接量（常量）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java转义字符"><span class="nav-number">121.</span> <span class="nav-text">Java转义字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java运算符"><span class="nav-number">122.</span> <span class="nav-text">Java运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算术运算符"><span class="nav-number">123.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系运算符"><span class="nav-number">124.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑运算符"><span class="nav-number">125.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#短路规则-amp-amp-和"><span class="nav-number">126.</span> <span class="nav-text">短路规则 ( &amp;&amp;和|| )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑运算-amp-和"><span class="nav-number">127.</span> <span class="nav-text">逻辑运算( &amp;和| )</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件运算符"><span class="nav-number">128.</span> <span class="nav-text">条件运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制结构"><span class="nav-number">129.</span> <span class="nav-text">控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if-else语句"><span class="nav-number">129.1.</span> <span class="nav-text">if-else语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for循环语句"><span class="nav-number">129.2.</span> <span class="nav-text">for循环语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while循环语句"><span class="nav-number">129.3.</span> <span class="nav-text">while循环语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构化程序设计"><span class="nav-number">130.</span> <span class="nav-text">结构化程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java语言基础"><span class="nav-number">131.</span> <span class="nav-text">Java语言基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个简单的例子"><span class="nav-number">132.</span> <span class="nav-text">一个简单的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标-识-符"><span class="nav-number">133.</span> <span class="nav-text">标  识  符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标识符构成规则"><span class="nav-number">133.1.</span> <span class="nav-text">标识符构成规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字"><span class="nav-number">134.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数-据-类-型"><span class="nav-number">135.</span> <span class="nav-text">数 据 类 型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整型"><span class="nav-number">136.</span> <span class="nav-text">整型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java语言中的常量分为两种："><span class="nav-number">136.1.</span> <span class="nav-text">Java语言中的常量分为两种：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实型"><span class="nav-number">137.</span> <span class="nav-text">实型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符型"><span class="nav-number">138.</span> <span class="nav-text">字符型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔型"><span class="nav-number">139.</span> <span class="nav-text">布尔型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符与表达式"><span class="nav-number">140.</span> <span class="nav-text">运算符与表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算术运算符-1"><span class="nav-number">141.</span> <span class="nav-text">算术运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#其他需要注意的几点与C语言相同："><span class="nav-number">141.1.</span> <span class="nav-text">其他需要注意的几点与C语言相同：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赋值运算符"><span class="nav-number">142.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系运算符-1"><span class="nav-number">143.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑运算符-1"><span class="nav-number">144.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">145.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换有两种方法："><span class="nav-number">145.1.</span> <span class="nav-text">类型转换有两种方法：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程控制语句"><span class="nav-number">146.</span> <span class="nav-text">流程控制语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分支语句"><span class="nav-number">147.</span> <span class="nav-text">分支语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件语句if-else"><span class="nav-number">148.</span> <span class="nav-text">条件语句if-else</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多分支语句switch"><span class="nav-number">149.</span> <span class="nav-text">多分支语句switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环语句"><span class="nav-number">150.</span> <span class="nav-text">循环语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-while语句"><span class="nav-number">151.</span> <span class="nav-text">do-while语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for语句"><span class="nav-number">152.</span> <span class="nav-text">for语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构化程序设计-1"><span class="nav-number">153.</span> <span class="nav-text">结构化程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA语言基本语法"><span class="nav-number">154.</span> <span class="nav-text">JAVA语言基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#温故"><span class="nav-number">154.1.</span> <span class="nav-text">温故</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java程序开发过程-1"><span class="nav-number">154.2.</span> <span class="nav-text">Java程序开发过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#环境变量的设置（path、classpath）"><span class="nav-number">154.3.</span> <span class="nav-text">环境变量的设置（path、classpath）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java程序的种类"><span class="nav-number">154.4.</span> <span class="nav-text">Java程序的种类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#要点"><span class="nav-number">155.</span> <span class="nav-text">要点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jcreater-pro"><span class="nav-number">156.</span> <span class="nav-text">Jcreater pro</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applet小程序的开发过程"><span class="nav-number">157.</span> <span class="nav-text">Applet小程序的开发过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的Applet小程序"><span class="nav-number">158.</span> <span class="nav-text">Java的Applet小程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标识符"><span class="nav-number">159.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标识符-1"><span class="nav-number">160.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字、标识符的命名习惯"><span class="nav-number">161.</span> <span class="nav-text">关键字、标识符的命名习惯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字全部小写"><span class="nav-number">162.</span> <span class="nav-text">关键字全部小写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标识符命名习惯"><span class="nav-number">163.</span> <span class="nav-text">标识符命名习惯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java语言的数据类型"><span class="nav-number">164.</span> <span class="nav-text">Java语言的数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型—常量数据及变量声明"><span class="nav-number">165.</span> <span class="nav-text">数据类型—常量数据及变量声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据类型的转换"><span class="nav-number">166.</span> <span class="nav-text">基本数据类型的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动类型转换，表达式类型的自动提升"><span class="nav-number">167.</span> <span class="nav-text">自动类型转换，表达式类型的自动提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强制类型转换"><span class="nav-number">168.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSP技术"><span class="nav-number">169.</span> <span class="nav-text">JSP技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基本数据类型"><span class="nav-number">170.</span> <span class="nav-text">Java基本数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象程序设计"><span class="nav-number">171.</span> <span class="nav-text">面向对象程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#了解类和对象的基本概念"><span class="nav-number">171.1.</span> <span class="nav-text">了解类和对象的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明定义"><span class="nav-number">171.2.</span> <span class="nav-text">声明定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类类型的声明"><span class="nav-number">172.</span> <span class="nav-text">类类型的声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义对象方法"><span class="nav-number">173.</span> <span class="nav-text">定义对象方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—类的定义"><span class="nav-number">174.</span> <span class="nav-text">回顾—类的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—类的成员函数定义语法规范"><span class="nav-number">175.</span> <span class="nav-text">回顾—类的成员函数定义语法规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—对象的初始化"><span class="nav-number">176.</span> <span class="nav-text">回顾—对象的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#教学内容和目标"><span class="nav-number">177.</span> <span class="nav-text">教学内容和目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#教学重难点-1"><span class="nav-number">178.</span> <span class="nav-text">教学重难点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包"><span class="nav-number">179.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建包"><span class="nav-number">180.</span> <span class="nav-text">创建包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问包中的类"><span class="nav-number">181.</span> <span class="nav-text">访问包中的类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管理Java的包"><span class="nav-number">182.</span> <span class="nav-text">管理Java的包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Java的包"><span class="nav-number">183.</span> <span class="nav-text">使用Java的包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CLASSPATH参数"><span class="nav-number">184.</span> <span class="nav-text">CLASSPATH参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">185.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装性"><span class="nav-number">186.</span> <span class="nav-text">封装性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问控制级别"><span class="nav-number">187.</span> <span class="nav-text">访问控制级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类成员封装性总结"><span class="nav-number">188.</span> <span class="nav-text">类成员封装性总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">189.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的特点"><span class="nav-number">190.</span> <span class="nav-text">继承的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承性的特点"><span class="nav-number">191.</span> <span class="nav-text">类的继承性的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数的继承特点"><span class="nav-number">192.</span> <span class="nav-text">构造函数的继承特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象"><span class="nav-number">193.</span> <span class="nav-text">类与对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象的基本思想和基本概念"><span class="nav-number">194.</span> <span class="nav-text">面向对象的基本思想和基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象的基本思想"><span class="nav-number">195.</span> <span class="nav-text">面向对象的基本思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象与类"><span class="nav-number">196.</span> <span class="nav-text">对象与类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承性"><span class="nav-number">197.</span> <span class="nav-text">继承性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态性"><span class="nav-number">198.</span> <span class="nav-text">多态性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装-1"><span class="nav-number">199.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的声明与对象的创建"><span class="nav-number">200.</span> <span class="nav-text">类的声明与对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量成员的定义"><span class="nav-number">201.</span> <span class="nav-text">变量成员的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法成员的定义"><span class="nav-number">202.</span> <span class="nav-text">方法成员的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参数传递的方法。"><span class="nav-number">202.1.</span> <span class="nav-text">参数传递的方法。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-number">203.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法"><span class="nav-number">204.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象初始化"><span class="nav-number">205.</span> <span class="nav-text">对象初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的初始化。"><span class="nav-number">206.</span> <span class="nav-text">对象的初始化。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的清除"><span class="nav-number">207.</span> <span class="nav-text">对象的清除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的使用"><span class="nav-number">208.</span> <span class="nav-text">对象的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态成员"><span class="nav-number">209.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态变量成员"><span class="nav-number">210.</span> <span class="nav-text">静态变量成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象计数器。"><span class="nav-number">210.1.</span> <span class="nav-text">对象计数器。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态变量的使用。"><span class="nav-number">211.</span> <span class="nav-text">静态变量的使用。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态方法成员"><span class="nav-number">212.</span> <span class="nav-text">静态方法成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类内方法的重载"><span class="nav-number">213.</span> <span class="nav-text">类内方法的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">214.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取字符串的信息"><span class="nav-number">215.</span> <span class="nav-text">获取字符串的信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串与其他类型数据的转换"><span class="nav-number">216.</span> <span class="nav-text">字符串与其他类型数据的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String类的使用。"><span class="nav-number">217.</span> <span class="nav-text">String类的使用。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuffer类"><span class="nav-number">218.</span> <span class="nav-text">StringBuffer类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuffer类的主要方法有："><span class="nav-number">219.</span> <span class="nav-text">StringBuffer类的主要方法有：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">220.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一维数组定义"><span class="nav-number">220.1.</span> <span class="nav-text">一维数组定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的使用。"><span class="nav-number">221.</span> <span class="nav-text">数组的使用。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的初始化"><span class="nav-number">222.</span> <span class="nav-text">数组的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组举例"><span class="nav-number">222.1.</span> <span class="nav-text">数组举例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡法排序。"><span class="nav-number">223.</span> <span class="nav-text">冒泡法排序。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多维数组"><span class="nav-number">224.</span> <span class="nav-text">多维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继-承"><span class="nav-number">225.</span> <span class="nav-text">继    承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">226.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子类对象的构造"><span class="nav-number">227.</span> <span class="nav-text">子类对象的构造</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final方法与final类"><span class="nav-number">228.</span> <span class="nav-text">final方法与final类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类与抽象方法"><span class="nav-number">229.</span> <span class="nav-text">抽象类与抽象方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">230.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的实现"><span class="nav-number">231.</span> <span class="nav-text">接口的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的派生"><span class="nav-number">232.</span> <span class="nav-text">接口的派生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#程序举例"><span class="nav-number">233.</span> <span class="nav-text">程序举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包-的-使-用"><span class="nav-number">234.</span> <span class="nav-text">包 的 使 用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的访问权限"><span class="nav-number">235.</span> <span class="nav-text">类的访问权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包的定义"><span class="nav-number">236.</span> <span class="nav-text">包的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实训三-面向对象程序设计"><span class="nav-number">237.</span> <span class="nav-text">实训三  面向对象程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#习-题-三"><span class="nav-number">238.</span> <span class="nav-text">习  题  三</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的定义和对象使用"><span class="nav-number">239.</span> <span class="nav-text">类的定义和对象使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象编程的基本概念"><span class="nav-number">239.1.</span> <span class="nav-text">面向对象编程的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法-1"><span class="nav-number">239.2.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程的基本概念-1"><span class="nav-number">240.</span> <span class="nav-text">面向对象编程的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承"><span class="nav-number">241.</span> <span class="nav-text">类的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的声明"><span class="nav-number">242.</span> <span class="nav-text">类的声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的定义"><span class="nav-number">243.</span> <span class="nav-text">类的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员变量与局部变量"><span class="nav-number">244.</span> <span class="nav-text">成员变量与局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员方法"><span class="nav-number">245.</span> <span class="nav-text">成员方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的定义–例1"><span class="nav-number">246.</span> <span class="nav-text">类的定义–例1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的定义–例2梯形"><span class="nav-number">247.</span> <span class="nav-text">类的定义–例2梯形</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建和使用对象"><span class="nav-number">248.</span> <span class="nav-text">创建和使用对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用对象—例3"><span class="nav-number">248.1.</span> <span class="nav-text">使用对象—例3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用对象—例4"><span class="nav-number">248.2.</span> <span class="nav-text">使用对象—例4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用对象—例5-梯形"><span class="nav-number">248.3.</span> <span class="nav-text">使用对象—例5 梯形</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的内存模型"><span class="nav-number">249.</span> <span class="nav-text">对象的内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法-2"><span class="nav-number">250.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法的说明"><span class="nav-number">251.</span> <span class="nav-text">构造方法的说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法的重载"><span class="nav-number">252.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象-1"><span class="nav-number">253.</span> <span class="nav-text">类与对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法的重载-1"><span class="nav-number">254.</span> <span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造方法的重载"><span class="nav-number">255.</span> <span class="nav-text">构造方法的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象变量的赋值"><span class="nav-number">256.</span> <span class="nav-text">对象变量的赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static关键字"><span class="nav-number">257.</span> <span class="nav-text">static关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类变量-类方法、实例变量-实例方法"><span class="nav-number">258.</span> <span class="nav-text">类变量/类方法、实例变量/实例方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存模型分析"><span class="nav-number">259.</span> <span class="nav-text">内存模型分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static应用注意事项"><span class="nav-number">260.</span> <span class="nav-text">static应用注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this关键字"><span class="nav-number">261.</span> <span class="nav-text">this关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包的概念"><span class="nav-number">262.</span> <span class="nav-text">包的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#package-语句"><span class="nav-number">263.</span> <span class="nav-text">package 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象-2"><span class="nav-number">264.</span> <span class="nav-text">类与对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问权限"><span class="nav-number">265.</span> <span class="nav-text">访问权限</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#private变量和方法"><span class="nav-number">265.1.</span> <span class="nav-text">private变量和方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#public变量和方法"><span class="nav-number">266.</span> <span class="nav-text">public变量和方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#友好变量和方法"><span class="nav-number">267.</span> <span class="nav-text">友好变量和方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#protected变量和方法"><span class="nav-number">268.</span> <span class="nav-text">protected变量和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法的访问控制"><span class="nav-number">268.1.</span> <span class="nav-text">方法的访问控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public类和友好类"><span class="nav-number">268.2.</span> <span class="nav-text">public类和友好类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承-1"><span class="nav-number">269.</span> <span class="nav-text">类的继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承性"><span class="nav-number">270.</span> <span class="nav-text">类的继承性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成员变量的隐藏和方法的重写"><span class="nav-number">271.</span> <span class="nav-text">成员变量的隐藏和方法的重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super变量"><span class="nav-number">272.</span> <span class="nav-text">super变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final类和final成员"><span class="nav-number">273.</span> <span class="nav-text">final类和final成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的上转型对象"><span class="nav-number">274.</span> <span class="nav-text">对象的上转型对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上转型对象操作说明"><span class="nav-number">275.</span> <span class="nav-text">上转型对象操作说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态性-1"><span class="nav-number">276.</span> <span class="nav-text">多态性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类的继承-2"><span class="nav-number">276.1.</span> <span class="nav-text">类的继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象类与抽象方法-1"><span class="nav-number">277.</span> <span class="nav-text">抽象类与抽象方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态性-2"><span class="nav-number">278.</span> <span class="nav-text">多态性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抽象方法与抽象类"><span class="nav-number">279.</span> <span class="nav-text">抽象方法与抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结-1"><span class="nav-number">280.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口及应用"><span class="nav-number">281.</span> <span class="nav-text">接口及应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的概念"><span class="nav-number">282.</span> <span class="nav-text">接口的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的声明-及注意事项"><span class="nav-number">283.</span> <span class="nav-text">接口的声明  及注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口声明实例"><span class="nav-number">284.</span> <span class="nav-text">接口声明实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口的实现与多继承"><span class="nav-number">285.</span> <span class="nav-text">接口的实现与多继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类实现接口时的注意事项"><span class="nav-number">286.</span> <span class="nav-text">类实现接口时的注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意："><span class="nav-number">286.1.</span> <span class="nav-text">注意：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结："><span class="nav-number">286.2.</span> <span class="nav-text">总结：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将小程序改为应用程序"><span class="nav-number">286.3.</span> <span class="nav-text">将小程序改为应用程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口应用实例—程序模块间的连接"><span class="nav-number">287.</span> <span class="nav-text">接口应用实例—程序模块间的连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间、日期和Math类"><span class="nav-number">288.</span> <span class="nav-text">时间、日期和Math类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date、SimpleDateFormat类"><span class="nav-number">289.</span> <span class="nav-text">Date、SimpleDateFormat类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Calendar类"><span class="nav-number">290.</span> <span class="nav-text">Calendar类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math类"><span class="nav-number">291.</span> <span class="nav-text">Math类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#猜数游戏"><span class="nav-number">291.1.</span> <span class="nav-text">猜数游戏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-的GUI概述"><span class="nav-number">292.</span> <span class="nav-text">Java 的GUI概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初识awt实例"><span class="nav-number">293.</span> <span class="nav-text">初识awt实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GUI组件分类"><span class="nav-number">294.</span> <span class="nav-text">GUI组件分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AWT-标准组件图示"><span class="nav-number">295.</span> <span class="nav-text">AWT 标准组件图示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本组件"><span class="nav-number">295.1.</span> <span class="nav-text">基本组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applet小程序编写及运行"><span class="nav-number">296.</span> <span class="nav-text">Applet小程序编写及运行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#身手"><span class="nav-number">296.1.</span> <span class="nav-text">身手</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Html标签"><span class="nav-number">297.</span> <span class="nav-text">Html标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组和字符串"><span class="nav-number">298.</span> <span class="nav-text">数组和字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—类的定义-1"><span class="nav-number">299.</span> <span class="nav-text">回顾—类的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—封装性"><span class="nav-number">300.</span> <span class="nav-text">回顾—封装性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—继承"><span class="nav-number">301.</span> <span class="nav-text">回顾—继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—类的多态性"><span class="nav-number">302.</span> <span class="nav-text">回顾—类的多态性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#掌握数组的定义和使用"><span class="nav-number">303.</span> <span class="nav-text">掌握数组的定义和使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中的数组"><span class="nav-number">304.</span> <span class="nav-text">Java中的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的定义"><span class="nav-number">305.</span> <span class="nav-text">数组的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配"><span class="nav-number">306.</span> <span class="nav-text">内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组初始化"><span class="nav-number">307.</span> <span class="nav-text">数组初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过初始化语句创建数组"><span class="nav-number">308.</span> <span class="nav-text">通过初始化语句创建数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的访问"><span class="nav-number">309.</span> <span class="nav-text">数组的访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多维数组-1"><span class="nav-number">310.</span> <span class="nav-text">多维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">310.1.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组与字符串"><span class="nav-number">311.</span> <span class="nav-text">数组与字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组-1"><span class="nav-number">312.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#声明数组"><span class="nav-number">313.</span> <span class="nav-text">声明数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建数组"><span class="nav-number">314.</span> <span class="nav-text">创建数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组元素的使用"><span class="nav-number">315.</span> <span class="nav-text">数组元素的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组初始化-1"><span class="nav-number">316.</span> <span class="nav-text">数组初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用数组注意事项"><span class="nav-number">317.</span> <span class="nav-text">使用数组注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串-1"><span class="nav-number">318.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串比较"><span class="nav-number">319.</span> <span class="nav-text">字符串比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串简介"><span class="nav-number">320.</span> <span class="nav-text">字符串简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串操作"><span class="nav-number">321.</span> <span class="nav-text">字符串操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串与数值转换"><span class="nav-number">322.</span> <span class="nav-text">字符串与数值转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象程序设计-1"><span class="nav-number">323.</span> <span class="nav-text">面向对象程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的成员函数定义语法规范"><span class="nav-number">324.</span> <span class="nav-text">类的成员函数定义语法规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回顾—对象的初始化-1"><span class="nav-number">325.</span> <span class="nav-text">回顾—对象的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包-1"><span class="nav-number">326.</span> <span class="nav-text">包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建包-1"><span class="nav-number">327.</span> <span class="nav-text">创建包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问包中的类-1"><span class="nav-number">328.</span> <span class="nav-text">访问包中的类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管理Java的包-1"><span class="nav-number">329.</span> <span class="nav-text">管理Java的包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Java的包-1"><span class="nav-number">330.</span> <span class="nav-text">使用Java的包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CLASSPATH参数-1"><span class="nav-number">331.</span> <span class="nav-text">CLASSPATH参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装-2"><span class="nav-number">332.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装性-1"><span class="nav-number">333.</span> <span class="nav-text">封装性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问控制级别-1"><span class="nav-number">334.</span> <span class="nav-text">访问控制级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类成员封装性总结-1"><span class="nav-number">335.</span> <span class="nav-text">类成员封装性总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承-1"><span class="nav-number">336.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承-2"><span class="nav-number">337.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的特点-1"><span class="nav-number">338.</span> <span class="nav-text">继承的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承性的特点-1"><span class="nav-number">339.</span> <span class="nav-text">类的继承性的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数的继承特点-1"><span class="nav-number">340.</span> <span class="nav-text">构造函数的继承特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象-3"><span class="nav-number">341.</span> <span class="nav-text">类与对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象的基本思想和基本概念-1"><span class="nav-number">342.</span> <span class="nav-text">面向对象的基本思想和基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象的基本思想-1"><span class="nav-number">343.</span> <span class="nav-text">面向对象的基本思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象与类-1"><span class="nav-number">344.</span> <span class="nav-text">对象与类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承性-1"><span class="nav-number">345.</span> <span class="nav-text">继承性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态性-3"><span class="nav-number">346.</span> <span class="nav-text">多态性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装-3"><span class="nav-number">347.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的声明与对象的创建-1"><span class="nav-number">348.</span> <span class="nav-text">类的声明与对象的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java的课程体系"><span class="nav-number">349.</span> <span class="nav-text">java的课程体系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Day01"><span class="nav-number">349.1.</span> <span class="nav-text">Day01</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java的产生与发展"><span class="nav-number">349.2.</span> <span class="nav-text">Java的产生与发展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java的产生与发展-1"><span class="nav-number">349.3.</span> <span class="nav-text">Java的产生与发展</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java语言的特性-1"><span class="nav-number">350.</span> <span class="nav-text">Java语言的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java是先编译后解释执行"><span class="nav-number">351.</span> <span class="nav-text">Java是先编译后解释执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM的作用："><span class="nav-number">352.</span> <span class="nav-text">JVM的作用：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的垃圾收集器"><span class="nav-number">353.</span> <span class="nav-text">Java的垃圾收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节码的作用"><span class="nav-number">354.</span> <span class="nav-text">字节码的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK的安装"><span class="nav-number">355.</span> <span class="nav-text">JDK的安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK的结构简介"><span class="nav-number">356.</span> <span class="nav-text">JDK的结构简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包的概念，含义和使用"><span class="nav-number">357.</span> <span class="nav-text">包的概念，含义和使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM搜索类的顺序与类加载"><span class="nav-number">358.</span> <span class="nav-text">JVM搜索类的顺序与类加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么使用包？"><span class="nav-number">359.</span> <span class="nav-text">为什么使用包？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-常用命令"><span class="nav-number">360.</span> <span class="nav-text">Java 常用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用命令"><span class="nav-number">361.</span> <span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分析程序文档结构和理解jdk的API文档"><span class="nav-number">361.1.</span> <span class="nav-text">分析程序文档结构和理解jdk的API文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中的特殊符号"><span class="nav-number">362.</span> <span class="nav-text">Java中的特殊符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java标识符"><span class="nav-number">363.</span> <span class="nav-text">Java标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java关键字"><span class="nav-number">364.</span> <span class="nav-text">Java关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java关键字-1"><span class="nav-number">365.</span> <span class="nav-text">Java关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的原始数据类型"><span class="nav-number">366.</span> <span class="nav-text">Java的原始数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#boolean类型"><span class="nav-number">366.1.</span> <span class="nav-text">boolean类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Integer-数据类型—byte-short-int-long"><span class="nav-number">367.</span> <span class="nav-text">Integer 数据类型—byte,short,int,long</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Integer-数据类型在内存的存储方式"><span class="nav-number">368.</span> <span class="nav-text">Integer 数据类型在内存的存储方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#char数据类型"><span class="nav-number">369.</span> <span class="nav-text">char数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String类型简介"><span class="nav-number">370.</span> <span class="nav-text">String类型简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浮点型数据类型"><span class="nav-number">371.</span> <span class="nav-text">浮点型数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Math类-1"><span class="nav-number">371.1.</span> <span class="nav-text">Math类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型之间的转换"><span class="nav-number">372.</span> <span class="nav-text">数据类型之间的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中的特殊类型——对象"><span class="nav-number">373.</span> <span class="nav-text">Java中的特殊类型——对象</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="heart">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">达叔小生</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">346.8k</span>
  
</div>






  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共346.8k字</span>
</div>

<div class="weixin-box">
  <div class="weixin-menu">
    <div class="weixin-hover">
      <div class="weixin-description">微信扫一扫，订阅本博客</div>
    </div>
  </div>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user">本站访客数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye">本站总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>





  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=65809965";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  



  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


  <script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>


   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>


  <!-- 代码块复制功能 -->
  <script type="text/javascript" src="/js/src/clipboard.min.js"></script>  
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hibiki"},"display":{"position":"right","width":75,"height":150},"mobile":{"show":false},"log":false});</script></body>
</html>