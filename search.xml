<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[腾讯智慧校园开发平台]]></title>
    <url>%2F2018%2F10%2F19%2F1%2F</url>
    <content type="text"><![CDATA[腾讯智慧校园开发平台 腾讯智慧校园开发平台优势: 智慧校园联合登录 身份角色同一 消息推送 智慧校园接入流程: 创建应用: 填写网站名称,简介和图标,官网地址等信息 开发应用: 提交审核: 审核通过上线: 第三方应用使用指引第三方应用？ 在“应用管理”-&gt; “本校应用”中看到。 在“应用管理”-&gt; “第三方应用”-&gt;“应用市场”中找到 安装后如何使用第三方应用？ 使用其PC管理功能，及移动端功能。 使用PC管理功能点击图标 -&gt; 进入应用PC管理页面 使用移动端功能(1) 独立应用可直接进入使用(2) 普通应用配置方法：登录学校后台 -&gt; 左侧菜单“应用管理” -&gt; 在“本校应用”或“第三方应用”下找到应用图标 -&gt; 点击图标右上角小齿轮 -&gt; 进入“应用基本信息”页 -&gt; 找到“移动端配置” 常见问题OpenAPI调用相关问题 请完整的阅读每篇文档，特别注意必传字段及字段格式和说明 使用开放平台后台”API测试工具” 对照文档中的代码Demo 反馈时提供信息 完整的请求url，包括get参数。 post的数据。 返回的code与msg。 sign签名所用的密钥key。 提供bug的发生时间，至少要以小时为单位（年-月-日-小时），当然越具体越容易查明问题。 重点 应用接入指引【重要】 开放API说明【重要】 使用哪种方式调用API？ ?–&gt; 1) 使用开发者方式2) 使用应用（openAppID）方式 开发流程1) 使用开发者方式1.1) 学校或上级单位自己开发：1.2) 以开发者身份，替学校/上级单位开发：调用方式为devCode+devType+keyId，其中keyId和密钥key需要找学校/上级单位创建者索要 【开发流程】获取devCode、devType、密钥key，用于生成后续的sign签名 开发者类型:学校/上级单位/合作伙伴/开发者，通过创建应用开发 调用API时，开发者信息、sign签名密钥获取方式：调用方式: openAppID开放平台后台==》应用管理==》查看详情==》AppID、AppSecret 签名生成的步骤第一步： 设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&amp;key2=value2…）拼接成字符串stringA。特别注意以下重要规则： 参数名按ASCII码从小到大排序（字典序）；如果参数的值为空不参与传参和签名；参数名区分大小写；get 和 post 参数均参与签名（注意：签名时不要对 get 和 post 的参数进行urlencode）；sign 参数不参与签名；根据HTTP协议要求，传递参数的值中如果存在特殊字符（如：&amp;、@等），那么该值需要做URL Encoding，这样请求接收方才能接收到正确的参数值。这种情况下，待签名数据应该是原始值而不是encoding之后的值。例如：调用某接口需要对请求参数email进行数字签名，那么待签名数据应该是email=test@msn.com，而不是email=test%40msn.com。 第二步 在stringA最后拼接上“&amp;key=AppSecret”得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值。 第三步： 拼接sign签名，得到最终请求字符串。 签名算法示例1234567891011&#123; &quot;openAppID&quot;:&quot;597882146416&quot;, &quot;objectid&quot;:1, &quot;objType&quot;:2, &quot;userid&quot;:1661, &quot;timestamp&quot;:1442401156, &quot;data&quot;:&#123; &quot;id&quot;: &quot;0&quot;, &quot;name&quot;: &quot;张三&quot; &#125;&#125; 第一步：12对参数按照key=value的格式，并按照参数名ASCII字典序排序如下：$stringA=&quot;data[id]=1&amp;data[name]=张三&amp;objType=2&amp;objectid=1&amp;openAppID=597882146416&amp;timestamp=1442401156&amp;userid=YmvhAU762R0done&quot;; 第二步：1234拼接API密钥，md5加密并转成大写，生成sign：$stringSignTemp=&quot;stringA&amp;key=testtoken123456&quot;$sign = strtoupper(md5($stringSignTemp));即$sign为：&quot;5F9F67A5635592A132BA935D44B25D40&quot; 第三步：12对请求的数据拼接sign签名：$param = $stringA . &apos;&amp;sign=5F9F67A5635592A132BA935D44B25D40; 最终请求如下：12https://open.campus.qq.com/api/OpenApi/getUserInfo?timestamp=1442401156&amp;data[id]=1&amp;data[name]=张三&amp;objType=2&amp;objectid=1&amp;openAppID=597882146416&amp;userid=1661&amp;sign=5F9F67A5635592A132BA935D44B25D40 最终请求如下：12https://open.campus.qq.com/api/OpenApi/getUserInfo?timestamp=1442401156&amp;data[id]=1&amp;data[name]=张三&amp;objType=2&amp;objectid=1&amp;openAppID=597882146416&amp;userid=1661&amp;sign=5F9F67A5635592A132BA935D44B25D40 【注意】 密钥key仅作加密使用，为了保证数据安全请不要在请求参数中传递，并对密钥key进行保密。 校验签名正确性签名校验工具：1https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=20_1 校验方式：选择“deeplink”或“自定义参数”PS.校验不通过那个提示不用管，只要对比自己代码生成的sign签名，与工具所生成的sign签名是否一致即可 【开发流程】获取devCode、devType、密钥key，用于生成后续的sign签名，详见签名参数sign生成说明 ==》获取objectid、objType、userid测试id详见开放平台后台-&gt;测试工具-&gt;沙盒测试环境-&gt;沙盒学校objectid 正式id详见签名参数sign生成说明、应用管理后台接入、应用H5前台接入 ==》查看公共参数文档，详见API公共参数说明 ==》查看API接口文档 ==》根据接口参数，生成和拼接sign签名，详见签名参数sign生成说明 ==》调用接口 ==》调试接口若接口报错，请参照以下顺序排查：仔细阅读接口文档，特别是必传参数及参数格式使用开放平台后台“API测试工具”，进行排查对照文档中的Demo代码若报签名错误，对照签名参数sign生成说明文档和文档中的“签名校验工具” 2) 使用应用（需创建应用，openAppID） 【开发流程】 登录到开放平台后台（open.campus.qq.com） ==》创建应用 ==》查看应用详情，获取AppID、AppSecret、H5Secret，用于生成后续的sign签名 ==》获取objectid、objType、userid应用上线前，只能使用测试id，获取方式为：开放平台后台-&gt;测试工具-&gt;沙盒测试环境-&gt;沙盒学校objectid 应用上线后，正式id的获取方式，详见签名参数sign生成说明、应用管理后台接入、应用H5前台接入 ==》查看公共参数文档，详见API公共参数说明 ==》查看API接口文档 ==》根据接口参数，生成和拼接sign签名，详见签名参数sign生成说明 ==》调用接口 ==》调试接口 ==》沙盒测试环境，测试应用 ==》测试应用无误后，申请上线 ==》一般情况下，腾讯智慧校园会在3个工作日内，审核应用 ==》应用审核通过后，学校/上级单位在PC后台-&gt;应用管理-&gt;第三方应用中，安装应用 ==》学校/上级单位，在PC或移动端使用应用时，会将objectid、objType、userid等参数，以url参数追加的形式传递到第三方应用的url中 【公共参数及签名密钥相关】 都有哪些公共参数？ 详见文档：开放API调用说明==》API公共参数说明 什么是objectid、objType、userid，如何获取它们？ 详见文档：开放API调用说明==》签名参数sign生成说明 什么是openAppID、AppSecret、H5Secret，如何获取它们？ 详见文档：开放API调用说明==》签名参数sign生成说明 什么是devCode、devType、授权密钥、授权密钥ID，如何获取它们？ 详见文档：开放API调用说明==》签名参数sign生成说明 如何生成和校验sign签名？ 详见文档：开放API调用说明==》签名参数sign生成说明，以及文档中的“签名校验工具” 【OpenAPI调用方式相关】 API调用说明？ 详见文档：开放API调用说明==》API调用说明 post请求参数demo？ 详见文档：开放API调用说明==》签名参数sign生成说明 OpenAPI调用代码demo？ 详见文档：开放API调用说明==》Demo下载 【OpenAPI调用出错相关】 业务错误码及说明 详见文档：开放API调用说明==》业务错误码 接口返回“1018 密钥不存在“或”1010 AppID或密钥不正确” 请核对devCode、devType、密钥是否匹配，获取方式详见文档：开放API调用说明==》签名参数sign生成说明 接口返回“1011 参数错误，请检查必传参数及类型” 请核对是否传了公共参数，并确认post格式是正确的，注意post数据为数组格式 详见文档： 开放API调用说明==》API调用说明 开放API调用说明==》签名参数sign生成说明 开放API调用说明==》API公共参数说明 开放API调用说明==》Demo下载 接口返回“1002 签名错误” 详见文档： 开放API调用说明==》签名参数sign生成说明，以及文档中的“签名校验工具” 请仔细对照工具中的每个步骤，看看是哪一步不一致。 调用发消息接口时，接口返回“1013 该学校/上级单位尚未安装此AppID应用” 只有学校/上级单位创建者，在PC后台==》应用管理==》第三方应用中，安装了开发者提供的第三方应用，才能调用发消息接口，进行发消息。 应用接入流程 简要介绍 腾讯智慧校园通过开放平台来满足学校/上级单位的定制化开发需求。 学校/上级单位/合作伙伴可在开放平台创建应用、开发调试、提交审核。应用上线后，学校/上级单位可安装使用。 第三方开发者也可通过智慧校园开放平台创建并提交第三方应用，供所有学校/上级单位使用。 应用类型 腾讯智慧校园开放平台期待各种富于创新、安全稳定，符合校园5大使用场景的应用，包括： （1）校内管理类应用 （2）学生学习类应用 （3）家校互动类应用 （4）移动办公类应用 （5）校园生活类应用 如何创建应用 （1）学校/上级单位：已加入腾讯智慧校园的学校/上级单位，将自动为其开通开放平台权限。学校超级管理员可直接登录到开放平台，创建并申请应用上线 （2）合作伙伴：签约的合作伙伴，将自动为其开通开放平台权限。合作伙伴管理员可直接登录到开放平台，创建并申请应用上线 （3）第三方公司/组织单位：需要先申请开发者资质，资质审核通过后，可登录开放平台，创建并申请应用上线。 如何开发调试 （1）应用程序开发 开发者可以在本地机器上进行应用程序的开发，实现业务逻辑。同时腾讯智慧校园开放平台开放了许多API，建议开发者先阅读API文档，了解不同场景下有哪些API可以调用。 （2）测试和联调 腾讯智慧校园开放平台提供的测试工具包含：沙盒学校测试环境、OpenAPI联调工具。详细信息请登录开放平台后查看“测试工具”。 如何部署应用 需要将应用部署在开发者自己的服务器上，因此需要自己准备服务器、域名等，并进行应用部署和测试。腾讯智慧校园暂不为该过程提供技术支持。 上线规范 为确保接入腾讯智慧校园开放平台应用的质量、提高后续运营服务的稳定性，上线前，请开发者按照接入规范对应用进行仔细检查及测试，对于不符合规范项进行修改。详见应用接入规范 应用审核 应用提交后，腾讯智慧校园将在5个工作日内对应用进行审核。审核中无法修改应用信息。审核通过后，应用将自动上线。 应用管理 开发者登录到腾讯智慧校园开放平台后，可以进入到管理中心统一管理应用，管理中心功能主要： （1）服务所有开发者； （2）服务于应用全生命周期； （3）提供依据用户权限的功能； （4）具备足够的帮助指引，可以由开发者自助使用。 详见管理中心使用说明 应用安装及使用 应用上线后，学校/上级单位可按如下步骤安装应用： 登录学校管理后台 -&gt; 点击“应用管理”右侧的设置按钮 -&gt; 选择“全部应用” -&gt; 点击要安装的应用icon -&gt; 进入安装页面，安装指引进行安装 安装成功后，使用方式如下： 若为独立应用：安装成功后应用将自动出现在菜单栏。可在学校管理后台访问其PC管理后台页面，可在微信企业号内使用其移动端功能。若为普通应用：安装成功后需手动配置其移动端地址。可在“应用管理-&gt;我的应用”中访问其PC管理后台页面，可在配置的应用菜单处使用其移动端功能。 开发api说明 PC管理后台、H5前台登录态打通 学校在管理后台【应用市场】安装了开发者的应用后，可以在学校后台【我的应用】==》【应用管理】中，对应用进行管理。 同时，学校可以将开发者所提供的H5 url粘贴到企业号应用菜单，或应用的H5页面中。 关于“PC管理后台应用管理登录态打通方案”，请参见“应用管理后台接入”小节。 关于“H5页面登录态打通方案”，请参见“应用H5前台接入”小节。 通过“API列表”中的接口，获取学校/上级单位信息 在获取登录态的同时，可以获取到学校ID/上级单位ID、用户ID等信息。 当开发者获取到学校ID、用户ID后，可以调用“API接口列表”中的接口，进一步获取学校/上级单位信息。 哪些学校和用户可以使用该应用，由【应用详情】中的“使用范围”和“适用人群”决定。开发者只能获取这部分人的信息。 API调用说明1.开发者调用腾讯智慧校园API时，需使用Https协议、UTF8编码，访问域名为https://open.campus.qq.com 数据包不需要加密。注：原有域名https://m.campus.qq.com 仍可正常使用，但不会再进行功能的升级和维护，并将于2018年底下线。 2.请求接口的数据为数组格式。 3.接口返回的数据为json格式。其中GET接口可以通过传入callback参数，兼容jsonp格式。 4.接口安全校验采用sign签名的方式，sign由密钥key生成（key为第三方应用AppSecret），sign参数的生成算法详见“签名参数sign生成说明”小节。 5.合作伙伴、第三方开发者通过在开放平台建立第三方应用的方式，使用openAppID（第三方应用ID）+AppSecret（第三方应用密钥）进行开发。 openAppID、AppSecret的获取方式：开放平台后台：应用管理==》应用详情，openAppID对应AppID 注意：应用AppSecret仅作加密生成sign签名使用，为了保证数据安全请不要在请求参数中传递，并对应用AppSecret进行严格保密。因自行泄漏密钥导致的数据安全问题，需要自行承担。 6.在每次调用智慧校园接口时都需要带上openAppID、objectid、objType、timestamp、sign参数。各参数具体含义及获取方式，详见“API公共参数说明”小节 7.在开发者调用API接口时，腾讯智慧校园会对签名和时间戳进行验证： 腾讯智慧校园会使用同样的sign签名算法判断接收到的sign与计算的签名是否一致，来验证请求来源的合法性；另外，接收到请求时会判断当前时间戳与接收到的timestamp参数是否在一个合理的范围，相差5分钟内才合法，以防止重放攻击。 API公共参数说明“API接口列表”中有一些请求参数是通用的，在此做以下统一说明： 数据id，如objectid、userid、departid等，最大长度为50位]]></content>
      <categories>
        <category>腾讯智慧校园开发平台</category>
      </categories>
      <tags>
        <tag>腾讯智慧校园开发平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发]]></title>
    <url>%2F2018%2F10%2F18%2F1%2F</url>
    <content type="text"><![CDATA[微信公众号开发 微信公众号开发 request用于网络请求,它是对原生的http request的封装. 微信的数据包装方式是xml,所以我们要借助ejs这个模板库,把数据作为变量替换到xml字符汇中 还有一些工具模板: lodash是一些常用的方法集,做数组拆分,类型判断等等.Heredoc是一个黑科技,把函数体里面的多行的注解作为字符串提取出来主要用来降低拼接字符串的成本 raw-body用来获取一个http请求返回的可读流的内容实体. sha1进行加密. 微信服务器返回的数据是xml格式,无法用js函数直接使用,所以要xml2js这个模块把xml数据解析为js对象,方便我们使用. 微信公众号开发:配置接入流程,加密认证环节,票据access_token. 利用nodejs开发一些网页或者爬虫工具,来对nodejs api和它的技术特点有一些基本的认知. 有一些其他的后端经验,php,java,ruby,主要弄明白一个网络http请求从开发到结束中间所经过的环节. nodejs和javascript 进击node.js教程 1针对微信常用接口进行一个一个单独讲解和实现,并且有许多小案例演示. 开发电影公众号的网站项目. 了解一:本地代理环节的搭建以及最入门的加密认证. 1.域名服务器环境的配置2.利用qq浏览器代理调式端口 重点:加密认证逻辑 微信公众号:企业号,订阅号,服务号订阅号:个人,小团队,只要是信息的传播,管理用户以及用户的互动. 如消息定制 服务,企业和组织,提供业务服务与用户管理能力.比如支付,智能接口. 企业号,管理全学校所有学院等,各个部门上班人员的考勤,活动进程等. 服务号,管理全学校的水果商店或者打印店,可以直接支持送货上门,以及推送一些特价水果. 订阅号,管理一个班级,一个学院的信息订阅,通知和互动. 公众号认证和非认证 认证:一般需要你有个开户过的企业大家可以法人身份去折腾下开一个小公司. 认证订阅号:认证和非认证账号的区别就是,认证账号别可以直接在添加好友里搜索关键词就能找到你. 订阅号和服务号三点不同出现位置不同.单月发送消息的数量,订阅号一天一篇,服务号一个月最多4篇.订阅号没有9大接口和支付功能. 服务号9大接口1.语音识别2.客服接口3.OAuth 2.0网页的授权:这个授权接口,可以请求用户授权,从而拿到更多用户的信息. 4.生成带参数二维码:公众号可以获取一系列携带不同参数的二维码,在用户扫描关注公众号后.公众号可以根据参数分析各二维码的效果.这些参数可以自己定制,从而可以实现更多分析结果,比如用户从哪里来的. 5.获取用户的地理位置:公众号能够获得用户进入公众号会话时的地理位置.可以做微信导航. 6.获取用户基本信息:公众号可以根据加密后的用户OpenID,通过一系列的参数交互,最终拿到用户基础信息,包括头像,名称,性别,地区. 7.获取关注者的列表:通过这个接口,可以拿到所有关注者的OpenID,就知道有多少人关注你,是谁在关注你.8.用户分组接口:通过分组接口,可以在后台为用户移动,创建,修改分组,比如把你们班级你们团队分成,男生一组,女生一组9.上传下载多媒体文件 订阅号1.会话界面的自定义菜单2.多客服接口3.获取用户地址位置4.高级群发接口5.用户分组接口 域名,服务器以及ngrok环境微信服务器域名应用服务器微信 ./ngork www.tunnel.mobl 使用:下载配置文件ngrok.cfg 1ngrok -config ngrok.cfg - subdomain example 8080 1234567cdcd textls// 写一个简单的服务器python m SimpleHTTPServer 3100python -m SimpleHTTPServer 3100-config ngrok.cfg subdomain imooc-wechat 3100 子域名: 1http://imooc-wechat.tunnel.mobi 使用nodejs的localtunnel服务 12npm install -g localtunnellt --port 3100 PageKite 花生壳 配置,接入微信公众号点击开发者工具:接口测试申请 获取:urltoken 接入公众号: 一:配置微信公众号后台二:验证公众号 配置服务器的url 验证公众号token,timestamp,nonce字典排序,sha1加密r===signature 一:将token,timestamp,nonce三个参数进行字典序排序二:将三个参数字符串拼接成一个字符串进行sha1加密.三:将加密后的字符串与signature对比,如果相同,表示这个请求来源于微信,我们直接原因返回echostr参数内容,接入验证就成功了. 实现加密认证逻辑 使用koa,不用express 使用Koa框架,代码可以更加精简,更加易懂,对于反反复复的异步交互更适合用这个框架实现. 123scott/wechat &gt;&gt;npm install koa sha1 123456789node -vnode --harmony app.js&gt;&gt; ./ngrok -config ngrok.cfg -subdomain scott_wechat 1234ls --port 1234// 把生成的地址配置到接口配置信息中url里面去node --harmony app 1https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1433401084 开发 填写服务器配置 验证服务器地址的有效性 根据接口文档实现业务逻辑 我们在手机上给微信公众号发送一个消息，这就相当于一个request请求，然后这个request到达微信服务器，紧接着微信服务器对这个request做出解析，然后开始响应一个response给你，这样你就收到了相应的回复。 当我们进行微信公众号的开发之后，用户的请求就不再有微信服务器去做处理了，而是由我们自己的服务做处理，然后把消息传给微信服务器，微信服务器再将消息返回给我们的用户。 在这个过程中，微信服务器起了一个中间商的作用，所以经过这样的分析，微信公众号开发要把握的一点就是，你只要返回给微信服务器正确的数据，微信服务器就能帮你做正确的事情。 所以作为微信公众号开发的第一步就是接入，你需要将自己的服务器和微信服务器做接通，只有接通之后，用户发送的请求到达微信服务器之后，微信服务器才知道该将这个请求转发给哪个服务器来处理。 问题一这个url是用来接收微信服务器发送过来的请求的，要对请求做处理？想一想，request？处理？该怎么做呢？ 12345678910111213public class OneServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); &#125;&#125; 需要服务器公众号 申请测试号这里是申请地址： 1https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login appID 和appsecret 通过他们我们能得到很重要的一个数值就access_tokenaccess_token是公众号的全局唯一接口调用凭据 公众号调用各接口时都需使用access_token 获取access_token官方技术文档中已经说了，公众号调用接口都需要使用到access_token 12// https请求方式: GEThttps://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET 123grant_type 是 获取access_token填写client_credentialappid 是 第三方用户唯一凭证secret 是 第三方用户唯一凭证密钥，即appsecret 问题二这个接口正确调用会返回什么数据呢？ 正常情况下会返回下述JSON数据包给公众号 1&#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125; 那么这里又包含如下参数12access_token 获取到的凭证expires_in 凭证有效时间，单位：秒 使用Postman这个工具简单演示一下发起get请求获取access_token 。 然后把响应的参数填写即可，这里的grant_type 就写默认的即可，剩下的appid和secret就填写你公众号的appID 和appsecret。 这个时候你就会发现，一个完整的get请求就拼接好了，接下来点击send即可，然后就会看到返回的数据 这样就得到我们需要的access_token 。 微信服务器会往我们填写的这个URL上面发送一个get请求，通过这个get请求能够得到微信服务器发送过来的一些消息，然后对消息做响应的处理来与微信服务器对接。 很显然，这个URL需要填写一个servlet，微信服务区器将消息发送过来之后需要对这个请求做处理，所以这里选择使用servlet对请求做处理。 问题三关于如何验证，文档中给了一个PHP的例子，那么Java中该如何验证呢？ 首先创建一个maven项目，然后创建一个CoreServlet用来接收微信服务器发送过来的请求 1234567891011public class CoreServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125;&#125; 创建完成servlet之后就需要将这个servlet进行注册了，这个是在web.xml中 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;coreServlet&lt;/servlet-name&gt; &lt;servlet-class&gt; com.ithuanqging.wechat.CoreServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- url-pattern中配置的/coreServlet用于指定该Servlet的访问路径 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;coreServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/coreservlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 填写服务器地址（URL）、Token和EncodingAESKey，其中URL是开发者用来接收微信消息和事件的接口URL。Token可由开发者可以任意填写，用作生成签名（该Token会和接口URL中包含的Token进行比对，从而验证安全性）。EncodingAESKey由开发者手动填写或随机生成，将用作消息体加解密密钥。 开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。 第二步：验证消息的确来自微信服务器1234signature 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。timestamp 时间戳nonce 随机数echostr 随机字符串 1）将token、timestamp、nonce三个参数进行字典序排序 2）将三个参数字符串拼接成一个字符串进行sha1加密 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 检验signature的PHP示例代码： 1234567891011121314151617private function checkSignature()&#123; _GET[&quot;signature&quot;]; _GET[&quot;timestamp&quot;]; _GET[&quot;nonce&quot;];tmpArr = array(timestamp, $nonce);sort($tmpArr, SORT_STRING);$tmpStr = implode( $tmpArr );$tmpStr = sha1( $tmpStr );if( signature )&#123;return true;&#125;else&#123;return false;&#125;&#125; 1234567891011121314151617181920@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 微信加密签名 String signature = req.getParameter(&quot;signature&quot;); // 时间戳 String timestamp = req.getParameter(&quot;timestamp&quot;); // 随机数 String nonce = req.getParameter(&quot;nonce&quot;); // 随机字符串 String echostr = req.getParameter(&quot;echostr&quot;); PrintWriter out = resp.getWriter(); // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败 if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123; out.print(echostr); &#125; out.close(); out = null; &#125; ##微信测试公众号基本配置URL和Token的验证-JAVA 我们填写的URL和Token，微信那边会根据你填的来验证是否正确，URL必须有域名的，Token自己定义的。 微信调用我们服务器，会通过GET请求，请求带有signature、timestamp、nonce、echostr参数。服务端返回echostr参数，则表示token验证成功。 123456789101112131415161718192021222324252627282930 @GET@Path(&quot;/tokenVarify&quot;)@Produces(MediaType.APPLICATION_JSON)@Consumes(MediaType.APPLICATION_JSON)@ApiOperation(value = &quot;Vatify wc token&quot;, position = 1)public void tokenVarify(@Context HttpServletRequest request, @Context HttpServletResponse response) &#123; boolean isGet = request.getMethod().toLowerCase().equals(&quot;get&quot;); PrintWriter print; if (isGet) &#123; // 微信加密签名 String signature = request.getParameter(&quot;signature&quot;); // 时间戳 String timestamp = request.getParameter(&quot;timestamp&quot;); // 随机数 String nonce = request.getParameter(&quot;nonce&quot;); // 随机字符串 String echostr = request.getParameter(&quot;echostr&quot;); // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败 if (signature != null &amp;&amp; CheckoutUtil.checkSignature(signature, timestamp, nonce)) &#123; try &#123; print = response.getWriter(); print.write(echostr); print.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; CheckoutUtil.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.security.MessageDigest;import java.security.NoSuchAlgorithmException; public class CheckoutUtil &#123; // 与接口配置信息中的Token要一致 private static String token = &quot;bryant.zhang.test&quot;; /** * 验证签名 * * @param signature * @param timestamp * @param nonce * @return */ public static boolean checkSignature(String signature, String timestamp, String nonce) &#123; String[] arr = new String[] &#123; token, timestamp, nonce &#125;; // 将token、timestamp、nonce三个参数进行字典序排序 // Arrays.sort(arr); sort(arr); StringBuilder content = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; content.append(arr[i]); &#125; MessageDigest md = null; String tmpStr = null; try &#123; md = MessageDigest.getInstance(&quot;SHA-1&quot;); // 将三个参数字符串拼接成一个字符串进行sha1加密 byte[] digest = md.digest(content.toString().getBytes()); tmpStr = byteToStr(digest); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; content = null; // 将sha1加密后的字符串可与signature对比，标识该请求来源于微信 return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false; &#125; /** * 将字节数组转换为十六进制字符串 * * @param byteArray * @return */ private static String byteToStr(byte[] byteArray) &#123; String strDigest = &quot;&quot;; for (int i = 0; i &lt; byteArray.length; i++) &#123; strDigest += byteToHexStr(byteArray[i]); &#125; return strDigest; &#125; /** * 将字节转换为十六进制字符串 * * @param mByte * @return */ private static String byteToHexStr(byte mByte) &#123; char[] Digit = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos; &#125;; char[] tempArr = new char[2]; tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F]; tempArr[1] = Digit[mByte &amp; 0X0F]; String s = new String(tempArr); return s; &#125; public static void sort(String a[]) &#123; for (int i = 0; i &lt; a.length - 1; i++) &#123; for (int j = i + 1; j &lt; a.length; j++) &#123; if (a[j].compareTo(a[i]) &lt; 0) &#123; String temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; &#125; &#125; &#125;&#125; qi文档中说的真的很清楚了，包括如何验证等表述的都很清楚，下面我们直接编码1234567891011121314151617181920@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // 微信加密签名 String signature = req.getParameter(&quot;signature&quot;); // 时间戳 String timestamp = req.getParameter(&quot;timestamp&quot;); // 随机数 String nonce = req.getParameter(&quot;nonce&quot;); // 随机字符串 String echostr = req.getParameter(&quot;echostr&quot;); PrintWriter out = resp.getWriter(); // 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败 if (SignUtil.checkSignature(signature, timestamp, nonce)) &#123; out.print(echostr); &#125; out.close(); out = null; &#125; 以上是从request请求中拿到传过来的参数，接下来就是需要创建一个工具类按照文档中说的方法去进行验证了，这里我已经写好了这个工具类SignUtil 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SignUtil &#123; // 与接口配置信息中的Token要一致 private static String token = &quot;mytoken&quot;; /** * 验证签名 */ public static boolean checkSignature(String signature, String timestamp,String nonce) &#123; // 1.将token、timestamp、nonce三个参数进行字典序排序 String[] arr = new String[] &#123; token, timestamp, nonce &#125;; Arrays.sort(arr); // 2. 将三个参数字符串拼接成一个字符串进行sha1加密 StringBuilder content = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; content.append(arr[i]); &#125; MessageDigest md = null; String tmpStr = null; try &#123; md = MessageDigest.getInstance(&quot;SHA-1&quot;); // 将三个参数字符串拼接成一个字符串进行sha1加密 byte[] digest = md.digest(content.toString().getBytes()); tmpStr = byteToStr(digest); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; content = null; // 3.将sha1加密后的字符串可与signature对比，标识该请求来源于微信 return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false; &#125; /** * 将字节数组转换为十六进制字符串 */ private static String byteToStr(byte[] byteArray) &#123; String strDigest = &quot;&quot;; for (int i = 0; i &lt; byteArray.length; i++) &#123; strDigest += byteToHexStr(byteArray[i]); &#125; return strDigest; &#125; /** * 将字节转换为十六进制字符串 */ private static String byteToHexStr(byte mByte) &#123; char[] Digit = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;,&apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos; &#125;; char[] tempArr = new char[2]; tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F]; tempArr[1] = Digit[mByte &amp; 0X0F]; String s = new String(tempArr); return s; &#125;&#125; 以上这个工具类你可以直接拿来使用。 这个时候就要回到我们的测试公众号后台了，去填写我们的配置，也就是接口配置信息，但是现在你写的程序还在本地，微信即使发送请求也发不到你这啊，所以这个时候需要将的项目打包传到你的服务器上 首先将你的项目通过maven打包成war 1G:\JavaCodeDemo\wechattest:mvn package 1234567wechattest &gt; target &gt;classesgenerated-sourcesmaven-archivermaven-statuswechattestwechattest.war 接下来将这个war包上传到你的服务器上，我这里使用的是FileZilla这个工具 找到刚才生成的war包，远程站点必须是tomcat下的webapps目录下。 服务器配置的知识涉及到在服务器中安装JDK和tomcat！ 现在只要告诉微信服务器你的这个项目中的CoreServlet的正确路径，就能接收微信服务器发动的消息了，现在回到测试公众号的后台。 接口配置信息: 12服务器公网IP地址coreservlet的路径 1http://139.199.98.152/wechattest/coreservlet]]></content>
      <categories>
        <category>微信公众号开发</category>
      </categories>
      <tags>
        <tag>微信公众号开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML入门教材]]></title>
    <url>%2F2018%2F05%2F17%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 HTML 基本结构及实体 了解 HTML 文档的基本结构 掌握 HTML 结构标签 掌握 HTML 字符实体 HTMLHTML 文件是什么？HTML 表示超文本标记语言（Hyper Text Markup Language）。HTML 文件是一个包含标记的文本文件。这些标记保证浏览器怎样显示这个页面。HTML 文件必须有 htm 或者 html 扩展名。HTML 文件可以用一个简单的文本编辑器创建。 想不想尝试一下？假如你运行的是 windows 系统，打开记事本，在其中输入以下文本： 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Title of page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;This is my first homepage.&lt;b&gt;This text is bold&lt;/b&gt;&lt;/body&gt;&lt;/html&gt; 将此文件保存为“mypage.htm”。 例子解释:HTML 文档中，第一个标签是。 这个标签告诉浏览器这是 HTML 文档的开始。 HTML 文档的最后一个标签是，这个标签告诉浏览器这是 HTML 文档的终止。 在和标签之间文本的是头信息。 在浏览器窗口中，头信息是不被显示的 。 在和标签之间的文本是文档标题，它被显示在浏览器窗口的标题栏 。 在和标签之间的文本是正文，会被显示在浏览器中。 在和标签之间的文本会以加粗字体显示。 关于 HTML 编辑器：用一些所见即所得的编辑器，比如 frontpage，dreamwaver，你可以很容易创建一个页面，而不需要在纯文本中编写代码。 但是假如你想成为一名熟练的网络开发者，我们强烈推荐你用纯文本编辑器编写代码 ，这有助于学习 HTML 基础。 常见问题:问：我编写完了 HTML 文件，但是不能在浏览器中看见结果，为什么？ 答 ： 请确 认 你 保 存了 文 件 ， 并且 使 用 了 正确 的 文 件 名和 扩 展 名 ，例 如 ：“c:\mypage.htm”，并且确认你用浏览器打开时使用同样的文件名。 问：我编辑了 HTML 文件，但是修改结果并没有在浏览器中显示，为什么？ 答：浏览器缓存了你的页面，所以它不需要两次读取同样的页面。你修改了这个页面 ，浏览器并不知道。请使用“刷新/重载”按钮来强迫浏览器读取编辑过的页面。 HTML 元素：HTML 文档是由 HTML 元素组成的文本文件。 HTML 元素是预定义的正在使用的 HTML 标签。 HTML 标签：HTML 标签用来组成 HTML 元素。 HTML 标签两端有两个包括字符：“&lt;”和“&gt;”,这两个包括字符被称为角括号。 HTML 标签通常成对出现，比如和。 一对标签的前面一个是开始标签，第二个是结束标签,在开始和结束标签之间的文本是元素内容。 HTML 标签是大小写无关的，跟表示的意思是一样的。 HTML 元素：回忆一下上面的 HTML 例子：123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Title of page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;This is my first homepage.&lt;b&gt;This text is bold&lt;/b&gt;&lt;/body&gt;&lt;/html&gt; 下面是一个 HTML 元素：1&lt;b&gt;This text is bold&lt;/b&gt; 此 HTML 元素以开始标签起始， 内容是：This text is bold，以结束标签中止 。 标签的目的是定义一个需要被显示成粗体的 HTML 元素。 下面也是一个 HTML 元素：1234&lt;body&gt;This is my first homepage.&lt;b&gt;This text is bold&lt;/b&gt;&lt;/body&gt; 此 HTML 标签以开始标签起始，终止于结束标签。 标签的目的 是定义一个 HTML 元素，使其包含 HTML 文档的主体。 为什么使用小写标签？ 我们刚说过，HTML 标签是大小写无关的： 跟含义相同。 当你上网的时候，你会注意到多数教程在示例中使用大写的 HTML 标签，我们总是使用小写标签。 为什么？ 假如你想投入到下一代 HTML 中，你应该开始使用小写标签。 W3C 在他们的 HTML4建议中提倡使用小写标签，XHTML（下一代 HTML）也需要小写标签。 标签属性：标签可以拥有属性。 属性能够为页面上的 HTML 元素提供附加信息。 标签定义了 HTML 页面的主体元素。 使用一个附加的 bgcolor 属性，你可以告诉浏览器：你页面的背景色是红色的，就像这样：1&lt;body bgcolor=&quot;red&quot;&gt; 标签定义了一个 HTML 表格。 使用一个附加的 border 属性，你可以告诉浏览器：这个表格是没有边框的，代码是：1&lt;table border=&quot;0&quot;&gt; 属性通常由属性名和值成对出现，就像这样：name=”value”。 属性通常是附加给 HTML元素的开始标签的。 引号样式：属性值应该被包含在引号中。双引号是最常用的，但是单引号也可以使用。 在很少情况下，比如说属性值本身包含引号，使用单引号就很必要了。 比如：name=’John “ShotGun” Nelson’。 注意：中文引号跟英文引号是不一样的。上面所指的引号都是英文状态下的引号。 HTML 实体有些字符，比如说“&lt;”字符，在 HTML 中有特殊的含义，因此不能在文本中使用。想要在 HTML 中显示一个小于号“&lt;”，需要用到字符实体。 字符实体：在 HTML 中，有些字符拥有特殊含义，比如小于号“&lt;”定义为一个 HTML 标签的开始 。 假如我们想要浏览器显示这些字符的话，必须在 HTML 代码中插入字符实体。 一个字符实体拥有三个部分：一个 and 符号（&amp;），一个实体名或者一个实体号，最后是一个分号（;） 想要在 HTML 文档中显示一个小于号，我们必须这样写：&lt;或者&#60; 使用名字相对于使用数字的优点是容易记忆，缺点是并非所有的浏览器都支持最新的实体名，但是几乎所有的浏览器都能很好地支持实体号。 注意：实体名是大小写敏感的。 下面这个例子能够让你针对 HTML 实体实践一下。12345&lt;html&gt;&lt;body&gt;&lt;p&gt;This is a character entity: &amp;#123;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 不可拆分的空格在 HTML 中，最常见的字符实体就是不可拆分空格。 通常，HTML 会合并你文档中的空格。假如在你的 HTML 文本中连续写了 10 个空格 ，其中 9 个会被去掉。想要在 HTML 中插入空格，可以使用实体：&nbsp; HTML 基本元素的运用12345段落相关标签&lt;p&gt;&lt;br&gt;&lt;hr&gt;格式化相关标签&lt;small&gt;&lt;sub&gt;&lt;sup&gt;&lt;pre&gt;列表相关标签&lt;ol&gt;&lt;ul&gt;&lt;li&gt;图片相关标签&lt;img&gt;超链相关标签&lt;a&gt; 段落 相关 标签标题元素：标题元素由标签到定义。定义了最大的标题元素，定义了最小的。123456&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;h2&gt;This is a heading&lt;/h2&gt;&lt;h3&gt;This is a heading&lt;/h3&gt;&lt;h4&gt;This is a heading&lt;/h4&gt;&lt;h5&gt;This is a heading&lt;/h5&gt;&lt;h6&gt;This is a heading&lt;/h6&gt; HTML 自动在一个标题元素前后各添加一个空行。 段落：段落是用标签定义的。1&lt;p&gt;This is another paragraph&lt;/p&gt; HTML 自动在一个段落前后各添加一个空行。 换行：当需要结束一行，并且不想开始新段落时，使用标签。标签不管放在什么位置，都能够强制换行。1&lt;p&gt;This &lt;br&gt; is a para&lt;br&gt;graph with line breaks&lt;/p&gt; 标签是一个空标签，它没有结束标记。 格式化 相关 标签格式化文字：12345678910111213141516171819202122232425262728&lt;html&gt; &lt;body&gt; &lt;b&gt;This text is bold&lt;/b&gt;&lt;br&gt; &lt;strong&gt; This text is strong &lt;/strong&gt;&lt;br&gt; &lt;big&gt; This text is big &lt;/big&gt;&lt;br&gt; &lt;em&gt; This text is emphasized &lt;/em&gt;&lt;br&gt; &lt;i&gt; This text is italic &lt;/i&gt;&lt;br&gt; &lt;small&gt; This text is small &lt;/small&gt;&lt;br&gt; This text contains &lt;sub&gt; subscript &lt;/sub&gt;&lt;br&gt; This text contains &lt;sup&gt; superscript &lt;/sup&gt; &lt;/body&gt;&lt;/html&gt; 列表相关标签无序列表：无序列表是一个项目的序列。各项目前加有标记（通常是黑色的实心小圆圈）。 无序列表以标签开始。每个列表项目以开始。1234&lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 无序列表的项目中可以加入段落、换行、图像，链接，其他的列表等等。 有序列表：有序列表也是一个项目的序列。各项目前加有数字作标记。 有序列表以标签开始。每个列表项目以开始。123456&lt;ol&gt;Web程序开发基础12&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; 不同类型：12345678&lt;ol type=&quot;A&quot;&gt;&lt;ol type=&quot;a&quot;&gt;&lt;ol type=&quot;I&quot;&gt;&lt;ol type=&quot;i&quot;&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;ul type=&quot;circle&quot;&gt;&lt;ul type=&quot;square&quot;&gt; 图片相关标签Img 标签和 src属性：在 HTML 里面，图像是由标签定义的。 是空标签，意思是说，它只拥有属性，而没有结束标签。 想要在页面上显示一个图像，需要使用 src属性。“src”表示“源”的意思。“src”属性的值是所要显示图像的 URL。 插入图像的语法：URL 指向图像存储的地址。 alt 属性： alt 属性用来给图像显示一个“交互文本”。alt 属性的值是由用户定义的。 “alt”属性在浏览器装载图像失败的时候告诉用户所丢失的信息，此时，浏览器显示这个“交互文本”来代替图像。给页面上的图像都加上 alt 属性是一个好习惯，它有助于更好地显示信息，而且，对纯文本浏览器很有用。 基本注意点——有用的技巧:如果一个 HTML 文档包含 10 个图像，那么为了正确显示这个页面，需要加载 11 个文件 。加载图像是需要时间的，所以请谨慎使用图像。 1234567&lt;img src=&quot;./images/hackanm.gif&quot; width=&quot;20&quot; height=&quot;20&quot;&gt;&lt;body background=&quot;./images/background.jpg&quot;&gt;&lt;a href=&quot;back.htm&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;./images/next.gif&quot;&gt;&lt;/a&gt; 超链相关标签锚标签和 href 属性：HTML 使用锚标签（）来创建一个连接到其他文件的链接。锚可以指向网络上的任何资源：HTML 页面，图像，声音，影片等等。 标签被用来创建一个链接指向的锚，href 属性用来指定连接到的地址，在锚的起始标签和结束标签中间的部分将被显示为超级链接。 target 属性：使用 target 属性，你可以定义从什么地方打开链接地址。 锚标签和 name 属性name 属性用来创建一个命名的锚。使用命名锚以后，可以让链接直接跳转到一个页面的某一章节，而不用用户打开那一页，再从上到下慢慢找。 下面是命名锚的语法： 你可以为锚随意指定名字，只要你愿意。 基本注意点——有用的技巧：命名锚通常用来在大型文档的开头创建章节表。这个页面的每个章节被加上一个命名锚，到这些锚的链接被放在页面的顶端。 如果浏览器无法找到指定的命名锚，它将转到这个页面的顶部，而不显示任何错误提示。 更多示例：在新浏览器窗口中打开链接：123456789&lt;html&gt;&lt;body&gt;&lt;a href=&quot;lastpage.htm&quot; target=&quot;_blank&quot;&gt;Last Page&lt;/a&gt;&lt;p&gt;If you set the target attribute of a link to &quot;_blank&quot;,the link will open in a new window.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 用 HTML 创建表格 了解掌握表格的基本结构 掌握跨行、跨列属性 colspan rowspan 掌 握 表 格 相 关 修 饰 属 性 border width height bgcolor background height cellpadding cellspacing HTML 表格表格 : 表格是用标签定义的。 表格被划分为行（使用标签），每行又被划分为数据单 元格（使用标签）。td 表示“表格数据”（ Table Data），即数据单元格的内容。 数据单元格可以包含文本，图像，列表，段落，表单，水平线，表格等等。想不想尝试一下？12345678910111213141516171819202122232425262728293031323334353637&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;table&gt; &lt;caption&gt;table title and/or explanatory text&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;header&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;data&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;table border=&quot;1&gt; &lt;tr&gt; &lt;th colspan=&quot;&quot; rowspan=&quot;&quot; headers=&quot;&quot; scope=&quot;&quot;&gt;&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/td&gt;&lt;/table&gt;&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 基本注意点——有用的技巧通常很少使用，，标签，因为浏览器对它们的支持不好。希望这个在 XHTML 的未来版本中得到改变。 cellpadding 属性在表格内容和边框之间留出更多空白cellspacing 属性来增加单元格间距使用“align”属性来设置单元格的对齐方式 HTML 表单页面的运用掌握表单基本结构掌握各种表单元素能理解 post 和 get 两种提交方式的区别 HTML 表单表单：表单是一个能够包含表单元素的区域。 表单元素是能够让用户在表单中输入信息的元素（比如文本框，密码框，下拉菜单，单选框，复选框等等）。 Input：最常用的表单标签是标签。Input 的类型用 type属性指定。最常用的 input 类型解释如下： 文本框：在表单中，文本框用来让用户输入字母、数字等等。 表单的 action 属性和提交按钮：当用户点击提交按钮的时候，表单的内容会被提交到其他文件。 表单的 action 属性定义了所要提交到的目的文件，该目的文件收到信息后通常进行相关的处理。 123&lt;form name=&quot;input&quot; action=&quot;xxxx&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;&quot; name=&quot;&quot;&gt;&lt;/form&gt; 简单的下拉列表： 123456789101112&lt;html&gt; &lt;body&gt; &lt;form&gt; &lt;select name=&quot;cars&quot;&gt; &lt;option value=&quot;volvo&quot;&gt;Volvo &lt;option value=&quot;saab&quot;&gt;Saab &lt;option value=&quot;fiat&quot;&gt;Fiat &lt;option value=&quot;audi&quot;&gt;Audi &lt;/select&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 创建一个含有预先选定元素的下拉列表。 1234567891011文本域：&lt;html&gt; &lt;body&gt; &lt;p&gt; This example demonstrates a text-area. &lt;/p&gt; &lt;textarea rows=&quot;10&quot; cols=&quot;30&quot;&gt; The cat was playing in the garden. &lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; 1234567&lt;html&gt; &lt;body&gt; &lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;Hello world!&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516&lt;html&gt; &lt;body&gt; &lt;fieldset&gt; &lt;legend&gt; Health information: &lt;/legend&gt; &lt;form&gt; Height&lt;input type=&quot;text&quot; size=&quot;3&quot;&gt; Weight&lt;input type=&quot;text&quot; size=&quot;3&quot;&gt; &lt;/form&gt; &lt;/fieldset&gt; &lt;p&gt; If there is no border around the input form, your browser is too old. &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819&lt;html&gt; &lt;body&gt; &lt;form action=&quot;x&quot; method=&quot;post&quot; enctype=&quot;text/plain&quot;&gt; &lt;h3&gt;xxxxxxxxxxx&lt;/h3&gt; Name:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;yourname&quot; size=&quot;20&quot;&gt; &lt;br&gt; Mail:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;mail&quot; value=&quot;yourmail&quot; size=&quot;20&quot;&gt; &lt;br&gt; Comment:&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;comment&quot; value=&quot;yourcomment&quot; size=&quot;40&quot;&gt; &lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Send&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;Reset&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用样式表美化页面 1 1掌握在网页中使用 CSS 的方法熟悉 CSS 的不同选择器的使用方法熟悉字体属性：font-family，font-size，font-style，font-weight熟悉文本属性：text-align，text-indent，text-decoration，text-transform，vertical-align，word-spacing，letter-spacing CSS 的工作原理在这一节，你将学习如何制作自己的第一个样式表。 你将了解基本的 CSS 模型，以及在HTML 文档里使用 CSS 所必需的代码。 级联样式表（CSS）里用到的许多 CSS 属性都与 HTML 属性相似，所以，假如你熟悉采用 HTML 进行布局的话，那么这里的许多代码你都不会感到陌生。我们先来看一个具体的例子。 基本的 CSS 语法：比方说，我们要用红色作为网页的背景色：用 L HTML 的话，我们可以这样：用 CSS的话，我们可以这样获得同样的效果： 为一个 HTML 文档应用 CSS：为 HTML 文档应用 CSS，有三种方法可供选择。 下面对这三种方法进行了概括。我们建议你对第三种方法（即外部样式表）予以关注。 方法 1：行内样式表（style 属性） 方法 2：内部样式表（style 元素） 方法 3：外部样式表（引用一个样式表文件） 元素的分类与标识（ class 和 和 id ）有时，你希望对特定元素或者特定一组元素应用特殊的样式。在这一节，我们将深入学习如何利用 class 和 id 来为所选元素指定属性。 如何实现为网站上许多标题中的某一个单独应用颜色？如何实现把网站上的链接分为不同的类，并对各类链接分别应用不同的样式？这只是本节将解决的诸多问题中的最具代表性的两个问题。 字体属性这一节，你将学习字体以及如何用 CSS 来设置字体。我们还会考虑如何解决“网站所选的字体仅当访问者的 PC 上安装有该字体时才会被显示”这一难题。本节将对下列 CSS属性进行讲解： • font-family• font-style• font-variant• font-weight• font-size• font 字体族[font-family]：CSS 属性 font-family 的作用是设置一组按优先级排序的字体列表，如果该列表中的第一个字体未在访问者计算机上安装，那么就尝试列表中的下一个字体，依此类推，直到列表中的某个字体是已安装的。 有两种类型的名称可用于分类字体：字体族名称（family-name）和族类名称（genericfamily）。下面来解释这两个术语。 字体族名称（family-name）： 字体族名称（就是我们通常所说的“字体”）的例子包括“Arial”、“Times New Roman” 、“宋体”、“黑体”等等。 字体样式[font-style]：CSS 属性 font-style 定义所选字体的显示样式： normal （正常）、 c italic （斜体）或 oblique（倾斜）。 字体变化[font-variant]：CSS 属性 font-variant 的值可以是： normal（正常）或 s small-caps（小体大写字母） 。small-caps 字体是一种以小尺寸显示的大写字母来代替小写字母的字体。 字体浓淡[font-weight]：CSS 属性 font-weight 指定字体显示的浓淡程度。其值可以是 l normal（正常）或 bold（加粗）。 字体大小[font-size]：字体的大小用 CSS 属性 font-size 来设置。字体大小可通过多种不同单位（比如像素或百分比等）来设置。 文本 属性文本的显示格式与式样对于网页设计师来说是一个重要问题。这一节将向你介绍 CSS 在文本布局方面令人激动的特性。本节将对下列 CSS 属性进行讲解： • text-indent• text-align• text-decoration• letter-spacing• text-transform 文本缩进[text-indent]：CSS 属性 text-indent 用于为段落设置首行缩进，以令其具有美观的格式。 文本对齐[text-align]：CSS 属性 text-align 与 HTML 属性 align 的功能相同。该属性的值可以是：left（左对齐）、 right（右对齐）或者 center（居中）。 文本装饰[text-decoration]：CSS 属性 text-decoration 令我们可以为文本增添不同的“装饰”或“效果”。 字符间距[letter-spacing]：CSS 属性 letter-spacing 用于设置文本的水平字间距。 文本转换[text-transform]：CSS 属性 text-transform 用于控制文本的大小写。无论字母本来的大小写，你可以通过该属性令它首字母大写（capitalize）、全部大写（uppercase）或者全部小写（lowercase）。 使用样式表美化页面熟悉显示属性：display熟悉边框属性：Border , border-style 等熟悉定位属性：top , Width , Height , Left 显示 属性显示属性允许使用四个值中的一个来定义一个元素：block ：在元素的前和后都会有换行inline ：在元素的前和后都不会有换行list-item ：与 block 相同，但增加了目录项标记none ：没有显示 边框 属性边框（border）可以有多种用途，比如作为装饰元素或者作为划分两物的分界线。在设置边框方面，CSS 为你提供了无尽选择。 • border-width• border-color• border-style 边框宽度[border-width]：边框宽度由 CSS 属性 border-width 定义，其值可以是“thin”（薄）、“medium”（普通 ）或“thick”（厚）等，也可以是像素值。 边框颜色[border-color]：CSS 属性 border-color 用于定义边框的颜色。其值就是正常的颜色值，例如：“#123456”、“rgb(123,123,123)”、“yellow”等。 边框样式[border-style]：边框样式有多种可供选择。 缩写[border]：跟许多其他属性一样，你也可以将有关边框的 CSS 属性缩写为一个 border 属性。 相对定位：要对元素进行相对定位，应将 position 属性的值设为relative。绝对定位与相对定位的区别在于计算位置的方式。 采用相对定位的元素，其位置是相对于它在文档中的原始位置计算而来的。这意味着 ，相对定位是通过将元素从原来的位置向右、向左、向上或向下移动来定位的。采用相对定位的元素会获得相应的空间。 HTML 中框架、层的运用掌握框架结构掌握组织元素：span 和 div 框架使用框架，可以在一个浏览器窗口中显示不止一个 HTML 文档。这样的 HTML 文档被称为框架页面，它们是相互独立的。： 使用框架的不利因素有： • 网站开发者需要关心更多 HTML 文档的情况。• 打印整个页面变得困难。 frameset 标签： • 标签定义了如何将窗口拆分成框架。• 每个 frameset 标签定义了一组行和列。• 行/列的值指明了每个行/列在屏幕上所占的大小 frame标签： • 标签定义了每个框架中放入什么文件。 基本注意点——有用的技巧： 假如一个框架有可见边框，用户可以拖动边框来改变它的大小。如果不想让用户改变大小，可以在标签中加入：noresize=”noresize”。给不支持框架的浏览器写上标签。 内联框架：1234567&lt;html&gt;&lt;body&gt;&lt;iframe src=&quot;intro.htm&quot;&gt;&lt;/iframe&gt;&lt;p&gt;Some older browsers don&apos;t support iframes.&lt;/p&gt;&lt;p&gt;If they don&apos;t, the iframe will not be visible.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 组织元素 ： span 和 和 divspan 和 div 元素用于组织和结构化文档，并经常联合 class 和 id 属性一起使用。 用 span 组织元素： span 元素可以说是一种中性元素，因为它不对文档本身添加任何东西。但是与 CSS 结合使用的话，span 可以对文档中的部分文本增添视觉效果。 XML 基本知识XML 的应用范围人类一直在不断地尝试改进自己的发明，其中也包括人类最伟大的发明——文字的构成。第一个文本处理系统是用纸笔记录文字。现在，计算机文本处理器已经取代了手工处理，它不仅包含原始文档，还负责设置格式、出版和管理。在这些方便的功能整合到字处理之前，是由排字工人遵循书面标记说明来完成所有格式编排的。正是利益于这种实践，人们将“标记”这个词加入到 HTML 和 XML。顾名思义，标记是指加上记号。文本处理环境（如 XML）中使用了相同的标记过程。 使用脚本语言或 DHTML 能够以各种方式显示信息。这就要求必须为相同的输出编写不同的代码以供不同的浏览器使用，因为这些语言不能跨浏览器兼容。 XML（eXtensible Markup Language，可扩展标记语言）克服了这些缺点。顾名思义，XM L是可扩展的，即开发人员可以定义自己的一组标签，并使其他的人或程序能够理解这些标签。 HTML 是单标记语言，为特定应用设计，而 XML 则是一系列的标记语言。因此 ，XML 比 HTML 灵活得多。 实际上，由于 XML 标签表示了数据的逻辑结构，不同的应用可以通过不同的方式来解释和使用这些标签。Web 上的数据大多是继承的，XML 继承了 SGML 和 HTML 的优点。也就是说，它不仅继承了 SGML 的特色，还结合了 HTM L的特色。 它采用了 SGML 的主要框架，有时，人们也将 XML 称为 SGML 的子集。因此 ，HTML 是 SGML 的应用，而 XML 是 SGML 的子集。 使用标签对文档进行标记以提供有关内容的信息，不仅能加快搜索速度，而且还能降低网络流量。XML 是由 SGML 修整并改造而来，它是一种元语言，用于描述其他语言。 我们可以使用 XML 为特定目的创建自己的标记语言（如化学标记语言）。 XML 是基于文本的格式，允许开发人员描述结构化数据并在各种应用之间发送和交换这些数据，这样客户端就可以显示并自定义数据。 XML 还有助于在服务器之间传输结构化数据。 有许多信息是分布在不同的和不匹配的数据库中。 如有必要，XML 允许通过使用自定义格式来标识、交换和处理这些数据库可以理解的数据。 XML 和 HTML 有许多相同点和不同点。XML描述数据，如城市名称、温度和气压；HTML定义描述数据显示方式的标签，如使用项目符号列表或表格。 但 XML 允许开发人员定义任意数量的标签集，使用开发人员有很大的灵活性来决定要使用哪些数据，并确定数据的适用标准或自定义标签。 L XML 的 文档 结构XML 文档是由一组使用唯一名称标识的实体组成。 所有文档都以根或文档实体开始，而且所有实体都是可选的。 实体可以被视为更复杂功能的别名。单个实体名称可以代替许多文本。 在别名方案中，每当需要引用某个文本时，只需要使用别名，处理器会展开别名的内容。 XML 文档也有一种逻辑结构。 ok,完]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[必背面试题]]></title>
    <url>%2F2018%2F05%2F16%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 1 抽象类和接口的区别? 抽象类： 1）抽象方法，只有行为的概念，没有具体的行为实现。使用abstract关键字修饰，没有方法体。子类必须重写这些抽象方法。2）包含抽象方法的类，一定是抽象类。3）抽象类只能被继承，一个类只能继承一个抽象类。 接口： 1）全部的方法都是抽象方法，属型都是常量2）不能实例化，可以定义变量。3）接口变量可以引用具体实现类的实例4）接口只能被实现，一个具体类实现接口，必须实现全部的抽象方法5）接口之间可以多实现6）一个具体类可以实现多个接口，实现多继承现象 列举你所知道的线程同步的方法wait():让线程等待。将线程存储到一个线程池中。 notify()：唤醒被等待的线程。通常都唤醒线程池中的第一个。让被唤醒的线程处于临时阻塞状态。 notifyAll(): 唤醒所有的等待线程。将线程池中的所有线程都唤醒。 简述String和StringBuffer、ArrayList和LinkedList、HashMap和HashTable的特点及区别。答: String 对象的长度一旦定义就固定就不可以改变， 对于已经存在的String对象的修改都是创建一个新的对象， 然后把新的值存进去, String类不能被继承。 StringBuffer是一个可变对象， 当对它进行修改的时候不会像String那样重新建立对象。 它只能通过构造函数来建立对象。 另外StringBuffer还是一个线程安全的类。 ArrayList是实现了基于动态数组的数据结构用于，LinkedList基于连表的数据结构， 二者都可以存储对象的引用。 对于随机访问get和set，ArrayList优于LinkedList， 因为LinkedList要移动指针。 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 HashMap是Hashtable的轻量级实现（非线程安全的实现）， 他们都完成了Map接口， 主要区别在于HashMap允许空（null）键值（key）, 由于非线程安全，在只有一个线程访问的情况下，效率要高于Hashtable。 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。 因为contains方法容易让人引起误解。 Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。 最大的不同是， Hashtable的方法是Synchronize的，而HashMap不是， 在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap 采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 就HashMap与HashTable主要从三方面来说。 一. 历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现二. 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的三. 值：只有HashMap可以让你将空值作为一个表的条目的key或value 什么是java序列化，如何事件java序列化序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。 可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决在对对象流进行读写操作时所引发的问题。 1234567891011121314public class Cat implements Serializable ｛｝……Try&#123; FileOutputStream fos = new FileOutputStream(&quot;catDemo.out&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); System.out.println(&quot; 1&gt; &quot; + cat.getName()); cat.setName(&quot;My Cat&quot;); oos.writeObject(cat); oos.close(); &#125;catch(Exception e)&#123;……&#125;…… 多线程有几种实现方式，同步有几种实现方式，stop()和suspend()方法为什么不推荐使用多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 同步的实现方面有两种，分别是synchronized,wait与notify” 反对使用stop()，是因为它不安全。 它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。 结果很难检查出真正的问题所在。 suspend()方法容易发生死锁。 调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。 此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。 对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。 所以不应该使用suspend()，而应在自己的 Thread类中置入一个标志， 简述你对java反射机制的理解JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性 写下你对多线程的理解，怎么创建一个线程以及线程同步的方法。1.多线程是操作系统的重要部分，可以提高应用程序的效率，将耗时操作放进工作线程，可以有效提高用户体验。 2.new Thread().start，在方法中重写run方法；新建类实现Runable接口，重写其抽象方法 3.public static synchronized void test() { } public void test2() { synchronized(lock){ }} 从操作系统角度请阐述一下线程与进程的区别答： 进程是系统进行资源分配和调度的一个独立单位，线程是CPU调度和分派的基本单位 进程和线程的关系： （1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 （2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。 （3）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 （5）线程是指进程内的一个执行单元，也是进程内的可调度实体。 线程与进程的区别： （1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。 （2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。 （3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。 （4）系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。 Android系统的架构，采用了分层的架构，从高层到底层分别是：1.Android系统架构之应用程序 Android会同一系列核心应用程序包一起发布，该应用程序包包括email客户端，SMS短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA语言编写的。 2.Android系统架构之应用程序框架 开发人员可以完全访问核心应用程序所使用的API框架（android.jar）。该应用程序的架构设计简化了组件的重用;任何一个应用程序都可以发布它的功能块并且任何其它的应用程序都可以使用其所发布的功能块。 3.Android系统架构之系统运行库 1)程序库Android 包含一些C/C++库，这些库能被Android系统中不同的组件使用。它们通过 Android 应用程序框架为开发者提供服务。 4.Android系统架构之Linux 内核 Android 的核心系统服务依赖于 Linux 2.6 内核，如安全性，内存管理，进程管理， 网络协议栈和驱动模型。 Linux 内核也同时作为硬件和软件栈之间的抽象层。 消息推送的方式有哪几种，每种方式的优缺点是什么？前Android上主要的推送实现方案有以下几种： 方案1、使用极光和友盟推送。 方案2、使用XMPP协议（Openfire + Spark + Smack） 简介：基于XML协议的通讯协议，前身是Jabber，目前已由IETF国际标准化组织完成了标准化工作。 优点：协议成熟、强大、可扩展性强、目前主要应用于许多聊天系统中，且已有开源的Java版的开发实例androidpn。 缺点：协议较复杂、冗余（基于XML）、费流量、费电，部署硬件成本高。 方案3、使用MQTT协议（更多信息见：http://mqtt.org/） 简介：轻量级的、基于代理的“发布/订阅”模式的消息传输协议。 优点：协议简洁、小巧、可扩展性强、省流量、省电，目前已经应用到企业领域（参考：http://mqtt.org/software），且已有C++版的服务端组件rsmb。 缺点：不够成熟、实现较复杂、服务端组件rsmb不开源，部署硬件成本较高。 方案4、使用HTTP轮循方式 简介：定时向HTTP服务端接口（Web Service API）获取最新消息。 优点：实现简单、可控性强，部署硬件成本低。 缺点：实时性差。 android的数据存储的方式?答： Android提供了5种方式存储数据： （1）使用SharedPreferences存储数据； 它是Android提供的用来存储一些简单配置信息的一种机制，采用了XML格式将数据存储到设备中。只能在同一个包内使用，不能在不同的包之间使用。 （2）文件存储数据； 文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。 （3）SQLite数据库存储数据； SQLite是Android所带的一个标准的数据库，它支持SQL语句，它是一个轻量级的嵌入式数据库。 （4）使用ContentProvider存储数据； 主要用于应用程序之间进行数据交换，从而能够让其他的应用保存或读取此Content Provider的各种数据类型。 （5）网络存储数据； 通过网络上提供给我们的存储空间来上传(存储)和下载(获取)我们存储在网络空间中的数据信息。 横竖屏切换时候activity的生命周期?不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新 调用各个生命周期，只会执行onConfigurationChanged方法 Android中动画分为哪几类?他们的特点和区分有那些?一种是tweened animation(补间动画) 一种是frame by frame(逐帧动画) 特点： 补间动画是通过改变view的大小、旋转的角度、透明度、位置来产生动画，可以控制动画的播放快慢以及加速度。 逐帧动画是用一组图片轮流绘制，产生动画的感觉。类似于gif图片。 区别： 补间动画的所有操作是通过矩阵变换对同一个物体（绘制的一个view或者图片）进行操作产生动画。 而逐帧动画是多个物体（多张图片）进行绘制，可以说这多张图片是不相关的（从播放的角度来看只能说是内容相关）。 请解释下在单线程模式中Message,Handler,MessageQueue,Looper之间的关系解释下.Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理. Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列. Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息. Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。 Looper也把消息队列里的消息广播给所有的Handler：Handler接受到消息后调用handleMessage进行处理. 说说mvc模式的原理,它在android中的运用答： android的官方建议应用程序的开发采用mvc模式。何谓mvc？ mvc是model,view,controller的缩写，mvc包含三个部分： l模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。 2视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。 3控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，想用用户出发的相关事件，交给m哦得了处理。 在android中mvc的具体体现如下： 1)视图层（view）： 一般采用xml文件进行界面的描述， 使用的时候可以非常方便的引入，当然，如何你对android了解的比较的多了话，就一定 可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通 信，幸运的是，android提供了它们之间非常方便的通信实现。 2)控制层（controller）： android的控制层的重 任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理， 这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。 3)模型层（model）： 对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。 请描述下Activity的生命周期.onCreate(Bundle savedInstanceState)：创建activity时调用。 设置在该方法中，还以Bundle的形式提供对以前储存的任何状态的访问！ onStart()：activity变为在屏幕上对用户可见时调用。 onResume()：activity开始与用户交互时调用（无论是启动还是重新启动一个活动，该方法总是被调用的）。 onPause()：activity被暂停或收回cpu和其他资源时调用，该方法用于保存活动状态的，也是保护现场，压栈吧！ onStop()：activity被停止并转为不可见阶段及后续的生命周期事件时调用。 onRestart()：重新启动activity时调用。该活动仍在栈中，而不是启动新的活动。 OnDestroy()：activity被完全从系统内存中移除时调用该方法 Android中4大组件有哪些?他们的作用是什么?Activity： Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑。 service： 后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事务，定义好需要接受的Intent提供同步和异步的接口。 Content Provider： 是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的接口模型，大大简化上层应用，对数据的整合提 供了更方便的途径。 BroadCast Receiver： 接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型。 Activity有哪4种启动模式?有哪些特点?standard 默认模式 ——— 来了intent，每次都创建新的实例。 singleTop ——– 来了intent, 每次都创建新的实例，仅一个例外：当栈顶的activity恰恰就是该activity的实例（即需要创建的实例)时，不再创建新实例。 这解决了栈顶复用问题，想一想，你按两次back键，退出的都是同一个activity，这感觉肯定不爽。 singleTask ———- 来了intent后，检查栈中是否存在该activity的实例，如果存在就把intent发送给它，否则就创建一个新的该activity的实例，栈中只能有它一个该activity实例，但允许其他activity加入该栈。解决了在一 个task中共享一个activity。 singleInstance ———– 肯定位于一个task的栈底,并且是该栈唯一的activity。解决了多个task共享一个activity。 注册广播有几种方式,这些方式有何特点?1)动态代码注册不是常驻型广播，也就是说广播跟随程序的生命周期。 2)清单文件注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。 谈谈对android内存优化的方法,方案,规则及对内存泄漏如何避免OOM即Out Of Memory,一般是由程序编写者对内存使用不当，如对该释放的内存资源没有释放，导致其一直不能被再次使用而使内存被耗尽的现象。根本的解决办法是对代码进行优化:在内存引用上做些处理，使用软引用、虚引用、和弱引用；在内存中加载图片时直接在内存中做处理，如边界压缩等；建立动态回收内存机制；优化Dalvik虚拟机的堆内存分配；自定义堆内存大小等。 一般而言，android中常见的原因主要有以下几个： 1.数据库的cursor没有关闭。2.构造adapter没有使用缓存contentview。3.调用registerReceiver()后未调用unregisterReceiver().4.未关闭InputStream/OutputStream。5.Bitmap使用后未调用recycle()。6.Context泄漏。7.static关键字等。 启动service有几种方式，说出他们之间的主要区别答： 调用startService()：通过此种方法启动的service会一直运行在后台直到stopService()或stopSelf()方法被调用。 调用bindService()：通过此种方法启动的service会与调用者绑定，如果这个service还没有被启动，那么service启动时将不会调用onStart()，只调用onCreate()和onBind()，调用者被销毁时，service也被销毁 intent.putExtra时，如果传递的不是基本类型，而是一个”Object”，那么对这个对象有什么要求？还是说任何对象都可以进行传递？答： 必须实现Serializable接口，或者实现Parcelable接口的对象才可以进行传递。 当调用startActivityForResult时，如何获取并处理返回的结构答： 通过onActivityResult(int requestCode, int resultCode, Intent data)处理返回的数据requestCode：调用startActivityForResult(Intent intent, int requestCode)时传递过去的请求码。 resultCode：被调用的Activity执行setResult(int resultCode, Intent intent)时传递的结果码，一般有RESULT_CANCELED，RESULT_OK等，用于区分被调用的Activity传回的不同结果 data：被调用的Activity传回来的数据，可以用data.getExtras()得到数据，用Bundle类型的变量来接收，调用get…(String key)来获取对应的值 使用startService（）和bindService（）启一个Service，这个Sercice的生命周期会有哪里不同？ 答: 1.Context.startService()方式的生命周期： 启动时，startService –&gt; onCreate() –&gt; onStart()停止时，stopService –&gt; onDestroy() 如果调用者直接退出而没有停止Service，则Service 会一直在后台运行 Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法， 接着调用onStart()方法。 如果调用startService()方法前服务已经被创建， 多次调用startService()方法并不会导致多次创建服务， 但会导致多次调用onStart()方法。 采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法附代码 2.Context.bindService()方式启动： ①Context.bindService()方式的生命周期： 绑定时,bindService -&gt; onCreate() –&gt; onBind()调用者退出了， 即解绑定时,Srevice就会unbindService –&gt;onUnbind() –&gt; onDestory() Context.bindService()方式启动 Service的方法： 绑定Service需要三个参数：bindService(intent, conn, Service.BIND_AUTO_CREATE); 第一个：Intent对象 第二个：ServiceConnection对象， 创建该对象要实现它的onServiceConnected()和 onServiceDisconnected()来判断连接成功或者是断开连接 第三个：如何创建Service，一般指定绑定的时候自动创建。 Android中什么是ANR,如何应对或者如何避免它？答: ANR 就是application not responding 在android中Activity的最长执行时间是5秒. BroadcastReceiver的最长执行时间则是10秒. 超出执行时间就会产生ANR. 解决方法: 运行在主线程里的任何方法都尽可能少做事情。 特别是，Activity应该在它的关键生命周期方法 （如onCreate()和onResume()）里尽可能少的去做创建操作。（可以采用重新开启子线程的方式，然后使用Handler+Message 的方式做一些操作，比如更新主线程中的ui等） 应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。 但不再是在子线程里做这些任务（因为 BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个 Service。 AIDL 的全称是什么？如何工作？能处理哪些类型的数据？ 答: AIDL: (Android Interface Definition Language)跨进程通信传输语言 如何工作:AIDL文件由自己定义,在被绑定的Service中和绑定的客户端中都要部署 1.创建AIDL文件, 在这个文件里面定义接口, 该接口定义了可供客户端访问的方法和属性。2、编译AIDL文件, 用Ant的话, 可能需要手动, 使用Eclipse plugin的话,可以根据adil文件自动生产java文件并编译, 不需要人为介入.3、在Java文件中, 实现 AIDL中定义的接口. 编译器会根据AIDL接口, 产生一个JAVA接口。这个接口有一个名为Stub的内部抽象类，它继承扩展 了接口并实现了远程调 用需要的几个方法(是Binder的子类)。 接下来就需 要自己去实现自定义的几个接口了. 4.第一个程序的Service:因为跨进程传递时利用Binder对象来实现的,所以我们要在Service端构建Binder对象,又因为我们定义的接口AIDL文件在编译转成.java时的内部类Sub实现了Binder,所以我们构建Binder对象时构建实例内部类直接继承Sub内部类,在类中我们可以调用Service中的方法,此类的对象也就是Binder对象. 5.第二个程序的Activity:在Activity中我们利用bindService方法启动一个绑定的Service的同时需要传入连接对象,所以我们先在Activity中构建Service的连接对象,在该对象的匿名内部类中重写获得Binder对象的方法,参数含有Binder对象,将此对象强制转换成我们在Service中继承Sub的类的对象,强转后我们可以利用该对象调用Service中的方法,从而实现跨进程通信,控制Service. 请简单介绍一下NDK。NDK全称：Native Development Kit。 1、NDK是一系列工具的集合。 NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。 你后台的Activity被系统回收怎么办：当你的程序中某一个Activity A 在运行时中，主动或被动地运行另一个新的Activity B 这个时候A会执行Java代码 publicvoid onSaveInstanceState(Bundle outState) {super.onSaveInstanceState(outState);outState.putLong(“id”, 1234567890);}public voidonSaveInstanceState(Bundle outState) { B 完成以后又会来找A, 这个时候就有两种情况，一种是A被回收，一种是没有被回收，被回 收的A就要重新调用onCreate()方法，不同于直接启动的是这回 onCreate()里是带上参数 savedInstanceState，没被收回的就还是onResume就好了。 savedInstanceState是一个Bundle对象，你基本上可以把他理解为系统帮你维护的一个Map对象。在onCreate()里你可能会用到它，如果正常启动onCreate就不会有它，所以用的时候要判断一下是否为空。 Java代码if(savedInstanceState !=null){long id =savedInstanceState.getLong(“id”);}if(savedInstanceState !=null){就像官方的Notepad教程里的情况，你正在编辑某一个note，突然被中断，那么就把这个note的id记住，再起来的时候就可以根据这个id去把那个note取出来。 怎么优化listview1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。4、设置listview的监听器，如果listview是飞快滑动状态则不更新view 根据自己的理解描述下Android数字签名。(1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序 (2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证 (3)如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名。 (4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。 简述Android root机制答: root指的是你有权限可以再系统上对所有档案有 “读” “写” “执行”的权力。root机器不是真正能让你的应用程序具有root权限。它原理就跟linux下的像sudo这样的命令。在系统的bin目录下放个su程序并属主是root并有suid权限。则通过su执行的命令都具有Android root权限。当然使用临时用户权限想把su拷贝的/system/bin目录并改属性并不是一件容易的事情。这里用到2个工具跟2个命令。把busybox拷贝到你有权限访问的目录然后给他赋予4755权限，你就可以用它做很多事了。 进程间通信机制，传统IPC 和 Binder答: 传统的进程间通信机制IPC 有管道（Pipe）、信号（Signal）和跟踪（Trace），这三项通信手段只能用于父进程和子进程之间，或者兄弟进程之间；后来又增加了命令管道（Named Pipe）,使得进程间通信不再局限于父子进程或兄弟进程之间。后来又出现了报文队列（Message）、共享内存（Share Memeory）和信号量（Semaphore）。Android系统没有采用上述提到的各种进程间通信机制，而是采用Binder机制，它是基于OpenBinder来实现的。它提供了远程过程调用（RPC）功能，在Android系统的Binder机制中，有一系列组件组成包括 Client、Server、ServiceManager和Binder驱动程序。 Serializable和Parcelable的特点及比较答: Serializable和Parcelable二者都是实现序列化的接口。Parcelable,定义了将数据写入Parcel，和从Parcel中读出的接口。一个实体（用类来表示），如果需要封装到消息中去，就必须实现这一接口，实现了这一接口，该实体就成为“可打包的”了。 一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才是可序列化的。 因此如果要序列化某些类的对象，这些类就必须实现Serializable接口。而实际上，Serializable是一个空接口，没有什么具体内容，它的目的只是简单的标识一个类的对象可以被序列化。Serializable的实现，只需要implements Serializable即可，这只是给对象打了一个标记，系统会自动将其序列化。 Parcelable的实现，需要在类中添加一个静态成员变量CREATOR，这个变量需要继承Parcelable.Creator接口。 比较: Serializable是Java.io中的，不可被activity中的内部类被继承，否则出错；Parcelable是Android特有的，比Serializable节省内存，可以传递Bundle对象，当我们有boolean型的变量可以现存在Bundle中。 View、surfaceView、GLSurfaceView有什么区别View： 显示视图，内置画布，提供图形绘制函数、触屏事件、按键事件函数等，必须在UI主线程内更新画面，速度较慢 SurfaceView： 基于view视图进行拓展的视图类，更适合2D游戏的开发，是view的子类，类似使用双缓机制，在新的线程中更新画面所以刷新界面速度比view快 GLSurfaceView： 基于SurfaceView视图再次进行拓展的视图类，专用于3D游戏开发的视图，是surfaceView的子类，openGL专用 你曾经用到的android手机访问服务端的方式有哪些？Android手机访问服务端的方式有两种，分别是：通过socket访问和通过Http协议发送Post和Get请求。 Socket是长连接，服务端和客户端之间通过Socket建立连接，首先ServerSocket将在服务端监听某个端口，当发现客户端有Socket来试图连接它时，它会接受该Socket的连接请求，同时在服务端建立一个对应的Socket与之进行通信。这样就有两个Socket了，客户端和服务端各一个。 发送get和post协议，通过HTTP协议建立短连接。客户端发送请求（Request），服务器端收到后根据请求的类型返回相应的响应（response）。 什么是TCP和IP，它们位于网络模型的哪层？TCP是传输控制协议，IP是internet协议， TCP在网络模型中与UDP一样同属于第二层(传输层)， IP属于三层(网络层)， IP用于确定主机在网络中的位置，而TCP与UDP用于标示不同的服务，即应用程序。 Xml和json的区别1．可读性 JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，很难分出胜负。 2可扩展性 XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。 3.编码难度 XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。 4．解码难度 XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。 5.流行度 XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。 SAX 、DOM4J 、PULL解析的区别Sax特点 1. 解析效率高，占用内存少 2.可以随时停止解析 3.不能载入整个文档到内存 4.不能写入xml 5.SAX解析xml文件采用的是事件驱动 pull与sax的不同之处 1.pull读取xml文件后触发相应的事件调用方法返回的是数字。 2.pull可以在程序中控制，想解析到哪里就可以停止到哪里 3.Android中更推荐使用pull解析 DOM的特点 &gt;优点 1.整个文档树在内存中，便于操作；支持删除、修改、重新排列等多种功能 2.通过树形结构存取xml文档 3.可以在树的某个节点上向前或向后移动 &gt;缺点 1.将整个文档调入内存（包括无用的节点），浪费时间和空间 &gt;适用场合 一旦解析了文档还需多次访问这些数据；硬件资源充足（内存，cpu） ok]]></content>
      <categories>
        <category>我的书籍</category>
      </categories>
      <tags>
        <tag>我的书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试题总结]]></title>
    <url>%2F2018%2F05%2F15%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 Android面试题总结 1.简述Activity的生命周期？ 1）Activity的生命周期通过7个生命周期方法onCreate(),onRestart(),onStart(),onResume(),onPause(),onStop(),onDestroy()来体现。 2）其中6个生命周期方法是成对对应起来的,哪里创建的对象，一般应该在其对应的方法中销毁。 onCreate() – onDestroy()onStart() – onStop()onResume() – onPause() 3）当程序启动之后，第一个Activity经过的生命周期方法是：onCreate() →onStart() → onResume()方法, 当第一个ActivityA启动第二个Activity B的时候 (备注:第二个Activity完全遮盖住第一个Activity，并且这个过程中没有出现点击Home键，或者第一个Activity被杀死等异常情况，并且两个Activity的启动模式是标准模式)， 这两个Activity经历的生命周期方法是： A onPause() → B onCreate() → B onStart() → B onResume() → A onStop() → (此时Activity A已经在回退栈的最低端， Activity B已经在Activity A的上面，在回退栈的最顶端) 当通过点击后退键退出Activity B的时候： (此时Activity B 弹出回退栈) → B onPause() → A onRestart() → A onStart() → A onResume() → B onStop() → B onDestroy() 此时B被销毁 简述Service的生命周期？ 1).如果在Activity中通过调用 startService() 方法启动一个Service的话，那么生命周期是： onCreate() → onStartCommand() → 运行中 → (如果自己或者客户端(如Activity)调用了stop Service的方法的话) → onDestroy() 2).如果在Activity中通过调用 bindService() 方法启动一个Service的话，那么生命周期是： onCreate() → onBind() → 运行中 → (如果有客户端(Activity)调用了unBindService()方法与Service解除绑定时) → onUnbind() → onDestroy() 有几种控件布局的方式？ 1）RelativeLayout:相对布局，可以根据相对位置来调整控件的位置。推荐使用相对布局，更利于屏幕的自适应。 2）LinearLayout:线性布局，控件之间的水平排列或者垂直排列。但是如果要想构建复杂布局，要进行多层的LinearLayout布局嵌套，但是这样会运行布局载入效率。 3）FrameLayout:帧布局，控件与控件之间处于上下叠加的状态。 备注：还有两个已经不怎么用的布局：TableLayout：表格布局 AbsoluteLayout 绝对布局。 布局实现方式有两种：xml文件静态实现，代码动态实现。 一般xml文件中可以实现布局控制的话，就不建议放在代码中实现布局控制，因为在xml文件中实现布局控制，可以做到布局与代码分离。 4.有几种数据存储方式，分别是什么？ 1）SQLite数据库存储结构化数据。 2）文件存储：分为内部存储和外部存储(SD卡)两种存储方式。 3）SharedPreferences共享参数，键值对形式存储。 4）网络存储。 5.IntentService与Service有什么区别？ IntentService是Service的子类 1）Service如果要处理异步请求(如耗时操作)的话， 需要自己启动一个worker thread, 如果启动多个worker thread来处理相关事务的话，各线程之间无法很好的控制。 而IntentService可以将多个异步请求的Intent放入队列中，封装了一个开启worker thread的onHandleIntent()方法，来依次处理放入队列中的Intent，只有一个worker thread在运行，同一时刻只有一个Intent被处理，当一个Intent处理完了之后才会处理另外一个Intent。 2）Service可以通过startService()或者bindService()方法来启动， 而IntentService则是通过startService()方法来启动。 3）Service适合多线程处理异步请求。 而IntentService则适合处理需要排队的请求。 6.StartService与bindService之间的区别？ 1）StartService启动了Service之后无法与Activity之间进行通信，与现有的Activity分离，即使Activity被杀掉了之后，Service还可以运行，同时通过设置Service的粘性，还可以让Service被杀掉之后，可以自启动。而bindService启动Service之后，与绑定的Activity之间有关系，可以依据Server/Client模式来进行通信(binder客户端主动请求模式，或者通过信使)，但是无法设置Serrvice的粘性。 2) StartService启动的Service,Activity中可以调用stopService()方法来结束一个Service，或者通过Service自己调用stopSelf()方法来结束Service。而bindService只能通过Activity()来调用unbindService()方法来结束Service，Service会调用onUnBind()方法，以及onDestroy()方法。 7.ArrayAdapter BaseAdapter CursorAdapter的区别？ ArrayAdpter CursorAdapter都是BaseAdapter的子类。都是用来填充那些含有item的控件。 1）主要区别是数据来源不同。 ArrayAdapter数据来源是Object数组，CursorAdapter数据来源是数据库的Cursor,而BaseAdapter适合创建复杂自定义的item内容， 通过继承BaseAdapter类，重写相关方法来实现。 8.Handler与Looper之间的关系? 1) Handler和Looper的关系就好比，坐地铁过安检时候：每一个人可以理解为一个Handler，一个人的一个或者多个东西看做Message而循环滚动的检查台装置可以看做是Looper，而要检查的东西排成队列可以理解为MessageQueue消息队列。 2)Looper是Handler和MessageQuene之间的桥梁，Looper将Handler发送过的消息放入MessageQueue,同时Looper也将MessageQueue中的Message发送给Handler来处理。 9.res文件夹与assets文件夹有什么区别? 1)res文件夹中的资源在会在R.java文件中生成ID，代码中可以直接通过R.id的形式来访问。 而assets文件夹中的资源不会在R.java文件中生成ID, 需要通过AssetsManager通过IO流的方式来访问。 2)res文件夹中的文件会被压缩， 而assets文件中的文件不会被压缩。 3)Res不能自定义目录名，不支持多层目录。 而assets支持自定义目录名，支持多层目录。 10.广播接收器有几种注册方式，分别是什么？ 1)动态注册：在代码中注册，创建一个IntentFilter(意图过滤器)对象，设置想要就收的广播，在onCreate()方法中通过调用registerReceiver()方法来注册广播接收器，在onDestroy()方法中通过调用unregisterReceiver()方法来注销广播接收器。 2)静态注册：在AndroidManifest.xml文件中注册，标签注册类，通过标签中的来过滤意图。静态注册的好处是，当程序关闭或者没有打开的时候，同样可以接收相关的广播。比如实现开机启动。 ok]]></content>
      <categories>
        <category>我的书籍</category>
      </categories>
      <tags>
        <tag>我的书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java就业面试题大全]]></title>
    <url>%2F2018%2F05%2F14%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 仅供学习 1、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。 2、Java有没有goto?java中的保留字，现在没有在java中使用。 3、说说&amp;和&amp;&amp;的区别。&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。 &amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式 4、在JAVA中如何跳出当前的多重嵌套循环？ 在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。 5、switch语句能否作用在byte上，能否作用在long上，能否作用在String上? 由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。 6、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? 对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。 7、char型变量中能不能存贮一个中文汉字?为什么? char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。 8、用最有效率的方法算出2乘以8等於几? 2 &lt;&lt; 3，因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 &lt;&lt; 3。 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ 使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，123456对于如下语句： final StringBuffer a=new StringBuffer(&quot;immutable&quot;);执行如下语句将报告编译期错误：a=new StringBuffer(&quot;&quot;);但是，执行如下语句则可以通过编译：a.append(&quot; broken!&quot;); 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：123public void method(final StringBuffer param)&#123;&#125; 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象： param.append(“a”); “==”和equals方法究竟有什么区别？==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。 equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。 静态变量和实例变量的区别？在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。 是否可以从一个static方法内部发出对非static方法的调用？ 不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部发出对非static方法的调用。 Integer与int的区别 int是java提供的8种原始数据类型之一。Java为每个原始类型提供了封装类，Integer是java为int提供的封装类。int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer。在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型。 下面的代码有什么不妥之处?1231. if(username.equals(“zxx”)&#123;&#125;2. int x = 1; return x==1?true:false; abstract class和interface有什么区别? 含有abstract修饰符的class即为抽象类，abstract 类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。 下面比较一下两者的语法区别：1.抽象类可以有构造方法，接口中不能有构造方法。2.抽象类中可以有普通成员变量，接口中没有普通成员变量3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 抽象类中可以包含静态方法，接口中不能包含静态方法 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 一个类可以实现多个接口，但只能继承一个抽象类。 什么是内部类？Static Nested Class 和 Inner Class的不同。 内部类就是在一个类的内部定义的类，内部类中不能定义静态成员（静态成员不是对象的特性，只是为了找一个容身之处，所以需要放到一个类中而已，这么一点小事，你还要把它放到类内部的一个类中，过分了啊！提供内部类，不是为让你干这种事情，无聊，不让你干。我想可能是既然静态成员类似c语言的全局变量，而内部类通常是用于创建内部对象用的，所以，把“全局变量”放在内部类中就是毫无意义的事情，既然是毫无意义的事情，就应该被禁止），内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中. jdk中哪些类是不能继承的？不能继承的是类是那些用final关键字修饰的类。一般比较基本的类型或防止扩展类无意间破坏原来方法的实现的类型都应该是final的，在jdk中System,String,StringBuffer等都是基本类型。 String是最基本的数据类型吗?基本数据类型包括byte、int、char、long、float、double、boolean和short。java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类 是否可以继承String类?String类是final类故不可以继承。 String 和StringBuffer的区别 JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。String类表示内容不可改变的字符串。而StringBuffer类表示内容可以被修改的字符串。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。另外，String实现了equals方法，new String(“abc”).equals(new String(“abc”)的结果为true,而StringBuffer没有实现equals方法，所以，new StringBuffer(“abc”).equals(new StringBuffer(“abc”)的结果为false。 StringBuffer与StringBuilder的区别 StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。 如何把一段逗号分割的字符串转换成一个数组?如果不查jdk api，我很难写出来！我可以说说我的思路：1.用正则表达式，代码大概为：String [] result = orgStr.split(“,”);2.用 StingTokenizer ,代码为：StringTokenizer tokener = StringTokenizer(orgStr,”,”);String [] result = new String[tokener .countTokens()];Int i=0;while(tokener.hasNext(){result[i++]=toker.nextToken();} 数组有没有length()这个方法? String有没有length()这个方法？数组没有length()这个方法，有length的属性。String有有length()这个方法。 final, finally, finalize的区别。 final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。内部类要访问局部变量，局部变量必须定义成final类型，例如，一段代码…… finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM不保证此方法总被调用 运行时异常与一般异常有何异同？异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。 error和exception有什么区别?error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？ java5以前，有如下两种： 第一种：12345new Thread()&#123;&#125;.start();这表示调用Thread子类对象的run方法，new Thread()&#123;&#125;表示一个Thread的匿名子类的实例对象，子类加上run方法后的代码如下：new Thread()&#123; public void run()&#123; &#125;&#125;.start(); 1234567第二种：new Thread(new Runnable()&#123;&#125;).start();这表示调用Thread对象接受的Runnable对象的run方法，new Runnable()&#123;&#125;表示一个Runnable的匿名子类的实例对象,runnable的子类加上run方法后的代码如下：new Thread(new Runnable()&#123; public void run()&#123; &#125; &#125; ).start(); sleep() 和 wait() 有什么区别? （网上的答案：sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。 wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。） sleep就是正在执行的线程主动让出cpu，cpu去执行其他线程，在sleep指定的时间过后，cpu才会回到这个线程上继续往下执行，如果当前线程进入了同步锁，sleep方法并不会释放锁，即使当前线程使用sleep方法让出了cpu，但其他被同步锁挡住了的线程也无法得到执行。wait是指在一个已经进入了同步锁的线程内，让自己暂时让出同步锁，以便其他正在等待此锁的线程可以得到同步锁并运行，只有其他线程调用了notify方法（notify并不释放锁，只是告诉调用过wait方法的线程可以去参与获得锁的竞争了，但不是马上得到锁，因为锁还在别人手里，别人还没释放。如果notify方法后面的代码还有很多，需要这些代码执行完后才会释放锁，可以在notfiy方法后增加一个等待和一些代码，看看效果），调用wait方法的线程就会解除wait状态和程序可以再次得到锁后继续向下运行。对于wait的讲解一定要配合例子代码来说明，才显得自己真明白。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MultiThread &#123; public static void main(String[] args) &#123; new Thread(new Thread1()).start(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(new Thread2()).start(); &#125; private static class Thread1 implements Runnable &#123; @Override public void run() &#123; //由于这里的Thread1和下面的Thread2内部run方法要用同一对象作为监视器，我们这里不能用this，因为在Thread2里面的this和这个Thread1的this不是同一个对象。我们用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时，指向的都是同一个对象。 synchronized (MultiThread.class) &#123; System.out.println(&quot;enter thread1...&quot;); System.out.println(&quot;thread1 is waiting&quot;); try &#123; //释放锁有两种方式，第一种方式是程序自然离开监视器的范围，也就是离开了synchronized关键字管辖的代码范围，另一种方式就是在synchronized关键字管辖的代码内部调用监视器对象的wait方法。这里，使用wait方法释放锁。 MultiThread.class.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;thread1 is going on...&quot;); System.out.println(&quot;thread1 is being over!&quot;); &#125; &#125; &#125; private static class Thread2 implements Runnable &#123; @Override public void run() &#123; synchronized (MultiThread.class) &#123; System.out.println(&quot;enter thread2...&quot;); System.out.println(&quot;thread2 notify other thread can release wait status..&quot;);//由于notify方法并不释放锁， 即使thread2调用下面的sleep方法休息了10毫秒，但thread1仍然不会执行，因为thread2没有释放锁，所以Thread1无法得不到锁。 MultiThread.class.notify(); System.out.println(&quot;thread2 is sleeping ten millisecond...&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(&quot;thread2 is going on...&quot;); System.out.println(&quot;thread2 is being over!&quot;); &#125; &#125; &#125; &#125; 同步和异步有何异同，在什么情况下分别使用他们？举例说明。 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。 多线程有几种实现方法?同步有几种实现方法? 多线程有两种实现方法，分别是继承Thread类与实现Runnable接口同步的实现方面有两种，分别是synchronized,wait与notifywait():使一个线程处于等待状态，并且释放所持有的对象的lock。sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。 启动一个线程是用run()还是start()?启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。 重点MVC的各个部分都有那些技术来实现?如何实现? 答:MVC是Model－View－Controller的简写。Model 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， View 是应用的表示面（由JSP页面产生），Controller 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。 数据库部分1、用两种方式根据部门号从高到低，工资从低到高列出每个员工的信息。employee: eid,ename,salary,deptid; select * from employee order by deptid desc,salary j2ee常用的设计模式？说明工厂模式。总共23种，分为三大类：创建型，结构型，行为型我只记得其中常用的6、7种，分别是：创建型（工厂、工厂方法、抽象工厂、单例）结构型（包装、适配器，组合，代理）行为（观察者，模版，策略）然后再针对你熟悉的模式谈谈你的理解即可。 Java中的23种设计模式：Factory（工厂模式）， Builder（建造模式）， Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式）， Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），Observer（观察者模式）， State（状态模式）， Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式） J2EE是什么？答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。 一个另类的回答：j2ee就是增删改查。 J2EE是技术还是平台还是框架？ 什么是J2EE J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。 J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。 ok]]></content>
      <categories>
        <category>我的书籍</category>
      </categories>
      <tags>
        <tag>我的书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四级考试听力场景词汇大全]]></title>
    <url>%2F2018%2F05%2F13%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 仅供学习 你永远也无法找到一个比这个更全更准的听力复习资料 一、机场、飞机上、客轮 常考思路： 1) 票已售完 2) 接人(飞机)晚点 3) 送人伤感 see somebody off 常见线索词： departure 离港 sect belt 安全带 arrival 进港 pick up 接机airplane, flight 航班, direct flight直航，transfer转机，first class头等舱， economy class经济舱，circle 盘旋 wing: a.建筑物的附属楼 b.飞机的翅膀 c.鸡翅 terminal: a.终端(机房里面 Should I use this terminal?) b. =final station公交站最后一站 c.候机大厅 domestic terminal国内候机大厅，international terminal国际候机大厅 1.机场地点­ Terminal (航站楼)­ Check-in counter (换票柜台) Customs (海关)­ 机场人物­ Airhostess/stewardess (空姐) steward (空哥、空少) flight attendant (飞机乘务员)­ 飞机动作­ Take off/land (起飞、降落) ascend/descend(上升、下降)­wait for further notice等候进一步通知 minor mechanical errors轻微的机械故障 terminal候机大厅 clear up天晴起来 swing不稳定,极端 weather forecast天气预报 freezing非常冷 coupled with strong wind伴有强风 二、餐厅 1)cafeteria学校饭堂：meal card/ticket饭卡/饭票，helping一人份 2)restaurant: fancy高档的, menu菜谱, order, manager经理, waiter book/reserve预订 ，make a reservation预定 上菜顺序：soup汤——&gt; main course主菜——&gt; salad沙拉(chef salad招牌沙拉)——&gt; dessert甜点 (pudding布丁, cheese , fruit) 赞美人家做菜好吃： 1) Even my mother’s can’t match this.即使我妈妈做的也比不上这个好吃。 2) I took the last one and it was out of the world.(太好吃了以至于)我把最后一块也吃掉了。 3) You wouldn’t have to force me to help another one. 你不用叫我吃，我自己也会拿来吃的。1.点菜：­ French Fries (薯条)­ 买单：­Check the bill please!(买单！) Treat (请客) split the bill (分开付)­ 三、图书馆 1.书籍：journal 学术类刊物 (08-6)­ volume 卷 current/back issue 现/过刊 periodical 期刊­2.人物：librarian 图书管理员­ 四、Campus life 校园生活­ 课程分类 Optional course 选修课 Required course 必修课Literature 文学09-12出现的一些新课程名称：­advanced physics (高级物理)data processing (数据处理)­ computer programming (计算机程序)­be through with sth 结束，完成(两次考到)­ due 到期 have sb’s hands full with sth 忙于做某事(07-12)­apply for申请business degree商学院学位pay your own way自己支付各种费用 2. 课程形式词汇：­ Seminar(06-6、07年6月词汇，研讨会) presentation (展示或演示课，多次考到)­biology生物学 class permit听课证informative信息量大 senior(大四)(05年考点)­graduate(毕业生)undergraduate (在校生，本科生)postgraduate (研究生)­tutor(导师)graduate school (研究生院)­Position/post (职位。多次考到) recruit (招聘。连续考到) resign (退休，多次考到)­benefit (package) (福利，两次考到)paid vacation (带薪假期)­social security (美国的社会保险)phased retirement (08-12 阶段性退休)be laid off (解雇 09-12考点)­hotel consultant (08-6 酒店咨询)sales manager(08-12 销售经理)­ Administrative work (08-12 行政工作)­ promotion(升职，09-6/12连续考到)­ 4.抱怨的作业： 1)paper a.论文 b.=newspaper 报纸 c. document文件 d.纸张 写论文的步骤： a. choose a topic选题 area: The area is too board for me. 题目的范围太广了 narrow the topic down 把题目范围缩小 b. do some research 做调查 (去图书馆library 做调查) c. type it out打印 typewriter打字机，computer, lap top手提电脑， printer打印机， laser printer激光打印机， ribbon色带 2) presentation口头演讲——oral form = speech = report = address a.时间性 20分钟，一般演讲18-19分钟，留下几分钟时间别人发问 b.正式着装——formal clothes change(穿的衣服不合适就要换) You can’t go like that. You need a change.你这样穿不行，要换一套衣服。 c.内心感受——nervous (演讲前心里很害怕) 3) Reading assignment / list 阅读作业/清单 Do you think the reading list is enormous? 你觉不觉要读的书太多了? 4) Research Financial Aid经济资助 a. Tuition wavier学费减免 b. RA——Researching Assistant助研 TA——Teaching Assistant 助教 Fellowship奖学金5.缺课 缺课原因： 1) get ill 由于生病而缺课 2) oversleep睡过头了 3)traffic jam交通堵塞/ (car)break down车抛锚 .考试middle exam 期中考试 make up 补考 test测验 pop test 事先没有说好的测验 quiz 测验 oral test 口试be through with结束，完成release发布（分数） 考试临近 draw on 、 in sight of 、 draw nearly 考试延期或取消 defer / hold up / postpone / put off / suspend 酒店、宾馆与约会 make a reservation 预订房间 confirm a reservation 确认预订 cancel a reservation 取消预订 fully booked / full up / full 客满 porter 行旅员 reception 前台 check in 登记入住 single room 单人房 suite 套房 room service 客房服务 (四级听力中的客房服务一般只有考一种——送餐) lobby 大堂salon 美容厅 night club 夜总会 check out 退房 饭店 hotel clerk (07年6月词汇，等于receptionist)eat out 出去吃 take away 外带appetizer 开胃菜 main course 主食 dessert 餐后甜点 keep the change 不用找零了move on to继续 the next item下一议题个 come in one’s place代表某人来on behalf of代表 罚款 fine 校内：library里面，书过期 校外： break the traffic rules违反交通规则，go speeding超速 各种费用： fare交通费(车费，船费)， fee杂费， tuition学费， tuition and fee学杂费，rent 房租， utilities水电费，rate 按比例收取的费用， post rate=postage邮资 1．交通 常考思路： 1) 交通堵塞 traffic jam back up: a.作业堆积如山 b. 车辆很多 c. back somebody up支持某人 2) 交通违章——&gt;fine罚款 break the traffic rule违反交通规则, go speeding超速 3) 晚点 behind schedule parking lot停车场 maintain保养 break down抛锚 garage修车场 scratches刮蹭 highway高速公路 single lane单行道 No-parking sign禁止停车标志 sleeper卧铺 be supposed to应该 打电话 常考思路： 1) 约人约不到 2) 约会去不了 sth comes up/ I’d like to reschedule/ Could you fit me in (the doctor’s schedule)? 3) 电话打不通(包括打错电话) 线索词： run out of coins(在公共电话亭里)没钱了 cut off被迫断线，hang up主动挂断电话， receiver听筒，slot 电话上的小投币口 九、医院 常考思路： 1) 医生难找 2) 病情如何(getting better/worse) 3) 有病耽误课miss the class 线索词： treat治疗(表过程)， cure治疗,治愈(表结果) infirmary / students’ help center学校的医院prescribe开药方，prescription处方 Send him to Ward Three. 把他送去3号病房。 Send him toward three.把他送到东方去。(因为时钟三点指向东(上北下南左西右东) ) fill the prescription按方抓药， refill the prescription继续按方抓药，dizzy头晕 a fever发烧 have the ankle twisted扭到脚踝 blood vessel血管 (四)买东西 1．采购衣服size型号 come in all sizes号全2．采购电器model款latest technology最新的科技 1) supermarket超级市场: supplies生活用品，price tag价格签，special offer/ on sale打折，cart手推车，vender售货员，cashier收银员2) appliance家用电器, costume服装, floor 层,men’s 男装区,for sale 热卖中,待售中,70% off 三折, 十一、 阅读与写作 intensively精细地reading assignment阅读任务 selectively有选择地chapter by chapter一章一章地 theory理论read through从头到尾地读 cover a few chapters涉及了几个章节revise修订quality paper好纸 get it published出版proofread[pru:fri:d]校对 十二、.求职与工作 常考思路: 1) 找到工作高兴 2) 失去工作伤心 a.被解雇 b.离开旧工作 3) 拒绝工作令人感到奇怪 线索词 找工作的过程: 1) 信息 a. classified ads分类广告 help and wanted section供求关系栏 b. bulletin board公告栏 c. flyer传单 2) make a phone call Is the position still available? 工作职位还仍然空缺吗? 3) resume个人简历 certification 学历证, ID身份证,qualification资历, recommendation letter推荐信 fill out= fill in = fill up填表格 interview面试 interview 面试 finance金融 suit西装 accounting会计 tie领带 brush up on温习，复习 travel出差 annual vacation年假job vacancy 有空缺职位 academic background 教育背景 offer 聘用信 ask for a raise 加钱 salary 日薪 bonus奖金 allowance 津贴 promotion 升职 十三. 租房子 常考思路 live on campus 住校 live off campus 住校外 for sale 可销售的房子 for rent / lease 可出租的房子 to let 同上 utilities 公用事业费 suburb / downtown 市郊 / 市中心 leaking 漏水 blackout 断电 transportation 交通 land lord 房东 land lady 房东太太 tenant 房客 roommate 室友 好的室友：neat 整洁的 considerate 体贴的，细心的 不好的室友：messy / untidy 脏乱的 noisy 吵闹的 apartment 公寓 dorm/dormitory 寝室 for rent房子出租，rest-room厕所 十四、 理发 线索词 cut大剪，trim小修剪，bang男生刘海儿，fringe女生刘海儿，parting分头(I want parting to the left.我想要左分头。) plait 辫子 十五、医院场景 send for a doctor 让医生出诊 health center / clinic 卫生所 / 门诊部 physician 内科医生 surgeon 外科医生 make an appointment 预约 liquid 喝药水 injection =&gt; shot 注射 medical result 诊断结果 8.宾馆和约会场景 十六、邮局场景 rate 费率 overweight 超重 postage 邮资 forward the mail to把邮件转发给 cc(carbon copy) 抄送 bcc(blind carbon copy)秘密抄送 attach 附件 log in登录 log off登出 十七、其他场景 be mad with对某人生气 干杯cheers the last man 最不愿意见的人 sell off 低价处理库存商品 selling machine 自动售货机 count for little 无足轻重 count for much 举足轻重 count down 倒计时 count up 相加健忘 forgetful, absent-minded, slip one’s mind count up to 共计 短对话考前嘱咐 1. 学习——基于学生的角度，一定是抱怨学习 2. 生活——poor,很穷。 Student ID 学生证 用于discount 打折， bargain 讨价还价 3. 学习vs 生活——忙，忙于学习 长对话十大类标志词 据研究有90%以上的考点都是由标志词引导活提示的，因此在语段听力中听到下列标志词时要引起高度的重视，集中注意力听清标志词前后的句子。 1.最高级标志词 形容词、副词最高级、most / chief / primary / main / leading / …… 2.唯一级标志輯div&gt; only / unique / prefer / every / one / of all / perfect / …… 3.因果项标志词 cause / lead to / contribute to / thanks to / owing to / question / answer / why / reason / 其他形式的问句 / …… 4.转则项关键词 despite / in spite of / instead / while / from ~ to ~ / although ~ (yet)~ / not only ~ but also ~ / …… 5.序数项标志词 所有的序数词(first , second)/ another / the other / next / last / in addition / on the other hand / …… 6.时间项标志词 when / how / today / as / before / after / since / then / until / …… 7.解释项标志词 or / namely / in other words / that is / that is to say / …… 8.目的项标志词 to / for / …… 9.总结项标志词 all in all / in brief / to conclude / at last / in summary / in short / …… 10.强调项标志词 副词：especially / particularly / almost / always / usually / …… 动词：show / remember / note / notice / say / pronounce / …… ok]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android面试常考题目]]></title>
    <url>%2F2018%2F05%2F12%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 来源网络资料 1、 Android的四大组件是哪些，它们的作用？ 答： Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑，Activity：不可见，只是一种容器，view组件（UI控件，容器控件的基类）用来显示可以看到的东西。 service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事物，定义好需要接受的Intent提供同步和异步的接口 Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的接口模型，大大简化上层应用，对数据的整合提供了更方便的途径 BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型 2、 请介绍下Android中常用的五种布局。 常用五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。 一、FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。 二、LinearLayout：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）。 当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。 三、AbsoluteLayout：绝对布局用X,Y坐标来指定元素的位置， 这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。 四、RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。 主要属性有：相对于某一个元素android:layout_below、 android:layout_toLeftOf相对于父元素的地方android:layout_alignParentLeft、android:layout_alignParentRigh； 五、TableLayout：表格布局，每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素。每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。 3、 android中的动画有哪几类，它们的特点和区别是什么 答：两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。 4、 android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。 答：XML解析主要有三种方式，SAX、DOM、PULL。常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。 5、 ListView的优化方案 答： 1、如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。 2、给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。 3、如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。 6、 请介绍下Android的数据存储方式。 答： 使用SharedPreferences存储数据；文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据； Preference，File， DataBase这三种方式分别对应的目录是/data/data/Package Name/Shared_Pref, /data/data/Package Name/files, /data/data/Package Name/database 。 一：使用SharedPreferences存储数据 首先说明SharedPreferences存储方式，它是 Android提供的用来存储一些简单配置信息的一种机制， 例如：登录用户的用户名与密码。 其采用了Map数据结构来存储数据，以键值的方式存储，可以简单的读取与写入，具体实例如下： 123456789101112131415161718192021void ReadSharedPreferences()&#123;String strName,strPassword;SharedPreferences user = getSharedPreferences(“user_info”,0);strName = user.getString(“NAME”,””);strPassword = user getString(“PASSWORD”,””);&#125;void WriteSharedPreferences(String strName,String strPassword)&#123;SharedPreferences user = getSharedPreferences(“user_info”,0);uer.edit();user.putString(“NAME”, strName);user.putString(“PASSWORD” ,strPassword);user.commit();&#125; 数据读取与写入的方法都非常简单，只是在写入的时候有些区别：先调用edit()使其处于编辑状态，然后才能修改数据，最后使用commit()提交修改的数据。 实际上SharedPreferences是采用了XML格式将数据存储到设备中，在DDMS中的File Explorer中的/data/data//shares_prefs下。 使用SharedPreferences是有些限制的：只能在同一个包内使用，不能在不同的包之间使用。 二：文件存储数据 文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与 Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。具体实例如下: 123String fn = “moandroid.log”;FileInputStream fis = openFileInput(fn);FileOutputStream fos = openFileOutput(fn,Context.MODE_PRIVATE); 三：网络存储数据 网络存储方式，需要与Android 网络数据包打交道，关于Android 网络数据包的详细说明，请阅读Android SDK引用了Java SDK的哪些package？。 四：ContentProvider 1、ContentProvider简介 当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。 2、Uri类简介 Uri代表了要操作的数据，Uri主要包含了两部分信息： 1.需要操作的ContentProvider ，2.对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成： 1.scheme：ContentProvider（内容提供者）的scheme已经由Android所规定为：content://…2.主机名（或Authority）：用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。 3.路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下：要操作contact表中id为10的记录，可以构建这样的路径:/contact/10要操作contact表中id为10的记录的name字段， contact/10/name要操作contact表中的所有记录，可以构建这样的路径:/contact?要操作的数据不一定来自数据库，也可以是文件等他存储方式，如下:要操作xml文件中contact节点下的name节点，可以构建这样的路径：/contact/name如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：Uri uri = Uri.parse(“content://com.changcheng.provider.contactprovider/contact”) 3、UriMatcher、ContentUrist和ContentResolver简介 因为Uri代表了要操作的数据，所以我们很经常需要解析Uri，并从 Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher 和ContentUris 。掌握它们的使用，会便于我们的开发工作。 UriMatcher：用于匹配Uri，它的用法如下： 1.首先把你需要匹配Uri路径全部给注册上，如下： 123456//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码(-1)。UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);//如果match()方法匹配content://com.changcheng.sqlite.provider.contactprovider /contact路径，返回匹配码为1uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact”, 1);//添加需要匹配uri，如果匹配就会返回匹配码//如果match()方法匹配 content://com.changcheng.sqlite.provider.contactprovider/contact/230路径，返回匹配码为2uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact/#”, 2);//#号为通配符 2.注册完需要匹配的Uri后，就可以使用uriMatcher.match(uri) 方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用 addURI()方法传入的第三个参数，假设匹配 content://com.changcheng.sqlite.provider.contactprovider/contact路径，返回的匹配码为1。ContentUris：用于获取Uri路径后面的ID部分，它有两个比较实用的方法：withAppendedId(uri, id)用于为路径加上ID部分parseId(uri)方法用于从路径中获取ID部分ContentResolver：当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用 ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver使用insert、delete、update、query方法，来操作数据。 7、 activity的启动模式有哪些？是什么含义？ 答： 在android里，有4种activity的启动模式，分别为： “standard” (默认)“singleTop”“singleTask”“singleInstance” 它们主要有如下不同： 如何决定所属task“standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。 是否允许多个实例“standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例；“singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。 是否允许其它activity存在于本task内“singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。而另外三种模式，则可以和其它activity共存。 是否每次都生成新实例“standard”对于没一个启动Intent都会生成一个activity的新实例；“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。 比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。“singleInstance”是其所在栈的唯一activity，它会每次都被重用。“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。 当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。 8、 跟activity和Task 有关的 Intent启动方式有哪些？其含义？ 核心的Intent Flag有：FLAG_ACTIVITY_NEW_TASKFLAG_ACTIVITY_CLEAR_TOPFLAG_ACTIVITY_RESET_TASK_IF_NEEDEDFLAG_ACTIVITY_SINGLE_TOPFLAG_ACTIVITY_NEW_TASK 如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的 Activity）定义了用户可以迁移的Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。这个标志一般用于呈现“启动”类型的行为：它们提供用户一系列可以单独完成的事情，与启动它们的Activity完全无关。 使用这个标志，如果正在启动的Activity的Task已经在运行的话，那么，新的Activity将不会启动；代替的，当前Task会简单的移入前台。参考FLAG_ACTIVITY_MULTIPLE_TASK标志，可以禁用这一行为。 这个标志不能用于调用方对已经启动的Activity请求结果。 FLAG_ACTIVITY_CLEAR_TOP 如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。 例如，假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。上例中正在运行的Activity B既可以在onNewIntent()中接收到这个新的Intent，也可以把自己关闭然后重新启动来接收这个Intent。 如果它的启动模式声明为 “multiple”(默认值)，并且你没有在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，那么它将关闭然后重新创建；对于其它的启动模式，或者在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，都将把这个Intent投递到当前这个实例的onNewIntent()中。这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。 FLAG_ACTIVITY_SINGLE_TOP 如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的FLAG_ACTIVITY_BROUGHT_TO_FRONT这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 如果设置，这将在Task的Activity stack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。 这在你的程序有分割点的时候很有用。 例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个 Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 如果设置，新的Activity不会在最近启动的Activity的列表中保存。 FLAG_ACTIVITY_FORWARD_RESULT 如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的 Activity。 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY 这个标志一般不由应用程序代码设置，如果这个Activity是从历史记录里启动的（常按HOME键），那么，系统会帮你设定。 FLAG_ACTIVITY_MULTIPLE_TASK 不要使用这个标志，除非你自己实现了应用程序启动器。与FLAG_ACTIVITY_NEW_TASK结合起来使用，可以禁用把已存的Task送入前台的行为。当设置时，新的Task总是会启动来处理Intent，而不管这是是否已经有一个Task可以处理相同的事情。 由于默认的系统不包含图形Task管理功能，因此，你不应该使用这个标志，除非你提供给用户一种方式可以返回到已经启动的Task。 如果FLAG_ACTIVITY_NEW_TASK标志没有设置，这个标志被忽略。 FLAG_ACTIVITY_NO_ANIMATION 如果在Intent中设置，并传递给Context.startActivity()的话，这个标志将阻止系统进入下一个Activity时应用 Acitivity迁移动画。这并不意味着动画将永不运行——如果另一个Activity在启动显示之前，没有指定这个标志，那么，动画将被应用。这个标志可以很好的用于执行一连串的操作，而动画被看作是更高一级的事件的驱动。 FLAG_ACTIVITY_NO_HISTORY 如果设置，新的Activity将不再历史stack中保留。用户一离开它，这个Activity就关闭了。这也可以通过设置noHistory特性。 FLAG_ACTIVITY_NO_USER_ACTION 如果设置，作为新启动的Activity进入前台时，这个标志将在Activity暂停之前阻止从最前方的Activity回调的onUserLeaveHint()。 典型的，一个Activity可以依赖这个回调指明显式的用户动作引起的Activity移出后台。这个回调在Activity的生命周期中标记一个合适的点，并关闭一些Notification。 如果一个Activity通过非用户驱动的事件，如来电或闹钟，启动的，这个标志也应该传递给Context.startActivity，保证暂停的Activity不认为用户已经知晓其Notification。 FLAG_ACTIVITY_PREVIOUS_IS_TOP 1If set and this intent is being used to launch a new activity from an existing one, the current activity will not be counted as the top activity for deciding whether the new intent should be delivered to the top instead of starting a new one. The previous activity will be used as the top, with the assumption being that the current activity will finish itself immediately. FLAG_ACTIVITY_REORDER_TO_FRONT 如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。 例如，假设一个Task由四个Activity组成：A,B,C,D。 如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。 9、 请描述下Activity的生命周期。 答：activity的生命周期方法有：onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()； 可见生命周期：从onStart()直到系统调用onStop()前台生命周期：从onResume()直到系统调用onPause() 10、 activity在屏幕旋转时的生命周期 答： 不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 11、 如何启用Service，如何停用Service。 服务的开发比较简单，如下： 第一步：继承Service类public class SMSService extends Service {} 第二步：在AndroidManifest.xml文件中的节点里对服务进行配置:服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。这两个方法都可以启动Service，但是它们的使用场合有所不同。使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。 如果打算采用Context.startService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。 如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。 如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。 服务常用生命周期回调方法如下： onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。 onDestroy()该方法在服务被终止时调用。 与采用Context.startService()方法启动服务有关的生命周期方法onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。 多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。 与采用Context.bindService()方法启动服务有关的生命周期方法onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。 onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。 该方法在调用者与服务解除绑定时被调用 12、 注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。 答：首先写一个类要继承BroadcastReceiver 第一种:在清单文件中声明,添加 第二种使用代码进行注册如: 123IntentFilter filter = new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);IncomingSMSReceiver receiver = new IncomgSMSReceiver();registerReceiver(receiver.filter); 两种注册类型的区别是： 1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。 13、 请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。 答： 简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理. Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列 Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息 Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的 Handler：Handler接受到消息后调用handleMessage进行处理 Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。 下面将对它们进行分别介绍： MessageMessage消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。 HandlerHandler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。 Message QueueMessage Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。 LooperLooper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。 对于子线程使用Looper，API Doc提供了正确的使用方法：这个Message机制的大概流程： 在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。 一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。 随后Looper取出了那个Message，则调用 该Message的target指向的Hander的dispatchMessage函数对Message进行处理。 在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低： 1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作；2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理；3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。由此可见，我们实现的handleMessage方法是优先级最低的！ Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！ 当Handler对象的构造函数的参数为空，则为当前所在线程的Looper； Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。 14、 简要解释一下activity、 intent 、intentfilter、service、Broadcase、BroadcaseReceiver 答： 一个activity呈现了一个用户可以操作的可视化用户界面；一个service不包含可见的用户界面，而是在后台运行，可以与一个activity绑定，通过绑定暴露出来接口并与其进行通信；一个broadcast receiver是一个接收广播消息并做出回应的component，broadcast receiver没有界面；一个intent是一个Intent对象，它保存了消息的内容。 对于activity和service来说，它指定了请求的操作名称和待操作数据的URI，Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。 但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。它是通过将Intent对象和目标的intent filter相比较来完成这一工作的；一个component的intent filter告诉android该component能处理的intent。 intent filter也是在manifest文件中声明的。 15、 说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？ mvc是model,view,controller的缩写，mvc包含三个部分： 模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。 视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。 控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。 android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下： 1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。 2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。 3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。 16、 什么是ANR 如何避免它？ 答： ANR：Application Not Responding。在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作的在5s内应用程序没能做出反应，BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，这既是ANR。 避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成。主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。 17、 什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？ 答：程序出现异常，比如nullpointer。 避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息 18、 描述一下android的系统架构 android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层。 linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。 libraries和 android runtime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit（引擎），该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。android的runtime负责解释和执行生成的dalvik格式的字节码。 applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。 applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。 上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。 android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个 applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。 19、 请介绍下ContentProvider是如何实现数据共享的。 一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。 要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。如何通过一套标准及统一的接口获取其他应用程序暴露的数据？Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。 20、 Service和Thread的区别？ 答： servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。 1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。 2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。 如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。 既然这样，那么我们为什么要用 Service 呢？ 其实这跟 android 的系统机制有关，我们先拿 Thread 来说。Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。 另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。 举个例子：如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。 因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。 因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。 21、 Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？ 答： 会，比如nullpointerException。我遇到过，比如textview.setText()时，textview没有初始化。会导致程序无法正常运行出现forceclose。打开控制台查看logcat信息找出异常信息并修改程序。 22、 IntentService有何优点? 答： Acitivity的进程，当处理Intent的时候，会产生一个对应的Service； Android的进程处理器现在会尽可能的不kill掉你；非常容易使用 23、 如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？ 答：重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据 24、 如何将一个Activity设置成窗口的样式。 答： 中配置：android :theme=”@android:style/Theme.Dialog”另外android:theme=”@android:style/Theme.Translucent” 是设置透明 25、 如何退出Activity？如何安全退出已调用多个Activity的Application？ 答： 对于单一Activity的应用来说，退出很简单，直接finish()即可。当然，也可以用killProcess()和System.exit()这样的方法。 对于多个activity， 1、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。 2、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。 3、递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。为了编程方便，最好定义一个Activity基类，处理这些共通问题。 在2.1之前，可以使用ActivityManager的restartPackage方法。 它可以直接结束整个应用。在使用时需要权限android.permission.RESTART_PACKAGES。注意不要被它的名字迷惑。 可是，在2.2，这个方法失效了。在2.2添加了一个新的方法，killBackground Processes()，需要权限 android.permission.KILL_BACKGROUND_PROCESSES。可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。 它需要权限android.permission.FORCE_STOP_PACKAGES。 并且需要添加android:sharedUserId=”android.uid.system”属性。同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。 因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。 而Android.mk是用于在Android源码下编译程序用的。 从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。 现提供几个方法，供参考： 1、抛异常强制退出：该方法通过抛异常，使程序Force Close。验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。 2、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。 3、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。 4、递归退出在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。 除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。 但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。 26、 AIDL的全称是什么？如何工作？能处理哪些类型的数据？ 答： 全称是：Android Interface Define Language在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢? 显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. 在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。 AIDL(AndRoid接口描述语言)是一种借口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象. AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。 它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 引入AIDL的相关类.; 调用aidl产生的class. AIDL的创建方法: AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型: 不需要import声明的简单Java编程语言类型(int,boolean等) String, CharSequence不需要特殊声明 List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型. (另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持) 27、 请解释下Android程序运行时权限与文件系统权限的区别。 答：运行时权限Dalvik( android授权) 文件系统 linux 内核授权 28、 系统上安装了多种浏览器，能否指定某浏览器访问指定页面？请说明原由。 通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性 29、 android系统的优势和不足 答：Android平台手机 5大优势： 一、开放性在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。 二、挣脱运营商的束缚在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市 ，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。 三、丰富的硬件选择这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？ 四、不受任何限制的开发商Android平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、方面的程序和游戏如可控制正是留给Android难题之一。 五、无缝结合的Google应用如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。 再说Android的5大不足： 一、安全和隐私由于手机 与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。 二、首先开卖Android手机的不是最大运营商众所周知，T-Mobile在23日，于美国纽约发布 了Android首款手机G1。但是在北美市场，最大的两家运营商乃AT&amp;T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！ 三、运营商仍然能够影响到Android手机在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。 四、同类机型用户减少在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。 五、过分依赖开发商缺少标准配置在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。但入手开始使用默认的程序同样可以应付多样的需要。在 Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐 播放器，全部依赖第三方开发，缺少了产品的统一性。 30、 Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念答：DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。 31、 sim卡的EF文件是什么？有何作用答：sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的 32、 嵌入式操作系统内存管理有哪几种， 各有何特性 页式，段式，段页，用到了MMU,虚拟空间等技术 33、 什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗? 嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。 34、 一条最长的短信息约占多少byte? 中文70(包括标点)，英文160，160个字节。 35、 有一个一维整型数组int[]data保存的是一张宽为width，高为height的图片像素值信息。请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50% ###。 36、 如何将SQLite数据库(dictionary.db文件)与apk文件一起发布解答：可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中 37、 如何将打开res aw目录中的数据库文件? 解答：在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。 复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。 在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。 38、 DDMS和TraceView的区别? DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器 。 39、 java中如何引用本地语言 可以用JNI（java native interface java 本地接口）接口 。 40、 谈谈Android的IPC（进程间通信）机制 IPC是内部进程通信的简称， 是共享”命名管道”的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。 41、 NDK是什么 NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so]]></content>
      <categories>
        <category>我的书籍</category>
      </categories>
      <tags>
        <tag>我的书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android课程体系]]></title>
    <url>%2F2018%2F05%2F11%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 来源网络收集 第一阶段：Java se阶段 阶段 课程 课程内容 讲解知识点 Java语言基础 入门基础 1.Java开发环境搭建（第一天只能使用文本文档编写代码） 1.Java语言发展史介绍2.Java体系与特点3.JVM与GC介绍4.Java跨平台原理5.JavaSE组成概念6.JDK与JRE介绍7.Java开发环境搭建8.实现 HelloWorld 程序9.HelloWorld程序编写与分析10.Java中的三种注释11.常见Java开发工具介绍12.Wiki文档的使用技巧 1.基本语法与命名规范2.程序分支结构控制3.数组及常用算法（可以考虑使用Editplus编辑器） 1.1 变量1.2 数据类型1.3 二进制以及进制间转换1.4 标识符1.5 类型转换1.6 关键字1.7 常量1.8 转义字符1.9 算术运算符1.10 赋值运算符1.11 关系运算符1.12 逻辑运算符1.13 位运算符1.14 移位运算符1.15 字符串连接运算符1.16 三目运算符1.17 运算符优先级 2.1 if条件语句2.2 switch语句2.3 for循环语句2.4 while循环语句2.5 do while循环语句 3.1数组四种声明方式以及特性3.2数组插入、遍历等常用操作3.3常用算法：最大、最小、平均值3.4多维数组声明及原理3.5多维数组的存储、遍历等操作 面向对象 基础 1.面向过程与面向对象思想分析2.封装性3.String类4.this关键字5.static关键字6.对象数组7.JDK1.5新特性8.代码块9.内部类 1.1面向对象思想介绍1.2面向过程与面向对象分析1.3什么是类？什么是对象？1.4类与对象之间的关系1.5类的定义格式1.6对象的定义格式1.7创建对象时的内存分析1.8调用类中的属性，调用方法1.9方法的重载 2.1 封装性介绍2.2 构造方法2.3 构造方法的重载2.4 匿名对象2.5 如何设计一个类 3.1 String的两种赋值方式3.2 String的比较3.3 String两种赋值方式的区别3.4 String的值不可改变 （字符串常量池）3.5 String类的常用操作方法3.6 引用传递深入讲解 （课件中三个范例）3.6一对一关系讲解 4.1 this关键字4.2 this调用类中的属性4.3 this调用类中的方法4.4 this表示当前对象4.5 this接收本类引用 （自定义对象的比较） 5.1 static关键字介绍5.2 static特点5.3 static访问限制5.4 成员变量和类变量5.5 static属性内存分析5.6 应用案例- - 计数器5.7 main方法讲解5.8 设计模式—单例（懒汉、饿汉） 6.1 自定义对象定义数组6.2 对象数组案例-商品管理系统 7.1 foreach输出7.2 可变参数 8.1 普通代码块8.2 构造块8.3 静态代码块8.4 三种代码块以及构造方法执行顺序 9.1内部类概念9.2内部类的访问规则9.3内部类的访问限制9.4递归9.5链表（添加、删除、输出） 高级 1.继承2.super关键字3.final关键字4.抽象类5.接口6.多态性7.instanceOf关键字8.Object类9.抽象类和接口的关系10.接口应用11.匿名内部类12.包装类13.包与访问修饰符14.Eclipse介绍 1.1继承的概念（定义）1.2继承的格式1.3继承的好处1.4继承的限制1.5子类的实例化过程1.6访问修饰符讲解1.7重载和重写的区别 2.1 super关键字2.2 super调用父类中的属性2.3 super调用父类中的方法 3.1 final关键字3.2 final修饰类3.3 final修饰方法3.4 final修饰属性 4.1 抽象类概念、定义4.2 抽象方法4.3 抽象类特点4.4 设计模式—模板方法（大保健的例子） 5.1 接口的定义5.2 接口的特点5.3 接口多实现、不能实例化…5.4 设计模式—策略模式5.5 接口总结（接口中定义什么？） 6.1 多态概念6.2 两种多态6.3 向上、向下转型6.4 多态的体现6.5 多态的好处6.6 多态的弊端6.7 多态的前提 7.1 instanceOf关键字7.2 抽象类的实际应用7.3 接口的实际应用 8.1 Object类讲解8.2 toString方法8.3 equals方法8.4 Object接收任意引用参数 9.1 （简单介绍即） 10.1 简单工厂设计模式10.2 代理设计模式（课件案例或潘金莲案例）10.3 适配器模式（课件案例）10.4 面向对象六大原则其中三个 12.1匿名内部类 12.1 包装类概念介绍12.2 装箱、拆箱概念12.3 JDK1.5新特性—自动装箱、自动拆箱12.4 转型操作12.5 Integer—享元设计模式 13.1 包介绍13.2 包的命名规则13.3 访问修饰符的访问范围整理 14.1Eclipse接受14.2发放Eclipse工具14.3发放Eclipse配色、快捷键大全 Java语言高级 异常处理 1.认识并处理异常2.异常的处理流程、3.标准的异常处理格式4.RuntimeException和Exception的区别5.自定义异常6.Eclipse Debug 1.1演示算数异常的产生1.2讲解异常结构图1.3讲解Exception和Error的区别1.4使用if语句先处理异常1.5使用try catch处理异常1.6演示数组下标越界异常1.7处理数组下标越界异常 2.1 讲解异常捕获的流程2.2 异常的统一出口finally2.3 面试题：在try块中有return 语句并且正常执行，问Finally语句块中的内容是否会执行 2.4 throws关键字2.5 throw关键字 3.1 演示标准的异常处理格式3.2 添加多个catch语句块3.3 多个catch块继承关系的顺序3.4 JDK1.7多个catch的新支持4.1 讲解RuntimeException4.2 讲解 Exception4.3 总结区别 5.1 自定义异常5.2 使用自定义异常 6.1 讲解Eclipse Debug使用 常用类库 1.深入StringBuffer类及其操作方法2.国际化程序的实现3.日期操作，Date、DateFormat、SimpleDateFormat等4.比较器的实现及原来二分查找、二叉树、以及对象的克隆 1.1由String特性引出1.2介绍StringBuffer特性1.3StringBuffer实现原理：A.默认缓冲区大小B.缓冲区扩充算法1.4StringBuilder介绍1.5面试题：Builder与Buffer区别？ 2.1 介绍国际化程序2.2 Locale类介绍2.3 ResourceBundle类介绍2.2 实现国际化程序2.5 处理动态文本 3.1 Math类介绍及常用方法演示3.2 Random介绍及演示3.3 Arrays类介绍及演示3.4 演示Arrays类中的binarySearch方法3.5 二分查找法（折半查找）3.6 Date类介绍3.7 Calendar类介绍3.8 使用Calendar实现中国式时间3.9 使用SimpleDateFormat格式化时间 4.1 Arrays的sort方法引出4.2 Comparable接口讲解4.3 排序规则的讲解4.4 二叉树算法（添加、输出）4.5 Comparator接口讲解4.6 Cloneable接口讲解4.7 对象的克隆实现 IO操作 1.File类的使用及利用递归实现文件搜索器2.字节操作流，InputStream、OutputStream、FileInputStream、ByteArrayInputStream等等3.字符操作流，缓冲流、管道流、合并流4.对象序列化及对象序列化原理，源码解析5.装饰者设计模式 1.1File类的介绍1.2 创建文件1.3 删除文件1.4 判断文件类型1.5 列出目录中的文件1.6 递归遍历文件 2.1 FileOutputStream2.2 FileInputStream2.3 一次读取一个字节示例2.4 一次读取整个文件示例2.5 定义缓冲区读取文件2.6 文件复制习题 3.1 字节流读取中文引出乱码3.2 字符流处理中文讲解3.3 示例：使用字节流字符流分别写入文件3.4 引出缓冲区概念，讲解字节流字符流区别3.5 位字节流添加缓冲功能BufferedOutputStream3.6 字节字符转换流OutputStreamWriter InputStreamReader 3.7 使用字符流向文件输出‘97’3.8 引出PrintStream打印流3.9 文件分割、合并练习 4.1 对象序列化概念介绍4.2 Serializable接口介绍4.2 序列化：ObjectOutputStream4.3 反序列化：ObjectInputStream4.4 序列化一组对象4.5 transient关键字作用4.6 内存操作流ByteArrayInputStream ByteArrayOutputStream4.7 缓冲区读取：BufferedReader类4.7 数据流DataOutputStream DataInputStream4.8 将管理系统序列化存储4.9 字符编码介绍4.10 IO体系结构梳理 5.1 装饰者设计模式讲解 集合 1.集合与数组的区别，缓存的管理，Collection 、List、Set接口的作用及相关的子类2.Map集合与Conllection的区别，Map的好处及用法HashMap、HashTable、Properties等3.Object 类中的方法及Object类存在的意义泛型的作用、枚举与泛型、泛型的好处4.常用集合工具类Collections5.哈希算法实现原来剖析 1.1类集引出1.2集合结构图讲解1.3Collection接口讲解1.4List接口讲解1.5ArrayList实现原理及使用1.6Vector实现原理及使用1.7ArrayList和Vector区别1.8LinkedList实现原理及使用1.9LinkedList当做队列、堆栈使用1.10Set接口讲解1.11HashSet实现原理及使用1.12TreeSet实现原理及使用1.13平衡二叉树介绍1.14集合输出Iterator接口1.15双向输出ListIterator接口1.16介绍废弃的接口Enumeration1.17Foreach输出集合 2.1Map接口介绍2.2HashMap实现原理及使用2.3Object类中的hashCode方法2.4哈希算法的存储实现原理2.5哈希表的重新散列2.6HashTable实现原理及使用2.7HashMap和HashTable区别2.8TreeMap实现原理 及使用2.9Map集合的输出讲解 3.1一对多关系讲解3.2多对多关系讲解 4.1Collections和Collection区别 5.1 分析hashCode、equals和内存泄露 多线程 1.进程和线程关系及区别2.Thread与Runnable底层原理及使用作用原理3.线程的优先级、线程池4.线程的同步与死锁线程的并发处理 1.1进程的概念1.2线程的概念1.3多线程概念介绍1.4线程的两种实现方式22.1两种实现方式的区别2.2线程的操作状态2.3线程的常用操作方法2.4线程的强制执行2.5线程的休眠2.6线程的中断原理33.1线程的优先级介绍3.2线程池介绍及使用44.1买票例子引出线程同步问题4.2同步方法与同步代码块解决问题4.3JDK1.5 新的加锁方式Lock4.4模拟线程死锁4.5生产者消费者案例讲解4.6线程的生命周期 通过本章学习，可以掌握Java中线程的两种实现方式，熟练使用Java中的多线程，要求掌握Java中线程的同步并且避免Java中线程的死锁问题。理解并熟练使用线程池。 2 网络编程 1.TCP、UDP程序的实现2.ServerSocket 和Scoket 类的使用3.URLConnection的使用 1.1计算机网络介绍1.2网络通信协议介绍1.3网络通信接口介绍1.4CS/BS程序介绍1.5TCP/IP协议介绍1.6三次握手原理讲解22.1使用Socket、和ServerSocket编写服务器端程序2.2使用Socket写客户端程序2.3为服务器端加入ECHO2.4为服务器端加入多线程2.5UDP协议介绍2.6使用DatagramPacket、DatagramSocket实现UDP程序 3.1 URL介绍3.2 URLConnection介绍3.3 连网下载图片案例讲解 GUI编程 1.常用组件了解2.事件与监听器3.观察者设计模式 1.1GUI介绍1.2AWT组成结构介绍1.3Component类介绍1.4Frame类介绍1.5Panel讲解1.6实现我们的第一个窗体1.7Toolkit介绍1.8使用Toolkit设置初始化位置1.9布局介绍1.10四种布局讲解 2.1实现事件处理的步骤2.23种事件处理方式 3.1观察者设计模式实现3.2使用JDK提供的观察者3.3Swing介绍3.4使用swing画登录窗体 反射内省 1.Java Reflection API的作用、检查运行时的对象、动态更新字段、调用方法 2.反射主要的类 Class 、Method 、Field 、Constructor3.内省机制的使用 1.1什么是反射1.2Class类讲解1.3Class类的三种实例化方式1.4使用Class类实例化对象1.5反射调用无参构造方法1.6反射调用有参构造方法1.7反射类所在的包1.8反射获取类中的属性（公有）1.9反射获取类中的私有属性1.10反射调用类中的私有方法 2.1Constructor类介绍2.2Method类介绍2.3Field类介绍 3.1内省概念介绍3.2JavaBean介绍3.3标准的get/set介绍3.4使用trospector模拟框架底层 XML 1.XML基础简介2.XML的解析方式3.深入XML两种解析思想DOM与SAX4.DOM4J与JDOM 1.1XML介绍1.2XML用途 2.1XML的两种解析原理2.2DOM原理讲解2.3DOM解析示例2.4SAX原理讲解2.5SAX解析示例 3.1JDOM解析示例3.2DOM4J解析示例3.3通过对象生成XML文件3.4各种解析方法分析比较 XML文件可以用作数据的存储，数据传输，配置文件。 第二阶段：Java Web（2周/10天共60课时） 数据库应用 MySQL 1.Mysql安装、基础语法、DDL、DML、DCL语法的操作、事务管理、数据库设计范式等 JDBC 1.JDBC实现对Mysql实现CURD操作2.Sql注入问题及解决方案3.批处理与事务控制4.DAO设计模式 Java Web前台与服务器端应用 1.HTML标签2.Web服务器环境搭建与配置3.Web三大组件，Servlet4.使用httpwatch解析Http协议原理5.Web程序设计及MVC设计模式6.Html5与JavaScript 第三阶段：Android阶段 Android基础Android入门 1.Android简史2.Android体系结构3.DVM与JVM4.SDK的获取(搭环境)5.SDK目录结构6.创建模拟器启动7.运行HelloWord8.项目目录结构9.应用打包安装过程10.DDMS使用11.Logcat的使用 Android基础UI 1.常用基本控件2.Toast3.常用响应事件4.Menu5.Dialog6.常用布局 掌握Android常用Menu 与 各种Dialog, 以及Android的五种布局 Android文件读写1.内部存储与外部存 储概念2.内部存储读写文件3.使用路径API在内部存储中读写文件4.文件访问权限5.外部存储读写文件6.导入Setting源码7.获取SD卡剩余容量8.SharedPreference的使用 掌握 SharedPreference的使用方式 生成XML文件,Android单元测试与数据库操作 1.Xml生成与解析 并通过debug 查看解析过程2.Android中的单元测试3.SQLite数据库简介4.创建数据库5.增删改查6.SQLite事物7.数据展示 Android单元测试 SQLite数据库的使用; AdapterView 1.ListView 预览2.Adapter简介3.ListView的使用4.ArrayAdapter ,SimpleAdapter ,CursorAdapter , SimpleCursorAdapter 等adapter的使用5.BaseAdapter的使用(自定义Adapter)6.Spinner选择列表的使用7.GridView网格视图的使用8.ListView , Spinner , GridView与BaseAdapter结合;9.ListView , Spinner , GridView缓存原理与BaseAdapter优化 Android进阶 Activity与 Intent 1.Activity使用2.Activity四大加载模式2.Activity 生命周期3.Activity 启动与关闭4.Activity 横竖屏5.Intent属性与使用6.Activity 显式 隐式 带返回值跳转7.IntentFilter(过滤器)8.Activity回退栈原理 多线程与Android网络编程 1.Android进程与线程2.UI线程模型3.Handler机制4.使用消息队列刷新UI5.AsyncTask的使用6.进程通信7.Android网络编程简介8.获取网络状态9.Get Post提交数据10.Http协议11.下载数据并建立本地缓存12.JSON生成与解析 , Gson.jar包使用 1.服务介绍2.启动Service与生命周期3.绑定Service与生命周期4.混合启动Service与声明周期5.启动远程服务 AIDL的使用 Android四大组件之广播 1.Android广播机制与概念2.定义广播接收者3.无序广播与有序广播4.短信拦截系统5.内存卡状态监听6.监控应用状态7.发送无序广播与有序广播8.发送系统级广播 Android四大组件之内容提供者 1.内容提供者简介2.增删改差3.URL匹配器4.备份系统短信5.插入系统短信6.备份通讯录7.插入联系人 Android多媒体编程 1.摄像头的使用2.图片处理3.画板4.音乐播放5.视频播放 Android动画 1.动画简介2.逐帧动画3.补间动画4.XML与JAVA代码形式实现5.混合使用补间动画 Android高级 高级UI组件与常用开源组件 1.widget 桌面控件2.XlistView 上拉刷新, 下拉加载更多3.Drawerlayout抽屉效果4.PopupWindow 定点弹窗5.ExpandableListView 二级展开列表6.ViewPager 滑动7.WebView 网页加载 Android碎片化之Fragment 1.Android碎片化介绍2.Fragment简介3.FragmentManager使用4.Fragment生命周期5.Fragment使用方式6.Fragment事物7.Fragment 常见错误使用方式8.Fragment与Viewpager结合使用 开源框架之Volly 1.Volly框架简介2.创建请求队列3.请求对象 StringRequest , JsonObjecyRequest,JsonArrayRequest,4.GET/POST请求5.绑定Activity6.二次回调封装7.ImageRequest,ImageLoader,NetWorkImageView, 加载网络图片 并 监听8.lruCache与ImageCache 本地缓存 开源框架之Xutils 1.Xutils四大模块简介2.ViewUtils模块: 简化界面代码3.DBUtils模块: 简化数据库操作4.BitmapUtils模块: 优化图片加载5.HttpUtils 模块: GET/POST请求网络 开源框架之UniversalImageLoader 1.图片加载器ImageLoader的单例模式简介2.ImageLoaderConfiguration的作用3.使用默认的ImageLoaderConfiguration给图片加载器ImageLoader配置加载参数4.通过API方法自行创建ImageLoaderConfiguration对象设置加载参数5.通过displayImage()异步加载图片6.通过loadImage()异步加载图片7.PauseOnScrollListener监听器的使用 开源框架之Glide 1.Glide简介2.Glide中Gif动图与视频的解码方式介绍,3.使用Glide加载gif图4.使用Glide加载缩略图 开源框架之Cropper 1.Cropper简介2.使用Cropper剪裁图片3.使用Cropper实现图片旋转等 LSB应用 百度地图 1.百度地图API简介2.注册百度开发者以及地图访问密钥3.集成百度地图SDK并成功调用出地图页面5.设置地图显示类型6.百度地图图层概念介绍7.添加实时交通状况图层、添加热力图图层、添加标注点图层、添加弹出窗图层8.使用百度地图实现定位9.使用百度地图实现路径规划（步行、公共交通、驾车）10.使用百度地图实现POI检索（附近检索、全程检索、详情检索 Android6.0新特性 Android M特点及Android Studio 1.Android Studio下载与安装2.Studio项目结构与运行HelloWord3.常用功能介绍4.常用快捷键介绍5.导出导入Eclipse项目6.APK打包签名设置7.Gradle Plugin 中 buildTypes 、 productFlavors8.Android6.0与新特性9.Gradle自动化项目构建工具 高级应用 项目构建工具、项目版本管理、Android测试与发布、阿里云服务器 1.Gradle项目构建工具2.Git项目版本控制3.JUnit单元测试4.Android应用发布流程5.阿里云服务器搭建及使用技巧 编辑 ：达叔 定位：分享 Android&amp;Java 知识点]]></content>
      <categories>
        <category>我的书籍</category>
      </categories>
      <tags>
        <tag>我的书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android技术面试整理附有详细答案(包括百度、新浪、中科软等多家公司笔试面试题)]]></title>
    <url>%2F2018%2F05%2F10%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 1、Android的四大组件是哪些，它们的作用？ 答： Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑 service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的食物，定义好需要接受的Intent提供同步和异步的接口 Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的借口模型，大大简化上层应用，对数据的整合提供了更方便的途径 BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型 2、请介绍下Android中常用的五种布局。 常用五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。 一、 FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。 二、 LinearLayout：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）。 当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。 三、 AbsoluteLayout：绝对布局，用X,Y坐标来指定元素的位置，这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。 四、 RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。 主要属性有： 相对于某一个元素android:layout_below、android:layout_toLeftOf 相对于父元素的地方android:layout_alignParentLeft、android:layout_alignParentRigh； 五、 TableLayout：表格布局，每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素。每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。 3、android中的动画有哪几类，它们的特点和区别是什么 答： 两种， 一种是Tween动画、还有一种是Frame动画。 Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化; 另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。 4、android 中有哪几种解析xml的类？官方推荐哪种？以及它们的原理和区别。 答： XML解析主要有三种方式，SAX、DOM、PULL。 常规在PC上开发我们使用Dom相对轻松些，但一些性能敏感的数据库或手机上还是主要采用SAX方式，SAX读取是单向的，优点:不占内存空间、解析属性方便，但缺点就是对于套嵌多个分支来说处理不是很方便。 而DOM方式会把整个XML文件加载到内存中去，这里Android开发网提醒大家该方法在查找方面可以和XPath很好的结合如果数据量不是很大推荐使用，而PULL常常用在J2ME对于节点处理比较好，类似SAX方式，同样很节省内存，在J2ME中我们经常使用的KXML库来解析。 SAX和PULL使用 Pull解析器的运行方式与 SAX 解析器相似 区别为：SAX解析器的工作方式是自动将事件推入事件处理器进行处理，因此你不能控制事件的处理主动结束；而Pull解析器的工作方式为允许你的应用程序代码主动从解析器中获取事件，正因为是主动获取事件，因此可以在满足了需要的条件后不再获取事件，结束解析。 你随便找个sax和pull的例子比较一下就可以发现，pull是一个while循环，随时可以跳出，而sax不是，sax是只要解析了，就必须解析完成。 5、ListView的优化方案 答： 1、 如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。 2、 给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。 3、 如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。 6、请介绍下Android的数据存储方式。 答： 使用SharedPreferences存储数据；文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据； Preference，File， DataBase这三种方式 分别对应的目录是 /data/data/Package Name/Shared_Pref, /data/data/Package Name/files, /data/data/Package Name/database 。 一：使用SharedPreferences存储数据 首先说明SharedPreferences存储方式，它是 Android提供的用来存储一些简单配置信息的一种机制，例如：登录用户的用户名与密码。 其采用了Map数据结构来存储数据，以键值的方式存储，可以简单的读取与写入，具体实例如下： 123456789101112131415161718192021void ReadSharedPreferences()&#123;String strName,strPassword;SharedPreferences user = getSharedPreferences(“user_info”,0);strName = user.getString(“NAME”,””);strPassword = user.getString(“PASSWORD”,””);&#125;void WriteSharedPreferences(String strName,String strPassword)&#123;SharedPreferences user = getSharedPreferences(“user_info”,0);uer.edit();user.putString(“NAME”, strName);user.putString(“PASSWORD” ,strPassword);user.commit();&#125; 数据读取与写入的方法都非常简单，只是在写入的时候有些区别：先调用edit()使其处于编辑状态，然后才能修改数据，最后使用commit()提交修改的数据。 实际上SharedPreferences是采用了XML格式将数据存储到设备中，在DDMS中的File Explorer中的/data/data//shares_prefs下。 使用SharedPreferences是有些限制的：只能在同一个包内使用，不能在不同的包之间使用。 二：文件存储数据 文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与 Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。具体实例如下: 123String fn = “moandroid.log”;FileInputStream fis = openFileInput(fn);FileOutputStream fos = openFileOutput(fn,Context.MODE_PRIVATE); 三：网络存储数据 网络存储方式，需要与Android 网络数据包打交道，关于Android 网络数据包的详细说明，请阅读Android SDK引用了Java SDK的哪些package？。 四：ContentProvider 1、ContentProvider简介 当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。 2、Uri类简介 Uri代表了要操作的数据，Uri主要包含了两部分信息： 1.需要操作的ContentProvider ， 2.对ContentProvider中的什么数据进行操作，一个Uri由以下几部分组成： 1.scheme：ContentProvider（内容提供者）的scheme已经由Android所规定为：content://…2.主机名（或Authority）：用于唯一标识这个ContentProvider，外部调用者可以根据这个标识来找到它。3.路径（path）：可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下： 要操作contact表中id为10的记录，可以构建这样的路径:/contact/10 要操作contact表中id为10的记录的name字段， contact/10/name 要操作contact表中的所有记录，可以构建这样的路径:/contact? 要操作的数据不一定来自数据库，也可以是文件等他存储方式，如下: 要操作xml文件中contact节点下的name节点，可以构建这样的路径：/contact/name如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：Uri uri = Uri.parse(“content://com.changcheng.provider.contactprovider/contact”) 3、UriMatcher、ContentUrist和ContentResolver简介 因为Uri代表了要操作的数据，所以我们很经常需要解析Uri，并从 Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher 和ContentUris 。掌握它们的使用，会便于我们的开发工作。UriMatcher：用于匹配Uri，它的用法如下： 1.首先把你需要匹配Uri路径全部给注册上，如下： //常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码(-1)。UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); //如果match()方法匹配content://com.changcheng.sqlite.provider.contactprovider /contact路径，返回匹配码为1 uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact”, 1);//添加需要匹配uri，如果匹配就会返回匹配码 //如果match()方法匹配 content://com.changcheng.sqlite.provider.contactprovider/contact/230路径，返回匹配码为2 uriMatcher.addURI(“com.changcheng.sqlite.provider.contactprovider”, “contact/#”, 2);//#号为通配符 2.注册完需要匹配的Uri后，就可以使用uriMatcher.match(uri) 方法对输入的Uri进行匹配，如果匹配就返回匹配码，匹配码是调用 addURI()方法传入的第三个参数，假设匹配 content://com.changcheng.sqlite.provider.contactprovider/contact路径，返回的匹配码为1。 ContentUris：用于获取Uri路径后面的ID部分，它有两个比较实用的方法： withAppendedId(uri, id)用于为路径加上ID部分parseId(uri)方法用于从路径中获取ID部分ContentResolver：当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，可以使用 ContentResolver 类来完成，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法。 ContentResolver使用insert、delete、update、query方法，来操作数据。 7、activity的启动模式有哪些？是什么含义？ 答： 在android里，有4种activity的启动模式，分别为：“standard” (默认)“singleTop”“singleTask”“singleInstance” 它们主要有如下不同： 如何决定所属task “standard”和”singleTop”的activity的目标task，和收到的Intent的发送者在同一个task内，除非intent包括参数FLAG_ACTIVITY_NEW_TASK。如果提供了FLAG_ACTIVITY_NEW_TASK参数，会启动到别的task里。“singleTask”和”singleInstance”总是把activity作为一个task的根元素，他们不会被启动到一个其他task里。 是否允许多个实例 “standard”和”singleTop”可以被实例化多次，并且存在于不同的task中，且一个task可以包括一个activity的多个实例； “singleTask”和”singleInstance”则限制只生成一个实例，并且是task的根元素。 singleTop要求如果创建intent的时候栈顶已经有要创建 的Activity的实例，则将intent发送给该实例，而不发送给新的实例。 是否允许其它activity存在于本task内 “singleInstance”独占一个task，其它activity不能存在那个task里；如果它启动了一个新的activity，不管新的activity的launch mode 如何，新的activity都将会到别的task里运行（如同加了FLAG_ACTIVITY_NEW_TASK参数）。而另外三种模式，则可以和其它activity共存。 是否每次都生成新实例 “standard”对于没一个启动Intent都会生成一个activity的新实例；“singleTop”的activity如果在task的栈顶的话，则不生成新的该activity的实例，直接使用栈顶的实例，否则，生成该activity的实例。 比如现在task栈元素为A-B-C-D（D在栈顶），这时候给D发一个启动intent，如果D是 “standard”的，则生成D的一个新实例，栈变为A－B－C－D－D。 如果D是singleTop的话，则不会生产D的新实例，栈状态仍为A-B-C-D如果这时候给B发Intent的话，不管B的launchmode是”standard” 还是 “singleTop” ，都会生成B的新实例，栈状态变为A-B-C-D-B。 “singleInstance”是其所在栈的唯一activity，它会每次都被重用。“singleTask”如果在栈顶，则接受intent，否则，该intent会被丢弃，但是该task仍会回到前台。 当已经存在的activity实例处理新的intent时候，会调用onNewIntent()方法 如果收到intent生成一个activity实例，那么用户可以通过back键回到上一个状态；如果是已经存在的一个activity来处理这个intent的话，用户不能通过按back键返回到这之前的状态。 8、跟activity和Task 有关的 Intent启动方式有哪些？其含义？ 核心的Intent Flag有：FLAG_ACTIVITY_NEW_TASKFLAG_ACTIVITY_CLEAR_TOPFLAG_ACTIVITY_RESET_TASK_IF_NEEDEDFLAG_ACTIVITY_SINGLE_TOPFLAG_ACTIVITY_NEW_TASK 如果设置，这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的 Activity）定义了用户可以迁移的Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。 这个标志一般用于呈现“启动”类型的行为：它们提供用户一系列可以单独完成的事情，与启动它们的Activity完全无关。 使用这个标志，如果正在启动的Activity的Task已经在运行的话，那么，新的Activity将不会启动；代替的，当前Task会简单的移入前台。参考FLAG_ACTIVITY_MULTIPLE_TASK标志，可以禁用这一行为。 这个标志不能用于调用方对已经启动的Activity请求结果。 FLAG_ACTIVITY_CLEAR_TOP 如果设置，并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。 例如，假设一个Task中包含这些Activity：A，B，C，D。如果D调用了startActivity()，并且包含一个指向Activity B的Intent，那么，C和D都将结束，然后B接收到这个Intent，因此，目前stack的状况是：A，B。 上例中正在运行的Activity B既可以在onNewIntent()中接收到这个新的Intent，也可以把自己关闭然后重新启动来接收这个Intent。如果它的启动模式声明为 “multiple”(默认值)，并且你没有在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，那么它将关闭然后重新创建；对于其它的启动模式，或者在这个Intent中设置FLAG_ACTIVITY_SINGLE_TOP标志，都将把这个Intent投递到当前这个实例的onNewIntent()中。 这个启动模式还可以与FLAG_ACTIVITY_NEW_TASK结合起来使用：用于启动一个Task中的根Activity，它会把那个Task中任何运行的实例带入前台，然后清除它直到根Activity。这非常有用，例如，当从Notification Manager处启动一个Activity。 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。 FLAG_ACTIVITY_SINGLE_TOP 如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的FLAG_ACTIVITY_BROUGHT_TO_FRONT 这个标志一般不是由程序代码设置的，如在launchMode中设置singleTask模式时系统帮你设定。 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET 如果设置，这将在Task的Activity stack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED标记进入前台时（典型的操作是用户在主画面重启它），这个Activity和它之上的都将关闭，以至于用户不能再返回到它们，但是可以回到之前的Activity。 这在你的程序有分割点的时候很有用。例如，一个e-mail应用程序可能有一个操作是查看一个附件，需要启动图片浏览Activity来显示。这个 Activity应该作为e-mail应用程序Task的一部分，因为这是用户在这个Task中触发的操作。然而，当用户离开这个Task，然后从主画面选择e-mail app，我们可能希望回到查看的会话中，但不是查看图片附件，因为这让人困惑。通过在启动图片浏览时设定这个标志，浏览及其它启动的Activity在下次用户返回到mail程序时都将全部清除。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 如果设置，新的Activity不会在最近启动的Activity的列表中保存。FLAG_ACTIVITY_FORWARD_RESULT 如果设置，并且这个Intent用于从一个存在的Activity启动一个新的Activity，那么，这个作为答复目标的Activity将会传到这个新的Activity中。这种方式下，新的Activity可以调用setResult(int)，并且这个结果值将发送给那个作为答复目标的 Activity。FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY 这个标志一般不由应用程序代码设置，如果这个Activity是从历史记录里启动的（常按HOME键），那么，系统会帮你设定。 FLAG_ACTIVITY_MULTIPLE_TASK 不要使用这个标志，除非你自己实现了应用程序启动器。与FLAG_ACTIVITY_NEW_TASK结合起来使用，可以禁用把已存的Task送入前台的行为。当设置时，新的Task总是会启动来处理Intent，而不管这是是否已经有一个Task可以处理相同的事情。 由于默认的系统不包含图形Task管理功能，因此，你不应该使用这个标志，除非你提供给用户一种方式可以返回到已经启动的Task。 如果FLAG_ACTIVITY_NEW_TASK标志没有设置，这个标志被忽略。 FLAG_ACTIVITY_NO_ANIMATION 如果在Intent中设置，并传递给Context.startActivity()的话，这个标志将阻止系统进入下一个Activity时应用 Acitivity迁移动画。这并不意味着动画将永不运行——如果另一个Activity在启动显示之前，没有指定这个标志，那么，动画将被应用。这个标志可以很好的用于执行一连串的操作，而动画被看作是更高一级的事件的驱动。 FLAG_ACTIVITY_NO_HISTORY 如果设置，新的Activity将不再历史stack中保留。用户一离开它，这个Activity就关闭了。这也可以通过设置noHistory特性。 FLAG_ACTIVITY_NO_USER_ACTION 如果设置，作为新启动的Activity进入前台时，这个标志将在Activity暂停之前阻止从最前方的Activity回调的onUserLeaveHint()。 典型的，一个Activity可以依赖这个回调指明显式的用户动作引起的Activity移出后台。这个回调在Activity的生命周期中标记一个合适的点，并关闭一些Notification。 如果一个Activity通过非用户驱动的事件，如来电或闹钟，启动的，这个标志也应该传递给Context.startActivity，保证暂停的Activity不认为用户已经知晓其Notification。FLAG_ACTIVITY_PREVIOUS_IS_TOP If set and this intent is being used to launch a new activity from an existing one, the current activity will not be counted as the top activity for deciding whether the new intent should be delivered to the top instead of starting a new one. The previous activity will be used as the top, with the assumption being that the current activity will finish itself immediately. FLAG_ACTIVITY_REORDER_TO_FRONT 如果在Intent中设置，并传递给Context.startActivity()，这个标志将引发已经运行的Activity移动到历史stack的顶端。 例如，假设一个Task由四个Activity组成：A,B,C,D。如果D调用startActivity()来启动Activity B，那么，B会移动到历史stack的顶端，现在的次序变成A,C,D,B。如果FLAG_ACTIVITY_CLEAR_TOP标志也设置的话，那么这个标志将被忽略。 9、请描述下Activity的生命周期。 答： activity的生命周期方法有： onCreate()、onStart()、onReStart()、onResume()、onPause()、onStop()、onDestory()； 可见生命周期：从onStart()直到系统调用onStop() 前台生命周期：从onResume()直到系统调用onPause() 10、activity在屏幕旋转时的生命周期 答： 不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 11、如何启用Service，如何停用Service。 服务的开发比较简单，如下： 第一步：继承Service类 public class SMSService extends Service {} 第二步：在AndroidManifest.xml文件中的 节点里对服务进行配置: 服务不能自己运行，需要通过调用Context.startService()或Context.bindService()方法启动服务。 这两个方法都可以启动Service，但是它们的使用场合有所不同。 使用startService()方法启用服务，调用者与服务之间没有关连，即使调用者退出了，服务仍然运行。 使用bindService()方法启用服务，调用者与服务绑定在了一起，调用者一旦退出，服务也就终止，大有“不求同时生，必须同时死”的特点。 如果打算采用Context.startService() 方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onStart()方法。 如果调用startService()方法前服务已经被创建，多次调用startService()方法并不会导致多次创建服务，但会导致多次调用onStart()方法。 采用startService()方法启动的服务，只能调用Context.stopService()方法结束服务，服务结束时会调用onDestroy()方法。 如果打算采用Context.bindService()方法启动服务，在服务未被创建时，系统会先调用服务的onCreate()方法，接着调用onBind()方法。 这个时候调用者和服务绑定在一起，调用者退出了，系统就会先调用服务的onUnbind()方法，接着调用onDestroy()方法。 如果调用bindService()方法前服务已经被绑定，多次调用bindService()方法并不会导致多次创建服务及绑定(也就是说onCreate()和onBind()方法并不会被多次调用)。 如果调用者希望与正在绑定的服务解除绑定，可以调用unbindService()方法，调用该方法也会导致系统调用服务的onUnbind()–&gt;onDestroy()方法。 服务常用生命周期回调方法如下： onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。 onDestroy()该方法在服务被终止时调用。 与采用Context.startService()方法启动服务有关的生命周期方法onStart() 只有采用Context.startService()方法启动服务时才会回调该方法。 该方法在服务开始运行时被调用。 多次调用startService()方法尽管不会多次创建服务，但onStart() 方法会被多次调用。与采用Context.bindService()方法启动服务有关的生命周期方法onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。 该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。 onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。 该方法在调用者与服务解除绑定时被调用 12、注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。 答： 首先写一个类要继承BroadcastReceiver 第一种:在清单文件中声明,添加 12345&lt;receive android:name=&quot;.IncomingSMSReceiver &quot; &gt;&lt;intent-filter&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;)&lt;intent-filter&gt;&lt;receiver&gt; 第二种使用代码进行注册如: 123IntentFilter filter = new IntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);IncomingSMSReceiver receiver = new IncomgSMSReceiver();registerReceiver(receiver.filter); 两种注册类型的区别是： 1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。 13、请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系。 答： 简单的说，Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理. Message Queue(消息队列) ：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列 Handler： 可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息 Looper： 是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的 Handler： Handler接受到消息后调用handleMessage进行处理 Message： 消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理在单线程模型下，为了线程通信问题，Android设计了一个Message Queue(消息队列)， 线程间可以通过该Message Queue并结合Handler和Looper组件进行信息交换。 下面将对它们进行分别介绍： Message Message消息，理解为线程间交流的信息，处理数据后台线程需要更新UI，则发送Message内含一些数据给UI线程。 Handler Handler处理者，是Message的主要处理者，负责Message的发送，Message内容的执行处理。后台线程就是通过传进来的 Handler对象引用来sendMessage(Message)。而使用Handler，需要implement 该类的 handleMessage(Message)方法，它是处理这些Message的操作内容，例如Update UI。通常需要子类化Handler来实现handleMessage方法。 Message Queue Message Queue消息队列，用来存放通过Handler发布的消息，按照先进先出执行。 每个message queue都会有一个对应的Handler。Handler会向message queue通过两种方法发送消息：sendMessage或post。这两种消息都会插在message queue队尾并按先进先出执行。但通过这两种方法发送的消息执行的方式略有不同：通过sendMessage发送的是一个message对象,会被 Handler的handleMessage()函数处理；而通过post方法发送的是一个runnable对象，则会自己执行。 Looper Looper是每条线程里的Message Queue的管家。Android没有Global的Message Queue，而Android会自动替主线程(UI线程)建立Message Queue，但在子线程里并没有建立Message Queue。所以调用Looper.getMainLooper()得到的主线程的Looper不为NULL，但调用Looper.myLooper() 得到当前线程的Looper就有可能为NULL。对于子线程使用Looper，API Doc提供了正确的使用方法： 这个Message机制的大概流程： 在Looper.loop()方法运行开始后，循环地按照接收顺序取出Message Queue里面的非NULL的Message。 一开始Message Queue里面的Message都是NULL的。当Handler.sendMessage(Message)到Message Queue，该函数里面设置了那个Message对象的target属性是当前的Handler对象。 随后Looper取出了那个Message，则调用 该Message的target指向的Hander的dispatchMessage函数对Message进行处理。在dispatchMessage方法里，如何处理Message则由用户指定，三个判断，优先级从高到低： 1) Message里面的Callback，一个实现了Runnable接口的对象，其中run函数做处理工作； 2) Handler里面的mCallback指向的一个实现了Callback接口的对象，由其handleMessage进行处理； 3) 处理消息Handler对象对应的类继承并实现了其中handleMessage函数，通过这个实现的handleMessage函数处理消息。 由此可见，我们实现的handleMessage方法是优先级最低的！ Handler处理完该Message (update UI) 后，Looper则设置该Message为NULL，以便回收！ 在网上有很多文章讲述主线程和其他子线程如何交互，传送信息，最终谁来执行处理信息之类的，个人理解是最简单的方法——判断Handler对象里面的Looper对象是属于哪条线程的，则由该线程来执行！ 1. 当Handler对象的构造函数的参数为空，则为当前所在线程的Looper； Looper.getMainLooper()得到的是主线程的Looper对象，Looper.myLooper()得到的是当前线程的Looper对象。 14、简要解释一下activity、 intent 、intent filter、service、Broadcase、BroadcaseReceiver 答： 一个activity呈现了一个用户可以操作的可视化用户界面；一个service不包含可见的用户界面，而是在后台运行，可以与一个activity绑定，通过绑定暴露出来接口并与其进行通信；一个broadcast receiver是一个接收广播消息并做出回应的component，broadcast receiver没有界面；一个intent是一个Intent对象，它保存了消息的内容。 对于activity和service来说，它指定了请求的操作名称和待操作数据的URI，Intent对象可以显式的指定一个目标component。如果这样的话，android会找到这个component(基于manifest文件中的声明)并激活它。但如果一个目标不是显式指定的，android必须找到响应intent的最佳component。它是通过将Intent对象和目标的intent filter相比较来完成这一工作的；一个component的intent filter告诉android该component能处理的intent。intent filter也是在manifest文件中声明的。 15、说说mvc模式的原理，它在android中的运用,android的官方建议应用程序的开发采用mvc模式。何谓mvc？ mvc是model,view,controller的缩写，mvc包含三个部分： 模型（model）对象：是应用程序的主体部分，所有的业务逻辑都应该写在该层。 视图（view）对象：是应用程序中负责生成用户界面的部分。也是在整个mvc架构中用户唯一可以看到的一层，接收用户的输入，显示处理结果。 控制器（control）对象：是根据用户的输入，控制用户界面数据显示及更新model对象状态的部分，控制器更重要的一种导航功能，响应用户出发的相关事件，交给m层处理。 android鼓励弱耦合和组件的重用，在android中mvc的具体体现如下： 1)视图层（view）：一般采用xml文件进行界面的描述，使用的时候可以非常方便的引入，当然，如果你对android了解的比较的多了话，就一定可以想到在android中也可以使用javascript+html等的方式作为view层，当然这里需要进行java和javascript之间的通信，幸运的是，android提供了它们之间非常方便的通信实现。 2)控制层（controller）：android的控制层的重任通常落在了众多的acitvity的肩上，这句话也就暗含了不要在acitivity中写代码，要通过activity交割model业务逻辑层处理，这样做的另外一个原因是android中的acitivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。 3)模型层（model）：对数据库的操作、对网络等的操作都应该在model里面处理，当然对业务计算等操作也是必须放在的该层的。 16、什么是ANR 如何避免它？ 答： ANR：Application Not Responding。在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作的在5s内应用程序没能做出反应，BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，这既是ANR。 避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成。主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。 17、什么情况会导致Force Close ？如何避免？能否捕获导致其的异常？ 答：程序出现异常，比如nullpointer。 避免：编写程序时逻辑连贯，思维缜密。能捕获异常，在logcat中能看到异常信息 18、描述一下android的系统架构 android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层。 linuxkernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。 libraries和 android runtime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit（引擎），该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。 android的runtime负责解释和执行生成的dalvik格式的字节码。 applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。 applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。 上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。 android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个 applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。 19、请介绍下ContentProvider是如何实现数据共享的。 一个程序可以通过实现一个Content provider的抽象接口将自己的数据完全暴露出去，而且Content providers是以类似数据库中表的方式将数据暴露。Content providers存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。 要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的Content provider中，前提是有相同数据类型并且有写入Content provider的权限。 如何通过一套标准及统一的接口获取其他应用程序暴露的数据？ Android提供了ContentResolver，外界的程序可以通过ContentResolver接口访问ContentProvider提供的数据。 20、Service和Thread的区别？ 答： servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。 1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。 2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。 既然这样，那么我们为什么要用 Service 呢？ 其实这跟 android 的系统机制有关，我们先拿 Thread 来说。 Thread 的运行是独立于 Activity 的，也就是说当一个 Activity 被 finish 之后，如果你没有主动停止 Thread 或者 Thread 里的 run 方法没有执行完毕的话，Thread 也会一直执行。 因此这里会出现一个问题：当 Activity 被 finish 之后，你不再持有该 Thread 的引用。 另一方面，你没有办法在不同的 Activity 中对同一 Thread 进行控制。 举个例子： 如果你的 Thread 需要不停地隔一段时间就要连接服务器做某种同步的话，该 Thread 需要在 Activity 没有start的时候也在运行。这个时候当你 start 一个 Activity 就没有办法在该 Activity 里面控制之前创建的 Thread。因此你便需要创建并启动一个 Service ，在 Service 里面创建、运行并控制该 Thread，这样便解决了该问题（因为任何 Activity 都可以控制同一 Service，而系统也只会创建一个对应 Service 的实例）。 因此你可以把 Service 想象成一种消息服务，而你可以在任何有 Context 的地方调用 Context.startService、Context.stopService、Context.bindService，Context.unbindService，来控制它，你也可以在 Service 里注册 BroadcastReceiver，在其他地方通过发送 broadcast 来控制它，当然这些都是 Thread 做不到的。 21、Android本身的api并未声明会抛出异常，则其在运行时有无可能抛出runtime异常，你遇到过吗？诺有的话会导致什么问题？如何解决？ 答： 会，比如nullpointerException。我遇到过，比如textview.setText()时，textview没有初始化。会导致程序无法正常运行出现forceclose。打开控制台查看logcat信息找出异常信息并修改程序。 22、IntentService有何优点? 答：Acitivity的进程，当处理Intent的时候，会产生一个对应的Service； Android的进程处理器现在会尽可能的不kill掉你；非常容易使用 23、如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？ 答：重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据 24、如何将一个Activity设置成窗口的样式。 答： 12&lt;activity&gt;中配置：android :theme=&quot;@android:style/Theme.Dialog&quot; 另外android:theme=&quot;@android:style/Theme.Translucent&quot; 是设置透明 25、如何退出Activity？如何安全退出已调用多个Activity的Application？ 答： 对于单一Activity的应用来说，退出很简单，直接finish()即可。 当然，也可以用killProcess()和System.exit()这样的方法。 对于多个activity， 1、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。 2、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。 3、递归退出：在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。 为了编程方便，最好定义一个Activity基类，处理这些共通问题。 在2.1之前，可以使用ActivityManager的restartPackage方法。 它可以直接结束整个应用。 在使用时需要权限android.permission.RESTART_PACKAGES。 注意不要被它的名字迷惑。 可是，在2.2，这个方法失效了。 在2.2添加了一个新的方法，killBackground Processes()，需要权限 android.permission.KILL_BACKGROUND_PROCESSES。 可惜的是，它和2.2的restartPackage一样，根本起不到应有的效果。 另外还有一个方法，就是系统自带的应用程序管理里，强制结束程序的方法，forceStopPackage()。 它需要权限android.permission.FORCE_STOP_PACKAGES。并且需要添加android:sharedUserId=”android.uid.system”属性。 同样可惜的是，该方法是非公开的，他只能运行在系统进程，第三方程序无法调用。 因为需要在Android.mk中添加LOCAL_CERTIFICATE := platform。 而Android.mk是用于在Android源码下编译程序用的。 从以上可以看出，在2.2，没有办法直接结束一个应用，而只能用自己的办法间接办到。现提供几个方法，供参考： 1、抛异常强制退出：该方法通过抛异常，使程序Force Close。验证可以，但是，需要解决的问题是，如何使程序结束掉，而不弹出Force Close的窗口。 2、记录打开的Activity：每打开一个Activity，就记录下来。在需要退出时，关闭每一个Activity即可。 3、发送特定广播：在需要结束应用时，发送一个特定的广播，每个Activity收到广播后，关闭即可。 4、递归退出在打开新的Activity时使用startActivityForResult，然后自己加标志，在onActivityResult中处理，递归关闭。 除了第一个，都是想办法把每一个Activity都结束掉，间接达到目的。但是这样做同样不完美。你会发现，如果自己的应用程序对每一个Activity都设置了nosensor，在两个Activity结束的间隙，sensor可能有效了。 但至少，我们的目的达到了，而且没有影响用户使用。为了编程方便，最好定义一个Activity基类，处理这些共通问题。 26、AIDL的全称是什么？如何工作？能处理哪些类型的数据？ 答： 全称是：Android Interface Define Language在Android中, 每个应用程序都可以有自己的进程. 在写UI应用的时候, 经常要用到Service. 在不同的进程中, 怎样传递对象呢? 显然, Java中不允许跨进程内存共享. 因此传递对象, 只能把对象拆分成操作系统能理解的简单形式, 以达到跨界对象访问的目的. 在J2EE中,采用RMI的方式, 可以通过序列化传递对象. 在Android中, 则采用AIDL的方式. 理论上AIDL可以传递Bundle,实际上做起来却比较麻烦。 AIDL(AndRoid接口描述语言)是一种接口描述语言; 编译器可以通过aidl文件生成一段代码，通过预先定义的接口达到两个进程内部通信进程的目的. 如果需要在一个Activity中, 访问另一个Service中的某个对象, 需要先将对象转化成AIDL可识别的参数(可能是多个参数), 然后使用AIDL来传递这些参数, 在消息的接收端, 使用这些参数组装成自己需要的对象. AIDL的IPC的机制和COM或CORBA类似, 是基于接口的，但它是轻量级的。它使用代理类在客户端和实现层间传递值. 如果要使用AIDL, 需要完成2件事情: 1. 引入AIDL的相关类.; 2. 调用aidl产生的class. AIDL的创建方法: AIDL语法很简单,可以用来声明一个带一个或多个方法的接口，也可以传递参数和返回值。 由于远程调用的需要, 这些参数和返回值并不是任何类型.下面是些AIDL支持的数据类型: 不需要import声明的简单Java编程语言类型(int,boolean等) String, CharSequence不需要特殊声明 List, Map和Parcelables类型, 这些类型内所包含的数据成员也只能是简单数据类型, String等其他比支持的类型.(另外: 我没尝试Parcelables, 在Eclipse+ADT下编译不过, 或许以后会有所支持) 27、请解释下Android程序运行时权限与文件系统权限的区别。 答： 运行时权限Dalvik( android授权)文件系统 linux 内核授权 28、 系统上安装了多种浏览器，能否指定某浏览器访问指定页面？ 请说明原由。通过直接发送Uri把参数带过去，或者通过manifest里的intentfilter里的data属性 29、android系统的优势和不足 答：Android平台手机 5大优势： 一、开放性 在优势方面，Android平台首先就是其开发性，开发的平台允许任何移动终端厂商加入到Android联盟中来。显著的开放性可以使其拥有更多的开发者，随着用户和应用的日益丰富，一个崭新的平台也将很快走向成熟。开放性对于Android的发展而言，有利于积累人气，这里的人气包括消费者和厂商，而对于消费者来讲，随大的受益正是丰富的软件资源。开放的平台也会带来更大竞争，如此一来，消费者将可以用更低的价位购得心仪的手机。 二、挣脱运营商的束缚 在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。从去年iPhone 上市 ，用户可以更加方便地连接网络，运营商的制约减少。随着EDGE、HSDPA这些2G至3G移动网络的逐步过渡和提升，手机随意接入网络已不是运营商口中的笑谈，当你可以通过手机IM软件方便地进行即时聊天时，再回想不久前天价的彩信和图铃下载业务，是不是像噩梦一样？互联网巨头Google推动的Android终端天生就有网络特色，将让用户离互联网更近。 三、丰富的硬件选择 这一点还是与Android平台的开放性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步、甚至软件的兼容，好比你从诺基亚 Symbian风格手机 一下改用苹果 iPhone ，同时还可将Symbian中优秀的软件带到iPhone上使用、联系人等资料更是可以方便地转移，是不是非常方便呢？ 四、不受任何限制的开发商 Android平台提供给第三方开发商一个十分宽泛、自由的环境，不会受到各种条条框框的阻扰，可想而知，会有多少新颖别致的软件会诞生。但也有其两面性，血腥、暴力、情色方面的程序和游戏如可控制正是留给Android难题之一。 五、无缝结合的Google应用 如今叱诧互联网的Google已经走过10年度历史，从搜索巨人到全面的互联网渗透，Google服务如地图、邮件、搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。再说Android的5大不足： 一、安全和隐私 由于手机 与互联网的紧密联系，个人隐私很难得到保守。除了上网过程中经意或不经意留下的个人足迹，Google这个巨人也时时站在你的身后，洞穿一切，因此，互联网的深入将会带来新一轮的隐私危机。 二、首先开卖Android手机的不是最大运营商 众所周知，T-Mobile在23日，于美国纽约发布 了Android首款手机G1。 但是在北美市场，最大的两家运营商乃AT&amp;T和Verizon，而目前所知取得Android手机销售权的仅有 T-Mobile和Sprint，其中T-Mobile的3G网络相对于其他三家也要逊色不少，因此，用户可以买账购买G1，能否体验到最佳的3G网络服务则要另当别论了！ 三、运营商仍然能够影响到Android手机 在国内市场，不少用户对购得移动定制机不满，感觉所购的手机被人涂画了广告一般。这样的情况在国外市场同样出现。 Android手机的另一发售运营商Sprint就将在其机型中内置其手机商店程序。 四、同类机型用户减少 在不少手机论坛都会有针对某一型号的子论坛，对一款手机的使用心得交流，并分享软件资源。而对于Android平台手机，由于厂商丰富，产品类型多样，这样使用同一款机型的用户越来越少，缺少统一机型的程序强化。 举个稍显不当的例子，现在山寨机泛滥，品种各异，就很少有专门针对某个型号山寨机的讨论和群组，除了哪些功能异常抢眼、颇受追捧的机型以外。 五、过分依赖开发商缺少标准配置 在使用PC端的Windows Xp系统的时候，都会内置微软Windows Media Player这样一个浏览器程序，用户可以选择更多样的播放器，如Realplay或暴风影音等。 但入手开始使用默认的程序同样可以应付多样的需要。 在 Android平台中，由于其开放性，软件更多依赖第三方厂商，比如Android系统的SDK中就没有内置音乐 播放器，全部依赖第三方开发，缺少了产品的统一性。 30、Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念 答： DVM指dalivk的虚拟机。 每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。 而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。 31、sim卡的EF文件是什么？有何作用 答： sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的 32、嵌入式操作系统内存管理有哪几种， 各有何特性 页式，段式，段页，用到了MMU,虚拟空间等技术 33、什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗? 嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。 主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于linux内核的，因此属于软实时。 34、一条最长的短信息约占多少byte? 中文70(包括标点)，英文160，160个字节。 35、有一个一维整型数组int[] data保存的是一张宽为width，高为height的图片像素值信息。 请写一个算法，将该图片所有的白色不透明(0xffffffff)像素点的透明度调整为50%。 36、如何将SQLite数据库(dictionary.db文件)与apk文件一起发布 解答： 可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。 所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。 可以将dictionary.db文件复制到res aw目录中 37、如何将打开res aw目录中的数据库文件? 解答： 在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。 复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。 在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。 38、DDMS和TraceView的区别? DDMS是一个程序执行查看器，在里面可以看见线程和堆栈等信息，TraceView是程序性能分析器 。 39、java中如何引用本地语言 可以用JNI（java native interface java 本地接口）接口 。 40、谈谈Android的IPC（进程间通信）机制 IPC是内部进程通信的简称， 是共享”命名管道”的资源。 Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。 Servier端实现IPC接口，Client端调用IPC接口本地代理。 41、NDK是什么 NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。 NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so 编辑 ：达叔 定位：分享 Android&amp;Java 知识点]]></content>
      <categories>
        <category>我的书籍</category>
      </categories>
      <tags>
        <tag>我的书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作个人简历模板网页效果 | 码云端的开源项目]]></title>
    <url>%2F2018%2F05%2F09%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 制作个人简历模板网页效果文 / 达叔 原创 制作个人简历模板网页效果 PC 端 移动端 首先要注册并登陆码云的网站：https://gitee.com/ 然后学会用 Git，就可以了，如图所示给出了文档 程序员技术交流群群号：711613774 大概教程： 就是下载源代码下来，然后更改 index.html 文件即可，再次用Git上传到自己的项目中，然后申请Pages模式，即可就可以在自己的网页中显示自己的简历。 在大学毕业季，需要找工作，还用什么纸质的吗？还用pdf文件吗？ 跟HR说：可以上网看 安装教程 - 使用说明 Fork 此项⽬目 将项⽬目 Clone 到本地 更更改⾃自⼰己的信息并更更新到远程 发布到⾃自⼰己的 Pages 贡献一个开源项⽬目提交贡献代码 项⽬目地址 https://gitee.com/itsay/resume 须知 码云可以支持 Pages 功能，跟 Github 一样了，用过 Github Pages 的朋友就会很快的上手的，跟 Github 一样，默认的根文件是 index.html ， 登陆码云创建新的项目 ，+ ，这个加创建项目 项目名称：自己看可以定义：例如：Pages 然后记得这个要打勾：使用 Readme 文件初始化这个项目，点击创建就好 创建好后，定义一个 index.html 文件即可，写一段简单代码，展示效果 如图点击后，进入Gitee Pages 服务，点击部署分支为 master 即可，然后点击开启 Gitee Pages 服务，网站地址就会自动给你，这时你就可以看到了哦~ 如果你没用过 Git ，可以去看文档，我已上传教程，很简单的 Git Bash here ，表示在这个目录中提交并使用； 这里我展示一下 Git 的过程，你可以参考一下，其他的你就 Google Chrome ，展示一下代码，其实这文档中也有展示的： 注意：git config –global user.name 中，是 – ，两个 “-”； GitHub 手把手教你如何把本地项目或代码提交到Github托管https://blog.csdn.net/qq_36232611/article/details/78509671 123456789101112131415161718192021222324252627282930313233343536373839404142434445git config --global user.name &quot;你的码云名字&quot;回车git config --global user.email &quot;你的登录邮箱&quot;回车git clone https://....gitcd 到你的目录然后把你下载好的源代码改一下，然后复制到次目录中即可--1git add .表示添加所有代码git commit -m &quot;chance log &quot;表示你提交代码后，进行备注，这个步骤一定要的，否则会出错git push origin master表示进行提交-----------大功告成如果提交后，要进行更改内容如：index.html 中的代码：这是后你是已经复制代码到目录中了--1更新：你所需代码：git status即可看到你的更新代码git commit -m &quot;随便写的&quot;git push origin master表示再次提交的步骤，🆗，大功告成 编辑 ：达叔 信箱：2397923107@qq.com 定位：分享 Android&amp;Java 知识点 我是简书的达叔小生。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零基础入门Android语法与界面笔记]]></title>
    <url>%2F2018%2F05%2F08%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 来源零基础入门Android语法与界面做笔记 面向对象 1、什么是对象2、什么是面向对象3、什么是类4、什么是属性5、什么是方法6、类和对象的关系 什么是对象• 万物皆对象、客观存在的事物• 对象：用来描述客观事物的一个实体，由一组属性和方法构成 什么是面向对象• 人关注对象• 人关注事物信息 类• 类是模子，确定对象将会拥有的特征（属性）和行为（方法）• 类的特点• 类是对象的类型• 具有相同属性和方法的一组对象的集合 什么是对象的属性和方法• 属性：对象具有的各种静态特征• “有什么”• 方法：对象具有的各种动态行为• “能做什么” 类和对象的关系• 类是抽象的概念，仅仅是模板• 对象是一个你能够看得到、摸得着的具体实体• 类是对象的类型• 对象是特定类型的数据• 具体开发过程中，先定义类再实例化对象 单一职责原则• 单一职责原则，也称为单一功能原则• 英文Single Responsibility Principle 缩写SRP• 是面向对象设计中的一个重要原则• 一个类，应该有且只有一个引起变化的原因• 在程序设计中，尽量把不同的职责，放在不同的职责中，即把不同的变化原因，封装到不同的类中。 对象实例化需要了解的 对象实例化• 实例化对象的过程可以分为两部分：– 声明对象 Cat one– 实例化对象 new Cat();– Cat one=new Cat(); 对象实例化• 每次new对象会产生新的实例化对象– Cat one=new Cat();– Cat two=new Cat(); 对象实例化• 多个对象可以指向同一块实例化空间– Cat one=new Cat();– Cat two=one; 对象实例化• 对象必须被实例化之后才能使用• 对象间的引用传递，实际上传递的是堆内存空间的使用权 构造方法1、构造方法与类同名且没有返回值2、构造方法的语句格式3、只能在对象实例化的时候调用 构造方法4、当没有指定构造方法时，系统会自动添加无参的构造方法5、当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法6、一个类中可以有多个构造方法 单一职责原则（SRP：Single responsibility principle）又称单一功能原则，面向对象五个基本原则（SOLID： SRP 单一责任原则、OCP 开放封闭原则、LSP 里氏替换原则、DIP 依赖倒置原则、ISP 接口分离原则）之一。它规定一个类应该只有一个发生变化的原因。该原则由罗伯特·C·马丁（Robert C.Martin）于《敏捷软件开发：原则、模式和实践》一书中给出的。马丁表示此原则是基于汤姆·狄马克(Tom DeMarco)和 Meilir Page-Jones 的著作中的内聚性原则发展出的。 所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。 单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。 之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：T负责两个不同的职责：职责 P1，职责 P2。当由于职责 P1 需求发生改变而需要修改类 T P2 功能发生故障。也就是说职责 P1 和 P2解决办法：遵守单一职责原则，将不同的职责封装到不同的类或模块中。分别建立两个类 T1、T2，使 T1 完成职责 P1 功能，T2 完成职责 P2 功能。这样，当修改类 T1 时，不会使职责 P2 发生故障风险；同理，当修改 T2 时，也不会使职责 P1 发生故障风险。 关键字的用法 this 在类中就是代表当前对象，可以通过 this 关键字完成当前对象的成员属性、成员方法和构造方法的调用。那么何时用 this？当在定义类中的方法时，如果需要调用该类对象，就可以用 this来表示这个对象。也就是说，但凡在本类功能内部使用到了本类对象，都用 this 表示。至于代表哪个对象，就看其所在功能被哪个对象调用，这样就知道谁在参与运算。 封装• 将类的某些信息隐藏在类内部，不允许外部程序直接访问• 通过该类提供的方法来实现对隐藏信息的操作和访问• 隐藏对象的信息• 留出访问的接口 封装特点：1、只能通过规定的方法访问数据2、隐藏类的实例细节，方便修改和实现 封装设为private修改属性的可见性设为public创建getter/setter方法用于属性的读写对属性值的合法性进行判断在getter/setter方法中加入属性控制语句 包作用：1、管理Java文件2、解决同名文件冲突 定义包语法：package 包名;例：package com.imooc.animal;注意：1、必须放在Java源文件中的第一行2、一个Java源文件中只能有一个package语句3、包名全部英文小写4、命名方式：域名倒序+模块+功能 导入包语法：import 包名.类名;例：1234导入包中全部类：import com.imooc.*;导入包中指定类：import com.imooc.animal.Cat; 常用系统包123java.lang 包含java语言基础的类java.util 包含java语言中各种工具类java.io 包含输入、输出相关功能的类 static1、static+属性—静态属性2、static+方法—静态方法3、static+类—不存在4、static+方法内局部变量—不存在静态成员随类加载产生，直至类销毁才回收 静态方法1、可以直接调用同类中的静态成员2、不可以直接调用同类中的非静态成员3、可以通过实例化对象后，对象调用的方式完成非静态成员调用 代码块1、通过{ }可以形成代码块2、方法内的代码块称为：普通代码块3、类内的代码块称为：构造代码块4、构造代码块前+static：静态代码块 代码块执行顺序1、无论实例产生多少对象，静态代码块只执行一次2、构造代码块随实例化过程调用3、普通代码块随方法调用执行 kage 和 import 的使用1、打包–package包名一般为小写，而类名的第一个字母一般为大写，这样在引用时，可以明显的分辨出包名和类名。如果在类的定义之前没有使用package定义包名，那么该类就属于缺省的包。 1.1、包的作用可以更好的组织类，包与文件夹类似，文件夹可以将不同的文件放在同一个文件夹中，而包也可以将不同的类文件放在同一包中。减少类名的冲突问题，这也与文件夹类似，同一文件夹中的文件不能重名，不同文件中的 文件可以重名，同一包中的类名不能重复，不同包中的类名可以重复。对包中的类起了一定的保护作用，详见 Java 的访问控制（在后面的课程中会详细讲解~~）。 1.2、包的使用使用 package 关键字指明类所在的包。 package 语句必须在文件的最前面。 编译时可使用 javac –d . Test.java 自动产生包需要目录。 可以使用 java testPackage.Test来执行编译后的代码。 2、导入–import使用了包机制后，如果在一个类中使用了其他包中的类，需要使用 import 来引入。 2.1 import的使用直接引用指定的类，如 import java.util.Vector。 12345678910111213引用一个包中的多个类，如 import java.awt.*。*号代替类名，但不能代替包名，如import java.awt.*，只引用 java.awt 下的类，而不引用 java.awt 下的子包里面的类。import java.awt.F*，这种使用方法是错误的。import 语句在所有类定义之前，在 package 定义之后。import 只告诉编译器及解释器哪里可以找到类、变量、方法的定义，而并没有将这些定义 引入代码中。2.2 包中类的使用如果要使用的类是属于 java.lang 包的，那么可以直接使用类名来引用指定的类，而不需要加上包名，因为包 java.lang 不用显示使用 import，它是缺省引入的。 如果要使用的类在其它包（java.lang 除外）中，那么可以通过包名加上类名来引用该类， 如java.awt.Font。对于经常要使用的类（该类在其它包中），那么最好使用 import 引用指定的包，如java.awt.*。如果 import 引入的不同的包中包含有相同的类名，那么这些类的使用必须加上包名。 生活中的继承• 孩子像爸妈• 富二代• 师徒关系 程序中的继承12345678910-表示私有Dog- name:String- month:int- species:String- sex:String- name:String- month:int- species:String- weight:double 123456789101112131415+表示公有+ eat():void+ eat():void+ getName():String+ getMonth ():int+ getSpecies ():String+ getSex():String+ sleep():void+ getName():String+ getMonth ():int+ getSpecies ():String+ getWeight():double+ run():void+ Dog()+ Cat() 123456789101112131415161718程序中的继承CatDogAnimal- sex:String+ sleep():void+ Dog()- weight:double- name:String- month:int- species:String+ run():void+ Cat()+ eat():void+ getName():String+ getMonth ():int+ getSpecies ():String+ getWeight():double 继承特点：1、利于代码复2、缩短开发周期 继承• 一种类与类之间的关系• 使用已存在的类的定义作为基础建立新类• 新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类•父类 基类•子类 派生类 123456继承的关系• 满足“A is a B ”的关系就可以形成继承关系如：猫、狗是动物==》猫，狗继承自动物学生、老师是人==》学生，老师继承自人小轿车、大卡车是汽车==》小轿车，大卡车继承自汽车 实现继承使用extends实现封装–编写父类12345678910class Animal&#123;//公共的属性和方法&#125;–编写子类，继承父类class Dog extends Animal&#123;//子类特有的属性和方法&#125;class Cat extends Animal&#123;&#125;只能继承一个父类 方法重写语法规则：• 返回值类型• 方法名• 参数类型、顺序、个数都要与父类继承的方法相同 方法重写 PK 方法重载• 方法重写：• 方法重载：– 在满足继承关系的子类中– 在同一个类中– 方法名相同– 方法名、参数个数、顺序、类型与父类、返回值相同– 参数个数、顺序、类型不同– 返回值类型、访问修饰符任意– 访问修饰符的限定范围大于等于父类方法 方法重写存在属性重写不存在 12345访问修饰符• 公有的：public• 私有的：private• 受保护的 ：protected• 默认 如何区分调用的是继承父类的方法还是子类自己重写的方法？ 123456super• 子类访问父类成员– 访问父类成员方法super.print();super.name;– 访问父类属性 12345678实例化顺序•继承后的初始化顺序父类静态成员子类静态成员父类对象构造（属性（赋值）、构造代码块、构造方法）子类对象构造（属性（赋值）、构造代码块、构造方法） 子类对象实例化时，能否选择父类的构造形式（调用指定的构造方法）？ 12345678super• 子类访问父类成员– 访问父类成员方法super.print();super.name;super();– 访问父类属性– 访问父类构造方法 super• 子类的构造的过程中必须调用其父类的构造方法• 如果子类的构造方法中没有显示调用父类的构造方法，则系统系默认调用父类无参的构造方法• 如果子类构造方法中既没有显式调用父类的构造方法，而父类又没有无参的构造方法，则编译出错• 使用super调用父类指定构造方法，必须在子类的构造方法的第一行 123456789101112super pk this• this: 当前类对象的引用– 访问当前类的成员方法– 访问当前类的成员属性– 访问当前类的构造方法– 不能在静态方法中使用• super: 父类对象的引用– 访问父类的成员方法– 访问父类的成员属性– 访问父类的构造方法– 不能在静态方法中使用• 构造方法调用时，super和this不能同时出现 设计模式• 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。• 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。 设计模式• 项目中合理的运用设计模式可以完美的解决很多问题• 每种模式在现在中都有相应的原理来与之对应• 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案 设计模式• 面向对象的设计模式很多，但大家认为这23个模式是其它模式的基础 单例模式（Singleton）• 滚滚历史，朝代更迭，永恒定律：– 一个朝代皇帝只有一个– 军队的最高司令官只有一个– 一山不容二虎• 计算机系统：– 驱动程序– 打印机后台处理程序（Printer Spooler）– 线程池– 缓存– 日志 单例模式（Singleton）目的：使得类的一个对象成为该类系统中的唯一实例定义：一个类有且仅有一个实例，并且自行实例化向整个系统提供 单例模式要点：1、某个类只能有一个实例2、必须自行创建实例3、必须自行向整个系统提供这个实例实现：1、只提供私有的构造方法2、含有一个该类的静态私有对象3、提供一个静态的公有方法用于创建、获取静态私有对象 单例模式代码实现方案：1、饿汉式2、懒汉式 饿汉式 PK 懒汉式1、饿汉式在类加载时就创建实例， 第一次加载速度快；懒汉式第一次使用时才进行实例化，第一次加载速度慢饿汉式：空间换时间懒汉式：时间换空间2、饿汉式线程安全；懒汉式存在线程风险解决方案：1、同步锁3、静态内部类4、枚举2、双重校验锁 单例模式优点：1、在内存中只有一个对象，节省内存空间2、避免频繁的创建销毁对象，提高性能3、避免对共享资源的多重占用缺点：1、扩展比较困难2、如果实例化后的对象长期不利用，系统将默认为垃圾进行回收，造成对象状态丢失 单例模式适用场景：1、创建对象时占用资源过多，但同时又需要用到该类对象2、对系统内资源要求统一读写，如读写配置信息3、当多个实例存在可能引起程序逻辑错误，如号码生成器 UML 中表示类与类的关系 UML(Unified Modeling Language), 又称统一建模语言或标准建模语言，它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，可用于多种类型软件系统开发建模的各个阶段。我们可以用 UML 图例来表示类与类之间的各种关系。 类的层次结构代表类与类之间的关系，类的关系有很多种，包括泛化、依赖、关联、聚合和组合。这些关系在大的类别上还可分为两种：横向关系和纵向关系，纵向关系就是泛化关系，而横向关系就是剩下的 4 种， 它们的强弱关系：依赖 &lt; 关联 &lt; 聚合 &lt; 组合。 理解这些类的关系，并应用于类的层次结构设计中，有助于优化代码组织结构。 接下来我们用 Enterprise Architect 12.0.1210 Corporate Edition 建模软件为大家演示这几种类与类关系的表示。 泛化 泛化关系就是继承，表示一般与特殊的关系，即“一般”元素是“特殊”元素的泛化。在继承中，一般类就是父类，特殊类就是子类。 它们之间是“is a”的关系。 如：一个 Cat 类继承 Animal 类，也就是说 Cat is an Animal。在 UML类图设计中，继承用一条带空心三角箭头的实线表示，从子类指向父类，或者子接口指向父接口。 依赖 表示一个元素以某种方式依赖于另一种元素。 依赖就是一个类 A 使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是类 B 的变化会影响到类 A。 它们之间是“use a”的关系。 依赖的例子有：一个类把另一个类的对象作为参数，一个类访问另一个类的全局变量，或者一个类调用另一个类的类操作。 比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。表现在代码层面，为类 B 作为参数被类 A 在某个 method 方法中使用。在 UML 类图设计中，依赖关系用由类 A 指向类 B 的带箭头虚线表示。 关联 关联体现的是两个类之间一种强依赖关系，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的。关联可以是单向、双向的。 比如老师和学生是双向关联，老师有多名学生，学生也可能有多名老师。学生跟学生学号之间是单向关联，一个学生只能对应一个唯一的学号。在 UML 类图设计中, 双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 聚合 聚合关系是关联关系的一种，是强的关联关系，它体现的是整体与部分的关系 ，且部分可以离开整体而单独存在；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 它们之间是“use a”的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。 在 UML 类图设计中，聚合关系以空心菱形加实线表示。如学校有很多老师。 组合 是整体与部分的关系，是比聚合关系还要强的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，如公司和部门是整体和部分的关系, 没有公司就不存在部门。 它体现的是一种“contains-a”的关系。在 UML 类图设计中，组合关系以实心菱形加实线表示。 抽象类和抽象方法 一：知识梳理 1.基本概念： 在面向对象的概念中，所有的对象都是通过类来描述的，但并不是说所有的类都是用来描述对象的，当一个类中没有包含足够的信息以描绘一个具体的对象时，这样的类就是抽象类。 例：形状就是一个抽象的概念。不同的子类计算形状面积的方法是不一样的。可提供抽象方法来被不同的子类所实现。 123abstract public class Shape&#123; abstract double area();&#125; 从例子中可看出，抽象类是用关键字 abstract 修饰的。抽象类中有一种特殊方法，即用 abstract 关键字来修饰的方法，称为“抽象方法”。 2.抽象类和抽象方法的声明格式： 12345abstract class &lt;类名&gt;&#123; 成员变量; 方法（）&#123;方法体&#125;; abstract 方法（）；&#125; 3.抽象类和抽象方法的特点： （1）抽象方法不允许直接实例化，换句话说抽象类不能创建对象，它只能作为其他类的父类。 但可以通过向上转型，指向实例化。 （2）抽象方法只有声明，不能有实现，也就是仅有方法头，而没有方法体和操作实现。 如：abstract double area( ); 4.定义抽象类的意义在于： （1）为其子类提供一个公共的类型（父类引用指向子类对象）；（2）封装子类中的重复内容（成员变量和方法）;（3）将父类设计成抽象类后，既可借由父子继承关系限制子类的设计随意性，在一定程度上避免了无意义父类的实例化。 二．重点注意 含有抽象方法的类，只能被定义成抽象类。 如下面，不定义为抽象类时会报错：123public class Shape&#123; abstract double area();&#125; 正确的代码为：123abstract public class Shape()&#123; abstract double area();&#125; 抽象类不一定包含抽象方法。例子：12345abstract public class Shape&#123; public void girth()&#123; System.out.println(&quot;图形周长为...&quot;); &#125;&#125; 在抽象类中的成员方法可以包括一般方法和抽象方法123456abstract public class Shape&#123; public void girth()&#123; System.out.println(&quot;图形周长为..&quot;); &#125; abstract double area();&#125; 抽象类不能被实例化，即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。抽象类的构造方法主要是用于被其子类调用。 例子：Shape 抽象类中不含抽象方法：12345abstract public class Shape&#123; public void girth()&#123; System.out.println(&quot;图形周长为..&quot;); &#125;&#125; 测试类中实例化 Shape,编译器会报错：1Shape s=new Shape(); 一个类继承抽象类后，必须实现其所有抽象方法，否则也是抽象类，不同的子类对父类的抽象方法可以有不同的实现。 如父类为：123abstract public class Shape&#123; abstract double area();&#125; 则其子类 Circle 有两种做法： 方案一：重写抽象方法 area( ),使方法得以实现123456789public class Circle extends Shape&#123; public double r; public Circle(double r)&#123; this.r=r; &#125; public double area()&#123; return(double)(3.14*r*r); &#125;&#125; 方案二：子类 Circle 类也定义为抽象类123456public abstract class Circle extends Shape&#123; public double r; public Circle(double r)&#123; this.r=r; &#125;&#125; 即使父类是具体的，但其子类也可以是抽象的。如 Object 是具体的，但可以创建抽象子类。 abstract 方法不能用 static 和 private 修饰；对于类，不能同时用 final 和 abstract 修饰，因为 final 关键字使得类不可继承，而 abstract 修饰的类如果不可以继承将没有任何意义。两者放在一起，会起冲突 如以下用法都会引起编译器报错：1234567static abstract double area();private abstract double area();abstract final class Shape()&#123; abstract double area();&#125; 三：一个完整准确的抽象类例子 声明一个抽象类 Shape,有抽象成员方法 area()。Shape 派生出两个子类圆 Circle 类和矩形 Rectangle 类。Shape 里声明了抽象方法area(),该方法分别在两个子类里得到实现。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758abstract public class Shape&#123; abstract double area();&#125;public class Circle extends Shape&#123; public double r; Circle()&#123; &#125; public Circle(double r)&#123; this.r=r; &#125; public double getR()&#123; return r; &#125; public void setR(double r)&#123; this.r=r; &#125; public double area()&#123; return(double)(3.14*r*r); &#125;&#125;public class Rectangle extends Shape&#123; public double lenghth; public double wide; Rectangle()&#123; &#125; public Rectangle(double lenghth,double wide)&#123; this.lenghth=lenghth; this.wide=wide; &#125; public double getLenghth()&#123; return lenghth; &#125; public void setLenghth(double lenghth)&#123; this.lenghth = lenghth; &#125; public double getWide()&#123; return wide; &#125; public void setWide(double wide)&#123; this.wide=wide; &#125; public double area()&#123; return lenghth*wide; &#125;&#125;public class Test&#123; public static void main(Stirng[] args)&#123; Circle c=new Circle(3.5); Rectangle re=new Rectangle(6,5); System.out.println(c.area()); System.out.println(re.area()); &#125;&#125; 接口中的内部类 我们在实际开发过程中，如果想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么接口内部的嵌套类会显得很方便。 也就是说，在接口中可以含有内部类。 在这里，向大家展示接口中放置普通成员内部类和抽象成员内部类的情况。 首先创建接口，接口中定义了普通内部类 InnerClass 和抽象内部类 AbInnerClass 普通成员内部类的实例化 创建接口的实现类 ClassDemo 123456789101112131415161718192021public interface IOuterInterface&#123; int TEMP=100; void abMethod(); public default void deMethod()&#123; System.out.println(&quot;默认&quot;); &#125; public static void stMethod()&#123; System.out.println(&quot;静态&quot;); &#125; public class InnerClass&#123; public void show()&#123; System.out.println(&quot;&quot;); &#125; &#125; public abstract class AbInnerClass&#123; public abstract void abInfo(); public void info()&#123; System.out.println(&quot;&quot;); &#125; &#125;&#125; 普通成员内部类的实例化创建接口的实现类 ClassDemo 123456789101112131415161718192021public class ClassDemo implements IOuterInterface&#123; public void abMethod()&#123; &#125; public InnerClass getInner()&#123; return new InnerClass(); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; IOuterInterface.InnerClass inner=new IOuterInterface.InnerClass(); inner.show(); ClassDemo demo=new ClassDemo(); demo.getInner().show(); InnerClass innerTwo = new InnerClass(); innerTwo.show(); &#125;&#125; 抽象成员内部类的实例化创建接口的实现类 AbClassDemo 12345678910public class AbClassDemo implements IOuterInterface&#123; public void abMethod()&#123; &#125; public class AbDemo extends AbInnerClass&#123; public void abInfo()&#123; System.out.println(); &#125; &#125;&#125; 12345678910111213141516public class TestOne&#123; public static void main(String[] args)&#123; IOuterInterface.AbInnerClass abInner=new IOuterInterface.AbInnerClass()&#123; public void abInfo()&#123; System.out.println(); &#125; &#125;; aabInner.abInfo(); abInner.info(); System.out.println(); IOuterInterface.AbInnerClass abInner=new AbClassDemo().new AbDemo(); abInnerOne.abInfo(); abInnerOne.info(); &#125;&#125; 匿名内部类详解 概 念 匿名内部类也就是没有名字的内部类正因为没有名字，所以匿名内部类只能使用一次， 它通常用来简化代码编写但使用匿名内部类还有个前提条件： 必须继承一个父类或实现一个接口 注意事项：  编译后的文件命名：外部类$数字 . class 无法使用 public、private、abstract、static 修饰，匿名内部类不能出现抽象方法 无法编写构造方法，但可以添加构造代码块 不能出现静态成员 匿名内部类可实现接口也可以继承类，但是不可兼得 匿名内部类不能是抽象的，它必须要实现继承的类或者实现接口的所有抽象方法 匿 名 内 部 类 初 始 化 我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的，那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。实例： 12345678910111213141516171819202122232425public class OutClass&#123; public InnerClass getInnerClass(final int age, final Stirng name)&#123; return new InnerClass()&#123; int age_; Stirng name_; &#123; if(0&lt;age&amp;&amp;age&lt;200)&#123; age_=age; nam_=name; &#125; &#125; public String getName()&#123; return name_; &#125; public int getAge()&#123; return age_; &#125; &#125;; &#125; public static void main(String[] args)&#123; OutClass out = new OutClass(); &#125;&#125; 实 例匿名内部类可以有不同的表现形式，下面用实例向大家展示一下：继承式的匿名内部类： 1234567891011121314abstract class Car&#123; public abstract void drive();&#125;class Test&#123; public static void main(String[] args)&#123; Car car=new Car()&#123; public void drive()&#123; System.out.println(&quot;&quot;); &#125; &#125;; car.drive(); &#125;&#125; 1234567891011121314interface Vehicle&#123; public void drive();&#125;class Test&#123; public static void main(Stirng[] args)&#123; Vehicle v=new Vehicle()&#123; public void drive()&#123; System.out.println(); &#125; &#125;; v.drive(); &#125;&#125; 12345678910111213141516171819202122abstract class Bar&#123; void doStuff(Foo f)&#123;&#125;&#125;class BarOne extends Bar&#123; void doStuff(Foo f)&#123;&#125;&#125;interface Foo&#123; void foo();&#125;class Test&#123; static void go()&#123; Bar b = new BarOne(); b.doStuff(new Foo())&#123; public void foo()&#123; System.out.println(); &#125; &#125;); &#125;&#125; thread 类的匿名内部类实现 123456789101112public class Demo&#123; public static void main(String[] args)&#123; Thread t = new Thread()&#123; public void run()&#123; for (int i=1;i&lt;=5;i++)&#123; System.out.println(); &#125; &#125; &#125;; t.start(); &#125;&#125; Runnable 接口的匿名内部类实现：12345678910111213public class Demo&#123; public static void main(Stirng[] args)&#123; Runnable r=new Runnable()&#123; public void run()&#123; for(int i=1;i&lt;=5;i++)&#123; System.out.println(); &#125; &#125; &#125;; Thread t=new Thread(r); t.start(); &#125;&#125; 向上转型和动态绑定机制 知 识 梳 理 向上转型的概念： 向上转型又叫自动转型、隐式转型。向上转型就是父类引用指向子类实例，也就是子类的对象可以赋值给父类的对象。 如：Animal dog=new Dog( ); //Dog 类是 Animal 类的子类 注：向上转型是安全的，因为任何子类都继承并接受了父类的方法。从例子中也可以理解，所有的狗狗都属于狗的父类——动物，这是可行的，但是向下转型则不行，若说所有的动物都是狗狗就不成立了。（所以向下转型要通过强制类型转换，后续章节中会讲解） 2、向上转型的应用 1）当一个子类对象向上转型父类类型以后，就被当成了父类的对象，所能调用的方法会减少，只能调用子类重写了父类的方法以及父类派生的方法（如 set()、get()方法），而不能调用子类独有的方法。例如： 对象实例化：1Pen pc = new Pencil(); 此时，调用方法调用时 12pc.writing();pc.show(); 可以调用子类重写父类的方法 writing(),但调用子类独有的方法 show()时就是无效的 2）父类中的静态方法是不允许被子类重写的。 如父类 Pen 中含有静态方法 draw( ) 123public static void draw()&#123; System.out.println();&#125; 当子类 Pencil 中也定义同名方法时，此时 draw( )算 Pencil 类自己独有的方法： 123public static void draw()&#123; System.out.println();&#125; 测试类中调用时： 返回结果为： 也就是实际上调用的是父类的静态方法 draw( ) 知 识 扩 展 多态的实现可以通过向上转型和动态绑定机制来完成，向上转型实现了将子类对象向上转型为父类类型，而动态绑定机制能识别出对象转型前的类型，从而自动调用该类的方法，两者相辅相成。 动态绑定： 绑定就是将一个方法调用同一个方法所在的类连接到一起就是绑定。绑定分为静态绑定和动态绑定两种。 静态绑定：在程序运行之前进行绑定（由编译器和链接程序完成的），也叫做前期绑定。 动态绑定：在程序运行期间由 JVM 根据对象的类型自动的判断应该调用哪个方法，也叫做后期绑定。 静态绑定的例子： 如有一类 Human,它派生出来三个子类 Chinese 类、American 类和 British 类，三个子类中都重写了父类中的方法 speak( )：void,在测试类中用静态绑定的方式调用方法speak( )。12345678Chinese c = new Chinese();c.speak();American a=new American();a.speak();British b=new British();b.speak(); 这种调用方式是在代码里指定的，编译时编译器就知道 c 调用的是 Chinese 的 speak( ),a调用的是 American 的 speak( )。 动态绑定的例子： 如果我们在测试类中做以下改动： 1Human[] human = new Human[5]; 此时，Human 类中随机生成 Chinese 类、American 类和 British 类的对象，编译器不能根据代码直接确定调用哪个类中的 speak( )方法，直到运行时才能根据产生的随机数 n 的值来确定 human[i]到底代表哪一个子类的对象，这样才能最终确定调用的是哪个类中的speak( )方法，这就是动态绑定。 向下转型和 instanceof 运算符的应用 知 识 梳 理 一：向下转型 向下转型 向下转型是与向上转型相对的概念，它是用子类引用指向父类实例。 如：下图，在进行转换是会报错 12Animal a = new Dog();Dog d=a; 这时就告诉我们向下转型不能自动转换，我们需要强转，所以向下转型又叫做强制类型转换。 正确的转换语句为： 12Animal a=new Dog();Dog d=(Dog)a; 向下转型后，可以调用子类自己独有的方法。例如：（承接上一文档例子） 测试类中通过强制类型转换后，可调用 Pencil 类中独有的方法 show( )了。123Pen pc = new Pencil();Pencil p = (Pencil)pc;p.show(); 兄弟类之间不能进行强制类型转换。 如：父类 Pen 类派生出另一个子类 Brush。 将指向 Brush 对象的父类引用 b 强制转换为 Brush 的兄弟类 Pencil 的对象，此时编译器并没有报错，但在运行时会报出如下错误： 二：instanceof 运算符 1． 基本概念instanceof 运算符用来判断对象是否可满足某个特定类型实例特征。返回值为true/false。一般用于 if 语句中。 表示方法为：如： 123boolean result;Pen pc=new Pencil();result=pc instanceof Pencil; 如果左边对象是右边类的实例则返回 true,否则返回 false。 2.instanceof 运算符的应用 1）用 instanceof 运算符用来判断对象是否可满足某个特定类型实例特征例子： 父类 Parents 类，Father 类和 Mother 类分别为它的两个子类：12Parents f=new Father();Parents m=new Mother(); 运行结果为：注：java 中所有类都直接或间接继承于 Object 类。 Four依赖与关联关系 依赖关系依赖关系(Dependency) 是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。如人要过河时要使用到船，人与船之间就是依赖关系；我用锤子在墙上锤了一下，我和锤子之间就是依赖关系；装修工人安装灯具时需要使用工具，装修工人和工具之间就是依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。依赖关系有下列三种情况： A 类是 B 类中（某种方法的）局部变量A 类是 B 类方法当中的一个参数A 类向 B 类发送消息，从而影响 B 类发生变化 我们这里就依赖关系最常出现的情况—在某个类的方法使用另一个类的对象作为参数进行举例说明：课程表与课程之间就是依赖关系，UML 图表示为：对应的 java 代码片段：123456789101112131415public class CourseTable&#123; public void addCourse(Course course)&#123; course.show(); System.out.println(); &#125; public void reCourse(Course course)&#123; course.show(); System.out.println(); &#125; public class Course&#123; public void show()&#123; System.out.println(); &#125; &#125;&#125; 课程表类中用课程的对象作为参数，进行增加课程和删除课程的功能。课程的变化会引起课程表的实时变更，这就是一种“use a”的关系，也就是课程表依赖于课程。 关联关系 关联关系是类与类之间最常用的一种关系，它是一种结构化关系，代表类的对象之间的一组连接。如客户与订单、老师与学生、公司与职员，人体与大脑，这些关系不是是使用时才有的，而是一种长期且稳定的关系。关联关系可以分为双向关联、单向关联、自关联。 a)双向关联：指双方都知道对方的存在，都可以调用对方的公共属性和方法。默认情况下，关联是双向的。如供货商和顾客之间的关系，一家供货商可以向多个顾客供货，一个顾客也可以向多家供货商进货 UML 图表示为：对应的 java 代码片段：12345678public class Customer&#123; private Supplier[] supplier; .....&#125;public class Supplier&#123; public Customer[] customer;&#125; b)单向关联：类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如：顾客(Customer)拥有地址(Address)，则 Customer 类与 Address 类具有单向关联关系UML 图表示为： 对应的 java 代码片段：c)自身关联（反身关联）：在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。顾客自身需要用到自己对象时，自己引用自己，带着一个自己的引用。UML 图表示为： 对应的 java 代码片段： 12345678public class Customer&#123; private Address address; ...&#125;public class Address&#123; ...&#125; 补充扩展：重数性关联: 表示一个类的对象与另一个类的对象连接的个数。在 UML 中多重性关系可以直接在关联直线上增加一个数字表示与之对应的另一个类的对象的个数。在关联的两端可写上一个被称为重数的范围，表示该类有多少个对象可与对方一个对象连接，重数的默认值为 1，重数的符号通常有：表示方式 多重性说明表示“1”，表示另一个类的一个对象只与一个该类对象有关系表示“零或多”，表示另一个类的一个对象与零个或多个该类对象有关系表示“1 或多”，表示另一个类的一个对象与一个或多个该类对象有关系表示“零或 1”，表示另一个类的一个对象没有或只与一个该类对象有关系表示另一个类的一个对象与最少 m、最多 n 个该类对象有关系 (m&lt;=n) ok]]></content>
      <categories>
        <category>我的视频</category>
      </categories>
      <tags>
        <tag>我的视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕向东Java基础视频教程光碟01笔记]]></title>
    <url>%2F2018%2F05%2F07%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 学习笔记 本套视频共计33天。第1天~第5天讲解Java基础知识，带着读者轻松掌握Java中的字词句如何使用。并实现Java版的计算器。第6天~第11天讲解Java的对象细节：培养面向对象思想，掌握对象和类的关系，封装、继承、多态的细节。如何使用内部类简化代码，第12天~第13天讲解Java中的异常和包的使用。第14天~第16天讲解Java中的多线程，实现多生产多消费，解决人妖问题。eclipse使用。第17天~第18天讲解String类和JDK5中的特性。第19天~第21天讲解Java中的各种集合容器使用。实现学生信息管理。第22天~第26天讲解Java中的IO操作，并且时间文件切合和合并。第27天讲解Java中的图形界面使用，实现自己想要的各种心动界面。第28天~第29天讲解Java中的网络编程，实现网络聊天，群聊，文件上传，自己的浏览器实现。第30天讲解Java中的正则表达式和反射技术。第31天讲解网页标签语言HTML第32天讲解网页布局，以及JavaScript揭秘第33天讲解Javascript和DOM技术结合，实现各种网页常见效果。]]></content>
      <categories>
        <category>我的视频</category>
      </categories>
      <tags>
        <tag>我的视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小码哥的MySQL笔记]]></title>
    <url>%2F2018%2F05%2F06%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 可联系删除，做复习用，看不懂可以问哦~ 数据库(DataBase:DB)：数据库是一个按数据结构来存储和管理数据的计算机软件系统。 存储和管理数据的仓库. 数据库管理系统（Database Management System:DBMS）：是专门用于管理数据库的计算机系统软件。数据库管理系统能够为数据库提供数据的定义、建立、维护、查询和统计等操作功能，并完成对数据完整性、安全性进行控制的功能。 我们一般说的数据库,就是指的DBMS: 数据库服务器 数据库应用系统（Database Application System）：使用数据库技术的系统； 数据库应用系统有很多，基本上所有的信息系统都是数据库应用系统。它通常由软件、数据库和数据管理员组成。 常见的数据库:1234Oracle : Oracle DB2 : IBMSQLServer : MSMySQL : AB--&gt;SUN--&gt;Oracle 什么是表？我们说MYSQL是一种关系型数据库。关系数据库最重要的概念就是表。表具有固定的列数和任意的行数，在数学上称为“关系”。 二维表是同类实体的各种属性的集合，每个实体对应于表中的一行，在关系中称为元组，相当于通常的一条记录；表中的列表示属性，称为Field，相当于通常记录中的一个数据项，也叫列、字段。 MySQL安装过程中:注意: MySQL的常用存储引擎: InnoDB:支持外键关系,支持事务(Transaction). 性能低. MyISAM:不支持外键关系,不支持事务管理. 性能高. 一般的,开发中外键关系可以不要,但是事务必须得有. InnoDB. MySQL的默认端口是:3306. 注意1: 选择MySQL的存储引擎: 注意2: 选择数据库的编码:UTF8,以后在MySQL中创建的数据库和表都是UTF8. 密码:admin123安装成功之后:要修改MySQL的配置.进入MySQL的安装路径:C:\Program Files\MySQL\MySQL Server 5.5\bin找到.MySQLInstanceConfig.exe MySQL常用命令12345678910111213141516171819202122232425262728293031323334353637MySQL常用命令:打开数据库连接之前:一定要保证MySQL服务已经开启了.net start 命令名字:开启一个服务net stop 命令名字:关闭一个服务器---------------------------------------1 连接MySQL数据库: 进入 mysql, 在命令行中输入: 格式:mysql -u账户 -p密码 -h数据库服务器安装的主机 -P数据库端口 mysql -uroot -padmin -h127.0.0.1 -P3306 若连接的是本机,端口也是3306: 简写: mysql -uroot -padmin--------------------------------------- 2 查看 mysq 中有哪些数据库: show databases;---------------------------------------3 指定使用哪一个数据库: use 数据库名称; ---------------------------------------4 查看指定的数据库中有哪些数据表: show tables---------------------------------------5 查看表的结构： desc 表名---------------------------------------新建一个数据库: create database 数据库名---------------------------------------删除一个数据库： drop database 数据库名---------------------------------------创建一张表: create table 表名( .... )---------------------------------------删除一张表: drop table 表名 和数据库建立连接:三要素:URL: 连接地址: IP/端口/[数据库名字]账户: root密码: admin 开发的时候,每个系统都应该由一个数据库实例.都要自己建立新的数据库.不要使用系统自带的. MySQL中常见的列的数据类型12345678910111213141516171819202122232425262728293031323334353637数据库中不区分大小写.-----------------------------------------------------------------数据类型 说明-----------------------------------------------------------------char(size) 定长字符，0 - 255字节,size指N个字符数 name char(20): 存储will这4个字符: 底层依然占了20个字符. 不足以空格占位.---&gt;&apos;will &apos;-----------------------------------------------------------------varchar(size) 变长字符，0 - 255字节 name varchar(20): 存储will这4个字符: 底层只占了4个字符. &apos;will&apos;注意:在MySQL中,字符使用单引号引起来. 相当于Java中字符串(String,StringBuilder/StringBuffer);-----------------------------------------------------------------date 日期数据:年月日，MySQL用&apos;YYYY-MM-DD&apos;格式检索和显示DATE值 格式受国际化影响.在中国YYYY-MM-DD: 在美国: 月日年(英文)-----------------------------------------------------------------datetime 日期数据:年月日时分秒，要比date数据更确切，包含时分秒。MySQL以&apos;YYYY-MM-DD HH:MM:SS&apos;格式检索和显示DATETIME值 注意:在MySQL中,日期使用单引号引起来----------------------------------------------------------------int(size) 整型数据(size是显示的宽度):int int类型中的size表示宽度,但是没有任何意义. int(1)或者int(2)...其实底层都是int(11); 一般定义int类型不需要指定size位数. age int-----------------------------------------------------------------bigint 大整型: Java:long-----------------------------------------------------------------double[(s,p)] 小数类型，可存放实型和整型 ,精度(p)和范围(s) money double(5,2): 整数和小数一共占5为.其中小数占2位. MAX:999.99,/ MIN:-999.99-----------------------------------------------------------------decimal 小数类型，BigDecimal-----------------------------------------------------------------blob 存放图形、声音和影像，二进制对象，0-4GB: 开发中,我们一般存储二进制文件保存路径.-----------------------------------------------------------------text 存放大文本文件， 0-4GB : 变长 :相当于Java中字符串(String,StringBuilder/StringBuffer);----------------------------------------------------------------- 创建表和约束123456789101112131415161718192021222324252627282930313233341.先进入某一个数据库.2.输入建表的命令:--------------------------------------------CREATE TABLE 表名( 列名1 列的类型 [约束], 列名2 列的类型 [约束], .... 列名N 列的类型 约束 );注意:最后一行没有逗号--------------------------------------------DROP TABLE IF EXISTS `student`;CREATE TABLE `student` ( `id` bigint(20) AUTO_INCREMENT, `name` varchar(20), `age` int(11), PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;等价于:CREATE TABLE `student` ( `id` bigint(20) PRIMARY KEY AUTO_INCREMENT, `name` varchar(20), `age` int(11)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-------------------------------------------若在建表中使用到了数据库的关键字.比如新建一张订单表:(order),但是order是数据库中的关键字(排序使用).表名:t_order,若费用使用order这个单词.此时使用反撇(`)括起来,`order`.-------------------------------------------常见的约束(针对于某一列):1.非空约束: NOT NULL, 不允许某列的内容为空.2.唯一约束: UNIQUE , 在该表中,该列的内容必须唯一.3.主键约束: PRIMARY KEY, 非空且唯一.4.主键自增长:AUTO_INCREMENT SQL和数据库导入导出/备份DQl语句分类 :Select查询语句 SELECT DML语句（数据操作语言） INSERT / UPDATE / DELETE DDL语句(数据定义语言) CREATE / DROP / ALTER DCL语句（数据控制语言）事务控制语句 Sql语句的书写规则:在mysql数据库中，Sql 语句大小写不敏感.Sql语句可单行或多行书写.在Sql语句中，关键字不能跨多行或缩写.为了提高可读性，一般关键字大写，其他小写.空格和缩进使程序易读. 简单查询(单表)123456789101112131415161718192021222324252627282930313233343536373839404142434445SELECT 列名1,列名2,列名3...FROM 表名------------------------------------SELECT *FROM 表名如果为 * 和创建表时的顺序一致。可以自己调整顺序，在select后边加上要查询的列名。-------------------------------------------定义字段的别名:1、改变列的标题头2、用于表示计算结果的含义3、作为列的别名4、如果别名中使用特殊字符,或者是强制大小写敏感,或有空格时,都需加双引号,不建议使用引号. 定义别名起有意义的英文单词或单词短语.(不要出现空格)SELECT 列名1 [AS] 别名,列名2,列名3...FROM 表名------------------------------------------带有限制条件的查询:过滤SELECT 列名1,列名2,列名3...FROM 表名WHERE 条件1 AND/OR 条件2...注意:字符串和日期要用单引号扩起来执行顺序:1.先执行FROM,确定查哪一张表2.再执行WHERE,过滤3.接着执行SELECT,筛选哪一些列4.接着执行ORDER子句,对查询的结果排序5.再接着执行GROUP BY子句,分组查询6.再接着执行HAVING子句,对分组的结果再筛选----------------比较运算符:BETWEEN 最小值 AND 最大值 :在两个值之间（闭区间）: &gt;= 最小值 AND &lt;=最大值IN :包含在什么之间: 或者等于,或者等于LIKE :像..:模糊查询,有两种占位符:%:可表示零或多个字符_:就只表示一个字符------------------------------------对查询结果排序:使用ORDER BY 子句将记录排序ASC: 升序,缺省DESC: 降序SELECT 列名1,列名2,列名3...FROM 表名WHERE 条件1 AND/OR 条件2...ORDER BY 列名1 ASC/DESC, 列表2 ASC/DESC; 1234567891011121314151617181920212223242526需求1:查询所有货品信息需求2:查询所有货品的id,productName,salePrice需求3:查询所有货品的id，名称和批发价(批发价=卖价*折扣)需求4:查询所有货品的id，名称，和各进50个的成本价(成本=costPirce)需求5:查询所有货品的id，名称，各进50个，并且每个运费1元的成本需求6:查询所有货品的id，名称，各进50个，并且每个运费1元的成本(使用别名)需求7:查询货品零售价为119的所有货品信息需求8: 查询货品名为罗技G9X的所有货品信息.需求9: 查询货品名 不 为罗技G9X的所有货品信息.不区分大小写的查询:区分大小写的查询:需求10:查询分类编号不等于2的货品信息需求11:查询货品名称,零售价小于等于200的货品需求12:查询id，货品名称，批发价大于350的货品 需求13:选择id，货品名称，批发价在300-400之间的货品需求14:选择id，货品名称，分类编号为2,4的所有货品需求15:查询id，货品名称，货品名称匹配&apos;%罗技M9_&apos;需求16:选择id，货品名称，批发价 不 在300-400之间的货品查询id,名称, 分类为2或者 名字不带有M并且零售价大于100的货品需求17:选择id，货品名称，分类编号,零售价并且按零售价降序排序需求18:选择id，货品名称，分类编号,零售价先按分类编号排序,再按零售价排序需求19:查询M系列并按照批发价排序(加上别名)需求20:查询分类为2并按照批发价排序(加上别名) 分组查询123456789101112131415161718192021222324252627282930313233343536分组函数:分组函数作用于一组数据，并对一组数据返回一个值。分组函数类型:--------------------------------------AVG(列名)： 平均值COUNT(列名)：总数 ,查询结果是bigint类型(long),不是int类型MAX(列名)： 最大值MIN(列名)： 最小值SUM(列名)： 求和--------------------------------------需求:查询所有商品平均零售价需求:查询商品总记录数需求:查询分类为2的商品总数需求:查询商品的最小零售价，最高零售价，以及所有商品零售价总和分组查询:SELECT 列名1,列名2,列名3...FROM 表名WHERE 条件1 AND/OR 条件2...GROUP BY 分组的列名ORDER BY 列名1 ASC/DESC, 列表2 ASC/DESC;注意:可以使用GROUP BY 子句将表中的数据分成若干组注意：在SELECT子句中所有未包含在组函数中的列都应该包含在 GROUP BY 子句中。包含在 GROUP BY 子句中的列不必包含在SELECT 列表中--------------------------------------需求:查询每个商品分类编号和每个商品分类各自的平均零售价需求:查询每个商品分类编号和每个商品分类各自的商品总数。需求:查询每个商品分类编号和每个商品分类中零售价大于100的商品总数：注意:不能在 WHERE 子句中使用组函数（注意）。可以在 HAVING 子句中使用组函数。HAVING子句: 对分组之后的结果做筛选/过滤.需求:查询零售价总和大于1500的商品分类编号以及总零售价和： MySQL的分页查询1234567891011121314151617MySQL分页查询: MySQL方言:语法:SELECT column1, column2...FROM table[WHERE condition]LIMIT beginIndex,pageSizebeginIndex:是开始索引(从0开始):第一条记录:0,第二条记录:1beginIndex = (当前页数 - 1) * pageSize---------------------------------每页最多3条记录: pageSize = 3:------------------------------------------第一页: SELECT * FROM `product` LIMIT 0, 3 : 0,1,2第二页: SELECT * FROM `product` LIMIT 3, 3 : 3,4,5第三页: SELECT * FROM `product` LIMIT 6, 3 : 6,7,8第四页: SELECT * FROM `product` LIMIT 9, 3第七页: SELECT * FROM `product` LIMIT 18,3 : 18,19,20第N页: SELECT * FROM `product` LIMIT beginIndex,3]]></content>
      <categories>
        <category>我的视频</category>
      </categories>
      <tags>
        <tag>我的视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小码哥JAVA大神班MySql]]></title>
    <url>%2F2018%2F05%2F05%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 可联系删除，做复习用，看不懂可以问哦~ 数据库概述数据库(DataBase:DB)：数据库是按照数据结构来组织、存储和管理数据的仓库。—-&gt;存储和管理数据的仓库. 数据库管理系统（Database Management System:DBMS）：是专门用于管理数据库的计算机系统软件。数据库管理系统能够为数据库提供数据的定义、建立、维护、查询和统计等操作功能，并完成对数据完整性、安全性进行控制的功能。 MIS:管理信息系统.我们一般说的数据库,就是指的DBMS: 数据库服务器. 数据库技术发展历程： 层次数据库和网状数据库技术阶段； 使用指针来表示数据之间的联系。 关系数据库技术阶段； 经典的里程碑阶段。代表DBMS:Oracle、DB2、MySQL、SQL Server、SyBase等。 后关系数据库技术阶段； 关系型数据库存在数据模型，性能，拓展伸缩性的缺点，出现了： ORDBMS：面向对象数据库技术。 NoSQL ：结构化数据库技术。 随着大数据的不断发展，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速，出色的NoSQL数据库： 常见的NoSQL数据库分为四大类：1):键值存储数据库：Oracle BDB,Redis,BeansDB2):列式储数数据库：HBase,Cassandra,Riak3):文档型数据库：MongoDB,CouchDB4):图形数据库：Neo4J,InfoGrid,Infinite Graph 常见的关系数据库: 数据库系统 所属公司 Oracle Oracle(甲骨文) DB2 IBM SQL Server MS MySQL AB–&gt;SUN–&gt;Oracle Oracle:运行稳定，可移植性高，功能齐全，性能超群！适用于大型企业领域。 DB2：速度快、可靠性好，适于海量数据，恢复性极强。适用于大中型企业领域。 SQL Server:全面，效率高，界面友好，操作容易，但是不跨平台。适用于于中小型企业领域。 MySQL:开源，体积小，速度快。适用于中小型企业领域。 SQL：结构化查询语言(Structured Query Language)。是关系型数据库标准语言。特点：简单，灵活，功能强大。 SQL包含6个部分：一：数据查询语言（DQL）：其语句，也称为“数据检索语句”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。 二：数据操作语言（DML）：其语句包括动词INSERT，UPDATE和DELETE。它们分别用于添加，修改和删除表中的行。也称为动作查询语言。 三：事务处理语言（TPL）：它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。 四：数据控制语言（DCL）：它的语句通过GRANT或REVOKE获得许可，确定单个用户和用户组对数据库对象的访问。某些RDBMS可用GRANT或REVOKE控制对表单个列的访问。 五：数据定义语言（DDL）：其语句包括动词CREATE和DROP。在数据库中创建新表或删除表（CREAT TABLE 或 DROP TABLE）；为表加入索引等。DDL包括许多与人数据库目录中获得数据有关的保留字。它也是动作查询的一部分。 六：指针控制语言（CCL）：它的语句，像DECLARE CURSOR，FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。 书写规则：1.数据库中，SQL语句大小写不敏感2.SQL语句可单行或多行书写3.在SQL语句中，关键字不能跨多行或缩写4.为了提高可读性，一般关键字大写，其他小写5.空格和缩进使程序易读 什么是表？我们说MySQL是一种关系型数据库。关系数据库最重要的概念就是表。 表:又称之为二维表.(有行和列)—-&gt;存储数据.表具有固定的列数和任意的行数，在数学上称为“关系”。 二维表是同类实体的各种属性的集合，每个实体对应于表中的一行，在关系中称为元组，相当于通常的一条记录； 表中的列表示属性，称为Field，相当于通常记录中的一个数据项，也叫列、字段。 MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。 MyISAM：拥有较高的插入，查询速度，但不支持事务，不支持外键。InnoDB：支持事务，支持外键，支持行级锁定，性能较低。InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但对比MyISAM，处理效率差，且会占用更多的磁盘空间以保留数据和索引。 最常用的整数类型：MySQL列类型 Java数据类型 INT: int/IntegerBIGINT: long/Long MySQL 以一个可选的显示宽度指示器的形式对 SQL 标准进行扩展，这样当从数据库检索一个值时，可以把这个值加长到指定的长度。 例如，指定一个字段的类型为 INT(6)，就可以保证所包含数字少于 6 个的值从数据库中检索出来时能够自动地用空格填充。 需要注意的是，使用一个宽度指示器不会影响字段的大小和它可以存储的值的范围。一般不用指定位宽。 表的操作创建表:1.先进入某一个数据库.2.输入建表的命令:1234567CREATE TABLE 表名( 列名1 列的类型 [约束], 列名2 列的类型 [约束], .... 列名N 列的类型 约束 );注意:最后一行没有逗号 使用SQL的时候,不要使用SQL的关键字,如果使用到,怎么办.建立一张表,表用来装订单的信息,订单叫做:ORDER.此时,SQL出错,因为ORDER是SQL中的关键字. 解决方案一:使用反引号()把自定义的标识符引起来:order`. 解决方案二:使用表名的前缀,一般的,习惯t_order. 需求:在jdbcdemo数据库中,创建一张学生表(包含了id,name,age).第一步:进入jdbcdemo数据库. USE jdbcdemo;第二步:输入建立表的语句. 12345CREATE TABLE `student` ( `id` bigint(20) DEFAULT NULL, `name` varchar(20) DEFAULT NULL, `age` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8; 删除表:DROP TABLE student; 查看表结构：DESC table_name;查看表的详细定义：SHOW CREATE TABLE table_name; 其实现实的建立表的SQL语句. 表的约束表的约束(针对于某一列):1.非空约束：NOT NULL，不允许某列的内容为空。2.设置列的默认值：DEFAULT。3.唯一约束：UNIQUE，在该表中，该列的内容必须唯一。4.主键约束：PRIMARY KEY， 非空且唯一。5.主键自增长：AUTO_INCREMENT，从1开始，步长为1。6.外键约束：FOREIGN KEY. A表中的外键列的值必须参照于B表中的某一列(B表主键)-明天讲解。 主键设计：1：单字段主键，单列作为主键，建议使用。 复合主键，使用多列充当主键，不建议。2：主键分为两种: 1）.自然主键:使用有业务含义的列作为主键(不推荐使用); 2）.代理主键:使用没有业务含义的列作为主键(推荐使用); 12345CREATE TABLE `student` ( `id` bigint(20) PRIMARY KEY AUTO_INCREMENT, `name` varchar(20) UNIQUE , `age` int(11) ); 简单查询 简单查询:语法：12SELECT &#123;*, column [alias],...&#125;FROM table_name; 说明：12SELECT 选择查询列表FROM 提供数据源(表、视图或其他的数据源) 如果为 * 和创建表时的顺序一致。可以自己调整顺序，在select后边加上要查询的列名。 需求:查询所有货品信息需求:查询所有货品的id,productName,salePrice 消除结果中重复的数据:需求:查询商品的分类编号。语法：123SELECT DISTINCT 列名，...FROM table_name; 实现数学运算查询:对NUMBER型数据可以使用算数操作符创建表达式（+ - * /）对DATE型数据可以使用部分算数操作符创建表达式 （+ -） 运算符优先级：1、乘法和除法的优先级高于加法和减法2、同级运算的顺序是从左到右3、表达式中使用”括号”可强行改变优先级的运算顺序 12345需求:查询所有货品的id，名称和批发价(批发价=卖价*折扣)需求:查询所有货品的id，名称，和各进50个的成本价(成本=costPirce)需求:查询所有货品的id，名称，各进50个，并且每个运费1元的成本 设置列名的别名。1、改变列的标题头；2、用于表示计算结果的含义；3、作为列的别名；4、如果别名中使用特殊字符，或者是强制大小写敏感，或有空格时，都需加双引号； 需求:查询所有货品的id，名称，各进50个，并且每个运费1元的成本(使用别名)123SELECT id,productName,(costPrice+1) * 50 AS pf FROM productSELECT id,productName,(costPrice+1) * 50 pf FROM productSELECT id,productName,(costPrice+1) * 50 &quot;p f&quot; FROM product 过滤查询过滤查询:使用WHERE子句限定返回的记录：语法：123SELECT &lt;selectList&gt; FROM table_nameWHERE 条件; 注意：WHERE子句在 FROM 子句后 比较运算符:运算符 含义123456= 等于&gt; 大于&gt;= 大于或等于&lt; 小于&lt;= 小于或等于!=(&lt;&gt;) 不等于 需求: 查询货品零售价为119的所有货品信息.需求: 查询货品名为罗技G9X的所有货品信息.需求: 查询货品名 不为 罗技G9X的所有货品信息.需求: 查询分类编号不等于2的货品信息需求: 查询货品名称,零售价小于等于200的货品需求: 查询id，货品名称，批发价大于350的货品思考：使用where后面使用别名不行,总结select和where的执行顺序 注意：字符串和日期要用单引号扩起来.要让MySQL查询区分大小写，可以：12SELECT * FROM table_name WHERE BINARY productName=&apos;g9x&apos;SELECT * FROM table_name WHERE BINARY productName=&apos;G9X&apos; SQL中不同子句执行先后顺序:1):首先执行FROM子句. 明确从哪一张表中做查询.2):其次执行WHERE子句.筛选符合条件的数据.3):接着执行SELECT子句.选择出要显示哪些列的数据.4):最后执行ORDER BY子句.对查询筛选的结果再做排序. 逻辑运算符:运算符 含义 AND(&amp;&amp;) 如果组合的条件都是TRUE,返回TRUEOR(||) 如果组合的条件之一是TRUE,返回TRUENOT(!) 如果下面的条件是FALSE,返回TRUE. 需求: 选择id，货品名称，批发价在300-400之间的货品需求: 选择id，货品名称，分类编号为2,4的所有货品需求: 选择id，货品名词，分类编号不为2的所有商品需求: 选择id，货品名称，分类编号的货品零售价大于等于250或者是成本大于等于200 运算符优先级规则:优先级 运算符 1 所有比较运算符2 NOT3 AND4 OR 范围查询:使用BETWEEN运算符显示某一值域范围的记录，这个操作符最常见的使用在数字类型数据的范围上，但对于字符类型数据和日期类型数据同样可用。格式：SELECT * FROM 表名 WHERE 列名 BETWEEN minvalue AND maxvalue：闭区间。需求: 选择id，货品名称，批发价在300-400之间的货品需求: 选择id，货品名称，批发价不在300-400之间的货品 集合查询:使用IN运算符，判断列的值是否在指定的集合中。格式： WHERE 列名 IN (值1，值2….);需求:选择id，货品名称，分类编号为2,4的所有货品需求:选择id，货品名称，分类编号不为2,4的所有货品 空值判断:IS NULL:判断列的值是否为空。格式：WHERE 列名 IS NULL;需求:查询商品名为NULL的所有商品信息。 模糊查询: 使用LIKE运算符执行通配查询，查询条件可包含文字字符或数字：123%:通配符：可表示零或多个字符。_:通配符：可表示一个字符。通配符：用来实现匹配部分值得特殊字符。 需求: 查询id，货品名称，货品名称匹配’%罗技M9_’需求: 查询id，货品名称，分类编号,零售价大于等于200并且货品名称匹配’%罗技M1__’模糊查询不是搜索引擎. Lucene 对查询结果排序使用ORDER BY子句将记录排序 ASC : 升序，缺省。DESC: 降序。ORDER BY 子句出现在SELECT语句的最后。格式：1234SELECT &lt;selectList&gt; FROM table_nameWHERE 条件ORDER BY 列名1 [ASC/DESC],列名2 [ASC/DESC]...; 按照某一列来排序:需求:选择id，货品名称，分类编号,零售价并且按零售价降序排序按多列排序:需求: 选择id，货品名称，分类编号,零售价先按分类编号排序,再按零售价排序列的别名排序:需求:查询M系列并按照批发价排序(加上别名)需求:查询分类为2并按照批发价排序(加上别名)注意：不能对使用了引号的别名排序。 SELECT语句执行顺序：先执行FROM—&gt;接着执行WHERE—&gt;再执行SELECT—&gt;最后执行ORDER BY MySQL的分页查询分页设计: 假分页/逻辑分页/内存 分页: 一次性把数据全部查询出来,存放在内存中,翻页的时候,只需要从内存中去截取指定的条数即可. 优缺点:缺点:若数据过多,可能造成内存溢出;优点:简单,翻页比较快. 真分页/物理分页/数据库分页: 每次翻页的时候,都从数据库中去截取指定条数的数据. 优缺点:缺点:复杂,翻页比较慢;优点:不会造成内存溢出. 此时,我们讲解MySQL特有的分页方式(LIMIT,在Oracle12C中也提供该语法了). 此时设置每页最多显示3条数据:Integer pageSize = 3;语法: LIMIT ?,?;第一个?:从哪一个索引位置开始截取数据(从0开始的). beginIndex第二个?:每页显示最多的条数. pageSizeLIMIT beginIndex, pageSize;beiginIndex = (currentPage - 1) * pageSize; 12345第一页: SELECT * FROM `product` LIMIT 0, 3第二页: SELECT * FROM `product` LIMIT 3, 3第三页: SELECT * FROM `product` LIMIT 6, 3第四页: SELECT * FROM `product` LIMIT 9, 3第N页: SELECT * FROM `product` LIMIT (N-1)*3, 3 聚集函数什么是聚集函数(分组函数/统计函数)：聚集函数作用于一组数据，并对一组数据返回一个值。 12345COUNT：统计结果记录数 MAX： 统计计算最大值MIN： 统计计算最小值SUM： 统计计算求和AVG： 统计计算平均值 需求:查询所有商品平均零售价需求:查询商品总记录数(注意在Java中必须使用long接收)需求:查询分类为2的商品总数需求:查询商品的最小零售价，最高零售价，以及所有商品零售价总和 笛卡尔积单表查询:从一张表中查询数据 多表查询:从多张表中联合查询出数据 为什么需要多表查询:简单说分别操作:类似于咱们Java中的分类.不同的事物使用不同的类型(类)来表示. 每一张表存储该类型的事物的数据,不同事物咱们采取分表操作. 单表查询:123SELECT &lt;selectList&gt;FROM 表名 注意:没有连接条件的表关系返回的结果:多表查询会产生笛卡尔积:假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。实际运行环境下，应避免使用全笛卡尔集(笛卡尔积的数据存在大量的不合理)。 消除笛卡尔积最简单最直接的方式: 使用等值连接.如果是N张表做连接查询,等值连接关系至少是N-1个.需求:查询所有的货品信息+对应的货品分类信息12SELECT productName,dirName FROM product,productdirWHERE dir_id = productdir.id 外键约束主键约束: PRIMARY KEY. 在表中主键列的值,非空且唯一.外键约束：FOREIGN KEY. A表中的外键列的值必须参照于B表中的主键列,外键列允许为NULL. 在MySQL中,只有InnoDB存储引擎才只能事务和外键,MyISAM不支持事务不支持外键.1修改表的存储引擎: ALTER TABLE product engine = &apos;InnoDB&apos;; 多表查询1234567select &lt;select_list&gt; from tablea a left join tableb b on a.key=b.key select &lt;select_list&gt; from tablea a left join tableb b on a.key = b.key where b.key is nullselect &lt;select_list&gt; from tablea a right join tableb b on a.key = b.key select &lt;select_list&gt; from tablea a on a.key = b.key where a.key is null 1234567select &lt;select_list&gt; from tablea a inner join tableb b on a.key = b.key select &lt;select_list&gt; from tablea a full outer join tableb b on a.key = b.key select &lt;select_list&gt; from tablea a full outer join tableb b on a.key = b.key select &lt;select_list&gt; from tablea a full outer join table b on a.key = b.key where a.key is null or b.key is null 内连接查询: 隐式内连接: 显示内连接:外连接查询: 左外连接: 右外连接: 全外连接:子查询:字连接查询: 内连接查询：是相对于外连接。内连接分为：隐式内连接、显示内连接，其查询效果相同,仅仅是语法不一样而已。1234567隐式内连接：SELECT &lt;selectList&gt;FROM A ,B WHERE A.列 = B.列显示内连接(推荐写法)：SELECT &lt;selectList&gt;FROM A [INNER] JOIN B ON A.列 = B.列 需求:查询所有商品的名称和分类名称:隐式内连接: SELECT p.productName,pd.dirName FROM product p,productdir pd WHERE p.dir_id = pd.id显示内连接: SELECT p.productName,pd.dirName FROM product p INNER JOIN productdir pd ON p.dir_id = pd.id显示内连接: SELECT p.productName,pd.dirName FROM product p JOIN productdir pd ON p.dir_id = pd.id 在做等值连接的时候,若A表中和B表中的列名相同. 则可以简写:1234SELECT &lt;selectList&gt;FROM A [INNER] JOIN B USING(同名的列)前提:在emp和dept表中都有deptno列. 并且是外键关系。如: SELECT * FROM emp JOIN dept USING (deptno) 使用表名前缀在多个表中区分相同的列。在不同表中具有相同列名的列可以用表的别名加以区分。使用别名可以简化查询。使用表名前缀可以提高执行效率。如果使用了表的别名，则不能再使用表的真名 需求: 查询货品id，货品名称，货品所属分类名称需求: 查询零售价大于200的无线鼠标需求: 查询零售价大于200的无线鼠标(使用表的别名)需求: 查询每个货品对应的分类以及对应的库存需求: 如果库存货品都销售完成,按照利润从高到低查询货品名称,零售价,货品分类（三张表）. 外连接查询: A LEFT JOIN B—-&gt; B RINGHT JOIN A 左外连接:查询出JOIN左边表的全部数据查询出来,JOIN右边的表不匹配的数据使用NULL来填充数据. 右外连接:查询出JOIN右边表的全部数据查询出来,JOIN左边的表不匹配的数据使用NULL来填充数据. 语法格式1234567SELECT &lt;selectList&gt;FROM A LEFT/RIGHT OUTER JOIN B ON (A.column_name = B.column_name)];左连接:SELECT * FROM product p LEFT JOIN productdir pd ON p.dir_id = pd.id右连接:SELECT * FROM product p RIGHT JOIN productdir pd ON p.dir_id = pd.id 自连接查询:把一张表看成两张来做查询. 操作数据(DML)DQL:查询语句,查询之后,会返回结果的临时表.DML:增删改语句,操作之后,会返回一个结果,表示受影响的行数(删除3条数据,就返回3). 插入语句:一次插入操作只插入一行.1INSERT INTO table_name (column1,column2,column3...) 1.插入完整数据记录2.插入数据记录一部分3.插入多条数据记录（MySQL特有）1234INSERT INTO table_name (column1,column2,column3...) VALUES (value1,value2,value3...), (value1,value2,value3...), (value1,value2,value3...)..; 4.插入查询结果12345INSERT INTO table_name (column1,column2,column3...) SELECT (column1,column2,column3...) FROM table_name INSERT INTO productdir (dirName,parent_id) SELECT dirName,parent_id FROM productdir 删除操作: 12DELETE FROM table_name [WHERE condition];注意:如果省略了where子句，则全表的数据都会被删除. 更新操作: 1UPDATE table_name SET columnName = value [, columnName = value] [WHERE condition]; 如果省略了where子句，则全表的数据都会被修改。注意:没有FROM 需求:将零售价大于300的货品零售价上调0.2倍需求:将零售价大于300的有线鼠标的货品零售价上调0.1倍 数据备份和恢复备份:很重要,修改之前,都先做备份.12345678910MySQL自身的数据库维护：通过cmd命令进入dos窗口：1.导出：mysqldump -u账户 -p密码 数据库名称&gt;脚本文件存储地址 mysqldump -uroot -padmin jdbcdemo&gt; C:/shop_bak.sql2.导入：mysql -u账户 -p密码 数据库名称&lt; 脚本文件存储地址 mysql -uroot -padmin jdbcdemo&lt; C:/shop_bak.sqlNavicat工具的导入和导出： 1 、 部门表：DEPTNo. 字段名称 类型 描述1 DEPTNO BIGINT 部门编号，由两位数字所组成( 主键)2 DNAME VARCHAR(20) 部门名称，由 14 位字符所组成3 LOC VARCHAR(20) 部门位置 2 、 雇员表：EMPNo. 字段名称 类型 描述1 EMPNO BIGINT 雇员编号，由四位数字所组成( 主键)2 ENAME VARCHAR(20) 雇员姓名3 JOB VARCHAR(20) 职位4 MGR BIGINT 一个雇员对应的领导编号（雇员编号）5 HIREDATE DATE 雇员的雇佣日期6 SAL DOUBLE(7,2) 基本工资，由两位小数和五位整数所组成7 COMM DOUBLE(7,2) 奖金/奖金8 DEPTNO BIGINT 一个雇员所在的部门编号，与 dept 表的对应 DEPT 表数据:1234INSERT INTO `DEPT` VALUES (10, &apos;ACCOUNTING&apos;, &apos;NEW YORK&apos;);INSERT INTO `DEPT` VALUES (20, &apos;RESEARCH&apos;, &apos;DALLAS&apos;);INSERT INTO `DEPT` VALUES (30, &apos;SALES&apos;, &apos;CHICAGO&apos;);INSERT INTO `DEPT` VALUES (40, &apos;OPERATIONS&apos;, &apos;BOSTON&apos;); EMP 表数据:1234567891011121314INSERT INTO `EMP` VALUES (7369, &apos;SMITH&apos;, &apos;CLERK&apos;, 7902, &apos;1980-12-17&apos;, 800, NULL, 20);INSERT INTO `EMP` VALUES (7499, &apos;ALLEN&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-02-20&apos;, 1600, 300, 30);INSERT INTO `EMP` VALUES (7521, &apos;WARD&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-02-22&apos;, 1250, 500, 30);INSERT INTO `EMP` VALUES (7566, &apos;JONES&apos;, &apos;MANAGER&apos;, 7839, &apos;1981-04-02&apos;, 2975, NULL, 20);INSERT INTO `EMP` VALUES (7654, &apos;MARTIN&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-09-28&apos;, 1250, 1400, 30);INSERT INTO `EMP` VALUES (7698, &apos;BLAKE&apos;, &apos;MANAGER&apos;, 7839, &apos;1981-05-01&apos;, 2850, NULL, 30);INSERT INTO `EMP` VALUES (7782, &apos;CLARK&apos;, &apos;MANAGER&apos;, 7839, &apos;1981-06-09&apos;, 2450, NULL, 10);INSERT INTO `EMP` VALUES (7788, &apos;SCOTT&apos;, &apos;ANALYST&apos;, 7566, &apos;1987-04-19&apos;, 3000, NULL, 20);INSERT INTO `EMP` VALUES (7839, &apos;KING&apos;, &apos;PRESIDENT&apos;, NULL, &apos;1981-11-17&apos;, 5000, NULL, 10);INSERT INTO `EMP` VALUES (7844, &apos;TURNER&apos;, &apos;SALESMAN&apos;, 7698, &apos;1981-09-08&apos;, 1500, 0, 30);INSERT INTO `EMP` VALUES (7876, &apos;ADAMS&apos;, &apos;CLERK&apos;, 7788, &apos;1987-05-23&apos;, 1100, NULL, 20);INSERT INTO `EMP` VALUES (7900, &apos;JAMES&apos;, &apos;CLERK&apos;, 7698, &apos;1981-12-03&apos;, 950, NULL, 30);INSERT INTO `EMP` VALUES (7902, &apos;FORD&apos;, &apos;ANALYST&apos;, 7566, &apos;1981-12-03&apos;, 3000, NULL, 20);INSERT INTO `EMP` VALUES (7934, &apos;MILLER&apos;, &apos;CLERK&apos;, 7782, &apos;1982-01-23&apos;, 1300, NULL, 10); 练习题：01.查询每个雇员的编号、姓名、职位。 02.查询每个雇员的职位，职位。 03.查询每个雇员的职位，使用 T DISTINCT 消除掉显示的重复 行记录。 04.计算出每个雇员的基本年薪，同时查询出雇员的编号、姓名。 105.每个雇员每个月公司会补贴饭食 200 元，交通补助 300 元，计算年薪（年薪=(工资+奖金)*12）。 06.查询基本工资高于 2000 的全部雇员信息。 07.查询出 smith 的信息。 08.查询出所有不是 CLERK 的详细信息。 09.查询出所有销售人员(SALESMAN)的基本信息，并且要求销售人员的工资高于 1300。 10.查询出工资范围在 1500~3000 之间的全部雇员信息（包含 1500 和 3000）。 11.查询出所有经理或者是销售人员的信息，并且要求这些人的基本工资高于 1500。 12.要求查询出所有在 1981 年雇佣的雇员信息。 13.查询所有领取奖金的雇员信息（comm 不为空）。 14.查询所有领取奖金高于 100 的雇员信息。 15.查询出雇员编号是 7369、7566、9999 的雇员信息。 16.查询出所有雇员姓名是以 A 开头的全部雇员信息。 17.查询出雇员姓名第二个字母是 M 的全部雇员信息。 18.查询出雇员姓名任意位置上包含字母 A 的全部雇员信息。 19.查询出所有雇员的信息，要求按照工资排序。 20.要求查询所有雇员的信息，按照雇佣日期由先后排序。 21.查询全部雇员信息，按照工资由高到低排序，如果工资相同，则按照雇佣日期由先后排序。 22.查询部门 30 中的所有员工。 23.查询出所有办事员（CLERK）的姓名，编号和部门编号。 24.查询出奖金高于薪金的员工。 25.查询出奖金高于薪金的 60%的员工。 26.查询出部门 10 中所有经理（MANAGER）和部门 20 中所有办事员（CLERK）的详细资料。 27.查询出部门 10 中所有经理，部门 20 中所有办事员，既不是经理又不是办事员但其薪金大于或等于 2000的所有员工的信息。 28.查询出收取奖金的员工的不同工作。 29.查询出不收取奖金或收取的奖金低于 100 的员工。 30.查询出不带有“R”的员工的姓名。 31.查询出每个雇员的姓名、职位、领导姓名。 32.查询出所有员工的编号、姓名及其直接上级的编号、姓名，显示的结果按领导年工资的降序排列。 33.查询出在销售部（SALES）工作的员工姓名、基本工资、雇佣日期、部门名称。（不知道销售部编号）。 34.查询出所有员工的姓名、部门名称和工资。 35.查询出所有员工的年工资，所在部门名称，按年薪从低到高排序。 36.查询出某个员工的上级主管及所在部门名称，并要求出这些主管中的薪水超过 3000。 37.查询出公司的最高和最低工资。 38.查询出每个部门的人数、平均工资，只显示部门编号。 39.查询出每种职位的最高和最低工资。 40.查询平均工资高于 2000 的职位信息，以及从事此职位的雇员人数、平均工资。 41 查询出至少有一个员工的所有部门编号、名称，并统计出这些部门的平均工资、最低工资、最高工资。 42.查询出部门名称和这些部门的员工信息（数量、平均工资），同时列出那些没有员工的部门。]]></content>
      <categories>
        <category>我的视频</category>
      </categories>
      <tags>
        <tag>我的视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发教程]]></title>
    <url>%2F2018%2F05%2F04%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 老罗Android开发视频教程 Android系统介绍Android是基于Linux内核的操作系统，是Google公司在2007年11月5日公布的手机操作系统。早期由原名为“Android”的公司开发，谷歌在2005年收购”Android.Inc“后，继续进行对Android系统开发运营，它采用了软件堆层的架构，主要分为三部分，底层Linux内核只提供基本功能，其他的应用软件则由各公司自行开发，部分程序以Java编写。 2011年初数据显示，仅正式上市两年的操作系统Android已经跃居全球最受欢迎的智能手机平台。现在，Android系统不但应用于智能手机，也在平板电脑市场急速扩张。 Android平台五大优势特色开放性 Android平台首先就是其开放性，开发的平台允许任何移动终端厂商加入到Android联盟中来。 挣脱运营商的束缚 在过去很长的一段时间，特别是在欧美地区，手机应用往往受到运营商制约，使用什么功能接入什么网络，几乎都受到运营商的控制。自从Android上市，用户可以更加方便地链接网络，运营商的制约减少。随着2G至3G移动网络的逐步过渡和提升，手机随意接入网络。 丰富的硬件选择 这一点还是与Android平台的开发性相关，由于Android的开放性，众多的厂商会推出千奇百怪，功能特色各具的多种产品。功能上的差异和特色，却不会影响到数据同步，甚至软件的兼容。 不受任何限制的开发商 Android平台提供给第三方开发商一个十分宽泛，自由的环境。因此不会受到各种条条框框的阻挠。 无缝结合Google应用 Google服务如地图，邮件，搜索等已经成为连接用户和互联网的重要纽带，而Android平台手机将无缝结合这些优秀的Google服务。 Android学习路线图介绍Java语言编程基础 面向对象基础 Java常用设计模式 Java数据结构和算法 关系型数据库 JDBC数据库编程 HTML和Javascript编程 Java动态网页编程 Java以及Web应用开发项目UI界面设计 Android数据库编程 Android服务的应用 Android内容提供者 Android网络编程 Android多媒体编程 Android异步任务加载 Android传感器编程 Android谷歌地图开发 Android蓝牙开发 Android Wifi编程 Android与Webservice Android与HTML开发 JQueryMobile编程 PhoneGap应用开发 Widget套件使用 Android与工作流引擎结合 Android报表制作 Android高速描绘 Android企业框架介绍 Android应用项目实战开发2D图形编程 图片处理 碰撞检测 物理引擎介绍 Cocoa 2D引擎介绍 OpenGLES 游戏资源调度 游戏实战项目 Android游戏应用开发第二集：android系统框架的介绍src目录：主要是完成java代码的编写assets目录：资源目录res目录：存在图片，布局文件和字符串，菜单等文件bin目录：输出文件夹，如生成的APK文件project.properties工程属性文件配置gen目录：系统自动生成的源代码目录这个R.java文件时系统自动生成的文件，非常的重要。这个R.java默认有attr,drawable,layout,string 4个静态内部类，每个类对应一种资源。例如我们在工程中添加一副图片，那么工程就会在此类的drawable内部类中添加一条数据，如果删除了此图片，工程则会自动删除此条数据。]]></content>
      <categories>
        <category>我的视频</category>
      </categories>
      <tags>
        <tag>我的视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android工程师初级知识点]]></title>
    <url>%2F2018%2F05%2F03%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 提示框，菜单，数据存储，组件篇Toast Toast.makeText(context, text, 时间).show(); setDuration();//设置时间setGravity();//位置 获取： 添加toast.getView();imageView添加到toast中，addView(); 1234LayoutInflater inflater = LayoutInflater.from(this);View toast_view=inflater.inflate(R.id.,null);Toast.Toast.setView(toast_view); AlertDialogAlertDialog.Builder 1234567891011setTitle();setIcon();setView();setItems();setMultiChoiceItems(); 复选setSingleChoiceItems(); 单选setNeutralButton();setPositiveButton();setNegativeButton(); 1234AlertDialog dialog = builder.create(); .show();消失dialog.dismiss(); Notification通知栏，如接收短信 123456789属性Notification setTicker();//手机状态栏的提示setWhen();//设置时间setContentTitle();setContentText();setContentIntent();Notification notification = builder.build(); OptionsMenu123onCreateOptionsMenu();动态：menu.add();监听：onOptionsItemSelected(); 1234public boolean onCreateOptionsMenu(Menu menu)&#123; getMenuInflater().inflate(R.menu.main,menu); return true;&#125; 监听：onOptionsItemSelected123456public boolean onOptionsItemSelected(MenuItem item)&#123; switch(item.getItemId())&#123; case R.id..: ... &#125;&#125; ContextMenu上下文菜单1234567public boolean onCreateItemSelected(MenuItem item)&#123;&#125;public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo)&#123; super.onCreateContextMenu(menu, v, menuIfo);&#125; SubMenu 子菜单12345678910protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);&#125;public boolean onCreateOptionsMenu(Menu menu)&#123; getMenuInflater().inflate(R.menu.main, menu); return true; //return super.onOptionsItemSelected(item);&#125; xml 12345678910&lt;menu ...&gt; &lt;item android:showAsAction=&quot;never&quot; android:title=&quot;文件&quot;&gt; &lt;menu&gt; &lt;item android:id=&quot;@+id/..&quot; android:showAsAction=&quot;never&quot; android:title=&quot;打开&quot;/&gt;&lt;/menu&gt; 12MenuInflater inflater = getMenuInflater();inflater.inflate(R.menu.main, menu); 数据存储方式四种： SharedPreferences SQLite Content Provider File SharedPreferences是一种比较轻型的数据存储，基于xml的键值对存储，存储一些简单的信息。 SharedPreferences只能获取数据不能存储和修改，但能通过Editor实现存储修改。 步骤： 获取SharedPreferences对象 SharedPreferences.Editor Editor的putXXX的方法 Editor.commit() 1SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(MainActivity.this); 1234SharedPreferences sharedPreferences = getSharedPreferences(&quot;sharedPreferences&quot;, MODE_PRIVATE);Editor editor = sharedPreferences.edit();editor.putXXX();editor.commit(); 用户名和密码的存储 12sharedPreferences = getSharedPreferences(&quot;UserInfo&quot;, MODE_PRIVATE);Editor editor = sharedPreferences.editor(); 123登录String name = etName.getText().toString().trim();String pass = etPass.getText().toString().trim(); SQLite的形式，以单个文件的存储，存储2T内存，以B-Tree形式。 SQLite的数据类型，null,integer,real,text,blob。 SQLiteDatabase SQLiteOpenHelper 1SQLiteDatabase db = openOrCreateDatabase(&quot;table.db&quot;, MODE_PRIVATE, null); SQLiteOpenHelper 123DBOpenHelper helper = new DBOpenHelper(MainActivity.this, &quot;user.db&quot;);SQLiteDatabase db = helper.getWritableDatabase();Cursor c = db.rawQuery(&quot;select * from user&quot;, null); 1234567891011public DBOpenHelper(Context context, String name, CursorFactory factory, int version)&#123; super(context, name, factory, version);&#125;public void onCreate(SQLiteDatabase db)&#123;&#125;public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)&#123;&#125; 12File file = this.getFilesDir();File file = this.getCacheDir();//重要文件就不要放在这里 MODE_PRIVATE 默认操作 MODE_APPEND 文件是否存在 1234567891011public void WriteFiles(String content)&#123; try&#123; FileOutputStream fileOutputStream = openFileOutput(&quot;super.txt&quot;, MODE_PRIVATE); fileOutputStream.write(content.getBytes()); fileOutputStream.close(); &#125;catch()&#123; &#125;catch()&#123; &#125;&#125; ContentProvider 123&lt;provider android:name=&quot;&quot; android:authorities=&quot;&quot;/&gt; 12345public class MyContentProvider extends ContentProvider&#123; public int delete(Uri uri,String selection, String[] selectionArgs)&#123; &#125;&#125; Uri 通用资源标志符 Broadcast广播 BroadcastReceiver 广播接收器 使用：需要Intent对象，sendBroadcast(),sendOrderBroadcast(),sendStickyBroadcast()。 Service 注册： 1&lt;service android:name=&quot;&quot;/&gt; 12345678public void onClick(View v)&#123; switch(v.getId())&#123; case R.id.: Intent intent = new Intent(MainActivity.this, MyService.class); startService(intent); break; &#125;&#125; 1234567891011121314public class MyService extends Service&#123; public void onCreate()&#123; super.onCreate(); &#125; public int onStartCommand(Intent intent,int flags,int startId)&#123; return super.onStartCommand(intent,flags,startId); &#125; public void onDestroy()&#123; super.onDestroy(); &#125; public IBinder onBind(Intent intent)&#123; return null; &#125;&#125; Bind 123456789public void onCreate()&#123;&#125;public IBinder onBind(Intent intent)&#123;&#125;public void unbindService(ServiceConnection conn)&#123;&#125; 12345678ServiceConnection conn = new ServiceConnection()&#123; public void onServiceDisconnected(ComponentName name)&#123; &#125; public void onServiceConnected(ComponentName name, IBinder binder)&#123; &#125;&#125; 系统服务 MountService,ClipboardService,getSystemService(). 123public Object getSystemService(String name)&#123;&#125; POWER_SERVICE,PowerManger电源服务ALARM_SERVICE,AlarmManager闹钟服务 123LayoutInflater inflater = MainActivity.this.getSystemService(LAYOUT_INFLATER_SERVICE);View view = inflater.inflate(R.layout. , null);setContentView(view); getSystemService GestureDetector 1MotionEvent,GestureDetector,onGestureListener. GestureOverlayView 1234Android:eventsInterceptionEnabledAndroid:fadeDurationAndroid:fadeEnabledAndroid:gestureColor 123456789&lt;android.gesture.GestureOverlayView android:id=&quot;&quot; android:layout_width=&quot;&quot; android:layout_height=&quot;&quot;&gt; &lt;ImageView android:id=&quot;&quot; android:layout_width=&quot;&quot; android:layout_height=&quot;&quot;&lt;/android.gesture.GestureOverlayView&gt; 完结！]]></content>
      <categories>
        <category>Android开发工程师文集</category>
      </categories>
      <tags>
        <tag>Android开发工程师文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA语言-985大学]]></title>
    <url>%2F2018%2F05%2F02%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 记录收藏，记录要点，来源各个大佬，部分内容也来源网络 Java学习课程——基础篇第一篇 Java 入门导论 对Java的历史、Java平台、Java语言建立基本概念。并实际地导览读者到网络上去看Java所构筑的网络新世界。然后再开始学习几个简易的入门程序，开始建立Java程序的概念与印象。 本篇包括：第1章 Java 概说第2章 Java的世界第3章 先来一杯Java 吧 第二篇 面向对象程序设计（一） 在开始学习Java语言时，先针对其面向对象的特性，诸如对象、类、封装、继承等概念加以说明。避开语言上的枝节探讨，先将Java面向对象的概念点出，以免使读者落入程序语言的丛林里。然后再介绍Java 1.3API对象结构化的类库，认识其所提供包、类的功能概述。 本篇包括：第4章 面向对象程序设计基本概念第5章 Java 1.3 API 简介 第三篇 Java语言基础 Java语言是由C/C++所演变，去芜存菁并重新设计的语言。采用Unicode编码，并有其特有的标识符与关键字。而数据的类型，也是有原生类型与参考类型之别。本篇各章主要根据Java Language Specification (Second Edition)，＜此规格书可由 www.java.sun.com 自由下载 ＞，挑选最主要的三部分来作编写架构。 本篇包括：第6章 语汇结构第7章 类型、数值、变量第8章 控制结构 第四篇 面向对象程序设计（二） 有了第二与第三篇的基础后，再来以实际的程序范例来看Java的面向对象，就会对Java的面向对象精神有清楚的认识。 本篇包括：第9章 类、接口、包第10章 方法与异常处理 第五篇 Java图形用户界面程序 图形用户界面的程序是现代程序设计的一大重点。而Java API所提供的图形界面包AWT及SWING，也是图形界面的一大进步，因为它们成功打破了各家操作系统图形界面的屏障，使程序设计师不必疲于修改要适用于各家平台的程序。而SWING更踏在AWT的肩膀上，进一步提供更强大、多元、弹性的功能。 本篇包括：第11章 Java GUI概论第12章 Java版面配置第13章 事件处理第14章 Applet与JApplet第15章 Swing初级 学习建议： 对较无程序设计基础的初学者 可依照本书安排次序循序渐进学习。尤其对没碰过C或 C++的人，更需要摸清每章的各部分。若本书不够清楚，请再参考别的书籍作比照，这样才能打好基础。 对有C/C++程序设计经验者 若您有C/C++的语法基础，可先略过第三篇Java语言基础部分。但可能您还不清楚Java的设计理念及其面向对象程序设计原理，所以还是建议您从第一篇开始（除了第三篇外）按部就班地学习。待有Java语言基础部分不懂之处，再去查看即可。 第一篇 Java入门导论第1章 Java 概说第2章 Java的世界第3章 先来一杯Java吧 第1章 Java 概说 Java的发展历史 Java的发展历史，要从1990年开始追溯起。当时Sun Microsystem公司为了发展消费性电子产品而进行了一个名为Green的项目计划。这个计划的负责人是James Gosling。起初他以C++来写一种内嵌式软件，可以放在烤面包机或PAD等小型电子消费设备里，使得机器更聪明，更具有人工智能。但后来他发现C++并不适合这类的任务！因为C++常会有使系统失效的程序错误，尤其是内存管理，C++是采用直接参考（direct reference）的方式，需要程序设计师记录并管理内存资源。这造成设计师们极大的负担，并可能产生许多bugs。若是一台烤面包机上的程序有错误，可能会使烤面包机烧坏了，甚至更严重会有爆炸产生！ 所以为了解决所遇到的问题，Gosling最后决定要发展一种新的语言，来解决C++的潜在性危险问题，这个语言名叫Oak。它保留了大部分与C++相似的语法，但却把些较具危险性的功能加以改进，像内存资源管理，便由语言本身来管理，以减少程序设计师的负担及错误的产生。Oak是一种可移植性（portable）语言，也就是一种平台独立（platform-independent）的语言，能够在各种芯片上运行。这样子各家厂商就可降低研发成本，直接把应用程序应用在自家的产品上。 Java与Internet时间到了1994年，Oak的技术已日趋成熟，这时刚好网络也正开始蓬勃发展。而Oak研发小组发现Oak很适合作为一种网络程序语言。因此发展了一个能与Oak相配合的浏览器——WebRunner，后更名为HotJava，它证明了Oak是一种能在网络上发展的程序语言。后来，因为Oak这个商标已被注册走了，工程师们便想到以手中常享用的咖啡(Java)来重新命名，并于Sun World 95中被发表出来。从此以后，Java就随着网络的快速发展，而成了一个程序语言的明日之星。 Java平台“网络即计算机”，是Sun企业的格言。所以在设计上，Java即是以网络为运作范畴，并且是架设在各种硬件环境上的一种纯软件平台(platform)。它与一般与硬件有关的各式操作系统（Operating System，如Windows，MacOS）或称操作平台不同。一般所谓的平台是指撰写程序时所依赖的API(Application Program Interface)，通常都预先定义在计算机中的操作系统上。因此在Java之前，程序设计师就只能借助所在环境的API写单一操作系统的程序。若要改成另一操作系统版本的程序，就需要花许多的转换功夫，或者根本不可能。但Java平台，虽然不算是一种操作系统（不过现在已有JavaOS的出现），却提供了甚至比现今各操作系统更深、更广的API。Java平台包括Java虚拟机器（Java Virtual Machine,JVM）以及Java API。 Java平台的版本目前Java平台有3种的版本，以因应各种需求： JAVATM 2 PLATFORM,STANDARD EDITION（标准版） JAVATM 2 PLATFORM,ENTERPRISE EDITION（企业版） JavaTM 2 Platform, Micro Edition (J2METM) （小型家电版） 借助这些平台版本，使得Java程序能在各式大小型机器及操作系统上运行，达成所谓程序可移植性、跨平台的目标。因着Java平台的这些特性，使微软倍感威胁。微软现今所展的.Net，便是视Java平台为强力竞争对手之一。 Java平台运作原理Java平台是一种新的计算机计算运作方式，植基于网络的能力与程序能“撰写一次，到处运行”（write once,run anywhere）的技术。借着Java技术，人们可以使用多种的上网工具来达到互相沟通的目的。像现今流行的新一代手机、PDA、可视电话，智能卡（smart cart）等先进设备等，也都能彼此沟通。而非仅限于台式计算机或笔记本电脑而已。当然能达到这些目的，主要就是通过前面所说的Java API、Java VM 与Java语言等技术的配合。 Java语言Java语言，是一个新一代的高级（high-level）、通用目的（general-purpose）、面向对象（objec-oriented）的程序语言。 其语法与C或C++类似，但在组织结构上却相当的不同。 它是一个完全面向对象的程序语言，程序的基本处理单位：类（class）及API的组织，均以对象的观点来处理及架构起来的。 不仅如此，它在被设计的时候也倾向于是一种具生产力的语言（production language）,而非只是研究性语言（research language）。 所以当我们学习运用Java语言的时候，便能很快地感受到它的便利与强大功能。 Java语言的特性面向对象程序语言简单（simple）强固（robust）安全（security）平台独立（platform-independent） 多任务线程（multithreading）动态（dynamic）分布式计算(distributed computing)运行效率（performance）内存管理与资源回收(garbage collection) Java 与C/C++的差异C/C++12345678910111213#include &lt;iostream.h&gt;public :unsigned int aData=10;class PrintOut&#123;void printData()&#123;cout&lt;&lt;”Data:”+aData;&#125;&#125;int main()&#123;PrintOut po;po.printData();return 0;&#125; Java1234567891011import java.io.*;public class Test&#123;public int aData=10;public static void main(String args[])&#123;Test test=new Test();test.printData();&#125;void printData()&#123;System.out.println(&quot;Data:&quot;+this.aData);&#125;&#125; Java 与C/C++的差异舍去功能新增功能取代改进功能 Java 程序的种类Java是一种网络程序语言，它能写出包含前端(Applet)、本地（Application）及后端（Servlets）的程序。虽然这三者的结构不同，但基本的语法都一样，所以能彼此沟通，构造出一个所谓的平台。 现在又加上了JSP(Java Server Pages)作为服务器端的加强，使得开发网络程序更快速。Java平台也更完整。 AppletApplet是一种可嵌入于Web文件中的一种小型程序。 通常其程序因网络传输速度关系都很短小。 但在应用上却常常比Application有用，一般都是通过浏览器来观看Applet。(数据来源：www.thejmaker.com) ApplicationApplication（应用程序）是在命令列环境运行的程序。 程序中由main()方法作为程序起点，运行顺序由程序本身来控制。但Applet却是由浏览器来控管。选择用Applet还是Application来写作，要视所欲表达内容及传输机制而定。 通常Applet较需图形用户界面（GUI,Graphical User Interface），而Application较不需要。但因GUI的便利，许多Application也都用GUI来增进用户的便利，右图便是一个连接数据库的应用程序。(数据来源：www.svcon.com) ServletsServlets是应用在服务器端的应用程序，可提供各种服务器服务。例如数据查询或动态产生聊天室，月历等，右图是由一个网站流量统计的Servelets所产生的画面。(数据来源：http://www.mycgiserver.com) 第一讲 JAVA语言概述本讲要点课程介绍什么是Java？我们的学习目标学习方法指导学习资料推荐 Java语言概述Java语言的特点Java语言程序分类Java程序开发过程Java虚拟机 什么是Java ？一种编程语言 面向对象的程序设计语言，提供了编译、运行、调试工具。 1991年Sun公司的 “绿色项目” Oak语言产生(Java) 项目失败，但Java活了下来(1995年发布第一个版本JDK1.0)。 一种软件平台 平台是程序运行的硬件或软件环境，Java平台与大多数其它平台不同，是基于其它软件或硬件的纯软件平台。 JVM：Java虚拟机，是Java平台的基础 Java API：Java应用程序接口，Java API是软件组件的集合，它们提供了很多有用的功能，如图形用户界面（GUI）。 随着应用范围越来越广，Java演化出三个不同领域的应用平台 J2SE：Java2 Platform， Standard Edition：标准版，桌面系统和低端服务 J2EE：Java2 Platform， Enterprise Edition：企业版，企业级应用 J2ME：Java2 Platform ，Micro Edition：小型版，嵌入式应用开发与.net简单比较 学习目标最终目标：Java软件工程师Java语法、J2se平台基础、面向对象编程思想和方法（Java基础）Java Web开发（简单应用）J2ee企业开发（企业级应用）、J2me（嵌入式应用）辅助技术：Struts设计模式、JavaScript、XML、SQL语言开发工具：JDK、JCreater、Eclipes、JBuilder 近期目标在校期间，掌握Java Web应用 本学期目标本学期， Java语法、J2se平台基础、面向对象编程思想和方法，培养自学能力。 学习方法指导奠定Java语法基础学习Java的第一步是用Java语言来编写程序，学习Java语言的第一步，就是熟悉其语法的使用。 注意思考和总结在学习的过程中，最好能够了解Java的底层机制，而不是仅仅停留在表层，不是抄书上的例子运行出结果就可以。即便对一个简单的例子也要有耐心去琢磨、调试、改动。 动手写代码在学习的过程中一定要动手做、写代码，而不是抱一本书看看就行。很多东西和体会必须自己动手才能真正属于自己。 在学到一定阶段后，试用学过的东西做些什么。 培养自学能力Java API文档 英文地址：http://java.sun.com/j2se/1.5.0/docs/api/ 中文：网上搜索下载 充分利用网络学习资源 使用搜索引擎 加入论坛参与讨论 学习资料推荐参考书（1）《Java学习笔记》，良葛格著， 清华大学出版社，2006.8。 （2）《Java编程基础、应用与实例》，［韩］徐明浩 著 武传海译，人民邮电出版社，2005.10。 （3）《Java编程思想》第3版 ，（美）埃克尔（Eckel,B.） 著 陈昊鹏 等译, 机械工业出版社，2005.5。 （4）《Java就业培训教程》, 张孝祥 编著， 清华大学出版社,2003.9。 网络学习资源（1）Java中国开发网–http://bbs.cjsdn.net/（2）中文JAVA技术网–http://www.cn-java.com/（3）天新网 - 软件开发 - Java开发–http://dev.21tx.com/java/（4）视频教程《Java无难事视频教程》孙鑫http://www.enet.com.cn/eschool/zhuanti/java/（5）ChinaJavaWorld.com技术论坛http://bbs.chinajavaworld.com/index.jspa（6）赛迪网技术社区 http://bbs.java.ccidnet.com/index.php（7）SUN中国技术社区 http://gceclub.sun.com.cn/ JAVA语言的特点简单、面向对象、与平台无关…… 简单风格类似于C++，易上手；抛弃了C++中容易引发程序错误的一些特性，如指针、结构、枚举以及内存管理等；Java提供了丰富的类库，可以帮助我们很方便的开发Java程序。 面向对象面向对象可以说是Java最重要的特性，所以它支持继承、重载、多态等面向对象的特性。Java语言的设计是完全面向对象的，它不支持类似C语言那样的面向过程的程序设计技术。 分布式程序设计语言面向网络的语言，编写网络应用程序 与平台无关、可移植性“一次写入，到处运行” 健壮、安全、高性能、多线程、动态性等等 Java与C及C++的比较边学边比 Java语言程序分类应用程序(Applicatiion)可通过JVM独立运行的程序 1234567public class Hello&#123; public static void main(String[]args) &#123; System.out.println (&quot;hello world!&quot;); &#125;&#125; 小程序(Applet)必须嵌入到网页，由支持JVM的浏览器解释运行。 123456789import java.awt.*;import java.applet.*;public class AppletHello extends Applet&#123; public void paint(Graphics g) &#123; g.drawString(&quot;hello,world!&quot;,20,20); &#125;&#125; Java程序开发过程开发程序前，进行开发环境配置 安装JDK 选择安装开发工具JDK＋记事本等文本编辑工具，可以直接使用JDK环境JCreater、JBuilder、EClipes等集成开发环境 开发步骤编写程序源文件 源文件类型名为.java 编译生成字节码文件 生成的字节码文件类型名为.class 运行 应用程序运行：通过Java虚拟机独立运行程序 小应用程序运行：嵌入浏览器中运行 下载安装JDK5.0(可以下载最新版)JDK5.0 (J2SDK1.5) 从SUN公司网站下载(jdk-1_5_0_11-windows-i586-p.exe)http://java.sun.com/javase/downloads/index_jdk5.jsp 安装:根据提示安装 JDK安装目录结构简介 binjavac: Java编译器，用来将java程序编译成字节码文件.class。java: Java解释器，执行已经转换成字节码的java应用程序。appletviewer : Java虚拟浏览器， 用来解释嵌到网页中的java小应用程序。 lib:Java类库 Jre\lib：Java核心类库 JDK环境下程序编译与运行编写Java应用程序源文件在D盘创建工作目录exam1(不是必须的)在工作目录下，使用记事体程序编写文件名为HelloWorld.java输入程序代码 准备编译和运行程序（环境配置）开始运行(cmd)，打开命令窗口输入set path=”c:\program files\java\jdk1.5.0_11\bin”并回车，设置Java命令的搜索路径输入d:并回车，将当前盘转至D盘输入cd exam1并回车，当前目录转至我们的工作目录 编译成字节码文件输入javac HelloWorld.java并回车，将源文件编译成字节码文件 执行程序输入java HelloWorld并回车，执行程序 Applet程序的运行编写源程序AppletHello.java内容123456789import java.awt.*;import java.applet.*;public class AppletHello extends Applet&#123; public void paint(Graphics g) &#123; g.drawString(&quot;hello,world!&quot;,20,20); &#125;&#125; 编译为字节码文件AppletHello.class运行编写网页文件hello.html，其内容如下： 123&lt;applet code=&quot;AppletHello&quot; height=&quot;50&quot; width=&quot;200&quot;&gt;&lt;/applet&gt; 用IE直接打开hello.html或者执行appletviewer hello.html 使用集成开发环境开发Java程序集成开发工具简介 UltraEdit、EditPlus：文本编辑器，适用于初学者，只能编辑，编译和运行需要借助java命令。 Jcreater：功能较为强大，可以编辑、编译、调试运行。初学者使用的工具。 JBuilder：功能强大的集成开发工具，一般用于商业开发中，不适用于初学者。 Eclipes：功能强大的集成开发工具，免费，也常用于商业开发，不适用于初学者。 使用Jcreater编写Java应用程序编辑编译运行 Java虚拟机JVM(Java Virtual Machine) 是一种利用软件方法来实现硬件功能的虚拟计算机。 是Java跨平台的保证 JVM的实现－Java运行时系统嵌入Java运行时系统的应用程序，可以执行Java字节码文件 小结课程介绍什么是Java?学习目标与学习方法Java语言简介特点程序分类程序开发过程 技能训练一 Java入门目的通过本次训练，使学生了解Java编程环境，掌握Java程序开发过程。 训练内容1、编写一个简单的Java应用程序（源文件Hello.java），该程序在命令行窗口输出两行文字：“我叫XXX，来自XX班”、“我的爱好是XXX”。2、写出在实训过程中涉及到的知识点及难点,遇到的问题和解决的办法，有哪些收获。3、实验后的练习（1）编译器如何提示丢失大括号的错误？（2）编译器如何提示将System写成system的错误？（3）编译器如何提示丢失行尾分号的错误？（4）编译器如何提示程序文件名与类名不同的错误？ 技能训练二 熟悉Java语言开发过程目的 使学生掌握Java开发环境的安装与配置，学会下载安装JDK开发工具包，掌握使用JDK环境开发Java程序的过程，掌握集成开发工具软件下载、安装和使用。 训练内容1、操作 从Sun公司网站下载JDK5.0的标准版，并安装 使用记事本编写Java应用程序、Java小程序 使用javac命令编译，并检查生成的字节码文件 运行Java应用程序 编写小程序的嵌入网页文件，并运行 2、总结实训过程中涉及到的知识点及难点,遇到的问题和解决的办法，有哪些收获 JAVA 程序设计课程的性质、任务 本课程是软件、网络技术专业的一门专业基础课程，是该专业理论与实践紧密结合的一门必修课，课程的任务是使学生掌握Java程序设计语言，理解面向对象的程序设计的思路和方法。 培养学生的编程能力。本课程的主要知识点群包括面向对象技术、异常处理、多线程、输入输出流、图形用户界面（GUI）设计、Applet开发、网络通信以及数据库使用等。 第1讲 基本要求了解Java的发展历史及基本特点掌握Java虚拟机的概念掌握Java2 SDK的开发环境的建立掌握 Java Applet, Java Application的Java应用种类及运行操作 实验一 JDK开发工具 内容：从网上下载JDK工具、帮助文档并安装，编写一个小程序 要求：掌握从网上下载JDK工具、帮助文档并安装、会使用 JDK运行程序 第1章 Java语言概述1.1 Java的发展历史1.2 Java的特点1.3 Java程序的开发过程与运行环境实训一 安装与熟悉Java开发工具习题一 1.1 Java的发展历史Java的产生 1995年5月，Sun公司在“SunWorld95”大会上推出了Java语言。Java语言作为一种网络编程语言，随着国际互联网的飞速发展，很快得到了广泛的支持和实际的应用。 了解内容：Java语言最初并不是为互联网设计的，它来自于Sun公司的一个叫“Green”的项目，目的是为家用消费电子产品开发一个分布式代码系统，这样用户可以把E-mail发给电冰箱、电视机等家用电器，对它们进行控制和信息交流。该项目小组开始准备采用C++，但他们很快意识到C++太复杂，安全性差，最后基于C++开发了一种新的语言Oak(Java的前身)。 Oak是一种用于网络的精巧而安全的语言，Sun公司曾以此投标一个交互式电视项目，但败于SGI，使得Oak几乎夭折。 Mark Ardreesen开发的Mosaic和Netscape启发了Oak项目组成员，他们用Java编制了HotJava浏览器，得到了Sun公司首席执行官Scott McNealy的支持，Java得以进军互联网。 目前通常所说的Java有三层含义：首先是指一种编程语言；其次是一种开发环境；再者是一种应用环境。 Java的现状Java作为新一代面向对象的程序设计语言，特别适合于Internet应用程序开发，它的平台无关性使Java作为软件开发的一种革命性技术地位已被确立。 计算机产业的许多大公司购买了Java的许可证，包括IBM、Microsoft、Apple、Oracle等。 Java开发工具软件日渐丰富，如Borland公司的JBuilder、Sun公司的JavaWorkshop、IBM的VisualAge、微软公司的Visual J++。 数据库厂商如Sybase、Versant、Oracle都在开发CGI接口，支持HTML和Java。 按照Java的应用领域Sun公司将Java分为三个版本： (1) J2SE(Java 2 Platform，Standard Edition)。J2SE含有基本的Java2 SDK工具和运行时API，开发者可以用来编写、部署和运行Java应用程序以及Applet(在Web浏览器(如IE)中运行的Java小程序)。 (2) J2EE(Java 2 Platform，Enterprise Edition)。J2EE建立在J2SE的基础上，它是JSP(Java Server Page)、Servlet、EJB、JTS(Java Transaction Service)、Java mail以及JMS(Java Message Service)等多项技术的混合体，主要用于开发分布式、服务器端多层结构的应用系统，如电子商务网站。 (3) J2ME(Java 2 Platform，Micro Edition)。它主要用于开发电子产品，如移动电话、数字机顶盒、汽车导航系统等。 Java 的 特 点 Java语言从诞生到得到很广泛的应用，只经过了短短的几年，这与它的特点是分不开的。 Java作者写了一个非常有影响的“白皮书”，来解释设计目标和已取得的成果。“白皮书”是按下列11个特征来定义的： ● 简单的；● 面向对象的；● 分布式的；● 健壮的(Robust)；● 安全的；● 中立结构的；● 可移植的；● 解释型的；● 高效的；● 多线程的；● 动态的。 结构中立Java语言编译器产生的二进制代码是一种与具体机器指令无关的指令集合，只要有Java运行时系统存在，编译后的代码便可在许多处理器上运行。 Java运行时系统被称为Java虚拟机(Java Virtual Machine，JVM)，Java编译器产生的代码由Java虚拟机解释执行，如图1.1所示。由此，Java语言实现了平台独立性，“一次编写，随处运行(Write once，Run anywhere)”。 Java编译器产生的二进制代码称为字节码(Byte Code)，字节码与任何具体计算机结构都无关。实际上，这并不是一个新想法，多年前的UCSD Pascal系统就在一个商业产品中做了同样的努力，不过，Java解决了这种技术存在的一个主要缺点，即与通常高级语言采用的编译为机器指令相比，采用这种方式程序执行效率相差很多。 同体系结构无关的特性使得Java应用程序可以在配备了Java虚拟机的任何计算机系统上运行，这成为Java应用软件便于移植的良好基础。 另外，Java系统的基本数据类型不依赖于具体实现，在任何硬件平台上均保持一致。而通常的高级语言数据类型是与平台相关的，如C语言在Windows 3.1中整数(int)为16位，在Windows 95中整数为32位，在DECAlpha中整数为64位，在Intel486中整数为32位。 面向对象面向对象可以说是Java最重要的特性，Java语言的设计完全是面向对象的，它不支持类似C语言那样的面向过程的程序设计技术。Java支持静态和动态风格的代码继承及重用。。 Java语言程序的基本单位是类class，一个完整的Java语言程序一般由多个类构成。 Java语言运行环境还提供了功能强大的类库(或称为应用程序接口API)，可以帮助应用程序很容易地实现一些复杂的功能。 简单Java语言的简单性主要体现在以下三个方面：(1) Java的风格类似于C++，因而C++程序员是非常熟悉的。从某种意义上讲，Java语言是C及C++语言的一个变种，因此，C++程序员可以很快掌握Java编程技术。(2) Java摒弃了C++中容易引发程序错误的地方，如指针、内存管理、运算符重载等。(3) Java提供了丰富的类库 分布式Java包括一个支持HTTP和FTP等基于TCP/IP协议的类库。 因此，Java应用程序访问网络上的对象很容易，其访问方式与访问本地文件系统几乎完全相同。为分布环境尤其是Internet提供动态内容无疑是一项非常宏伟的任务，但Java的语法特性却使得程序员可以很容易地实现这项目标。 健壮Java致力于检查程序在编译和运行时的错误。 类型检查帮助检查出许多开发早期出现的错误。Java自已操纵内存，减少了内存出错的可能性。Java还实现了真数组，避免了覆盖数据的可能。这些功能特征大大缩短了开发Java应用程序的周期。Java提供null指针检测、数组边界检测、异常出口和字节代码校验。 安全Java的安全性可从两个方面得到保证：一方面，在Java语言里，指针和释放内存等C++功能被删除，避免了非法内存操作；另一方面，当用Java来创建浏览器时，语言功能和浏览器本身提供的功能会结合起来，使它更安全。 Java语言程序在机器上执行前，要经过多次测试。它经过代码校验，检查代码段的格式，检测指针操作、对象操作是否错误等。 如果字节码通过代码校验后，没有返回错误，则表示代码没有堆栈上溢出和下溢出，所有操作代码参数类型都是正确的，没有发生非法数据转换，如将整数转换成指针，访问对象操作是合法的。 通过校验的代码由类装载器(ClassLoader)装载执行。类装载器通过将本机类与网络资源类的名称分开来保持安全性。因为装入类时要经过检查，所以避免了特洛伊木马现象的出现。 多线程Java提供的多线程功能使得在一个程序里可同时执行多个小任务。多线程带来的更大的好处是更好的交互性能和实时控制性能。 Java是第一个支持多线程的程序设计语言，而传统的程序设计语言要实现多线程必须调用操作系统提供的有关编程接口。当然，Java虚拟机本身并不实现多线程机制，多线程的实现最终还取决于系统本身(UNIX、Windows等). Java程序的开发过程与运行环境Java程序的开发过程Java程序的开发过程与其他高级语言相似。 首先编写程序，然后采用文本编辑软件输入源程序，再使用Java语言编译器进行编译，生成字节码文件。 Java虚拟机直接执行字节码文件，没有连接生成独立的可执行文件的过程，Java类库代码也不像C/C++的函数库或类库那样需要连接到执行文件中去。 Java语言最基本的开发环境是由Sun公司免费提供的JDK(Java Development Kit)，它的开发环境比较简单，使用命令行编译源代码，编译调试程序都不是很方便。 Java语言的集成开发工具，集源代码的编辑、编译以及调试于一体，而且这些开发工具可以帮助程序员生成应用程序框架，减少程序员的重复劳动，提高软件开发的效率。常见的集成开发工具有Microsoft公司的Visual J++、Borland公司的Jbuilder、IBM公司的VisualAge for Java等。 Application与AppletJava程序主要有Java应用程序(Java Application)和Applet两种。下面首先给出两个最简单的Java程序，从中可以了解Java语言程序的基本结构。 【程序1.1】 最简单的Java应用程序。 1234567891011/* HelloWorldApp.java */ class HelloWorldApp &#123; /** * 传统的 &quot;Hello World!&quot; 程序 **/ public static void main (String args[]) &#123; // 输出到标准输出设备 System.out.println(&quot;Hello World!&quot;); &#125;&#125; 程序1.1是一个Java Application，它的功能很简单，向标准输出设备输出字符串“Hello World!”，运行该程序后可以在显示器上看到该字符串。 从程序1.1中首先看到的是注释语句，Java语言的注释语句与C/C++语言中的注释语句类似，有两种基本形式： (1) 以/开始，以/结束。其中的所有字符在编译时被忽略。(2) 行注释。以//开始到本行结束。 程序1.1定义了一个类HelloWorldApp，其中定义了一个方法main，方法类似于C语言的函数。 main方法是程序的入口点，Java应用程序从main方法开始执行，main方法执行结束则该程序退出运行。因此，如果一个程序由多个类构成，只能有一个类有main方法。 程序1.1使用了Java API完成字符串的输出功能，System.out为标准输出流对象，相当于C语言中的标准输出文件，println为其方法成员。println方法的功能为输出括号中的字符串或其他类型的数据并换行。类似的还有方法print，它与println的区别是输出数据后不换行。 与C语言中标准输入文件对应，Java语言中也有标准输入流System.in，不过它的功能与C语言标准输入文件相比较弱，Java语言只提供了从标准输入设备读入字符的方法，而没有提供读入其他类型数据的方法。如果希望直接从键盘输入一个整数或实数，必须用程序将从键盘输入的字符串转换为所需的类型。 Java Applet的执行环境与Java应用程序不同，Applet不是独立的应用程序，它是嵌入在HTML文件中使用的，程序被放置在Web服务器上，下载到客户端后，由Web浏览器(如微软的Internet Explorer)执行。 123456789【程序1.2】 最简单的Java Applet。import java.applet.Applet;import java.awt.Graphics;public class HelloWorld extends Applet&#123; public void paint(Graphics g) &#123; g.drawString (&quot;你好，Java世界！&quot;，2，20); &#125;&#125; 程序1.2是一个最简单的Java Applet，下面是一个发布程序1.2的HTML文件的内容，请读者注意其中斜黑体的内容。1234567891011&lt;html&gt;&lt;head&gt;&lt;title&gt;我的第一个Java Applet程序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&lt;applet code=HelloWorld.class width=300 height=200&gt;&lt;/applet&gt;&lt;/body&gt;&lt;/html&gt; 将上述HTML文件和程序1.2编译得到的字节码文件HelloWorld.class放在Web服务器的同一个目录下，当使用Web浏览器浏览该HTML文件时，浏览器将下载HelloWorld.class，然后执行。 因为执行环境与Java Application不同，Applet的程序结构与Java Application也有所不同，当然它们有一点是共同的：都是由若干个类组成的。 程序1.2的第1行相当于C语言中的#inlcude，表示该Applet程序需要引用Java的Applet类。 不过，Java编译器的处理方法不同于C语言，它并不将该文件读入，而且它引用的是已经编译过的Java字节码文件。在编译阶段，Java编译器将从该字节码文件中读取有关Applet类的信息，检验程序中对Applet的使用是否正确。程序1.2编译生成的HelloWorld.class文件中也不包含Applet类的代码。 第2行的作用与第1行类似，由于程序中用java.awt.Graphics类的功能来输出字符串，因此引入该类。 第3行开始定义HelloWorld类，注意后面的extends Applet，这是Java类继承语法。一个Applet程序可以由多个类构成，其中只有一个类继承于Applet类，这是Applet程序的入口。 Applet的执行与Java Application不同，从程序中看不到像Application中main方法那样的一个明显的执行流程。 实际上这些都已经在Applet中实现了，Applet在执行时一直等待用户的输入或其他的一些事件(如关闭浏览器)，根据不同的事件执行不同的功能。 在编写Applet时需要做的就是提供各种事件的处理程序， 例如程序1.2类HelloWorld中定义了方法paint，该方法在Applet需要绘制界面时被调用。 Applet类中定义了paint方法的调用形式，它有一个Graphics类的对象作参数，通过它可以在Applet的界面上绘制图形和文字。程序1.2调用drawString方法来输出一个字符串：g.drawString (“你好，Java世界！”，2，20); drawString方法有三个参数： 第一个是要输出的字符串； 第二、三个是输出位置，分别为x、y轴的值。 图1.2是程序1.2在IE 6.0中执行的画面。 JDK的安装与使用JDK(Java Development Kit )是最基本的Java程序开发工具，可以从Java官方站点http://java.sun.com 下载。目前该站点提供的正式版本是Java2 SDK 1.4.2，支持的平台有Windows、Linux、Solaris SPARC和Solaris x86，用户可选择合适的版本下载。 J2SE的下载页面为http://java.sun.com/j2se/1.4.2/download.html， 如图1.3所示，它提供了带集成开发环境和不带集成开发环境两种版本。 下面介绍Windows 98平台下不含集成开发环境的Java2 SDK 1.4.2的安装和使用。 1) 安装运行下载的可执行文件，出现画面，选择“I accept the terms in the license agreement”，然后单击“Next”按钮，显示选择安装的项目。 如果不需安装演示程序和类库的源代码，可去掉安装项目中的“Demos”和“Source Code”。如果需要修改JDK安装的目录，点击“Change”按钮选择。最后单击“Next”按钮，进入画面，确定是否为系统当前已安装的Web浏览器安装了Java虚拟机插件。单击“Next”按钮开始复制文件和配置，最后画面，单击“Finish”按钮结束安装。 JDK的使用JDK使用命令行方式进行编译。要调试Java程序，首先要使用文本编辑器输入保存Java源程序，然后编译执行。 第一步：编辑源程序。使用纯文本的编辑软件，如Windows 98的记事本(Notepad.exe)或MS-DOS的edit.exe。保存文件时注意文件名应与程序中的类名相同，程序1.1的文件名为HelloWorldApp.java(注意大小写)。 第二步：编译源程序。在DOS命令提示符下执行(注意大小写)javac HelloWorldApp.java 如果正常的话，将生成HelloWorldApp.class文件。 第三步：运行程序。在DOS命令提示符下执行(注意大小写)java HelloWorldApp注意不要输入文件的扩展名class。 用JDK编译运行Java Applet过程与编译运行Java应用程序类似，只是最后运行程序的方式不同。 Java Applet可以在支持Java Applet的Web浏览器中运行，也可以使用JDK提供的appletviewer.exe。在DOS命令行中输入appletviewer Page1.htm这里，Page1.htm为程序1.2中的HTML文件。 Visual J++ 6.0的使用 Visual J++ 6.0是微软公司可视化集成开发环境Visual Studio 6.0的一个组成部分，Visual Studio是运行于Windows环境下的一个集成工具集，包括Visual C++、Visual J++和Visual InterDev等。 Visual J++通过解决方案(Solution)和项目(Project)来组织程序。一个解决方案中可包含多个项目，每个项目相当于一个完整的程序，而解决方案相当于一个完整的应用系统。解决方案不可单独创建，在新建一个项目时会自动创建一个解决方案。图1.11是使用Visual J++调试程序1.2的画面，Visual J++创建了一个解决方案ch1-2，该解决方案包含一个项目ch1-2，而该项目由两个文件构成：HelloWorld.java和Page1.htm。 Visual J++ 6.0集成开发环境的功能很强大，限于篇幅，本书不详细介绍其使用方法，仅简单介绍如何使用Visual J++ 6.0调试Java应用程序和Java Applet。 1．用Visual J++调试Java应用程序 调试Java应用程序时，首先应为要调试的应用程序创建一个项目，在File菜单下选择“New Project”，弹出图1.12所示的对话框。在左边的树形列表中选择“Visual J++ Projects”→“Applications”，然后在右侧的列表中选择“Console Application”，在对话框下部的Name编辑框中输入项目名，在Location编辑框中输入项目文件存放的目录或单击“Browse”按钮选择一个目录。最后单击“打开”按钮，Visual J++将创建新项目。 对于Java应用程序，Visual J++自动创建了一个文件Class1.java，并给出了类的声明和main方法的声明，用户可在此基础上修改。 首先在解决方案窗口中展开该项目，然后在Class1.java文件名上单击鼠标右键，选择“Rename”，如图1.13所示，修改文件名。对于程序1.1应将文件名修改为HelloWorldApp.java，然后双击文件名打开源程序编辑窗口修改程序。 源程序输入完成后，选择Debug菜单的子功能即可执行程序。第一次执行可能会出现图1.14所示的对话框，原因是在创建该项目时，设定执行的类为Class1。单击“确定”按钮会出现图1.15所示的对话框，再单击“OK”按钮就可以，此时设定执行的类已改为HelloWorldApp。该窗口也可以通过“Project”菜单的子功能激活，然后修改要执行的类。 当然，如果源程序有错误，程序将不能正常编译执行，错误信息会显示在Task List窗口上。 选择File菜单的子功能Close All可以关闭当前打开的所有项目，Save All可保存当前项目的信息。Visual J++中解决方案保存的文件的扩展名为.sln，项目保存的文件的扩展名为.vjp，可以在以后再次打开。 用Visual J++调试Java Applet 用Visual J++调试Java Applet的步骤与调试Java应用程序基本相同，也需要先创建一个项目。在选择项目类型时，首先在左边的树形列表中选择Web Pages，然后在右边选择Applet on HTML。 Visual J++为新项目生成两个文件：Applet1.java和Page1.htm。Applet1.java提供了一个比较复杂的Applet程序的框架，对于程序1.2这样的Applet，可以将原来的代码删除。与Java应用程序类似，也应保持文件名与类名的一致。Page1.htm是Visual J++提供的一个HTML文档，用于在Web浏览器中调试Applet。 Visual J++提供了两种调试运行Applet的方法，可以在项目的Properties对话框中选择。选择运行HTML文件将使用Web浏览器，而选择运行Java类将使用微软公司提供的与appletviewer相似的WJView.exe。 实训一 安装与熟悉Java开发工具JDK开发工具 一、实训目的 学习从网络下载JDK开发工具与帮助文档。 学习安装JDK开发工具及其文档。 掌握Java Appllcation程序的开发过程并编写一个Java Application程序。 掌握Java Applet程序的开发过程并编写一个Java Applet程序。 学习编写简单的HTML文件，配合Java Applet使用。 学习使用JDK的帮助文档。 二、实训内容 1．从网络下载JDK开发工具与帮助文档。 (1)访问 http://java.sun.com， 浏览JDK下载页面,J2SE v 1.4.2的下载页面为 http://java.sun.com/j2se/1.4.2/download.html 也可以通过访问其他国内外的免费FTP站点或从CD-ROM光盘中下载得到JDK开发工具。 (2) 选择适合本地实验计算机平台的软件版本，运行Windows 95 / 98的计算机，应选择“Windows Installation”版本的JDK开发工具，即单击图1.18所示的链接。 单击此链接后，所示的网页，点击指定的链接。所示的页面中单击 按钮接受有关软件下载的协议，单击下载链接，如果采用Internet Explorer则出现所示保存文件的提示，单击 按钮，在所示的对话框中选择保存的目录。 (3) 按同样的方法下载JDK的帮助文档。 安装JDK开发工具与帮助文档。 (1) 运行下载的可执行文件，按照1.3节介绍的步骤安装JDK。(2) 为方便运行Java编译器，设置环境变量Path。对于Windows 95/98，修改计算机的C:\AUTOEXEC.BAT文件时应在文件末增加一句：set Path=%Path%;C:\j2sdk1.4.2\bin这里，C:\j2sdk1.4.2为JDK的安装目录。 对于Windows XP及Windows 2000等平台，在控制面板中选择系统，在系统属性对话框中单击按钮。然后在“系统变量”列表中选择“Path”，然后单击按钮，在出现的对话框中仿照上面的set命令将C:\j2se1.4.2\bin加入到Path环境变量中。 使用解压缩工具Winzip将JDK帮助文档j2sdk-1_4_2-doc.zip文件解压，该压缩文件包含一组以HTML文件形式组织的帮助文件，把它们保存在本地的一个目录下，例如保存在C:\j2sdk1.4.2\document\目录下。 编写并运行一个Java Application程序(1) 打开一个纯文本编辑器，例如Windows记事本NotePad.exe或DOS下的edit.exe。 (2) 键入1.2节中的程序1.1。 (3) 检查无误后(注意大小写准确)把文件保存起来，命名为HelloWorldApp.java，可以创建一个目录，如C:\Java\prog1_1，保存这个文件。 (4) 进入DOS命令行方式，用cd命令进入(3)中创建的目录，运行Java编译器：javac HelloWorldApp.java (5) 如果JDK安装正确、程序输入无误且保存的文件名正确，运行编译器没有任何输出；否则，会输出错误信息，一般的错误都是由于拼写失误引起的。运行dir命令查看是否已在相同目录下生成一个名为HelloWorldApp.class的文件。 (6) 利用Java解释器运行这个Java Application程序，并查看运行结果：java HelloWorldApp 编写并编译一个Java Applet程序。(1) 打开一个纯文本编辑器。(2) 键入1.2节的程序1.2。(3) 创建一个目录，保存文件，命名为HelloWorld.java。(4) 进入DOS命令行方式，在保存有上述Java文件的目录下运行Java编译器：javac HelloWorld.java(5) 如果程序输入无误且保存的文件名正确，运行编译器将没有任何输出；否则，会输出错误信息。运行dir命令查看是否已在相同目录下生成—个名为HelloWorld.class的文件。 编写配合Applet的HTML文件。(1) 打开一个纯文本编辑器。(2) 键入如下的HTML程序： 1234567891011&lt;html&gt;&lt;head&gt;&lt;title&gt;我的第一个Java Applet程序&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&lt;applet code=HelloWorld.class width=300 height=200&gt;&lt;/applet&gt;&lt;/body&gt;&lt;/html&gt; (3) 检查无误后把文件命名为Page1.htm，保存在与文件HelloWorld.java同一目录下。(4) 直接双击这个HTML文件的图标，或者打开Web浏览器(例如IE)，在地址栏中键入这个HTML文件的全路径名，查看Applet在浏览器中的运行结果。(5) 利用模拟的Applet运行环境解释运行这个Java Applet程序并观察运行结果。进入DOS环境，在程序所在目录下运行下面的命令：appletviewer Page1.htm 使用JDK帮助文档。在Windows中打开JDK文档目录，双击index.html文件，或者在Web浏览器的地址栏中输入这个文件的全路径名，打开这个文件对应的网页，查阅相关内容。B．Visual J++ 6.0集成开发环境 一、实训目的 学习安装Visual J++ 6.0集成开发环境。 掌握集成开发环境(IDE)的概念，了解并学习使用Visual J++开发环境的基本构成和功能。 了解“项目”的概念，掌握利用Visual J++开发并编译运行一个Java Application的过程。 了解“可视化开发”的概念，掌握利用Visual J++的向导开发一个Java Applet的过程。 给出Java Applet和Java Application例子，调试程序、修改程序功能。 二、实训内容1．安装Visual J++ 6.0。Visual J++ 6.0集成开发环境可以从CD-ROM光盘上安装，也可以从网络上利用共享目录安装，整个安装过程是自动完成的，用户只要给出安装到本机的目录、选择安装选件(通常选择“典型安装”)即可。 2．编写并运行第一个Java Application程序。Visual J++是以“项目”(Project)来组织应用开发的。一个完整的应用通常由若干个源程序文件和辅助性文件构成，同时，为了保证开发的连续性，开发工具通常还会记录用户的桌面安排和其他种种设置。Visual J++中所有这些与一个应用开发任务相关的文件被放在一个目录中，称为一个Project。 (1) 新建—个空项目(Empty Project)。通过Windows 95/98“开始”菜单的“程序”选项选择“Microsoft Visual J++ 6.0”，打开Visual J++开发环境，出现“New Project”窗口(见图1.12)。选中图标左边区域的“Visual J++ Projects”一项，右边的图标变成一个“Empty Project”，如图1.27所示，选中该图标。然后在对话框下方的“Location”一栏输入新建项目所在的目录，在“Name”一栏中输入新建项目的名称，然后单击“打开”按钮。系统将在指定目录中为这个项目生成一个指定名称的子目录，以保存这项目中的所有文件。 (2) 加入并编辑Java Application源程序。选中位于屏幕右上方的窗口“Project Explorer”，选中项目名，用鼠标右键单击项目名前的的图标，选择弹出菜单的“Add”菜单项的“Add Class”子菜单项所示的对话框。 第二个图标“ClassMain”，然后在“Name”栏中输入类名HelloWorldApp.java，点击“打开”按钮，系统将创建一个名为HelloWorldApp.java的源代码文件，将其加入当前项目并打开编辑这个源代码文件的窗口，其中包含系统自动生成的几行代码：123456public class HelloWorldApp &#123; public static void main(String[] args) &#123; &#125; &#125; 按照程序1.1修改该文件，然后选择File菜单下的“Save HelloWorldApp”子菜单保存该文件。 (3) 编译并运行Java Application程序。选择“Build”菜单的“Build”选项编译该程序，屏幕最下方的状态条将显示“Solution update succeeded”，表示编译成功。选择“Debug”菜单的“start”选项即可运行此程序。程序第一次运行时，系统需要了解这个项目的有关属性。 由于程序是采用字符界面，因此以系统将打开一个字符界面的窗口，在其中运行该程序。这个字符界面的窗口将在程序运行完毕后自动关闭，读者可能来不及查看运行结果。为解决这个问题，可将光标定位到main方法结束的大括号处，然后选择“Debug”菜单的“Run to cursor”运行程序，程序运行到光标所在处后暂停，此时可切换到程序的字符界面窗口查看，然后再选择“Debug”菜单的“start”选项继续。 编写并调试一个Java Applet程序(1) 新建Applet项目。按照1.3.4节介绍的步骤创建一个Applet项目。(2) 编辑Applet源代码。按照程序1.2的清单修改Applet1.java文件。(3) 修改Applet1.java文件名。 将文件名中的Applet1改为类名HelloWorld 修改HTML文档。在Project Explorer窗口中双击Page1.htm文件打开编辑窗口，用鼠标单击Applet显示区。然后，所示的Properties窗口中将code属性修改为HelloWorld.class，可同时修改height、width属性，调整Applet在浏览器中显示区域的大小。 HTML文档的编辑窗口有三页视图：第一页Design，可以利用屏幕左边Toolbox窗口中的HTML工具可视化地加入一些图形界面组件，如文本区域、按钮等(注意：这些组件是加入到HTML文件中，不是Applet中)；第二页Source，显示HTML的具体代码，其中蓝色的区域是HTML中所嵌入的Applet的显示效果；第三页QuickView，显示整个HTML在浏览器中的显示效果。 如果想以文本方式编辑HTML文档，可选择第二页视图，选中代表Applet的矩形区域，单击鼠标右键，在弹出的菜单中选择“Always View As Text”菜单项。 (5) 运行Applet程序。 使用Visual J++的调试功能。Visual J++的集成环境的调试功能很强大，开发人员启动调试功能后，可以介入程序的运行过程，能够分解、控制程序的运行或使程序在指定条件下运行，并随时查看运行的中间结果，极大地方便了开发人员，也提高了开发效率。 (1) 打开已有项目。选择File菜单的“Close All”菜单项关闭当前的项目及其中的所有文件，如果该项目修改后尚未保存，则系统将询问“是否保存当前项目中修改过的文件”，此时选择“Yes”。 选择File菜单的“Open Project”菜单项，打开“Open Project”对话框，找到HelloWorldApp应用程序所在的目录，选择所列出的文件(共列出两个文件，分别为 .sln文件和 .vjp文件，可选择其中任意一个)，点击“打开”按钮关闭对话框，系统打开前面创建的Java Application项目。 (2) 修改源代码。打开HelloWorldApp.java源程序编辑窗口，将程序修改为下面的内容：12345678910111213141516/* HelloWorldApp.java */ import java.lang.System; class HelloWorldApp &#123; /** * Traditional &quot;Hello World!&quot; program. **/ public static void main (String args[]) &#123; char c; try&#123; c = System.in.read(); // 输出到标准输出设备 System.out.println(&quot;Hello World!&quot;); &#125;catch(IOException e)&#123;&#125; &#125;&#125; 排除编译错误。选择Build菜单的Build选项，系统下方的状态条将提示“Solution failed”，表示出现了编译错误。错误内容显示在屏幕下方的TaskList窗口中。 该程序共有三个编译错误，双击第一行错误信息，光标将停留在源程序编辑窗口中发生该错误的那一行。产生这个错误是由于System.in.read方法的返回值为int类型，不能直接赋给char类型的变量c。将这行语句改为 c = (char)System.in.read(); 从错误提示信息可以看出，第二个错误与第三个错误实际上都是由IOException这个标识符引起的。上面的程序使用了Java语言的异常处理机制，IOException是为Java类库提供的一个异常类，该程序中未引入该类，因此产生错误。在程序头部加上下面的语句即可：1import java.io.*; 再次编译，系统显示“Solution update Succeeded”，表明错误已排除。 调试。排除了编译错误不等于程序就一定正确，如果程序里还包含了一些逻辑错误，则需要深入程序内部，动态地控制程序的运行过程，观察各种中间现象和中间结果。 调试一个程序所用的命令都在Debug菜单中，也可以使用专用的Debug工具条。选择View菜单的Toolbar菜单项，在打开的子菜单中选择Debug，系统将显示debug工具条. 在源代码编辑窗口中把光标移到1System.out.println(&quot;Hello World!&quot;); 这一行，点击Debug工具条中的“运行到光标”(Run to cursor)按钮，程序将运行，输入一个字符换行后程序在指定行之前停止，源代码窗口中该指定行左边出现一个黄色的箭头。同时，系统将在屏幕下方打开观察程序内各变量取值的窗口和Watch窗口(如果未出现，可以点击Debug工具条上的对应按钮)，选择变量取值窗口的第二页Locals，可以观察到程序中局部变量的取值情况。 单步运行是调试的重要手段，单步运行时用户每发出一个单步命令，程序从当前位置开始运行一个语句。Debug菜单条中有三个单步运行按钮，它们是“Step Into”、 “Step Over”和“Step Out”，分别代表跟踪当前语句中的方法调用、不跟踪方法调用一次执行完当前语句和运行完当前循环并跳出。 Watch窗口用于在调试过程中观察指定变量的值，可在“Name”栏中输入变量名并回车，如果需要观察多个变量的值，可重复上述过程。 调试程序常用的另一种手段是设置断点，当程序运行到断点时，回到集成环境。可以观察变量的值，然后继续执行。 习 题 一1．编译型语言与解释型语言是如何划分的?答：编译型语言在程序执行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序的时候，就不用再进行翻译了。 解释型语言，是在运行的时候将程序翻译成机器语言，所以运行速度相对于编译型语言要慢。 C/C++ 等都是编译型语言，而Java，C#等都是解释型语言。 虽然Java程序在运行之前也有一个编译过程，但是并不是将程序编译成机器语言，而是将它编译成字节码（可以理解为一个中间语言）。 在运行的时候，由JVM将字节码再翻译成机器语言。 注：脚本语言一般都有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。JAVASCRIPT,ASP,PHP,PERL,Nuva都是脚本语言。C/C++编译、链接后，可形成独立执行的exe文件。 4.脚本语言是一种解释性的语言,例如vbscript,javascript,installshield script,ActionScript等等,它不象c\c++等可以编译成二进制代码,以可执行文件的形式存在. 脚本语言不需要编译，可以直接用，由解释器来负责解释。 5.脚本语言一般都是以文本形式存在,类似于一种命令. 举个例子说,如果你建立了一个程序,叫aaa.exe,可以打开.aa为扩展名的文件. 你为.aa文件的编写指定了一套规则(语法),当别人编写了.aa文件后,你的程序用这种规则来理解编写人的意图,并作出回应.那么,这一套规则就是脚本语言 百度来源答案：编译型语言与解释型语言 计算机是不能理解高级语言的，更不能直接执行高级语言，它只能直接理解机器语言，所以使用任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言，也就是机器码。 而这种转换的方式有两种： 1）编译 2）解释 由此高级语言也分为编译型语言和解释型语言。 编译型语言：使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。 特点： 在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。 总结： 1）一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高； 2）与特定平台相关，一般无法移植到其他平台； 3）现有的C、C++、Objective等都属于编译型语言。 解释型语言：使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。 特点： 解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。 总结： 1）解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低； 2）只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植； 3）Python等属于解释型语言。 Java属于哪种类型语言?来源百度： Java是一种计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。 Java不同于一般的编译语言和直译语言。它首先将源代码编译成字节码，然后依赖各种不同平台上的虚拟机来解释执行字节码，从而实现了“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的运行速度有了大幅提升。 Java程序的编译和解释有何特点?编译执行和解释执行是不同语言之间的特性，所有的java都是编译执行的。 如果不是编译执行，其实已经完全不用java的编译器。那么只是一个使用java语法的另一种语言而已。 编译执行是指把代码先编译成机器码。然后按顺序运行，如果编译中有任何异常，都无法继续运行。java的编译就是把java转换成class。而解释执行则是运行到哪一行代码就执行哪一行代码。如果其他代码有错误但没有运行到，一般不会影响。 比较起来，编译执行速度要快的多。而解释执行则在于比较灵活。可以动态修改。甚至可以在代码运行到指定语句之前，修改该代码。 1、java编译生成的字节码，在所有操作系统都是一样，故其有这样的特点：write once, run anywhere.其意思：只需要一次编码，就可以在任何环境下运行。 2、不同的操作系统，其java虚拟机是不一样的。虚拟机将java字节代码转换对应操作系统的相关指令，保证其正常运行。 3、java 系统支持所有的硬件的平台，不存在你提及的问题，你可以放心使用。 4、解释器在java虚拟机中，编译器在JDK或JRE 中。 5、java虚拟机就是常说的java 运行环境，其缩写是 JRE，安装在操作系统下的一个目录中，这个目录在安装时可以由你自行指定，就像你安装其它应用软件一样。JDK中包含了JRE，还有开发环境，如编译器，帮助文档生成器，以及系统API的jar库文件等。 这些特点对于Java成为Internet上的编程语言有什么影响?Java编程语言并不是为Internet、www而设计的，它还可以用来编写独立的应用， Java编程是一种面向对象语言，Java语言类似于C++语言。Java程序需要编译，它被放置在Internet服务器上，当用户访问服务器时，Java程序被下载到本地的用户机上，由浏览器解释运行。实际上有两种Java程序：一种Java应用程序是一个完整的程序，如Web浏览器。另一种Java小应用程序是运行于Web浏览器中的一个程序。 Java程序和它的浏览器HotJava，提供了可让你的浏览器运行程序的方法。你能从你的浏览器里直接播放声音，你还能播放页面里的动画，Java还能告诉你的浏览器怎样处理新的类型文件。当我们能在2400 baud线上传输视频图象时，HotJava将能显示这些视频。 Java在电子商务方面的应用和特性 电子商务要求程序代码具有基本的要求：安全、可靠、同时要求能与运行于不同平台的机器的全世界客户开展业务。Java以 其强安全性、平台无关性、硬件结构无关性、语言简洁同时面向对象，在网络编程语言中占据无可比拟的优势，成为实现电子商务系统的首选语言。 在桌面应用上，尽管Java在桌面GUI方面尚有不尽如人意之处，但仍然有很多开发者用来开发运行在多种操作系统平台上的 桌面应用。具体应用在如下几个领域: 行业和企业信息化 由于Sun、IBM、Oracle、BEA等国际厂商相继推出各种基于Java技术的应用服务器以及各种应用软件，带动了Java在金融电信、制造等领域日益广泛的应用。如清华大学计算机系利用Java、XML和Web技术研制开发了多个软件平台，东方科技的Tong Web、金碟的Apusic、中创的Inforweb 等J2EE应用服务器及和佳ERP和宝信ERP等ERP产品，已在许多企业得到应用。 电子政务及办公自动化 东方科技、金碟、中创等开发的J2EE应用服务器在电子政务及办公自动化中也得到应用: 如金碟的Apusic在民政部、广东省市工商局应用; 东软电子政务架构EAP平台在社会保险、公检法、税务系统得到应用; 中创的Inforweb等Infor系列中间件产品在国家海事局、山东省政府及中国建设银行、民生银行等金融系统应用; 无锡永中科技基于Java平台开发的国产化集成办公软件Office”也已在一些省市政府部门得到应用。 嵌入式设备及消费类电子产品 无线手持设备、通信终端、医疗设备、信息家电(如数字电视、机顶盒、电冰箱)、汽车电子设备等是今年以来比较热门的Java应用领域。在这方面的应用有中国联通CDMA 1X网络中基于Java技术的无线数据增值服务——UniJa 来源：http://www.sohu.com/a/155169478_445013 2．JDK的编译命令是什么?1、window+R 2、在窗口里输入 cmd 3、进入你放java的文件目录下 4、javac 文件名.java (这个是编译) 5、java 文件名 (执行) 前提是你装了JDK才能编译和执行！！！ 如果编译结果报告说找不到要编译的源代码，通常会是哪些错误?123JAVA_HOME=C:\Program Files\Java\jdk1.8.0_40PATH=%JAVA_HOME%\bin;CLASSPATH=.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; 3．运行编译好的字节码文件使用什么命令? 什么是JIT? 什么是JVM?javac针对.java文件，编译源代码为字节码文件java针对.class文件，JVM解释执行程序 什么是JIT1、动态编译（dynamic compilation）指的是“在运行时进行编译”；与之相对的是事前编译（ahead-of-time compilation，简称AOT），也叫静态编译（static compilation）。 2、JIT编译（just-in-time compilation）狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。JIT编译是动态编译的一种特例。JIT编译一词后来被泛化，时常与动态编译等价；但要注意广义与狭义的JIT编译所指的区别。3、自适应动态编译（adaptive dynamic compilation）也是一种动态编译，但它通常执行的时机比JIT编译迟，先让程序“以某种式”先运行起来，收集一些信息之后再做动态编译。这样的编译可以更加优化。 来源：https://blog.csdn.net/sunxianghuang/article/details/52094859 来源：https://baike.baidu.com/item/JVM/2902369?fr=aladdin JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 基本数据类型byte://1字节有符号整数的补码short://2字节有符号整数的补码int://4字节有符号整数的补码long://8字节有符号整数的补码float://4字节IEEE754单精度浮点数double://8字节IEEE754双精度浮点数char://2字节无符号Unicode字符 其它数据类型object//对一个Javaobject（对象）的4字节引用returnAddress//4字节，用于jsr/ret/jsr-w/ret-w指令 JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是：JVM 指令系统JVM 寄存器JVM 栈结构JVM 碎片回收堆JVM 存储区 JVM执行程序的过程 ：I.加载.class文件II.管理并分配内存III.执行垃圾收集 JRE（java运行时环境）包含JVM的java程序的运行环境 JVM是Java程序运行的容器,但是他同时也是操作系统的一个进程,因此他也有他自己的运行的生命周期,也有自己的代码和数据空间。 JVM在整个jdk中处于最底层,负责与操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也叫虚拟计算机. 操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境。 1.创建JVM装载环境和配置2.装载JVM.dll3.初始化JVM.dll并挂接到JNIENV(JNI调用接口)实例4.调用JNIEnv实例装载并处理class类。 4．Java程序分为哪两大类？它们之间有哪些差别?Application和Applet是两个概念，前者指的是一个完整程序，后者指的是一个小程序，作为一个完整程序他具有一定的独立性，玩过手机游戏都知道一个手机游戏对应一个jar文件，这个jar文件就相当于一个Application，你运行游戏只需要选中它运行即可，不需要先启动另外一个程序后才能启动它。 而Applet则需要先启动浏览器后才能运行它。Applet因为小可以被看作一个软件组件，他可以作为一个动态网站的一个组成部分，Applet的主要用途是完成复杂的逻辑，这个是在JAVASCRIPT等脚本语言和JSP和ASP等动态网页技术还没出现时负责动态的显示数据的作用，类似微软的ActiveX组件。 在JAVA领域有三个“let”：MIDlet：移动设备应用程序Servlet:服务器程序Applet:浏览器小程序 来源：https://zhidao.baidu.com/question/2265873673648119708.html 5．Java程序中有哪几种注释方式？123//…… 单行注释/*……*/ 多行注释/**......*/用来做文档的注释 6．分别编写Applet和Application，在屏幕上生成如下图案：1234********** 略 第二章 结构化程序设计回顾—Java开发环境的建立1) 下载J2SE安装程序2) 运行J2SE安装程序，安装J2SE3) 设置环境变量：运行路径(path)类路径(classpath)4)下载J2SE的在线帮助文档 回顾—Java程序设计步骤打开文本编辑器编辑Java应用程序保存Java源程序使用javac命令编译源程序使用java命令运行Java程序 回顾—Java应用程序1234567public class HelloWorldApp&#123; public static void main(String args[]) &#123; System.out.println(“Hello World!”); &#125;&#125; 编辑存盘：文件名和公共类名(用public声明)要一致 HelloWorldApp.java编译程序：javac HelloWorldApp.java运行程序：java HelloWorldApp运行结果：Hello World! 教学目标掌握Java中基本数据类型来源：https://blog.csdn.net/hs2201056/article/details/58680629 1.布尔型—–boolean，boolean 类型所占存储空间的大小没有明确指定，其取值为true或false,其默认值为false。 2.字节型—-byte，byte 类型所占存储空间大小为1个字节，其取值为-128——127，其默认值为0。 3.整型——int，int类型所占存储空间大小为4个字节，其取值为-2^31——2^31-1，其默认值为0。 4.短整型—–short，short类型所占存储空间大小为2个字节，其取值为-2^15——2^15-1，其默认值为0。 5.长整型—–long，long类型所占存储空间大小为8个字节，其取值为-2^63——2^63-1，其默认值为0。 6.字符型—–char，char类型所占存储空间大小为2个字节，其默认值为\u0000。 7.单精度浮点型—–float，float类型所占存储空间大小为4个字节，其取值为-2^128——2^128，其默认值为0.0F。 8.双精度浮点型—–double，double类型所占存储空间大小为8个字节，其取值为-2^1024——2^1024，其默认值为0.0D。 掌握Java中各种运算符的使用掌握Java的控制结构理解结构化程序设计方法 教学重难点重点Java的基本数据类型Java的控制结构 难点Java程序控制结构 Java的标示符和关键字标识符可以用来标识变量名、类名、类中的方法名和文件名等. 标识符组成: (1) 字母, (2)数字, (3)下划线“_” 和 (4)美元符号“$”; 首字符必须是(1) 字母, (2)下划线“_” 和 (3)美元符号“$”; 所有标识符是区分大小写的; 除去关键字、false、true和null; 具有特殊含义的字符序列例如： public、 static和class具有特殊用途，不能作为变量名、方法名和类名 Java的关键字abstract continue for new switchassert default goto package synchronizedboolean do if private thisbreak double implements protected throwbyte else import public throwscase extends int short trychar final interface static voidclass finally long strictfp volatileconst float native super while Java的数据类型数据类型： 基本数据类型：布尔（boolean）: 数据类型：定点类型： 字符（char） 字节（byte） 短整数（short） 整数（int） 长整数（long） 浮点类型： 单精度（float） 双精度浮点数（double） 引用数据类型：类或枚举或接口数据 变量 变量在计算机内部对应着一个存储单元，而且总是具有某种数据类型：基本数据类型或引用数据类型 变量总是具有与其数据类型相对应的值 每个变量均具有: 名字、类型、一定大小的存储单元以及值 变量名对应内存的位置 Java变量必须属于某种类型变量值也必须与变量类型相匹配例如:int studentNumber; // 声明单个变量double velocity, distance; // 声明多个变量studentNumber=30; // 给变量赋以整数30int studentNumber=30;// 声明变量，并赋初值 Java变量int sum = 0;String s = “Hello World!”; Java直接量（常量）Java直接量包括基本数据类型直接量、字符串(String)直接量和null 布尔(boolean)直接量只有两个：true 和 false ‘c’, ‘\u0061’, ‘\u0051’ 和 ‘\u005a’ 是char直接量. 34是int直接量 1.5, 45.6, 76.4E8和-32.0是double直接量 34L是long直接量. 1.5F, 45.6f, 76.4E8F和-32.0F是float直接量 “Hello World!”是String直接量 null是引用数据类型的直接量 任意引用数据类型的直接量(null) Java转义字符12345678&apos;\b&apos; (退格)&apos;\f&apos; (换页)&apos;\n&apos; (换行)&apos;\r&apos; (回车)&apos;\t&apos; (水平制表符(到下一个tab位置))&apos;\&apos; &apos; (单引号)&apos;\&quot; &apos; (双引号) &apos;\\&apos; (反斜杠) Java运算符算术运算符关系运算符布尔逻辑运算符位运算符赋值类运算符条件运算符其他运算符 算术运算符算术运算符包括：+, -, *, /, ++, –, % 没有指数运算 Math.pow(2.0, 3.0); // 2.03.0 整数除法：截去余数 7 / 5 结果为 1 取模：返回余数 7 % 5 结果为 2 关系运算符六个关系运算符: &lt;、 &gt;、&lt;=、&gt;=、== 和 != 1234561 &gt; 2; // false3.5 != 1; // true 51.5 &gt;= 23.0; // true540 &lt;= 654; // true24 == 3*8; // trueboolean test1=(10 &lt; 10); // test1= false; 逻辑运算符六个布尔逻辑运算符:123456789 &amp; (逻辑 与 AND) | (逻辑 或 OR) ^ (逻辑 异或 XOR ) ! (逻辑 非 NOT)单目运算符, 即只有一个操作数 &amp;&amp; (条件 与 AND) || (条件 或 OR) 短路规则 ( &amp;&amp;和|| )如果从第一个操作数可以推断出表达式结果，就不再计算第二个操作数例如: 12if ((x == 2) &amp;&amp; (y != 2))System.out.println(&quot;两个条件都为 true.&quot;); 逻辑运算( &amp;和| )两个操作数均会被运算 (即不采用短路规则)用不用短路规则，副作用不同例如, (birthday == true) | (++age &gt;= 65) 条件运算符条件运算符“? :”的表达式形式为“op1 ? op2 : op3”op1:布尔表达式例如: int k= ( (i&gt;=0) ? 1 : -1); 控制结构 顺序结构Java最基本的结构 选择结构三种类型: if、if/else和switch 循环结构三种类型: for、while和do/while if-else语句if-else语句的格式是:if (布尔表达式) 语句1或语句块1else 语句2或语句块2 例： 1234 if (grade&gt;60)System.out.println(&quot;Passed!&quot;); elseSystem.out.println(&quot;Failed!&quot;); for循环语句格式: for (表达式1;表达式2;表达式3) 语句或语句块 while循环语句while循环语句格式为： while (布尔表达式) 语句或语句块 当条件(布尔表达式)为true ，则不断地执行语句或语句块 “while” 循环中止条件是布尔表达式变为false 如果布尔表达式一开始就为false，则不执行循环体 结构化程序设计1,从“最简单”的基本结构出发2，任何一个矩形都能分解成两个顺行的矩形3，任何一个矩形都可以用前的控制结构替换4,2,3，可以不断地进行下去，直接完成程序设计 学习目的 主要讨论: 标识符数据类型运算符与表达式流程控制语句 主要目的是对程序中所使用的各类符号及其使用规则有一个基本认识,建立程序设计的基本概念,初步掌握简单程序设计方法. 基本要求 掌握标识符的命名规则和常用关键字,运算符及注释符.重点掌握常量,变量,数据类型的基本概念.重点掌握各类运算符在复合表达式中的运算优先顺序.掌握Java基本语法，能够编写简单的Java application和Java Applet程序. Java语言基础2.1 一个简单的例子2.2 标识符2.3 数据类型2.4 运算符与表达式2.5 流程控制语句 实训二 结构化程序设计习题二 一个简单的例子Sun公司在开发Java语言时是以C/C++语言为基础进行的，因此，Java语言的基本语法，如变量声明、方法调用中的参数传递、运算符、流程控制结构等，都与C/C++语言非常相似。 下面首先给出一个简单的程序，通过该程序读者可以对Java语言的基本语法有一个大致的了解。 【程序2.1】 Fibonacci数列。 12345678910111213class Fibonacci &#123; //输出Fibonacci数列中值小于50的值 public static void main(String []args) &#123; int lo = 1; int hi = 1; System.out.println(lo); while(hi &lt; 50)&#123; System.out.println(hi); hi = lo + hi; lo = hi - lo; &#125; &#125;&#125; 上面的程序输出Fibonacci数列，从中可以看出Java语言与C语言的相似性，不过Java在继承C语言语法时很多方面都有所改进，学习时应特别注意。 标 识 符Java字符集 与C语言或其他传统的高级程序设计语言不同，Java语言的基本符号采用Unicode字符集，而不是ASCII字符集，以方便支持多语种。 在Unicode字符集中，字母不仅仅限于英语，还包括其他语言的字符，包括汉字。Unicode字符集采用16位编码，一个字符在内存中占用两个字节。虽然现有的多数程序使用ASCII编码，但在运行前都被转换为Unicode字符。 标识符构成规则标识符是变量、类、方法、标号及其他各种用户自定义对象的命名。Java语言的标识符可以由字母、数字、下划线或$符号组成，以字母、下划线或$符开头，区分大小写，对标识符的长度没有特别限定。 Unicode字符集中的字母包括英文字母以及序号大于十六进制数0xC0的字符，因此可以使用汉字作标识符。以下都是合法的Java语言标识符： 1变量1，$Str，_var1，myVar 关键字与大多数程序设计语言一样，Java语言也有一些系统保留的标识符，称为关键字或保留字。 目前Java语言用到的关键字有： abstract、boolean、break、byte、byvalue、case、catch、char、class、continue、default、do、double、else、extends、final、finally、float、for、if、implements、import、inner、instanceof、int、interface、long、native、new、null、package、private、protected、public、return、short、static、super、switch、synchronized、this、throw、throws、transient、try、var、volatile、void、while。 cast、const、future、generic、goto、operator、outer、rest等也被列为系统保留字，但目前的Java规范并未用到。另外，在Visual J++中true和false也作为关键字使用。 数 据 类 型Java语言的数据类型与C语言有相似之处，但对C语言的数据类型作了一定的简化。C中的一些数据类型在Java语言中不再支持，如结构体、枚举类型、共用体、指针等，但增加了布尔类型。Java语言在对数据的类型检查方面总的来说要比C语言更严格。 Java语言支持的数据类型包括简单数据类型，如整型、实型、字符型、布尔型，以及复合数据类型类与接口。下面首先介绍简单数据类型。 整型Java语言的整型分为byte、short、int、long四种 与C语言相似，Java语言中的数据也分为常量和变量，常量在程序执行的过程中其值不可改变，而变量的值可以改变。 Java语言中的常量分为两种：一种称为直接量，其字面代表了该常量的值； 另一种用标识符表示，定义方法与变量的定义类似，只是需要用关键字final修饰，表示该数据在执行过程中不可修改，Java语言编译器会作相应的检查，如果发现程序中有改变该常量值的语句，编译器将指出错误。 Java语言中的整型直接量可以用十进制、八进制和十六进制表示。 十进制表示方法最为常见，如：123、-780。 在书写十进制常量时，注意不能以0为打头字符，因为Java语言中以0开始的整型常量被当作八进制处理，例如：017、-0234，都是八进制表示的整型常量。 八进制数据使用的数字字符只能是0～7，不能出现8、9。 十六进制整型常量以0x或0X开始，例如：0x123、0X1AB，十六进制数据使用的数字字符是0～9和A～F(或a~f)。 整型常量中，byte、short、int表示方法相同，而长整型(long)常量必须在数后加字母L或l，表示该数是长整型，例如：0L、306l。整型变量的定义与C语言相似 ，例如： byte b; //指定变量b为byte型short s; //指定变量s为short型int i; //指定变量i为int型long l; //指定变量l为long型 Java语言中的变量与C/C++程序一样，也必须先定义后才能使用，同样，它们也有各自的作用域。 Java语言中的变量定义有两种形式： 一种是类的成员； 另一种是局部变量，在方法或复合语句(由大括号括起的若干语句)中定义，分别在所定义的方法或复合语句中起作用，与C语言的局部变量类似。 变量定义的时候可以赋初值，例如： 12int k=20;long x=200L,y=150L; 用标识符定义常量的方法与变量的定义方法相似，用标识符定义常量时必须赋初值。例如： final int IntVar=200; 有些教材将用这种方法定义的常量称为final变量或只读变量。 实型Java语言的实型数据分为单精度实数(float)和双精度实数(double)两种，分别为32位和64位IEEE754-1985标准浮点数。 与C语言相同，Java的实型常量有两种表示形式： (1) 十进制数形式。 十进制数形式由数字和小数点组成，且必须有小数点，如0.123、.123、123.、123.0。 (2) 科学计数法形式。 如：123e3或123E3，其中e或E之前必须有数字，且e或E后面的指数必须为整数。 实型常量缺省为double型，如果希望声明某个实型常量为float型，则要在数字后加f或F，如12.3F，它在机器中占4个字节，精度较低。 实型变量的定义与C语言类似，如： 12float f=2.3f; //指定变量f为float型double d=2.3; //指定变量d为double型 Java语言对数据类型的检查比C语言更严格，不允许用双精度的常量初始化单精度变量，因此下面的变量定义语句是错误的： float f=1.23; 字符型Java语言使用Unicode字符集，因此其字符型数据在内存中占用2个字节，共16位，其范围为0～65 535。 字符常量是用单引号括起来的一个字符，如’a’、’A’。另外，与C语言相同，Java语言也使用转义字符，以反斜杠()开头，其后的字符转变为另外的含义。 字符型的类型标识符为char，下面是字符型变量的定义的例子： char c=’a’；//指定变量c为char型，且赋初值为’a’与C语言不同，Java语言不允许将字符型变量用作整型，因为Java不提供无符号整数类型，但可与整型进行混合运算。例如：int i=’A’;是非法的，而下面的语句是合法的：int i=3;i=i+’0’; 与C相同，Java语言用双引号(“)括起一串字符表示字符串常量，如”This is a string.\n”。但不同的是，Java中的字符串常量是作为字符串类String的一个对象来处理的，而不是一个字符数组。 布尔型与C语言不同，Java语言引入了布尔类型用以表示关系运算和逻辑运算的结果，布尔型数据只有两个值true和false。 布尔型变量用关键字boolean定义，例如： boolean b=true；//定义b为布尔型变量，且初值为true布尔型数据不可作为整型数据使用，不同于C语言中的0和非0。Java语言中应该使用布尔型数据的地方，不可使用其他类型的数据。 运算符与表达式概述 运算符是指明对操作数所进行的运算的符号。按操作数的数目来分，可以有单目运算符、双目运算符和三目运算符，它们分别对应于一个、两个和三个操作数。Java语言中的运算符按照功能来分有下面几类：123456789(1) 算术运算符：+，-，*，/，%，++，- -；(2) 关系运算符：＞，＜，＞=，＜=，= =，!= ；(3) 布尔逻辑运算符：!，&amp;&amp;，||，&amp;，|；(4) 位运算符：＞＞，＜＜，＞＞＞，&amp;，|，^，～；(5) 赋值运算符：=，复合赋值运算符如+=；(6) 条件运算符：?: ；(7) 其他运算符：包括分量运算符，下标运算符[]，实例运算符instanceof，内存分配运算符new，强制类型转换运算符(类型)，方法调用运算符()等。Java程序通过各种不同的运算符与操作数连接起来构成的表达式完成各种运算。 算术运算符算术运算符是最基本的运算符，Java语言的算术运算符与C语言的算术运算符非常相似。 Java语言中算术运算符的优先级和结合性与C语言相同。 Java语言对运算符+的功能进行了扩展，使它能够进行字符串的连接，如“abc”+“de”,得到串“abcde”。 另外，与C语言不同，取模运算符%操作数可以为浮点数，如37.2%10=7.2。 其他需要注意的几点与C语言相同：(1) 除法运算。当两个运算对象均为整型数据时，作整除运算。 (2) i++与++i的区别。 i++在使用i之后，使i的值加1，因此执行完i++后，整个表达式的值为原来i的值，而i的值加1。 ++i在使用i之前，使i的值加1，因此执行完++i后，整个表达式和i的值均为i原来的值加1。 i–与–i的运算方式与++运算符相似。++、–运算符只能对变量进行操作。 【程序2.2】 算术运算符的使用。 1234567891011121314151617181920212223242526public class ArithmaticOp&#123;public static void main(String args[])&#123; int a=5+4; //a=9 int b=a*2; //b=18 int c=b/4; //c=4 int d=b-c; //d=14 int e=-d; //e=-14 int f=e%4; //f=-2 double g=18.4; double h=g%4; //h=2.4 int i=3; int j=i++; //i=4,j=3 int k=++i; //i=5,k=5 System.out.println(&quot;a=&quot;+a); System.out.println(&quot;b=&quot;+b); System.out.println(&quot;c=&quot;+c); System.out.println(&quot;d=&quot;+d); System.out.println(&quot;e=&quot;+e); System.out.println(&quot;f=&quot;+f); System.out.println(&quot;g=&quot;+g); System.out.println(&quot;h=&quot;+h); System.out.println(&quot;i=&quot;+i); System.out.println(&quot;j=&quot;+j); System.out.println(&quot;k=&quot;+k);&#125;&#125; 赋值运算符与C语言一样，Java语言将赋值作为一种运算符处理。赋值运算的功能是将一个数据或表达式的值赋给一个变量。赋值运算符是双目运算符，左边的操作数必须是变量。 Java语言的赋值运算符可以分为两种：基本赋值运算符和复合赋值运算符。 所有赋值运算符的优先级都相同，与其他运算符相比，赋值运算符的优先级最低。 基本赋值运算符是最简单的赋值运算符，格式为 变量名=表达式 先计算表达式，再将结果赋给变量，整个赋值表达式的值为赋值后变量的值。使用赋值运算符时，应尽量使变量和表达式的数据类型一致，否则，先将表达式的值转换为变量的数据类型再赋值。 复合赋值运算符是在基本运算符的基础上加上另一个运算符，例如： 1x*=a-b 这个表达式与下面的表达式等价： 1x=x*(a-b) 先计算复合赋值运算符右边的表达式，然后在变量与该表达式的值进行指定的运算后将结果赋给变量。 常见的双目算术运算符如1+、-、*、/、% 以及下面将介绍的位运算符1&gt;&gt;、&lt;&lt;、&amp;、|、^ 等都可以构成复合赋值运算符。 关系运算符关系运算符用来比较两个值，Java语言关系运算的结果为布尔类型的值true或false，而不是C / C++中的1或0。 逻辑运算符Java语言的逻辑运算符只能对布尔型的数据进行运算 类型转换在编程时，经常会出现不同类型的数据进行混合运算的情况，运算前应将不同类型的数据转换为相同类型。 类型转换有两种方法：自动类型转换和强制类型转换。 整型、实型、字符型等数据混合运算时，Java语言编译器可以对它们进行自动类型转换。转换规则类似于C语言，从低级数据类型转换为高级数据类型： (1) (byte或short) op int→int；(2) (byte或short或int) op long→long；(3) (byte或short或int或long) op float→float；(4) (byte或short或int或long或float) op double→double；(5) char op int→int。 这里箭头左边表示参与运算的数据类型，op为运算符(如加、减、乘、除等)，右边表示转换后进行运算的数据类型。 流程控制语句(1) 布尔型数据的使用；(2) Java语言不再使用goto语句；(3) 带标号的break和continue。 分支语句分支语句提供了一种控制机制，使得程序可以根据指定的条件选择执行部分语句或跳过某些语句不执行。 Java语言提供了两种分支语句：if-else、switch。 条件语句if-elseif-else语句根据判定条件的真假来执行两种操作中的一种，格式为： 12345if(布尔表达式)语句1[ else语句2]其中，else子句是任选的，可以不出现。 【程序2.5】 判断某一年是否为闰年。闰年的条件是符合下面二者之一：①能被4整除，但不能被100整除；②能被4整除，又能被100整除。 123456789101112131415161718public class LeapYear&#123; public static void main(String args[])&#123; int year=2003; boolean leap; if(year%4!=0) leap=false; else if(year%100!=0)leap=true; else if(year%400!=0) leap=false; else leap=true; if(leap) System.out.println(year+&quot; is a leap year.&quot;); else System.out.println(year+&quot;is not a leap year.&quot;); &#125; &#125; 多分支语句switchswitch语句根据指定表达式的值来执行多个操作中的一个，格式如下： 123456switch (表达式)&#123;case 值1：语句段1；case 值2：语句段2 case 值N：语句段N[default：语句段N+1]&#125; 循环语句循环语句的作用是反复执行一段代码，直到满足终止循环的条件为止。Java中提供的循环语句有while语句、do-while语句和for语句. 1．while语句while语句实现“当型”循环，格式为while (布尔表达式)循环体 do-while语句do-while语句实现“直到型”循环，格式为： do循环体while (布尔表达式); do-while语句首先执行循环体，然后计算布尔表达式。如果布尔表达式的值为true，则重复上述过程，直到布尔表达式的结果为false。与while语句不同的是，do-while语句的循环体至少执行一次。 for语句for语句也用来实现“当型”循环，它的一般格式为： for (初始化表达式;布尔表达式;增量表达式)循环体 for语句首先计算初始化表达式，然后判断布尔表达式的值是否为true，如果为true，则执行循环体中的语句，最后计算增量表达式。完成一次循环后，重新判断终止条件。 结构化程序设计一、实训目的1．理解定义变量的作用并掌握其方法。2．掌握各种基本数据类型及其运算。3．掌握表达式的使用和各种运算符的优先级控制。4．掌握结构化程序设计的分支结构。5．学习用if-else语句实现单分支。6．学习用if-else语句和switch语句实现多分支。7．掌握结构化程序设计的循环结构。8．学习使用while语句、do-while语句和for语句实现循环。9．学习控制循环终止条件，包括循环的正常退出和使用continue语句和break语句。 二、实训内容1．使用if-else语句判断并输出今天是星期几。提示：用Date类获取有关的信息，首先引入Date类：import java.Util.Date;然后创建一个Date类对象，并获取信息：Date day=new Date();int today = day.getDay()；//0表示为星期天，1表示为星期一……2．使用switch语句完成上面的功能。3．编写Java应用程序，找出所有的水仙花数并输出。水仙花数是三位数，它的各位数字的立方和等于这个三位数本身，例如371＝33+73+13，371就是一个水仙花数，请分别用while循环和for循环实现。4．编写Java应用程序，找出所有符合下列条件的a、b、c：a、b、c为三个200～300之间的整数，其和为452。 JAVA语言基本语法标识符、关键字和数据类型 温故Java程序开发过程编写Java源文件（可用文本编辑工具），文件名与类名相同编译生成字节码文件（.class）(javac.exe命令)解释执行字节码文件中的类（java.exe命令） 环境变量的设置（path、classpath） Win2000 命令窗口 Java程序的种类 Application应用程序 Applet小程序 要点集成开发环境:Jcreater一个Applet小程序标识符关键字数据类型 Jcreater pro一个类似于TC的Java集成开发环境可以方便地编写java源文件可以方便地编译、运行Java程序Jcreater不是免费的软件安装时，可以先安装SDK，然后再安装Jcreater使用时注意：创建文件时，注意只需创建java文件，不用创建java项目，注意文件的命名和文件的保存路径。 Applet小程序的开发过程编写源文件（Applet源程序）编译生成字节码文件（.class）编写html文件，将字节码文件嵌入其中。1&lt;applet code=“Boy.class” height=&quot;120&quot; width=&quot;300&quot;&gt;&lt;/applet&gt; 用浏览器打开html文件，即可自动调用Applet小程序并解释执行。或是appletviewer调用html文件 Java的Applet小程序一个Java Applet程序也由若干个类组成，最简单的为一个类。一个Applet小程序不需要main方法，但是必须有一个主类是Applet的子类。如果要在窗口中绘制文字、图像，paint()方法是必要的。 123456789101112import java.applet.*;import java.awt.*;public class BoyApplet extends Applet//从Applet类继承而来&#123; public void paint(Graphics g)//paint方法用来绘制屏幕 &#123; g.setColor(Color.red);//设置文字颜色为红色 g.drawString(&quot;我一边喝着咖啡，一边学Java呢&quot;,5,30); g.setColor(Color.blue);//设置文字颜色为兰色 g.drawString(&quot;我学得很认真！&quot;,10,50); &#125;&#125; 标识符分隔符：注释、空白、普通注释符（软件编码规范中说：“可读性第一，效率第二”，注释一般占程序代码的20%-50%） 123// ：单行注释/* */ ：多行注释/** */：文档注释，可被解释成程序的正式文档 空白：空格、回车、制表 标识符java中的包、类、方法、参数、变量等的名字 由大小写字母、数字、下划线、美元$组成，但不能以数字开头。不能是Java中的关键字。 这里的字母也包括世界上任何国家的“字母表”中的字符，比如汉字、日文等。不建议使用。 1例：Inner$1、123、java hello、user_name、user-name 关键字、标识符的命名习惯关键字全部小写具有专门的意义和用途，不能当作一般的标识符使用，这些标识符称为保留字(reserved word)（P11） 标识符命名习惯类、接口名：每个词的首字母都要大写方法、变量名：首字母要小写，其它单词首字母要大写常量：字母全部大写，单词之间用下划线分隔观察一个java程序，识别哪个标识符是类或接口名，哪个标识符是变量或方法名。 Java语言的数据类型数据类型概述 基本数据类型 数值 整数：byte、short、int、long：8，16，32，64 浮点：float、double：32，64 字符：char：16 逻辑：boolean：1 引用数据类型：类、数组、接口 数据类型—常量数据及变量声明常量数据 整型： 23(十进制)、 0X63(十六进制) 、063(八进制) 长整型：25L 浮点常量：小数常量默认为是double型的，float类型后一定要加f(F)，34d、34.0是double类型常量，34f、34.0f是float类型常量。 逻辑常量：true、false 字符常量：’a’ ‘8’ ‘\n’ ‘我’ 都是字符常量（16进制表示的字符）占用两个字节，采用国际编码标准—Unicode码。 字符串常量：”a” “dkdkdk\n” 。 null常量：表示对象的引用为空 变量声明 类型 变量名1[,变量名2][=变量初始值]； 基本数据类型的转换自动类型转换，表达式类型的自动提升整形、实型、字符型数据可以进行混合运算。运算时，不同类型的数据先转化为同一类型，字符型会转换为数值型，然后进行运算。 表达式的类型为存储长度最大，精度最高的数据类型。 当把级别低的表达式的值赋给级别高的变量时，系统会自动完成数据类型的转换。而级别高的表达式的值不能直接赋给级别低的变量。 1例：float f; f=34*12;f=f+23.5; 强制类型转换一般情况下，当精度高的类型向精度低的类型转换时，要明确指明，如：12double k=6;float b=(float)k; JSP技术Java Server Pages基于Java Servlet以及整个Java体系的Web开发技术，利用这一技术可以创建安全、跨平台的动态网站。 Java基本数据类型训练目的 本次技能训练的目的是让学生掌握开发Applet小程序的过程。熟悉Java的数据类型、运算符和表达式，能熟练运用它们编写程序解决一定的问题。 训练内容及要求 1、编写、编译、运行一个java applet小程序，使用绿色字显示“你好，Java！我是XXX！”。2、写出System.out.print()和System.out.println()的区别。3、写出在实训过程遇到的问题和解决的办法，有哪些收获。 指导 （1）启动Jcreater，创建源文件（注意文件名与类名一致）保存到自己的工作目录中。（2）使用训练Jcreater的菜单命令编译源文件。生成字节码文件。（3）使用Jcreater创建一个html文件，并保存至自己的工作目录中，其内容如下：1&lt;Applet code=”BoyApplet.class” width=”300” height=”300”&gt;&lt;/Applet&gt; 其中BoyApplet.class要用你自己生成的字节码文件名代替。（4）用浏览器打开html文件，观察运行效果。 面向对象程序设计了解类和对象的基本概念来源：https://baike.baidu.com/item/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/1394902?fr=aladdin 类和对象（class）是两种以计算机为载体的计算机语言的合称。对象是对客观事物的抽象，类是对对象的抽象。类是一种抽象的数据类型。 它们的关系是，对象是类的实例，类是对象的模板。对象是通过new className产生的，用来调用类的方法;类的构造方法 。 声明定义类，对象的定义 类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。 类是一种对数据的分装，我们可以理解为Java中的代码。 对象是具有类类型的变量。 类和对象是面向对象编程技术中的最基本的概念。 类类型的声明123456789class 类名&#123; public： 公用的数据和成员函数 protected： 保护的数据和成员函数 private： 私有的数据和成员函数&#125; 定义对象方法1.先声明类类型，然后再定义对象举例：Student stud1,stud2; //Student是已经声明的类类型2.在声明类类型的同时定义对象 12345678910111213141516class Student//声明类类型&#123; public://先声明公用部分 void display() &#123; cout&lt;&lt;″num:″&lt;&lt;num&lt;&lt;endl; cout&lt;&lt;″name:″&lt;&lt;name&lt;&lt;endl; cout&lt;&lt;″sex:″&lt;&lt;sex&lt;&lt;endl; &#125; private://后声明私有部分 int num; char name[20]; char sex;&#125;stud1，stud2;//定义了两个Student类的对象//在定义Student类的同时，定义了两个Student类的对象。 3.不出现类名，直接定义对象 12345678 class//无类名&#123; private://声明以下部分为私有的 ┆ public://声明以下部分为公用的 ┆&#125;stud1，stud2;//定义了两个无类名的类对象 掌握类的定义方法掌握对象的初始化掌握类的成员函数的定义 回顾—类的定义123456[类的修饰字] class 类名称 [extends 父类名称][implements 接口名称列表]&#123; 变量定义及初始化； 方法定义及方法体；&#125;类体，其中定义了该类中所有的变量和该类所支持的方法，称为成员变量和成员方法。 回顾—类的成员函数定义语法规范1234[方法修饰字] 返回类型 方法名称(参数1,参数2,…) [throws exceptionList]&#123; …(statements;) //方法体：方法的内容&#125; [public | protected | private ] [static] [final | abstract] [native] [synchronized] 返回类型可以是任意的Java数据类型，当一个方法不需要返回值时，返回类型为void。 参数的类型可以是简单数据类型，也可以是引用数据类型（数组、类或接口），参数传递方式是值传递。 方法体是对方法的实现。它包括局部变量的声明以及所有合法的Java指令。局部变量的作用域只在该方法内部。 回顾—对象的初始化（1）对象的生成 通过new操作符生成一个对象；例如： 12Car demoCar;demoCar = new Car(); （2）对象的构造过程 为对象开辟空间，并对对象的成员变量进行缺省的初始化； 对成员变量进行指定的初始化； 调用构造方法。 教学内容和目标掌握类的封装性 掌握类的继承性 教学重难点重点 不同访问修饰符的应用 Java中类继承的定义 难点 类的继承特性 包“包”是由一组类和接口所组成的具有一定功能的集合 简单地说，将一组功能相关的类和接口打包起来形成的整体，就是包 两个类如果名字相同，只要所属的包不同，Java就会认为它们是不同的类 创建包在定义类或接口的源文件开始加入“package”关键字和包名，就将类或接口放到包里了 如果两个java源文件的开头都有相同的包名，则意味着这两个源文件中的所有类和接口都属于同一个包 访问包中的类访问公开类的方法(1) 用类的全名（包名+类名）访问；(2) 导入包中的某个类；(3) 导入包中的所有类。如果某个类只访问一次，那么可以直接使用类的全名，形式是“包名.类名” 12345用“import”关键字导入一个类： import PackageName.ClassName;一次性导入所有类的方法： import PackageName.*; 管理Java的包Java系统建议的文件存储方式就是按照包名将源文件和二进制代码文件分级存放将源文件放到与包名相同的路径下，包名对应子目录名 使用Java的包设定Rectangle.java放在“graphics”子目录下编译源文件的命令如下：javac graphics\Rectangle.java 执行程序时，用小圆点“.”分隔包名和类：java graphics.Rectangle CLASSPATH参数如果你的Java包都放在一个固定的目录下，轻易不会改变它，那么你可以在操作系统中设置“CLASSPATH”环境变量 编译和运行Java程序时，不需要指定包路径参数，系统会自动从环境变量中读取 封装封装把对象的所有组成部分组合在一起 封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 封装性封装性与访问级控制类的一个优势在于类可以保护它的成员变量和成员函数不会被其它对象随意访问到在Java程序里，可以为成员变量和函数设定四级访问级： 1234privateprotectedpublicdefault（缺省） 访问控制级别private（私有级） private是最严格的访问控制级 私有变量只能在它所在的类内部被访问到 它用于定义只在类内部使用的成员变量 成员变量，如果从外界随意改变它的值可能会造成不稳定的情况 成员函数，如果从外界调用，可能会危害到对象的状态或程序的运行 protected（保护级） 被定为保护级的成员可以被它所属的类、所属类的子类，以及处于同一个包里的其它类访问到 如果一个成员变量或成员函数可以被它的子类或相关的类访问，而不能被无关类访问的话，就可以用保护级 保护级就像家庭秘密，可以让家庭成员知道，也不介意让几个亲密朋友知道，但你不想让任何外人知道 public（公开级） 公开级是限制最少的访问级，任何类，不管它在哪个包里，都能够访问公开级的成员 公开级使用最方便，实际使用得也最多 需要注意的是：对于成员变量或成员函数，只有当你确认外界的类访问甚至修改它不会造成不希望的后果时，才使用公开级 公开级类似于公开张贴的信息，其中没有个人或家庭隐私，你不介意任何人知道 default（缺省级） 包访问级是成员的缺省访问级 如果没有定义访问级，那么它就是包访问级 权限：可以被属于同一个包的其它类所访问，但不能被其它包的类所访问 如果这个类的子类在其它包，则子类不能继承和访问父类中包访问级的成员 这一访问级假设在同一个包里的其它类都是可信任的朋友，但子类反而不能信任 类成员封装性总结public 同一个类，同一个包，子类，所有类protected 同一个类，同一个包，子类default 同一个类，同一个包private 同一个类 继承继承性是面向对象程序设计语言的另一基本特征，通过继承可以实现代码的复用。继承而得到的类为子类，被继承的类为父类，父类包括所有直接或间接被继承的类。Java中不支持多重继承。通过在类的声明中加入extends子句来创建一个类的子类： 1234class SubClass extends SuperClass&#123;……&#125; 子类可以继承父类中访问权限设定为public、 protected、 default的成员变量和方法，但是不能继承访问权限为private的成员变量和方法。 一个类可以从另一个类中继承它的成员变量和函数，前者称为子类，后者称为父类。类的这种特点称为继承性 类的继承通过extends关键字来说明，extends关键字跟在类名称后面，形式如下： class SubClass extends FatherClass { … }其中SubClass是子类名，FatherClass是父类名 子类是作为另一个类的扩充或修正而定义的一个类。 继承的特点类的继承性的特点 在Java中，一个类只能有一个父类 Java只支持单继承，而不支持多重继承 单继承的类子代相承，会形成一棵继承树，结构较为清晰 多重继承会形成一张复杂的继承网，结构复杂，容易出错 如果需要多重继承，Java提供了一种接口技术，可以部分地实现多重继承的功能 在Java中定义的所有类都直接或间接地是Object类的子类。以Object类为根，所有Java类形成一棵类继承树 类的继承性的特点子类可以继承的部分：(1) 父类中公开级的成员；(2) 父类中保护级的成员；(3) 如果子类和父类在同一个包里，则子类继承父类中缺省的包访问级的成员； 子类不能继承的部分：(1) 父类中私有级的成员；(2) 如果不在同一个包里，则缺省级的成员；(3) 同名的成员函数或成员变量； 构造函数的继承特点父类相当于一个硬球，子类则是在球外的包装构造对象时显然应当先构造最内部的硬球，也就是最顶端的父类之后再从里往外一层层地构造外包装，直到最后整个对象都构造起来如果父类的构造函数有参数，那么就需要用super关键字，它指代父类 何时选择继承?一个很好的经验：“B是一个A吗?”如果是则让B做A的子类. 类与对象3.1 面向对象的基本思想和基本概念3.2 案例3.3 类的声明与对象的创建3.4 继承3.5 包的使用3.6 编程实例实训三 面向对象程序设计习题三 面向对象的基本思想和基本概念大部分传统的高级程序设计语言(如C语言)都是过程化的语言，在软件开发的过程中采用自顶向下逐步细化的方法将整个程序描述为一个过程。对于小型的系统，这种方法是可行的，但是当系统规模很大，复杂度很高时，用过程化方法描述变得十分困难，面向对象的软件开发方法可以很好地解决这个问题。 目前，面向对象的方法在软件开发工作中得到了广泛的应用，越来越多的软件开发工具开始支持面向对象的开发方法。Java语言就是一种面向对象的程序设计语言，要充分利用Java语言的特性首先应该理解面向对象的基本思想。 面向对象的基本思想面向对象的基本思想认为系统是由若干个对象构成的，每个对象都有各自的内部状态和运动规律，不同对象之间通过消息传送相互作用和联系。 采用对象的观点看待所要解决的问题，并将其抽象为系统是极其自然与简单的，因为它符合人类的思维习惯，使得应用系统更容易理解。同时，由于应用系统是由相互独立的对象构成的，使得系统的修改可以局部化，因此系统更易于维护。 例如，对于一个企业的管理信息系统，将整个系统描述成一个过程是难以想像的，但可以分别描述各个部门的特性及工作流程，然后描述部门之间的联系。这里各个部门就是组成企业的对象，当然，在描述每个部门特性时可以采用同样的方法。 对象与类对象是面向对象方法中的一个重要概念。 所谓对象，是指客观世界中事物在计算机领域中的抽象，用一组数据和施加于该组数据上的一组操作(行为)来描述。 对象的描述通常由三个部分组成： (1) 私有的数据结构。用于描述对象的内部状态。(2) 处理，称为操作或方法。它是施加于数据结构之上的。(3) 接口。这是对象可被共享的部分，消息通过接口调用相应的操作。接口规定哪些操作是允许的，它不提供操作是如何实现的信息。 实际上，采用面向对象方法进行系统分析与设计时要描述的并不是一个个具体的对象。对于一个具体的系统而言，可能存在很多具有相同特征的对象，而且通常系统中对象的数目是不确定的。例如，对于一个学籍管理系统，存在许多学生对象，它们具有相同的结构特征和行为特征，只是表示内部状态的数据值不同。为了描述这种相同结构特征和行为特征的对象，面向对象方法引入了类的概念。这一点与人们在认识客观世界的事物时所采取的分类思想相同。人们在认识事物时总是将具有相同特征的事物归为一类，属于某类的一个事物具有该类事物的共同特征。 类是对一组具有相同特征的对象的抽象描述，所有这些对象都是这个类的实例。对于学籍管理系统，学生是一个类，而一个具体的学生则是学生类的一个实例。一个类的不同实例具有相同的操作或行为的集合和相同的信息结构或属性的定义，但属性值可以不同；不同的实例具有不同的对象标识。对于学生类中的每一个对象，描述它们所使用的数据结构相同，但是值不同。在程序设计语言中，类是一种数据类型，而对象是该类型的变量，变量名即是某个具体对象的标识。 因此，一个类的定义至少包含以下两个方面的描述：(1) 该类所有实例的属性或结构的定义。(2) 该类所有实例的操作(或行为)的定义。 类是构成Java语言程序的基本单位，一个完整的Java程序是由若干个类构成的，每个类由若干数据和方法构成，一个类的定义包含属性(数据)和方法(行为)两部分内容。 继承性人们在对客观世界的事物进行描述时，经常采取分类的方法。类是有层次的，即某个大类的事物可能分为若干小类，而这些小类可能又分为若干个更小的类。 面向对象思想采纳了事物分类的层次思想，在描述类的时候，某些类之间具有结构和行为的共性。例如，描述教师与学生时均需描述姓名、年龄、身高、体重等属性，将这些共性抽取出来，形成一个单独的类——人，用于描述教师类和学生类的共性。类人的结构特征和行为特征可以被多个相关的类共享，教师类和学生类继承了类人的结构和行为特征。 Java语言支持类的继承，可以从一个类中派生出一个新的类，原来的类称为超类或父类，新类称为超类的子类或派生类。子类的对象具有超类对象的特征，同时又有其自身特有的特征。子类又可以派生出新的子类，子类的子类也称为派生类。 利用类之间的继承关系，可以简化类的描述，提高软件代码的可重用性。在设计一个新类时，不必从头设计编写全部的代码，可以通过从已有的具有类似特性的类中派生出一个类，继承原有类中的部分特性，再加上所需的新特性。 另外，人们在对客观世界的事物进行分类时，一个事物可能属于多个类，具有多个类的特性。例如，一个黑人学生，他既属于学生类，又属于黑人类。这种情形在面向对象方法中称为多继承，即一个类同时从多个类中派生出来，此时类的层次结构是网状的。 Java语言为了不使语法过于复杂，不支持多继承，只允许子类有一个超类，称为单继承。不过，Java语言提供了接口机制，可以在一定程度上模拟多继承。 多态性多态性是面向对象系统的又一重要特性。所谓多态，即一个名词可具有多种语义，如一个方法名有多种功能，或者相同的接口有多种实现方法。 在Java语言中，多态性通过方法的重载、覆盖和接口来实现。 方法的重载是指多个方法具有相同的名称，但各个方法的参数表不同，即参数的类型和参数的数量不同。 覆盖是指在类的派生过程中，子类与超类的方法不仅名称相同，参数也完全相同，但它们的功能不同，这时子类中的方法覆盖了超类中同名的方法。 接口实际上是一种特殊的类，只给出方法的名称、参数和返回值的类型，方法的具体实现在实现该接口的类中给出。 多态性使得方法的调用更加容易、灵活和方便。 封装封装是一种信息隐藏技术，对象内部对用户是隐藏的，不可直接访问；用户只能见到对象封装界面上的信息，通过对象的外部接口访问对象。 用户向对象发送消息后，对象根据收到的消息调用内部方法作出响应。 封装的目的在于将对象的使用者和对象的设计者分开，使用者无需知道对象内部实现的细节，只需知道对象接收的消息即可。 Java语言通过类来实现封装，类中定义的属性和方法分为私有的和公有的，私有属性和方法不能在对象的外部访问，只能由类内的方法访问。 而在对象的外部，只能访问对象的公有属性和方法，只需要知道公有属性的数据类型和名字以及公有方法的原型，至于这些方法是如何实现的对象外部并不需要知道。 这就像人们在使用电视机时只需要通过遥控器来操作即可，至于电视机内部细节用户则无需知道，这里遥控器上的按钮实际上就是电视机的外部接口。 对象的封装特性可以提高模块之间的独立性，使得系统易于调试和维护。 类的声明与对象的创建类声明的基本语法 1．类的声明 Java语言类声明的完整语法很复杂，下面先介绍最简单的形式： 123class 类名&#123; 类体 &#125; 类中定义的变量和方法都是类的成员，Java语言对类成员的访问有一定的权限限制。在定义属性和方法时，可以指定访问权限，Java中访问权限有private、protected和public。 变量成员的定义变量成员的定义形式类似于C语言中的变量定义，ComplexRoot类的变量成员a、b和disc。 变量成员定义的一般形式为： 1[final] [private|protected|public] 类型 属性名[=初值]; final为可选项，用final修饰的成员变量为常量。在程序中不能改变常量的值，常量必须在定义时初始化。 成员变量初始化的方法与C语言相似，例如： 123class Point&#123; int x=0,y=0;&#125; 成员变量的类型可以是Java语言中的任意数据类型，包括简单类型、数组、类和接口。在类中，成员变量名应该是唯一的。 方法成员的定义方法成员的定义形式与C语言的函数定义类似，基本形式为： 1234[private|protected|public] 返回值类型 方法名([形式参数表]) &#123; 方法体 &#125; 12345 int func(int a，int b) &#123; if(a&gt;b) return a-b;&#125; 该方法的定义是错误的，当a&lt;=b时该方法在执行时没有确切的返回值。 12(1) return 表达式; 或 return(表达式);(2) return;。 第一种形式用于有返回值的情况，第二种形式用于无返回值的情况。对于第一种情况，return后的表达式类型应与声明的返回值类型一致，否则会产生编译错误。 Java语言中的方法可以有参数也可以没有参数，参数类型可以是简单数据类型，如整型、实型、字符型、布尔型，也可以是复合类型，如数组、自定义类的对象。 方法被调用时，必须给定实际参数，实际参数的类型应与形式参数的类型一致。对于简单类型数据，实际参数传递给形式参数时采用值传递，这一点与C语言相同；如果参数为复合类型，则传递引用，此时实参、形参为同一对象。 参数传递的方法。1234567891011121314151617181920212223242526class B&#123; private int b; int Getb()&#123;return b;&#125; void Setb(int j)&#123;b=j;&#125;&#125;public class MethodParm&#123; void Method1(int Parm1,B Parm2) &#123;Parm1=Parm1+10; Parm2.Setb(20); &#125; public static void main (String[] args) &#123; int a=10; B b=new B(); b.Setb(10); MethodParm obj=new MethodParm();obj.Method1(a,b); System.out.println(a); System.out.println(b.Getb()); &#125;&#125;运行结果为1020 this如果局部变量或形式参数与变量成员同名，在该方法体中直接使用变量名则是对局部变量或形式参数的访问。如果需要访问变量成员，可通过关键字this来访问。 123456public ComplexRoot(double a,double b,double disc)&#123; this.a=a; this.b=b; this.disc=disc; &#125; 这里，this.a访问当前对象的成员a，而赋值运算符后的a表示形式参数表中的a。 类的构造方法与对象的初始化 类定义了一类对象的特性，每一个对象都是相应类的实例。定义一个类后，就可以定义对象，然后访问对象的方法和变量成员了。 1．new运算符 Java语言使用new运算符创建对象。 Equation e=new Equation(1,2,1); 创建了一个Equation类的对象，也可以写为下面的形式：12Equation e;e=new Equation(1,2,1); 即首先声明一个Equation类对象的引用e，与定义简单数据类型变量不同，这里尚未创建Equation类的对象。变量名e只是程序中访问对象的一条途径，并不是对象本身，执行下面的语句后e、e1表示同一个对象： Equation e1=e; 这一点与C/C++语言不同，Java语言将这类数据类型称为引用类型，与C/C++中的指针相似。引用类型变量在未赋值前，其值为null。 定义对象引用后，用new运算符完成对象的创建工作，分配存储空间，并对其初始化。new运算符创建对象的一般方法为： 变量名=new 类名([构造方法实参表]); 类名可以是系统预定义的类，也可以是自定义的类。括号中是传递给构造方法的实参，用于初始化该对象。 构造方法构造方法是一种特殊的方法，创建对象时被自动调用。与一般的方法不同，它没有返回值类型的说明，方法体中也不可以用return语句带回返回值。构造方法的方法名与类名相同 OneRoot o=new OneRoot(a,b); 其中，a、b为传递给构造方法的参数。Java语言允许一个类有多个构造方法，只要这些方法的参数形式不同即可。例如：12345class Point&#123;int x,y;Point(int x,int y)&#123;this.x=x;this.y=y;&#125;Point()&#123;x=y=0;&#125;&#125; 下面的语句在创建Point类对象时分别调用不同的构造方法：12Point p1=new Point(10,10);Point p2=new Point(); 在构造方法中可以通过this关键字调用该类中其他的构造方法。例如，上面的例子可改写为下面的形式： 12345class Point&#123; int x,y; Point(int x,int y)&#123;this.x=x;this.y=y;&#125; Point()&#123;this(0,0);&#125;&#125; 第二个构造方法调用了第一个构造方法，this后面括号中内容为传递给第一个构造方法的实参。如果该构造方法中还有其他的语句，应保证将this语句放在最前面。 对象初始化Java语言提供了三种初始化对象的方法，除了上面介绍的构造方法外，还可以采用下面两种方法： (1) 定义变量成员时赋初值；(2) 在类体中的初始化程序块。 对象的初始化。//ch3_3.java 对象的初始化方法演示123456789101112131415161718192021222324class A&#123; int x=5; &#123; //初始化程序块开始 System.out.println(x); x=6; System.out.println(x); &#125; //初始化程序块结束 A(int i) &#123;x=i; System.out.println(x); &#125;&#125;public class InitDemo&#123; public static void main (String[] args) &#123; A a=new A(7); &#125;&#125; 程序运行结果为： 5 6 7 对象的清除与C/C++语言不同，Java语言中对象的清除是自动进行的，当系统内存用尽或用户在程序中调用System.gc时，Java运行系统启动垃圾收集机制，自动回收不再使用的对象。垃圾收集器可以自动判断哪些对象不再使用，例如，程序片断 12A a=new A();a=new A(); 在内存中创建了两个A类对象，执行该程序片断之后，第一次创建的A类对象在程序中无法再访问，Java垃圾收集器将自动收回该对象占用的空间。对不再使用的对象，程序中可以将对该对象的引用赋值为null，以释放资源。 Java语言允许用户为每个类定义一个特殊的方法finalize()，当垃圾收集器清除该类对象时将调用该方法，如果用户有一些特殊的清除工作可安排在finalize方法中。 但是，用户无法预测finalize()方法被调用的时间，即使调用System.gc强制启动垃圾收集，也可能因为其他任务的优先级高于垃圾收集任务，而不能立即启动。因此，一些与时间相关的代码不应加入到finalize()方法中。 对象的使用在对象创建之后，就可以使用该对象了，可以访问对象的变量成员和方法成员。访问成员的基本语法形式如下：12对象名.变量成员名对象名.方法成员名([实际参数表]) public 类内，子类，包内其他类，其他包内的类private 类内protected 类内，子类，包内其他类friendly 类内，子类，包内其他类 成员访问权限。123456789101112131415161718192021222324252627282930313233343536373839//ch3_4 成员访问权限演示 VistMember.javaclass A&#123; private int PrivateMember=0; public int PublicMember=0; int FriendMember=0; void Copy(A AObject) &#123; PrivateMember=AObject.PrivateMember;//访问同类对象的private成员 PublicMember=AObject.PublicMember;//访问同类对象的public成员 FriendMember=AObject.FriendMember;//访问同类对象的friendly成员 &#125;&#125;class B&#123; private int PrivateMember=0; public int PublicMember=0; int FriendMember=0; void CopyA(A AObject)&#123; PrivateMember=AObject.PrivateMember;//错误，访问另一个类对象的private成员 PublicMember=AObject.PublicMember;//访问另一个对象的public成员 FriendMember=AObject.FriendMember;//访问另一个对象的friendly成员 &#125; &#125;public class VistMember&#123; public static void main (String[] args) &#123; A aobj=new A(); aobj.PublicMember = 20; aobj.FriendMember = 30; A aobj2=new A(); aobj2.Copy(aobj); B bobj=new B(); bobj.CopyA(aobj); &#125;&#125; Java语言引入了一个与对象有关的运算符instanceof，用来测试一个指定的对象是否是指定类的实例，若是，则返回true；否则，返回false。例如：12if(obj1 instanceof Class1)&#123; &#125; obj1为对象名，Class1为类名，若obj1为Class1类的对象，则执行大括号中的语句。 静态成员从前面的介绍可以知道，对象创建之后，Java程序通过对象调用方法成员，在方法中使用变量成员名访问当前对象的成员。不过，在前面的例子中，有一个例外的情况，就是main方法，它是程序执行的入口点，Java程序开始执行时，并没有创建它所在类的对象。 main方法与其他方法的不同之处在于定义时前面有修饰符static，它是一个静态方法。Java语言允许用static修饰符定义静态的变量成员和方法成员。 静态变量成员静态的变量成员通常称为类变量，而非静态的变量成员称为实例变量。Java语言在创建对象时不为静态变量成员分配空间，而只为非静态变量成员分配空间。因此，静态变量成员不依赖某一个具体的对象，即使没有创建一个它所属类的对象，它也是存在的，只要该类的代码装入，则该静态变量就是存在的，就可以使用。 因为静态变量成员不依赖于具体的对象，在访问时可以不像非静态变量成员那样通过对象访问。静态变量成员的访问方法为 类名.静态变量成员名 对象计数器。1234567891011121314151617181920212223242526272829//ch3_5 静态变量的作用 NumberOfClass.javaclass MyClass&#123; static int count=0; public MyClass()&#123;count++;&#125; public void output() &#123; System.out.println(&quot;You have got &quot;+count+&quot; objects of MyClass&quot;); &#125;&#125;public class NumberOfClass&#123; public static void main (String[] args) &#123; MyClass c1,c2,c3,c4; c1=new MyClass(); c1.output(); c2=new MyClass(); c2.output(); c3=new MyClass(); c3.output(); c4=new MyClass(); c4.output();&#125;&#125;程序运行结果为：You have got 1 objects of MyClassYou have got 2 objects of MyClassYou have got 3 objects of MyClassYou have got 4 objects of MyClass 前面例子中多次使用了System.out.println方法来输出数据，其中System为Java系统预定义的类，out为System类的静态变量成员。程序中使用它向标准输出设备输出数据，无需创建System类对象即可直接使用。而在C/C++语言中类似的功能是通过系统预定义的全局变量来实现的，例如C语言中的文件指针stdout、C++的流对象cout，而Java语言不允许定义全局变量，所有变量都必须在类中定义。 静态变量的使用。12345678//ch3_6 静态变量的使用public class Class1 &#123; public static void main (String[] args) &#123; System.out.println(&quot;The maximum integer is &quot;+Integer.MAX_VALUE ); System.out.println(&quot;The minimum integer is &quot;+Integer.MIN_VALUE ); &#125;&#125; 静态方法成员静态方法与静态变量类似，不依赖于具体的对象，在调用时直接通过类名来调用： 类名.静态方法名([方法的参数表]) 正如前面所说，main方法不依赖于任何对象直接被调用，因此必须将其定义为静态方法。 静态方法在调用时不通过对象调用，因此在定义静态方法时，在方法体中不能使用this，因为对静态方法来说，不存在当前对象，同样也不能直接访问所在类的非静态变量成员及方法成员。 静态方法的使用。1234567891011121314151617181920212223242526//ch3_7 StaticMethod.javaimport java.math.*;public class StaticMethod&#123; double Radius; StaticMethod(double r) &#123; Radius=r; &#125; static double CircleArea(double r) &#123; return Math.PI*r*r; &#125; double Area() &#123; return Math.PI*Radius*Radius; &#125; public static void main (String[] args) &#123; System.out.println(&quot;Area=&quot;+CircleArea(2.0)); //直接访问静态方法成员 StaticMethod obj=new StaticMethod(2.0); System.out.println(&quot;Area=&quot;+obj.Area()); //通过对象访问非静态方法成员 &#125; &#125; 类内方法的重载Java语言允许一个类有多个同名的方法成员，这些同名的方法具有不同形式的参数，在调用时只需带入不同的实参,Java编译器就可以根据实参的类型确定调用哪一个方法成员 类内方法重载一个最常见的例子就是前面使用的System.out.println方法，在前面的程序中用它来输出整型数据、实型数据、字符串等。下面是重载的println方法的类型： 12345678910public void println()public void println(boolean x)public void println(char x)public void println(int x)public void println(long x)public void println(float x)public void println(double x)public void println(char x[])public void println(String x)public void println(Object x) 方法重载为程序调用带来了方便，用户无需为不同类型的数据选择输出方式，只需使用同一个方法即可实现不同类型数据的输出。 Java编译器对重载方法匹配时首先根据实参类型寻找形参类型与其完全匹配的方法，如果找不到，则按如下原则对实参作类型转换： (1) 对于简单类型，按照byte、short、int、long、float、double的顺序进行转换；(2) 如果实参为布尔型，不进行转换；(3) 如果实参为复合数据类型，可以将子类对象转换为超类对象。 如果按以上原则对实参进行类型转换仍然找不到匹配的重载方法，则认为是错误。 程序3.8演示了方法重载中参数匹配的方法，OverLoad类有两个同名的方法成员max，main方法中多次调用了max。 第一次调用，两个实参为int类型，匹配第一个max方法；第二次调用，两个实参为double类型，匹配第二个max方法；最后一次调用，第一个实参为int类型，第二个实参为double类型，没有参数类型完全匹配的max方法，Java编译器将第一个实参转换为double类型后与第二个max匹配。 12345678910111213141516171819202122232425262728293031323334353637383940414243【程序3.8】 类内方法重载。//ch3_8 类内方法重载演示 OverLoad.javapublic class OverLoad&#123; int ix,iy; double dx,dy; OverLoad(int ix,int iy,double dx,double dy) &#123; this.ix=ix; this.iy=iy; this.dx=dx; this.dy=dy;&#125; int max(int a,int b) &#123; if(a&gt;b) return a; else return b; &#125; double max(double a,double b) &#123; if(a&gt;b) return a; else return b; &#125; public static void main (String[] args) &#123; OverLoad obj=new OverLoad(3,4,5.0,6.0); System.out.println (&quot;the max integer is &quot;+obj.max(obj.ix,obj.iy)); System.out.println (&quot;the max double is &quot;+obj.max(obj.dx,obj.dy));System.out.println(&quot;The max is &quot;+obj.max(obj.max(obj.ix,obj.iy),obj.max(obj.dx,obj.dy))); &#125;&#125;运行结果为：the max integer is 4the max double is 6.0The max is 6.0 使用方法重载还应注意：123456789101112131415(1) Java编译器对实参进行类型转换时，应注意避免二义性。例如下面的程序片段：class A&#123; void m(int a,double b) &#123; &#125; void m(double a,int b) &#123;&#125; public static void main (String[] args) &#123; A obj=new A(); obj.m(2,3);&#125;&#125; 类A定义了两个同名方法m，在main方法中调用时两个实参为int类型，由于没有参数类型完全匹配的重载方法，因此Java编译器尝试对实参类型进行转换，这时有两种转换途径：将第一个实参转换为double类型与第二个m匹配，或者将第二个参数转换为double类型与第一个m匹配。Java编译器无法确定选择哪一种转换途径，这是不允许的。 类内方法重载时，不允许参数表完全一致，而只是返回值类型不同。例如：12345678class A&#123;void m(int a,int b)&#123; &#125; int m(int a,int b) &#123; &#125;&#125; 字符串Java语言定义了专门的字符串类型String，它是一种复合类型，一个字符串变量就是一个String类的对象，而C语言中的字符串只是一块连续的存储空间，用于存储若干个字符类型的数据。 创建String类对象String类对象的创建与其他类型对象创建的方法是相同的，例如： String str=new String(“This is a string”); String类的构造方法有多个，常用的形式有：123public String()public String(String value)public String(char value[]) 由于字符串类型在程序设计中经常会用到，因而Java语言还提供了一种简便的方法来初始化String对象。例如： String str=”This is a string”; 另外，在程序中大部分需要使用String类对象的地方可以直接使用字符串常量。例如： System.out.println(“This is a string”); 这里，Java语言用字符串常量”This is a string”构造一个String类对象，然后将该对象作为实参传递给println方法。 获取字符串的信息创建了String对象后，就可以通过调用String类的方法成员来对字符串进行各种操作或者获取有关字符串的信息了。例如，通过调用length方法可以获得字符串的长度：12String str=&quot;A String Object&quot;;int len=str.length(); startsWith方法可以判断一个字符串的前缀是否为指定的字符串：12String str=&quot;Java String&quot;;boolean result=str.startsWith(&quot;Java&quot;); //result=true endsWith用于确定字符串是否以给定的字符串结尾：123String str=&quot;This is a string&quot;;boolean result=str.endsWith(&quot;String&quot;); //result=falseboolean result=str.endsWith(&quot;string&quot;); //result=true 如果需要比较两个字符串的值是否相等，可以使用equals方法，也可以直接使用关系运算符==。例如：1234String firstName=&quot;Nancy&quot;;if(firstName.equals(&quot;Nancy&quot;))&#123; //条件满足，执行此程序段 &#125; equals方法区分大小写，如果不区分大小写比较两个字符串是否相等，可以使用方法equalsIgnoreCae。 字符串的操作 String类还提供了一些方法用于从字符串中抽取字符串的某些部分，如一个字符或一个子串，下面介绍一些常用的方法。 charAt用于抽取指定位置的字符，例如：12String str=&quot;Java string&quot;;char c=str.charAt(3); //c=&apos;a&apos; 该方法的参数为希望抽取的字符所在的位置，这里位置是从0开始计数的。 subString用于提取字符串中从某个位置开始的若干个字符，例如：123String str=&quot;Tom and Jerry&quot;;String str1=str.subString(4); //str1=&quot;and Jerry&quot;String str2=str.subString(4,7); //str2=&quot;and&quot; 对字符串的操作(如合并字符串、替换字符)，String类也提供了一些方法，例如：replace方法可以将字符串中的一个字符替换为另一个字符，concat方法可以合并两个字符串。 replace方法有两个字符类型的参数，第一个为原来的字符，第二个为替换用的字符。例如：12String str=&quot;java&quot;;String str1=str.replace(&apos;a&apos;, &apos;A&apos;); //str1=&quot;jAvA&quot;; concat方法有一个参数，为需要合并的字符串。例如：12String str=&quot;First&quot;;String str1=str.concat(&quot;Program&quot;); //str1=&quot;First Program&quot; 需要注意的是：String类对象创建后，字符串的值是不能改变的，replace、concat方法并不改变原来字符串的值，而是创建了一个新的String类对象作为返回值。如果希望字符串在创建后值可以改变，应使用StringBuffer类。 Java语言中可以直接使用+运算连接两个字符串，例如：12String str=&quot;First&quot;;String str1=str+&quot; Program&quot;; //str1=&quot;First Program&quot; 字符串与其他类型数据的转换程序设计中经常需要将字符串转换为整型或实型数据，例如，从键盘输入一个整数，只能先读入字符串，然后将其转换为整数，因为System.in.read方法只提供了读取字符的方法；同样，反向的转换也经常会用到，例如，在Java Applet中将数据转换为字符串后输出。Java语言中这样的转换都可以通过简单数据类型的包装类来实现。 String类的使用。1234567891011121314151617181920//ch3_9 StringClass.javapublic class StringClass&#123; String myString=&quot;1&quot;; public static void main (String[] args) &#123; StringClass myObj = new StringClass(); myObj.stringModifier(myObj.myString); StringClass myObj = new StringClass(); myObj.stringModifier(myObj.myString);System.out.println(&quot; &quot;+myObj.myString); &#125; void stringModifier(String theString) &#123; theString = theString+&quot;2&quot;; System.out.print(theString); &#125;&#125;程序的运行结果为12 1 Java语言为每一个简单数据类型定义了一个类(如 int 对应 Integer， float 对应 Float)，称为包装类(Wrapper Class)。 包装类为与该类型相关的方法和变量提供一个归属，如字符串转换和值域常量。 如果需要将简单类型变量转换为字符串，可以首先创建一个包装类对象，然后调用该对象的toString方法即可。例如： String IntStr = new Integer(123).toString();String DoubleStr = new Double(123.456D).toString(); 实际上，Java语言中的每一个对象都有一个 toString() 方法。例如： Date day = new Date(); //Date为Java类库中处理日期的类System.out.println(day);这里的输出语句相当于System.out.println(day.toString()); 前面提到，Java语言对+运算符的功能进行了扩展，可以允许字符串与int、float等类型的数据连接，实际上这里使用了包装类，例如： String str=””+5;相当于：String str=””+(new Interger(5).toString());即两个 String 的相加。 包装类的另一种构造方法以字符串作参数，可以使用该构造方法创建包装类对象，将字符串转换为简单类型数据。例如： int intNumber = new Integer (“10”).intValue();boolean con = new Boolean (“true”).booleanValue(); 这里，Boolean为boolean类型的包装类，常用的包装类还有：Character包装char，Byte包装byte，Long包装long。 从包装类型对象获取基本类型值的方法为typeValue，其中type为相应的数据类型。例如：intValue获取int值，charValue获取char值，doubleValue获取double值。 另外，String类还提供了静态的方法valueOf，可以用来将基本类型的值转换为字符串。valueOf有多种形式，分别用于转换不同类型的数据，例如： ● public static String valueOf(boolean b)；● public static String valueOf(char c)；● public static String valueOf(int i)；● public static String valueOf(long l)；● public static String valueOf(float f)；● public static String valueOf(double d)。 StringBuffer类 String类是字符串常量，对象创建后值不可更改。 而StringBuffer是字符串变量，它的对象是可以扩充和修改的。StringBuffer类的构造函数主要有以下几种形式： ● public StringBuffer()：创建一个空的StringBuffer类的对象。● public StringBuffer( int length )：创建一个长度为参数length 的StringBuffer类的对象。● public StringBuffer( String str )：用一个已存在的字符串常量来创建StringBuffer类的对象。 StringBuffer类的主要方法有：● public String toString()：转换为String类对象并返回。由于很多类的方法需要String类的对象，如Graphics类的方法drawString，经常要将StringBuffer类的对象转换为String类的对象。 ● public StringBuffer append( boolean b )。● public StringBuffer append( char c )。● public StringBuffer append( int i)。● public StringBuffer append( long l )。● public StringBuffer append( float f )。● public StringBuffer append( double d )。 以上六种方法可分别将boolean、char、int、long、float和double 六种类型的变量追加到StringBuffer类的对象的后面。例如：123456double d=123.4567;StringBuffer sb=new StringBuffer();sb.append(true);sb.append(&apos;c&apos;).append(d).append(99);//sb的值为truec123.456799 ● public StringBuffer append( String str )：将字符串常量str追加到StringBuffer类的对象的后面。● public StringBuffer append( char str[] )：将字符数组str追加到StringBuffer类的对象的后面。● public StringBuffer append( char str[], int offset, int len )：将字符数组str从第offset个开始取len个字符，追加到StringBuffer类的对象的后面。 ● public StringBuffer insert( int offset, boolean b )。● public StringBuffer insert( int offset, char c )。● public StringBuffer insert( int offset, int i )。● public StringBuffer insert( int offset, long l )。● public StringBuffer insert( int offset, float f )。● public StringBuffer insert( int offset, double d )。● public StringBuffer insert( int offset, String str )。● public StringBuffer insert( int offset, char str[] )。 数组与其他程序设计语言一样，Java语言也支持数组。数组是一组类型相同的有序数据，数组中的每个元素具有相同的数组名，通过下标来唯一地确定数组中的元素。 一维数组定义 一维数组定义形式为type arrayName[]; 其中，类型(type)可以为Java中的任意数据类型，包括简单类型和复合类型；数组名arrayName为一个合法的标识符，[]指明该变量是一个数组类型变量，可以写在数组名后，也可以写在数组名前。例如： int []intArray; 为一个整型数组分配3个int型整数所占据的内存空间。这两部分也可以合在一起，定义数组时直接为其分配空间，格式如下： type arrayName = new type[arraySize];例如：int intArray[]=new int[3]; 引用数组元素 定义数组并为其分配了内存空间后，就可以引用数组中的每一个元素了。数组元素的引用方式为12arrayName[index]其中：index为数组下标，它可以为int类型常量或表达式，如a[3]，b[i](i为整型)，c[6*i]等。 Java语言数组的下标从0开始，一直到数组的长度减1，数组的长度可以通过属性length获得。对于上面例子中的数组intArray来说，它有3个元素，分别为intArray[0]、intArray[1]和intArray[2]。 数组的使用。12345678910111213141516171819//ch3_10 ArrayTest.javapublic class ArrayTest&#123;public static void main(String args[])&#123;int i;int a[]=new int[5];for(i=0;i&lt;5;i++) a[i]=i;System.out.println(&quot;数组长度为：&quot;+a.length);for(i=0;i&lt;=a.length;i++) System.out.println(&quot;a[&quot;+i+&quot;]=&quot;+a[i]);&#125;&#125;使用Visual J++ 6.0调试该程序后，首先输出结果如下：数组长度为：5a[0]=0a[1]=1a[2]=2a[3]=3a[4]=4 数组的初始化可以按照上述的例子对数组元素进行赋值，也可以在定义数组的同时进行初始化。例如：int a[]={1,2,3,4,5};用逗号(,)分隔数组的各个元素，系统自动为数组分配一定空间，无需再使用new分配空间。 数组举例下面看几个使用一维数组的例子。12345678910111213【程序3.11】 用数组计算Fibonacci数列。 //ch3_11 Fibonacci.java public class Fibonacci&#123;public static void main(String args[])&#123;int i;int f[]=new int[10];f[0]=f[1]=1;for(i=2;i&lt;10;i++)f[i]=f[i-1]+f[i-2];for(i=1;i&lt;=10;i++)System.out.println(&quot;F[&quot;+i+&quot;]=&quot;+f[i-1]);&#125;&#125; 冒泡法排序。对给定数组的元素从小到大排列，采用冒泡法排序，相邻的两个元素进行比较，并把小的元素交到前面。12345678910111213141516171819202122232425 //ch3_12 BubbleSort.java public class BubbleSort&#123; public static void main(String args[])&#123; int i,j; int intArray[]=&#123;20,1, -11,80,25&#125;; int l=intArray.length; for(i=0;i&lt;l-1;i++) for(j=0;j&lt;l-i-1;j++) if(intArray[j]&gt;intArray[j+1])&#123; int t=intArray[j]; intArray[j]=intArray[j+1]; intArray[j+1]=t; &#125; for(i=0;i&lt;l;i++) System.out.println(intArray[i]+&quot;&quot;); &#125;&#125;运行结果为：-111202580 多维数组Java语言将多维数组看作数组的数组。例如，二维数组可以看成一个特殊的一维数组，其每个元素又是一个一维数组。下面简单介绍一下二维数组的使用。 二维数组的定义方式为 type arrayName[][];例如：int intArray[][]; (1) 直接为每一维分配空间，如int a[][]=new int[2][3];(2) 从最高维开始，分别为每一维分配空间。如：int a[][]=new int[2][];a[0]=new int[3];a[1]=new int[4]; 继 承继承的基本语法 利用继承性可以提高代码的可重用性，提高软件开发的生产率。Java语言支持继承机制，在定义类时通过关键字extends指定超类的名称即可。 1．子类的定义 子类定义的基本语法形式为：12class 子类名 extends 超类名&#123; &#125; Java语言不支持多继承，因此超类名只有一个。子类继承超类的特性，也可以通过定义新的成员修改超类的特性或增加新的特性。 Java语言在为子类对象分配空间时，不仅为子类中新定义的成员分配空间，同时也为超类中定义的成员(包括public、protected、private以及friendly成员)分配空间，在一定程度上可以认为一个子类对象内部包含一个超类对象。 Java语言允许将一个子类对象作为超类对象使用，当需要时可以进行隐含的类型转换。例如，若将一个方法的形式参数定义为超类对象，则在调用时可以将子类对象作为实际参数。Java语言中的各种类型的对象都可以当作Object类的对象使用，Object类中定义了Java语言对象的基本特性，例如前面用到的toString方法。如果在定义一个类时没有用extends关键字指定超类，则该类的超类为Object。 超类中定义的成员根据其权限的不同在该类中的访问权限也不同 子类在定义新的成员时，允许新成员与超类成员同名。对于同名变量成员，超类中的相应成员被隐藏。对于同名方法成员，如果参数形式相同且返回值类型相同，则超类中该方法成员被隐藏；如果参数形式不同，则调用时根据实参类型决定调用哪一个方法成员，与类内方法重载相同。Java语言不允许子类与超类方法同名，而参数形式相同但返回值类型不同。 super如果程序中需要访问被隐藏的同名超类成员，可以使用关键字super，super指代当前对象中在超类中定义的那一部分。 用super访问超类同名变量成员。123456789101112131415161718192021class Test&#123; int i; public Test()&#123;i=10;&#125;&#125;public class Test1 extends Test&#123; double i; public Test1()&#123;i=12.345678;&#125; public void print() &#123; System.out.println(&quot;i of sub class &quot;+i); //访问子类成员i System.out.println(&quot;i of super class &quot;+super.i); //访问超类成员i &#125; public static void main (String[] args) &#123; Test1 t1=new Test1(); t1.print(); &#125;&#125; 子类对象的构造子类对象在创建时需要调用超类的构造方法来构造超类中定义的那部分成员，如果在子类中不特别声明，则调用超类的不带参数的构造方法。 如果超类没有不带参数的构造方法，必须在子类的构造方法中用super关键字指定如何调用超类的构造方法。先看下面的程序。12345678910111213141516171819class A&#123; int a; A(int a)&#123; this.a=a; &#125;&#125;class B extends A&#123; int b; B(int b)&#123; this.b=b;System.out.println(&quot;Class B&quot;); &#125;&#125;public class Class1 &#123; public static void main (String[] args) &#123; B b=new B(10); &#125;&#125; final方法与final类通过在子类中定义与超类同名的方法成员，覆盖超类的方法成员，改变了超类原有的特征。有时可能程序员不希望子类修改超类原有的特性，这时可以将对应的方法定义为最终(final)方法，子类不再可以覆盖该方法。例如：1234class A&#123; final void Method1() &#123;System.out.println(&quot;This is a final method&quot;);&#125; &#125; 当从A类派生子类时，子类不可以定义与Method1形式相同的方法。 关键字final也可以用来修饰类的定义，将一个类定义为最终类，则不再可以从该类派生出子类。基本语法形式为：123final class 类名&#123; //成员定义&#125; 抽象类与抽象方法1234567abstract class Root&#123;public Root(double a,double b,double disc) &#123; this.a=a; this.b=b; this.disc=disc; &#125; abstract void Print();&#125; 其中，第一个abstract表示定义一个抽象类，第二个abstract表示Print方法为抽象方法。如果一个类包含有抽象方法，该类必须声明为抽象类。 抽象方法在定义时无需给出方法体，只要给出方法的返回值类型和形式参数表即可。程序中不可创建抽象类对象，必须从抽象类派生出子类，在子类中实现所有抽象的方法后才可以创建子类的对象。如果子类没有实现超类中所有抽象方法，则子类也必须定义为抽象类。 接口Java语言不支持多继承，但通过接口可以实现部分多继承的功能。 接口的定义 接口与抽象类相似，也表达一个抽象的概念。接口中的所有方法都是抽象的，每一个都没有方法体。另外，接口只可以定义static final变量成员。 接口用关键字interface来定义，基本的语法形式为：123interface 接口名 &#123; //成员定义 &#125; 接口中所有方法都是抽象的，不要使用abstract。下面是一个简单的例子。123interface Printable &#123; public void Print(); &#125; 接口的实现接口的实现与继承类似，不过接口实现时使用关键字implements而不是extends。例如：12345class IntClass implements Printable&#123; int a; IntClass(int a)&#123;this.a=a;&#125; public void Print()&#123;System.out.println(a);&#125; &#125; 该类实现了上面定义的Printable接口。 当类实现特殊接口时，必须先定义该接口定义的所有抽象方法，然后才可以在该类的任何对象上调用接口的方法。与抽象类相似，允许使用接口名作为复合变量的类型，在运行时根据对象的实际类型决定调用哪个类中定义的方法，这个过程通常称为动态联编。 例如：Printable obj=new IntClass(10);obj.Print(); 可以用instanceof运算符来判断某对象的类是否实现了特定的接口。 一个类可以实现多个接口，多个接口名在implements后面一一列出，以逗号分隔。 123例如：public class MyApplet extends Applet implements Runnable, MouseListener&#123; &#125; 接口的派生定义接口时也可以从已有的接口派生，新的接口包含了原来接口的所有成员。例如：123interface PrintName extends Printable&#123; public String ClassName(); &#125; 程序举例下面看一个完整的例子，该例演示了如何定义接口、实现接口和使用接口定义的方法。 接口的使用。1234interface Shape&#123; static double pi=3.14159; public double area();&#125; 12345678910111213141516class Circle implements Shape&#123; double Radius; Circle(double r)&#123; Radius=r; &#125; public double area()&#123; return pi*Radius*Radius; &#125;&#125;public class ch3_19 &#123; public static void main(String argv[]) &#123; Shape s=new Circle(2.0); System.out.println(&quot;Area is &quot;+s.area()); &#125;&#125; 包 的 使 用包的概念 Java程序编译后每一个类和接口都生成一个独立的class文件。对于一个大型程序，由于类和接口的数量很大，如果将它们全放在一起，往往显得杂乱无章，难于管理。Java语言提供了一种解决该问题的方法：将类和接口放在不同的包中。 一个包由一组类和接口组成，包内还可以有子包，类似于目录(文件夹)中可以有若干文件和子目录(子文件夹)一样。实际上，Java系统就是使用文件夹来存放包的，一个包对应一个文件夹，文件夹下有若干个class文件和子文件夹。 当要使用其他包内的类时，可以使用import语句引入其他包内的类。 1这里，java为包名，math为java包内的子包，*表示该包中所有类，该语句引入了java.math包中的所有类。 ava包是Sun公司使用Java语言开发的类的集合，是随Java运行系统提供的，Java语言的很多功能依赖于该包中的类。 目前的Java虚拟机通常将java包以一种压缩文件的形式存储在特定的目录中。java包中的子包lang是自动引入的，无需使用import语句引入该包，前面提到的String、StringBuffer、Sytem等类均在该包中定义。1import也可以引入特定的类，只要用类名取代上面例子里的*即可。 例如：1import java.awt.Graphics; 包的使用可以避免名字冲突，每一个类和接口的名字都包含在某个包中，不同的包中可以有同名的类和接口。 在程序中使用同名类时，可以加上包名以免引起歧义，例如java.awt.Button表示java.awt包中的Button类，此时无需使用import语句引入该类。 另外还应注意：使用import语句引入某个包中的所有类时并不包括该包的子包中的类。 类的访问权限Java语言规定只能使用其他包中公有(public)的类和接口，即在定义该类时使用了public修饰符 包的定义如果希望将程序中不同的类放在多个不同的包中，可以首先在程序的当前目录中创建相应的子目录，然后将相应的源文件放入对应的文件夹，分别编译，同时应在源文件前面加上相应的包定义语句。 实训三 面向对象程序设计一、实训目的1．掌握定义类、创建对象、使用类与对象的方法。2．掌握类及其成员的修饰符的使用。3．掌握如何定义和调用方法。4．掌握形式参数定义，形式参数与实际参数的关系。5．掌握静态变量与非静态变量、局部变量的使用以及静态方法与非静态方法的使用。6．掌握构造方法的使用。7．掌握字符串类、数组的使用。8．掌握继承和重载的概念与实现方法。9．掌握如何从已有类中派生子类。10．掌握方法的覆盖和重载。11．掌握定义包和接口的方法。12．掌握多文件、多类程序编译和发布的方法。 二、实训内容 1．定义并使用一个新类(使用Visual J++完成本任务请参考第1章有关内容)。(1) 使用纯文本编辑软件输入下面这个源程序，保存为Birthday.java。1234567891011121314151617181920212223242526public class Birthday &#123;public String year;public String month;public String day;public Birthday()&#123;year=&quot;0000&quot;;month=&quot;00&quot;;day=&quot;00&quot;;&#125;public Birthday(String y,String m,String d)&#123;year=y;month=m;day=d;&#125;public String getBirthday()&#123;String fullbirthday=month+&quot;/&quot;+day+&quot;/&quot;+year;return fullbirthday;&#125;&#125; (2) 编译这个程序，如果顺利完成，将在当前目录下生成一个名为Birthday.class的文件。(3) 输入以下源程序，保存为useBirthday.java。12345678910 public class useBirthday &#123; public static void main(String argv[]) &#123; Birthday birthday1=new Birthday(); Birthday birthday2=new Birthday(&quot;1949&quot;,&quot;10&quot;,&quot;01&quot;); System.out.println(birthday1.getBirthday()); System.out.println(birthday2.getBirthday());&#125;&#125; (4) 编译useBirthday.java后，执行以下命令运行程序：java useBirthday 2．定义一个类Myclass，包含一个整型属性data和封装这两个属性的两个方法getData()和setData()。然后编写一个使用上面定义的类Myclass的Java Applet程序，实现数据的访问和输出。 3．编写一个类实现复数的运算。复数类Complex的属性有：mReal：实部，代表复数的实数部分；mImage：虚部，代表复数的虚数部分。 复数类Complex的方法有： Complex(double r，double i)：构造函数，创建复数对象的同时完成复数的实部、虚部的初始化，r为实部的初值，i为虚部的初值。 getReal()：获得复数对象的实部。getImage()：获得复数对象的虚部。 setReal(double d)：将当前复数对象的实部设置为给定的形式参数的值。setReal(String s)：将当前复数对象的实部设置为给定的形式参数字符串字面所代表的值。 习 题 三1．类及类成员的访问控制符有哪些? 答：来源网络 public：可以在任何地方进行访问，不受任何约束；protected:可被子类访问，不管是同一个包还是不同包同一个包中非子类需要通过对象访问private：只能够被本类中的其它成员访问，而不能从类的外部进行访问缺省：称为friendly，可被同一包的所有的类访问final:final修饰的类表示这个类不可被继承，被称为最终类Static:不能用来修饰类,可以用来修饰变量，用static修饰的变量称为静态变量，可以直接通过 类名.变量名来调用 2．为什么说构造方法是一种特殊的方法? 特殊在哪里? 构造方法什么时候执行? 在java语言 中，构造函数又称构造方法。特殊性在于，与普通方法的区别是，他与类名相同，不返回结果也不加void返回值。构造函数的作用是初始化对象，即在创建对象时被系统调用（与普通方法不同，程序不能显示调用构造函数）。构造函数还能够被重载，即可以传入参数，当程序中包含有带参的构造函数时，系统将不会再提供的无参构造函数。 3．下面的关键字哪些是类及其成员的修饰符?(1) public (2) synchronized (3) class (4) void(5) private (6) protected (7) friendly (8) double 4．静态变量成员有什么特点? 类对象可以访问或修改静态变量成员吗？ 1.特点一:静态变量的值是共享。比如说A类中有个静态变量V_A，A类创建了两个实例a，b。如果给实例a的变量V_A赋值，如a.V_A=1。那么这时候查看实例b的V_A变量的值也为1，也就是说A对象实例化的两个类共享同一个变量值，而且静态变量2.特点二:不需要对象实例化就可以使用。比如A类中的静态变量V_A可以用A.V_A的形式使用 一、static变量有什么作用呢？（1） 在函数体内，值维持不变，具有“记忆”功能；（2）在模块内（但在函数体外），不能被模块外的其他函数访问；（3）只在一个源文件中有效，不能被其他源文件使用。 引申：static变量只初始化一次 5．对象初始化有哪几种方法? 写出它们的执行顺序。 1、构造器创建对象时初始化，比较常见。 12345classA&#123;publicA()&#123;&#125;&#125;public 2、初始化块较少见，用于有特殊要求的类。 12static &#123;&#125; java 创建对象的四种方式、java对象初始化顺序java创建对象的几种方式： (1) 用new语句创建对象，这是最常见的创建对象的方法。(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。(3) 调用对象的clone()方法。(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。 其中：(1)和(2)都会明确的显式的调用构造函数 ； (3)是在内存上对已有对象的影印，所以不会调用构造函数 ； (4)是从文件中还原类的对象，也不会调用构造函数。 对象的初始化顺序： （1）类加载之后，按从上到下（从父类到子类）执行被static修饰的语句； （2）当static语句执行完之后,再执行main方法； （3）如果有语句new了自身的对象，将从上到下执行构造代码块、构造器（两者可以说绑定在一起）。 3、方法即Setter方法，虽然方便（不必在创建对象时一次性初始化），但是可能引发空指针异常。 6．抽象类有什么作用? 接口与抽象类有什么区别？ 接口和抽象类有什么区别? 你选择使用接口和抽象类的依据是什么？ 接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。 抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。 人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它. 所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。第二点． 接口可以多继承，抽象类不行第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。第四点． 接口中基本数据类型为static 而抽类象不是的。 当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的 所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。 7．抽象方法有什么特点? 抽象方法的方法体在何处定义? 抽象方法一般都定义在父类里面,但这个父类也必须是抽象的,它的特点是没有方法体,只有方法名如:123456789abstract class A&#123; public abstract void print();//print()方法没有方法体;&#125;//类B 继承A,类B 必须实现父类A中的抽象方法print()class B extends A&#123; public void print()&#123; //方法体.... &#125;&#125; 抽象方法的好处就在于能让子类做一些特定的事 8．为什么定义fianl变量成员时往往声明为static的？ Java中常量为什么定义为public static final final关键字定义常量，就使得他在被定义后无法再对此进行赋值。而有时候定义的常量是个随机数，这时为了保证不使每次初始化后常量改变，就需要加static了。在同一个对象中是不需要的。被static修饰的变量可以不通过对象用类名直接访问，且只被分配一次内存，节约内存。实质上，就是一个全局变量。static定义的类。。。不知道你指的是不是类中的静态方法。方法的话，和变量一样，可以用类名直接调用，但是不能直接访问这个类除静态外的变量和方法。如果是静态类的话，普通类是不支持声明为静态类的，只有内部类才可以。能直接作为一个普通类使用，不需要实例外部类。作用就很多了，它可以在他所属类创建之前就被访问，最常用的例子就是main方法了。他会独立于该类的任何对象。java虚拟机的加载的顺序为，先加载静态成员变量，然后是静态代码块；同等级的才按照前后顺序依次加载。 final是常量，这个是不占有存储空间的，只能通过对象来引用。static是类成员（区别于对象成员），可以通过类（推荐）和对象来引用。只要你的类加载了，则你的类中static成员就一直可以使用。而final只能存活到对象销毁之前。还有一种是 static final，这个是静态类成员变量，也不占内存。其他和static一样。 9．下面哪些访问控制修饰符的使用是合法的：(1) public class MyClass{…}(2) public protected int IntegerValue;(3) friendly float FloatValue;(4) String s;10．final修饰符和abstract可以同时使用吗？为什么？ 关键字final和abstract是否可以同时做类的修饰符，为什么？ 不可以的。解释：final的类不能被重写和继承，而abstract的类是抽象类，本身没有实现，只能通过子类来实现，也就是说必须被继承。所以说它们是没法同时做修饰符的。 不可以。final修饰类代表该类不能有子类，abstract修饰的类为抽象类，抽象类就是给其他类继承的。明显存在矛盾 final关键字的用法： 1、final关键字修饰变量（成员变量和局部变量的区别，引用变量和基本数据类型的区别）。122、final可以修饰方法3、final修饰类 其中final修饰方法跟继承有关，而且不能被子类重写； fianl修身类是不能被继承的；而且要注意：fianl修饰基本数据类型的成员变量必须赋值，否则编译器报错。并且fianl修饰的成员变量一旦赋值就不可改变。 abstract 关键字：1234567891011121314151617181920abstract要注意一下几点：1.对于方法来说，加了abstract就没有意义了。2.有抽象方法的类一定是抽象类，抽象类不一定有抽象方法。然而方法中用了abstract，那本身就成了抽象类。 例如：public abstract class Shape&#123;&#125; // 表示抽象类。3.抽象类不允许被实例化。4.抽象类有构造方法，子类可以通过shper调用父类的构造方法，对从父类的属性进行初始化。5.抽象关键字不可以与fianl关键字一起使用，因为abstract要求子类一定要重写父类的方法，但fianl不允许重写。6.抽象关键字不恶意和private关键字一起使用，因为private是私有的，不能被继承的内容代表根本不存在7.关键字不能与static一起使用，static是静态修饰符，代表不需要实例化对象，直接类名就可以调用，如果是抽象方法，没有方法实现调用方法会出错，所以不能一起使用。8.构造方法不允许被继承，也没有重写，不能用abstract修饰。注意：用abstract修饰的方法没有方法执行体，因为不行有任何内容；而且abstract修饰的方法在子类中必须重写，抽象类不能够被实例化，可子类创建对象进行调用。 类的定义和对象使用Java程序的开发过程数据类型运算符和表达式语句 面向对象编程的基本概念类的定义 类首部 类体 成员变量 成员方法 对象的创建与使用 创建对象 使用对象 构造方法面向对象编程的基本概念类和对象 类是 定义对象的 模板，用来描述一类事物的 共有 属性 和 功能 。 对象 是 一个具体的 事物。 例：汽车类—某辆汽车学生类—某个学生窗口类—某个具体的窗口 类的继承 类的定义 可以是 分层次 的，低层的类 具有 高层类的 属性 和 方法 ，称高层类为 父类 ，低层类 为 子类。 子类 使用父类中定义的 方法和变量 时，就像它们属于子类本身一样。 可以简化编程的过程，有利于代码的复用。 子类除了拥有 父类的方法和变量 之外，也可以 定义自己 方法和变量 。 哺乳动物：胎生，能用母乳喂养幼仔。猫：胎生，能用母乳喂养幼仔。会捉老鼠。 类的声明类 是 Java语言中的一种 复合数据类型 ，是组成Java程序的 基本要素 。Java的类 具有两种基本成分： 数据和行为（状态和方法）。类的这两种 成分 被封装在类体中，与外界隔开。 类的定义类首 [修饰符] class 类名 [extends父类名] 类体1234&#123; [类成员变量声明；] [类方法声明]&#125; 最简单的类定义123class A&#123;&#125; 类的修饰符有：public、abstract、final…… extends 父类名：表示所定义的类由“父类”继承而来。 implements 接口列表：该类对指定接口进行实现。 成员变量与局部变量成员变量：是类的数据成分，在类体中直接定义，定义格式如下： [修饰符] 变量类型 成员变量名列表； 成员变量的定义可以在定义前加修饰符：public、private、protected、final、static等，用来标识变量的使用范围和性质。 局部变量：在方法体内定义的变量和方法的参数是局部变量。 变量类型可以是基本数据类型，也可以是引用数据类型，如：数组、类类型。 成员变量在整个类的内部有效，局部变量只在定义它的方法内有效。 局部变量名可以和成员变量名重名，此时局部变量会隐藏成员变量，如果想在该方法内部使用成员变量，使用关键字this。 123456789public class People&#123; float hight,weight; String head,ear,mouth; void speak(String s) &#123; System.out.println(s); &#125;&#125; 成员方法成员方法是类的行为成分，声明格式如下：12345[修饰符] 返回值类型 方法名（[形参列表]） &#123; [方法体] [return 表达式；]&#125; 修饰符：public 、 private、protected、static、final…… 如果方法没有返回值，则使用void关键字。如果有返回值类型，则方法体中必须有return语句，并且表达式类型与方法类型一致。 形式参数列表的形式如下： 123类型名 形参名1，类型名 形参名2，……如：public void out(int x,int y,float f) &#123;System.out.println(“x=”+x+”y=”+y+”f=”+f); &#125; 12345678class Triangle&#123; float sideA,sideB,sideC,lengthSum; void setSide(float sideA,float sideB,float sideC)&#123; this.sideA=sideA; this.sideB=sideB; this.sideC=sideC; &#125;&#125; 类的定义–例1定义描述“人”的类：成员变量：姓名、性别、年龄；成员方法：唱歌，跳舞，输出123456789101112131415161718class Person&#123; String name,sex; int age; void sing() &#123; System.out.println(&quot;I can sing!&quot;); &#125; void dance() &#123; System.out.println(&quot;I can dance!&quot;); &#125; void out()//成员变量的操作只能放在方法中 &#123; System.out.println(&quot;name:&quot;+name); System.out.println(&quot;age:&quot;+age); &#125; &#125; 注意：一个类中可以没有main方法，此时它不是Java的application应用程序，也就是不能被Java虚拟机直接调用。 类的定义–例2梯形1234567891011121314梯形类：class Ladder&#123; float a,b,h; void setH(float h) &#123; this.h=h; &#125; float calculatArea() &#123; return (a+b)*h/2; &#125; &#125; 创建和使用对象如何调用类中定义的成员变量和成员方法，在Java中类只有实例化为对象后才能被使用(注：main方法为特殊方法，由系统调用) ，对象的使用“分三步走”： 1、声明对象 类名 对象名； 2、分配内存（对象的实例化） 对象名=new 类构造方法名（[实参表]）； 3、使用对象（对象的成员变量及方法的访问） 对象名.方法名、对象名.成员变量名 声明和初始化可以合并：类名 对象名=new 类的构造方法名（ [实参表] ）；说明：构造方法名与类名相同，如果一个类中未定义构造方法，系统自动定义。 使用对象—例3方法一：在同一个类中使用对象123456789101112131415class Person&#123; . . . public static void main(String[] args) &#123; Person p; p=new Person(); p.name=&quot;zhangsan&quot;; p.age=20; p.sing(); p.out(); &#125; &#125; 使用对象—例4方法二：在不同类中使用对象123456789101112131415161718class Person&#123; . . .&#125;class PersonTest&#123; public static void main(String[] args) &#123; Person p; p=new Person(); p.name=&quot;zhangsan&quot;; p.age=20; p.sing(); p.out(); &#125;&#125; 使用对象—例5 梯形12345678910public static void main(String[]args)&#123; float area; Ladder ladder=new Ladder(); ladder.a=10.0f; ladder.b=20.0f; ladder.setH(5f); area=ladder.calculatArea(); System.out.println(&quot;area=&quot;+area);&#125; 对象的内存模型引用数据类型 与 引用变量：引用数据类型（数组、类）声明的变量为 引用变量 ，引用变量本身 并不存放数据 ，而只是 存放数据的地址 。 Java的内存分配 — Java把内存划分成两种： 栈内存、堆内存 Person p;声明对象p时， 在栈内存中分配空间，用来存放一个地址，此时地址未指向任何数据。 p=new Person();时， 首先在堆内存中为对象分配存储空间，并对各成员变量进行初始化，数值型为0，布尔型为false，引用型为null；然后 取得这个存储空间的地址（引用），将其“交给”引用变量p，以后对这个对象的操作全由p去控制。 多次使用new便会创建多个不同的对象。 在方法中定义的一些基本类型的变量和引用变量都是在方法的栈内存中分配。当在一段代码块（也就是一对{}之间）定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后， Java会自动释放为该变量分配的内存空间，以前所讲的变量分配都是在栈内存中存放的。 构造方法1234public Person()&#123; System.out.println(“我是构造方法，已被调用！&quot;);&#125; 我们并没有调用对象的Person()方法，但是它却被执行了。这个方法就是构造方法 构造方法的说明说明形式如下：12 [构造方法修饰符] 方法名（[形式参数列表]）&#123;方法体&#125; ⑴构造方法的名字与类的名字相同 ⑵构造方法没有返回类型 (千万不要将返回值类型声明为void。也不能在方法内部使用return返回一个值。) 一般将构造方法声明为公共的public型。 ⑶构造方法对对象的创建是必须的。 实际上Java语言为每一个类提供了一个默认的构造方法，也就是说，每个类都有构造方法。 如果不定义一个构造方法，Java语言将调用它提供的默认的构造方法对一个新的对象进行初始化。 方法的重载在一个类中可以定义同名的方法，但是 参数的类型和个数 不能完全相同， 同名的方法可以有不同的方法体从而完成不同的任务， 当调用方法时，系统会自动调用与实际参数类型和个数相匹配的的那一个方法， 这就是方法的重载。 在面向对象编程中，这种同一个名字可以有不同解释的现象称为多态。 类与对象方法的重载、static、包 类的定义 成员变量说明 成员方法说明 对象的创建和使用 创建对象 通过对象引用成员变量和成员方法 构造方法 构造方法与一般成员方法的区别 方法的重载 成员方法的重载 构造方法的重载 static变量和static方法 包 package命令 import命令 方法的重载在一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同，即或者是参数的个数不同，或者是参数的类型不同。 同名的方法可以有不同的方法体从而完成不同的任务，当调用方法时，系统会根据调用方法的实际参数类型和个数自动调用相应的方法，这就是方法的重载。 12345678910111213141516171819202122class Heshang&#123; void dashui(String s) &#123; System.out.println (s+&quot;挑水喝&quot;); &#125; void dashui(String s1,String s2) &#123; System.out.println (s1+&quot;和&quot;+s2+&quot;抬水喝&quot;); &#125; void dashui(String s1,String s2,String s3) &#123; System.out.println (s1+&quot; &quot;+s2+&quot; &quot;+s3+&quot;没水喝&quot;); &#125; public static void main(String[]args) &#123; Heshang h=new Heshang(); h.dashui(&quot;孙悟空&quot;); h.dashui(&quot;孙悟空&quot;,&quot;猪八戒&quot;); h.dashui(&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;); &#125;&#125; 构造方法的重载123456789101112131415161718192021222324252627class Person&#123; String name;int age;float height,weight; public Person() &#123; age=18; name=&quot;无名&quot;; &#125; public Person(String name) &#123; this.name=name; &#125; public Person(String name,int age,float height,float weight) &#123; this.name=name; this.age=age; this.height=height; this.weight=weight; &#125; void out()//成员变量的操作只能放在方法中 &#123; System.out.println(“姓名:”+name+“ 年龄:”+age+“岁”+ &quot; 身高:&quot; +height+&quot;米&quot;+&quot; 体重:&quot;+weight+&quot;斤&quot;); System.out.println (); &#125; &#125; 1234567891011class PersonTest&#123; public static void main(String[] args) &#123; Person p1,p2,p3; p1=new Person(); p2=new Person(&quot;孙悟空&quot;); p3=new Person(&quot;猪八戒&quot;,300,2.8f,380); p1.out();p2.out();p3.out(); &#125; &#125; 对象变量的赋值12345678910111213class PersonTest&#123; public static void main(String[] args) &#123; Person p1,p2,p3; p1=new Person(); p2=new Person(&quot;孙悟空&quot;); p3=new Person(&quot;猪八戒&quot;,300,2.8f,380); p1=p2; p1.name= “唐僧”;p1.age=50; p1.out(); p2.out(); p3.out(); &#125; &#125; 对象变量的赋值，只是对象中保存的地址发生的变化，而并未改变对象的状态。如果一个对象没有任何变量引用它，则它成为垃圾内存。 static关键字静态变量/静态方法：对于成员变量/成员方法的声明，可以在类型的前面加修饰符“static”，称之为静态变量/静态方法。 类变量/类方法和实例变量/实例方法：静态变量/静态方法属于类而不属于类的某个实例，可直接由类名来调用（类名·变量名/类名·方法名），因此也叫类变量/类方法； 非静态的成员变量/方法必须实例化后通过对象名来调用（对象名·变量名/对象名·方法），因此称为实例变量/实例方法。 说明：类变量和类方法也可以通过实例调用。 类变量，它属于类所有，且在所有的实例中都共享同一个内存空间； 实例变量，对于每一个实例，这个变量都拥有独自的内存空间。 类方法，在类加载时分配方法入口地址，因此可被类直接调用。 实例方法，只有创建类的对象，才会分配方法入口地址，并只能通过对象调用方法。 main()方法是静态的，因此java虚拟机在执行main方法时不需创建main方法所在类的实例就可以直接调用。 类变量/类方法、实例变量/实例方法123456789101112131415161718192021class StaticDemo&#123; static int x; int y; public static int getX() &#123; return x; &#125; public static void setX(int newX) &#123; x=newX; &#125; public int getY() &#123; return y; &#125; public void setY(int newY) &#123; y=newY; &#125;&#125; 内存模型分析123456789101112131415161718public class ShowDemo&#123; public static void main(String[] args) &#123; System.out.println(&quot;静态变量 x=&quot;+StaticDemo.getX()); StaticDemo a=new StaticDemo(); StaticDemo b=new StaticDemo(); a.setX(10); a.setY(20); b.setX(30); b.setY(40); System.out.println(&quot;静态变量 a.x=&quot;+a.getX()); System.out.println(&quot;实例变量 a.y=&quot;+a.getY()); System.out.println(&quot;静态变量 b.x=&quot;+b.getX()); System.out.println(&quot;实例变量 b.y=&quot;+b.getY()); System.out.println(&quot;静态变量 x=&quot;+StaticDemo.getX()); &#125;&#125; static应用注意事项总结（静态成员在使用时应该注意）： 1、静态方法中只能直接调用同类中其他静态成员，而不能调用非静态成员。反之，则可以。2、静态成员的引用直接通过类名引用，也可以通过该类的对象来引用。3、静态方法中不能使用super和this变量。 1234567891011例3：class A&#123; static int i=10; String s=&quot;hello world!&quot;; public static void main(String[] args) &#123; System.out.println(&quot;i=&quot;+i); // System.out.println(&quot;s=&quot;+s); &#125;&#125; this关键字this关键字只能用在实例方法或构造方法中，代表使用该方法的当前的对象。 12345678910111213void setAge(int age)&#123; this.age=age;&#125;public static void main(String[] args)&#123; Person p1,p2,p3; p1=new Person(); p2=new Person(&quot;孙悟空&quot;); p3=new Person(&quot;猪八戒&quot;,300,2.8f,380); p1.setAge(18);p2.setAge(19);p3.setAge(20); p1.out();p2.out();p3.out();&#125; 包的概念为了便于管理大型软件系统中数目众多的类，解决类命名冲突的问题，java引入了包。Java中的包与文件系统的目录层次结构是一一对应的。一个包中可以包含子包，包名与子包名间用“·”分隔。Java提供的类和接口是按不同的用途分别放在不同的包中。123456java.appletjava.awtjava.langjava.iojava.netjava.util package 语句功能：创建包格式：package 包名[.子包名[…]];要求：此语句必须放在整个源程序第一条语句例：package p;//(在当前目录下创建一个p包) package a.b;//（在当前目录下创建a，在a下再创建b）注意：嵌套的包名之间以圆点分隔（“.”）。如果源文件中省略了package语句，则文件中定义的类隐含在一个无名包中，这个无名包就是源文件所在的位置。 引入java包中的类和接口import语句 一般情况下import语句紧跟在package语句之后功能：将其他包中的类引入到当前程序中。格式：import 带包层次结构的类名; 123456说明：1、引入包时，类名可以使用通配符“*”，表示包模块中某个层次的类全引入进来。例： import java.io.*; import java.awt.Graphics;2、java会自动引入lang包下的所有类和接口。3、前缀包名法：不用import语句也可以引入其他包中的类和接口。 类与对象 访问权限、类的继承、对象的上转型 访问权限 私有变量和私有方法（private关键字）共有变量和共有方法(public关键字)保护变量和保护方法(protected关键字) 友好变量和友好方法public类与友好类 类的继承（重点） 创建子类子类的继承性 成员变量的隐藏和方法的重写 final类和final方法 对象的上转型对象多态性 访问权限用一个类创建一个对象后，通过对象可以访问这个类的成员变量和成员方法，但这种访问是有一定限制的。 这种限制取决于在声明变量和成员方法时使用的修饰符：public、private、protected、友好（未使用修饰符）。 private变量和方法访问权限最小，只能在同一个类中被访问。 同一个类的方法中直接访问。 同一个类的对象也可以引用本类的私有成员。 1234567891011121314151617class Tom&#123; private float weight; private static String name; private void out() &#123; System.out.println (name+&quot;体重：&quot;+weight+&quot;斤&quot;); &#125; public static void main(String[]args)&#123; Tom.name=&quot;汤姆猫&quot;; Tom cat=new Tom(); cat.weight=20; //或cat.setWeight(20); cat.out(); &#125;&#125; 类中的私有成员不能在另一个类中引用私有的类变量和类方法也只能在本类中使用。 1234567891011class Jerry&#123; public static void main(String[]args)&#123; Tom.name=&quot;汤姆猫&quot;;//非法使用类变量 Tom cat=new Tom(); cat.weight=20;//非法引用变量weight cat.setWeight(20);//合法地调用方法setWeight() cat.out();//非法调用方法out()&#125;&#125; public变量和方法访问权限最大，可以在不同类、不同包的类中访问。 123456789101112131415161718192021222324package p1;public class Area&#123; public float getArea(float r) &#123; System.out.print(&quot;方法一：&quot;); return 3.14f*r*r; &#125; public double getArea(float x,int y) &#123; System.out.print(&quot;方法二：&quot;); return x*y; &#125; public float getArea(int x,float y) &#123; System.out.print(&quot;方法三：&quot;); return x*y; &#125; public double getArea(float x,float y,float z) &#123; System.out.print(&quot;方法四：&quot;); return (x+x+y*y+z*z)*2.0; &#125;&#125; 12345678910111213package p2;import p1.Area;class AreaTest&#123; public static void main(String[]args)&#123; Area a=new Area(); System.out.println (a.getArea(2.0f)); System.out.println (a.getArea(12,2.7f)); System.out.println (a.getArea(2.7f,12)); System.out.println (a.getArea(2.0f,10,20));&#125;&#125; 友好变量和方法不使用修饰符：public、private、protected，即缺省这些修饰符的情况。比private权限级别高一级友好成员只能被同类或同包中的不同类引用。 protected变量和方法比友好成员高一级，比public低一级。不能在不同包的类中被引用。如果不同包中的类是本类的子类，则子类的对象可以引用本类的受保护成员。 方法的访问控制同类 public protected 友好 private 同包不同类 public protected 友好 不同包子类 public protected 通用 public public类和友好类如果定义类时，使用public修饰，则该类为公共类。可以在不同的包中被其他类使用。如果未使用修饰符，则为友好类。只能被同包里的类使用。 类的继承继承：由已有类创建新类的机制。新类继承已有类的成员，并可根据需要增加自己新的成员。已有类称为父类，新类称为已有类的子类。 Java不支持多继承，一个子类只能有一个父类，但一个父类可以派生出若干个子类。 12345678910111213public class Person&#123; String name; int age; public void setAge(int age) &#123; this.age=age; &#125; public void out() &#123; System.out.println(&quot;姓名:&quot;+name+&quot; 年龄:&quot;+age+&quot;岁&quot;); &#125;&#125; 123456789101112131415161718192021public class Student extends Person&#123; int java,flash; void learn() &#123; System.out.println (name+&quot; is learning!&quot;); &#125; void outStudent() &#123; System.out.println (&quot;java:&quot;+java+ &quot;\tflash:&quot;+flash); &#125; public static void main(String[]args) &#123; Student s=new Student(); s.name=&quot;孙悟空&quot;; s.age=500;s.java=80;s.flash=85; s.learn(); s.outStudent();s.out(); &#125;&#125; 类的继承性子类和父类在同一包中子类可继承其父类中非私有成员（不是private的成员）子类和父类不在同一包中子类只能继承受保护的和共有成员（public、protected） 成员变量的隐藏和方法的重写成员变量的隐藏：如果在子类中定义了与父类中同名的变量，父类的这个变量将被隐藏。 方法的重写：如果子类中定义了与父类同名、同类型、相同参数的方法，则称子类覆盖了父类的方法。 这是子类的一种“变异”，子类可以根据需要把从父类继承来的方法进行改造。比如：在student类中重新声明变量age和方法out() 12345678910public static void main(String[]args) &#123; Student s=new Student(); s.name=&quot;孙悟空&quot;; s.age=500; s.java=80; s.flash=85; s.learn(); s.out(); &#125; super变量特殊变量super，提供了对父类的访问。 1、可以使用super访问父类被子类隐藏的变量或覆盖的方法。如：在student类中改写out方法时，可以使用super.out();来调用父类中对name和age的输出。调用父类的变量super.name。 2、可能通过Super([参数表])来高用父类的构造方法。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。如：在Person类中只定义带参数的构造方法，如何定义子类Student的构造方法？？？？？？？ final类和final成员final类：不能派生子类。final变量，其值不能在程序运行过程中改变，是常量。final方法，不能被子类方法重写。 对象的上转型对象父类的变量能否引用子类的对象？能。 子类的变量能否引用父类的对象？不能。 父类的变量称为子类对象的上转型对象。 Person p;p=new Student(); Student s;s=new Student(); p=s; 上转型对象操作说明上转型对象不能操作子类新增成员上转型对象可以操作从父类继承的成员，或在子类中重写的父类成员。上转型对象在被改写的成员时，调用子类成员，而非父类成员。上转型对象通过强制类型转换成为子类对象。 多态性在程序中同一符号或名字在不同情况下具有不同解释的现象称为多态性。表现在两方面：方法的重载。 对象的上转型对象。子类可以改写父类的方法，而上转型对象（父类的对象）可以调用改写后的方法。不同的子类可能改写的内容不同。比如：动物类中的cry()方法，在子类“猫”中可以改写为“喵喵”，而在子类“狗”中可以改定为“汪汪”。猫类的和狗类的上转型对象在调用cry()方法时是各不相同的。 1234567访问权限种类，级别顺序子类子类继承成员的隐藏和重写对象的上转型对象多态性 类的继承相关知识点子类的构造方法与父类构造方法之间的关系：子类构造方法的第一条语句隐含调用父类的构造方法—super();子类继承父类中的非private成员（在同一个包中）子类继承父类中的非private与非友好成员（不同的包中）子类中的成员与父类中成员相同，则隐藏父类成员父类的对象变量（对象的上转型对象）可以引用子类的对象 抽象类与抽象方法 类的多态 抽象方法与抽象类 多态性在程序中同一符号或名字在不同情况下具有不同解释的现象称为多态性。表现在两方面：方法的重载。 对象的上转型对象。子类可以改写父类的方法，而上转型对象（父类的对象）可以调用改写后的方法。不同的子类可能改写的内容不同。比如：动物类中的cry()方法，在子类“猫”中可以改写为“喵喵”，而在子类“狗”中可以改定为“汪汪”。猫类的和狗类的上转型对象在调用cry()方法时是各不相同的。 抽象方法与抽象类用关键字abstract修饰的类就是抽象类。 没有方法体的方法，且首部用关键字abstract修饰，就是抽象方法。声明抽象方法的格式： [修饰符…]abstract 返回值类型 方法名([形参列表]); 123456789101112public abstract class AAnimal &#123; public String name; public int age; public void print() &#123; System.out.println(&quot;名字:&quot;+name); System.out.println(&quot;大小:&quot;+age); &#125; public abstract void run(); public abstract void cry();&#125; 抽象方法与抽象类使用说明 含有抽象方法的类必须定义为抽象类。 123456789101112public class AAnimal //错误&#123; public String name; public int age; public void print() &#123; System.out.println(&quot;名字:&quot;+name); System.out.println(&quot;大小:&quot;+age); &#125; public abstract void run(); public abstract void cry();&#125; 不能由抽象类直接创建对象。它只能做为父类使用，由它派生的子类必须实现抽象类中所有的抽象方法，才能创建对象。 抽象方法的实现：子类重写父类的抽象方法，增加方法体，使之成为一个非抽象方法。可以空实现。 12345678class Test&#123; public static void main(String[]args) &#123; AAnimal a; a=new AAnimal(); //错误 &#125;&#125; 12345678910111213141516171819202122232425class Dog extends AAnimal&#123; String type; public Dog() &#123; type=&quot;宠物狗&quot;; &#125; public void run()&#123; &#125; public void cry() &#123; System.out.println (&quot;汪汪叫&quot;); &#125;&#125;class Test&#123; public static void main(String[]args) &#123; Dog a; a=new Dog(); a.name=&quot;欢欢&quot;;a.age=2; a.print(); a.cry(); System.out.println (&quot;这是一只&quot;+a.type); &#125;&#125; 如果子类没有实现抽象基类(父类)中所有的抽象方法，则子类也必须定义成一个抽象类。即：抽象的子类也必须使用修饰符：abstract 可以将没有任何抽象方法的类声明为abstract，避免由这个类直接创建任何的对象。 12345678910111213abstract class Dog extends AAnimal&#123; String type; public Dog() &#123; type=&quot;宠物狗&quot;; &#125; //public void run()&#123; &#125; public void cry() &#123; System.out.println (&quot;汪汪叫&quot;); &#125;&#125; 12345678910111213141516class Bird extends AnimalClass//定义鸟类继承动物类&#123; public Bird()//构造方法初始化 &#123; name=&quot;麻雀&quot;; age=3; &#125; public void run()//实现父类的抽象方法 &#123; System.out.println(&quot;会飞&quot;); &#125; public void cry() &#123; System.out.println (&quot;叽叽喳喳&quot;); &#125;&#125; 小结用abstract关键字来修饰一个类时，这个类叫做抽象类；用abstract来修饰一个方法时，该方法叫做抽象方法。 abstract类必须被继承，abstract方法必须被重写。 抽象类不能被实例化（直接创建对象）。 抽象方法只需声明，而不需实现（无方法体）。 接口及应用接口的基本概念接口定义接口实现接口应用举例理解接口Jar文件（略） 接口的概念在《Thinking in Java》一书中，作者对接口有这样的描述：“接口（interface）比抽象（abstract）的概念更进了一步。你可以把一个接口看成是一个纯的抽象类。” 为什么使用接口？ 1、Java中不允许类的多继承，但在解决实际问题过程中，仅仅依靠单一继承在很多情况下都不能将问题的复杂性表述完整。 通过接口可以实现多继承。 如：Father类有playFootball()，Mother类有sing()，如果采用类的继承来产生一个Son类，则它只能从一个类中继承。要么继承Father，要么继承Mother。 2、接口在面向对象的设计与编程中应用非常广泛，特别是实现 软件模块间的连接 方面有着巨大的优势。 接口的声明 及注意事项如果一个抽象类中所有的方法都是抽象的，就可以将这个类用另外一种方式来定义，也就是接口定义。12345[public] interface 接口名 [extends 父接口名列表]&#123; 数据类型 常量名=常数; 返回值 方法名([参数列表]);&#125; 几点说明： 1、interface是接口的关键字，定义接口和定义类相似。并被编译为class文件。2、接口的访问控制符只有public，如果使用public修饰符，则可以被所有类和接口使用，且接口名与文件名相同。如果不使用public，则接口只能被同一个包中的类和接口使用。3、接口中所有的方法都是public abstract 即公共的抽象方法。4、接口中可以有数据成员，这些数据成员默认都是public static final即公共类常量。 接口声明实例1234567891011121314151617181920//Father.java 文件名public interface Father//父亲会踢球&#123; public abstract void playFootball ();&#125;//Mother.java 文件名public interface Mother//母亲爱唱歌&#123; public abstract void sing();&#125;//Flyable.java 能飞的动物public interface Flyable &#123; void fly();&#125;//Talkable.java 能说话的动物public interface Talkable &#123; void talk();&#125; 接口的实现与多继承接口的实现通过类来完成，在定义类时使用“implements 接口名列表”短语，并在类体中实现接口中的抽象方法。接口和实现类之间的关系实质上是继承的关系1、一个类可以实现多个接口，从而实现多继承。 1234567891011121314151617public class SmartChild implements Father,Mother&#123; public void playFootball() &#123; System.out.println(&quot;我会踢足球！&quot;); &#125; public void sing() &#123; System.out.println(&quot;我会唱歌！&quot;); &#125; public static void main(String[] args) &#123; SmartChild child=new SmartChild(); child.playFootball(); child.sing(); &#125;&#125; 类实现接口时的注意事项注意：在类声明部分，用implements关键字指明该类将要实现哪些接口。实现接口的类必须在类体中给出所有方法的实现，否则该类应该声明为抽象类。接口中的方法都是public的，所以实现方法时也必须加上public，否则编译报错。 总结：一个接口可以继承另一个接口Java中不允许类的多继承，但允许接口的多继承在java中一个类可以实现多个接口一个类在继承另一个类的同时，可以实现多个接口。 将小程序改为应用程序1234567interface Computable&#123; final int MAX=100; void speak(String s); int f(int x); float g(float x,float y);&#125; 1234567891011121314151617181920class China implements Computable&#123; int xuehao; public int f(int x) &#123; int sum=0; for (int i = 1; i&lt;=x; i++) &#123; sum+=i; &#125; return sum; &#125; public float g(float x,float y) &#123; return 6; &#125; public void speak(String s) &#123; &#125;&#125; 接口应用实例—程序模块间的连接123456789101112131415161718192021222324//PCI接口，可看成一种标准interface PCI &#123; void setName(String s); void run(); &#125;//符合PCI接口标准的网卡，即实现了PCIclass NetworkCard implements PCI &#123; String name; public NetworkCard() &#123; name=&quot;D-Link&quot;; &#125; public void setName(String s)//实现接口中的抽象方法 &#123; name=s; &#125; public void run()//实现接口中的抽象方法 &#123; System.out.println(name+&quot;网卡已开始工作！&quot;); &#125;&#125; 小结 1、接口的概念：如果一个方法中的所有方法都是抽象的，则可以以接口的形式进行定义。2、接口定义：使用interface关键字进行定义，数据成员隐含修饰符：public static final，方法隐含修饰符：public abstract3、接口实现：通过类来实现，使用implements短语。4、接口应用。 时间、日期和Math类数组声明数组：int [] a; 或 int a[]; 数组创建：a=new int[10]; 数组静态初始化：int[]a={1,0,2,3,4,5,5,7,4,12}; 数组元素引用：a[0]…a[9] 字符串 String类String构造方法String类的成员方法：length()、equals()等 123456字符串与数值类型转换Date类SimpleDateFormat类Calendar类Math类AWT工具集简介 123456789lang包中类- Integer类—parseInt()- Float类—parseFloat()- Double类—parseDouble()- 将字符串转换为数值时，字符串必须是合法数值格式的字符串，否则会产生转换异常。数值转换为字符串- String.value(3.14159)- 3.14159+&quot;&quot; Date、SimpleDateFormat类Date d=new Date();获取系统日期某个瞬间。SimpleDateFormat类：对日期进行格式化。format()方法可以对指定日期进行格式化。 12345678910111213import java.util.*;import java.text.*;class E1&#123; public static void main(String[]args) &#123; Date d=new Date(); SimpleDateFormat sdf= new SimpleDateFormat(&quot;yyyy年MMMdd日HH时mm分&quot;); System.out.println (sdf.format(d)); &#125;&#125; Calendar类该类的静态方法getInstance()可获取当前系统日历：Calendar d=Calendar.getInstance(); 通过该类提供的get(int field)方法来获取日历中各字段的值。field应该使用该类的相关常量字段。 Math类常用方法参考javaAPI文档猜数游戏JOptionPane中的showInputDialog()方法。 猜数游戏1234567891011121314151617181920212223import javax.swing.*;class E3&#123; public static void main(String[]args) &#123; int num,count=0; num=(int)(Math.random()*20+1); int i=Integer.parseInt(JOptionPane.showInputDialog(&quot;请输入你猜1-20的数&quot;)); while(i!=num&amp;&amp;count&lt;=6) &#123; count++; if (i&gt;num) i=Integer.parseInt(JOptionPane.showInputDialog(&quot;第&quot;+count+&quot;次！太大了，请重新输入&quot;)); else i=Integer.parseInt(JOptionPane.showInputDialog(&quot;第&quot;+count+&quot;次！太小了，请重新输入&quot;)); &#125; if(i==num) &#123; JOptionPane.showMessageDialog(null,&quot;猜对了&quot;); System.exit(0); &#125; &#125;&#125; Java 的GUI概述123451、图形用户界面GUI（Graphics User Interface)，就是应用程序提供给用户操作的图形界面，包括窗口、菜单、按钮、工具栏和其他各种界面元素。2、在Java里有两个包为GUI设计提供了丰富的功能：awt(abstract windows toolkit)包和Swing包。3、awt是java的早期版本，组件种类有限，只提供基本的GUI设计工具。4、Swing包是SUN公司对早期版本的改进版本，它不仅包括AWT中所有部件，并且提供了更加丰富的部件和功能，它足以完全实现GUI设计所需的一切功能。5、Swing会用到AWT中许多知识，掌握了AWT，也就基本掌握了Swing。 初识awt实例12345678910111213import java.awt.*;//引用awt包中的组件类public class TestFrame&#123; public static void main(String[]args) &#123;//产生一个具有标题栏的框架窗口 Frame f=new Frame(“我的框架窗口”); Pane p=new Pane();//创建一个面板 p.add(new Button(“确定”));//向面板中填加按钮 f.add(p);//向窗口中填加面板 f.setSize(300,300);//设置窗口的大小 f.show();//显示窗口 &#125;&#125; 图形用户界面程序中可以使用各种各样的图形界面元素，如文本框、按钮、列表框、对话框等，我们将这些图形用户界面元素称为GUI组件。 ATW为各种GUI组件提供了对应的Java组件类，这些组件类都是java.awt.Component的直接或间接的子类。 GUI组件分类在AWT的概念中，窗口系统中所显示的各种对象都统称为“GUI组件”（Component）。组件有基本组件和容器组件之分。 1231、顾名思义，基本组件是不可再分割的组件，基本组件各自都有它们特定的功能。基本组件是构成图形用户界面的基本元素。2、容器组件是用来包含其他组件的，故称之为容器（container）。用户可以把各种组件放入到容器中，也可以把容器放到另一个容器中，从而形成具有层次的组件结构。 3、AWT提供了的容器类有：Frame类、Dia1og类和Panel类。除了AWT提供的容器外，Applet类也是一个容器，它是Panel类的一个子类。 AWT 标准组件图示基本组件1234567891011Button 按钮Checkbox 复选框CheckboxGroup 单选框Choice 下拉式列表List 列表Menu 菜单TextField 文本框Label 标签Canvas 画布TextArea 多行文本框ScrollBar 滚动条 Applet小程序编写及运行Java有两种类型的程序：应用程序(application)、小应用程序(applet)。 Java应用程序只有一个程序入口—main方法，通过JVM调用执行，小应用程序是嵌入到网页中由浏览器调用执行的，其中不必包含main方法。 回忆一下小应用程序的书写格式 123import java.applet.*; public class MyApplet extends Applet&#123;&#125; 每个小应用程序中必须有一个主类，冠以public，并且从Applet类继承。小应用程序的运行：将小应用程序源文件编译成字节码文件 12编写html文件，使用&lt;applet&gt; 标签将字节码文件嵌入其中用浏览器打开html文件或者用appletviewer小程序浏览器。 身手123456789import java.applet.Applet;import java.awt.*;public class Test extends Applet&#123; public void paint(Graphics g) &#123; g.drawOval(10,10,100,100); &#125;&#125; 12&lt;!-- test.html文件--&gt;&lt;applet code=Test height=120 width=400&gt;&lt;/applet&gt; 任何与绘图有关的类： 1java.awt.Graphics，Graphics类的对象不是由new产生的， 一般由系统直接将生好的Graphics对象当作方法的参数，交给程序设计者去处理.例如: public void paint(Graphics g)，每一个GUI组件都有paint方法，利用Graphics对象可以在组件中绘制图像或字符串。 Html标签基本形式： 1&lt;applet code=Test height=120 width=400&gt;&lt;/applet&gt; 123&lt;Applet 属性&gt;Code：指出要加载的类名，直接写类名，则要求类与html文件在同一路径下。Height、width：指出applet显示区的高和宽 字符串转换为数值获取系统当前日期及时间Math类的静态方法AWT包简介Applet 类简单 首先通过JavaAPI文档，学习以下内容 12345javax.swing包中的类JOptionPane中的showInputDialog()方法java.lang包中的Integer类中的parseInt()方法java.util包中的Date类java.text包中的SimpleDateFormat类java.lang包中的Math类中的random()方法 数组和字符串类的定义类的封装特性类的继承特性类的多态特性 回顾—类的定义类的严格定义及修饰字 12345678[类的修饰字] class 类名称 [extends 父类名称][implements 接口名称列表] &#123; 变量定义及初始化； 方法定义及方法体；&#125; 类体，其中定义了该类中所有的变量和该类所支持的方法，称为成员变量和成员方法。 12类的修饰字： [public] [abstract | final] 缺省方式为 package 回顾—封装性封装性与访问级控制类的一个优势在于类可以保护它的成员变量和成员函数不会被其它对象随意访问到在Java程序里，可以为成员变量和函数设定四级访问级 1234privateprotectedpublicdefault（缺省） 回顾—继承继承性是面向对象程序设计语言的另一基本特征，通过继承可以实现代码的复用。 继承而得到的类为子类，被继承的类为父类，父类包括所有直接或间接被继承的类。 123456Java中不支持多重继承。通过在类的声明中加入extends子句来创建一个类的子类class SubClass extends SuperClass&#123;&#125; 回顾—类的多态性多态是指在一棵继承树中的类可以有多个同名但不同方法体以及不同形参的方法。两种情况 覆盖 重载 掌握数组的定义和使用123Java数组类的定义和使用难点多维数组的定义和使用 Java中的数组数组的特点 数组：可以容纳很多同类型的数据的结构数组中存放的每个数据称为数组的一个元素，元素的数量称为数组的长度在Java语言中，数组的长度是在数组创立时就固定了的，以后不能更改 数组的定义123456789一维数组变量的声明格式有如下两种:(1)数组元素的数据类型[ ] 变量名;(2)数组元素的数据类型 变量名[ ];示例:int [ ] c; String[ ] names; int c[ ]; String names[ ]; 内存分配Java数组实际上也是对象，所以可通过new 关键字来创建 1234567int[ ] c; // 声明c = new int[12]; // 创建对象，并分配内存声明时不必指定数组的大小上面的两个语句可以简化成一个语句int[ ] c = new int[12]; 数组初始化基本数据类型的元素初始化为0值或false 非基本数据类型的元素初始化为null 可以采用循环结构初始化数组 123456double[ ] squares; squares = new double[100]; for (int i=0; i &lt; squares.length; i++)&#123; squares[i] = i*i; &#125; 通过初始化语句创建数组Java语言允许通过数组的初始化语句创建数组 1int[ ] n = &#123; 10, 20, 30, 40, 50 &#125;; 上面语句创建了一个含有五个元素的数组 下标值分别为0, 1, 2, 3, 4 这时不需要运算符new 数组的访问当定义了一个数组，并用运算符new为它分配了内存空间后，就可以引用数组中的每一个元素了。元素的引用方式为 arrayName[index] index为数组下标，可以是整型常数或表达式， 1如：arrayName[1], arrayName[i], arrayName[6*i]等。 下标是0序的，即从0开始，一直到数组长度减1。 12345678910111213int[ ] c = new int[12];c 是数组名如何获得数组的长度?c.length第一个数组元素的下标为0 使用数组可以通过数组名与下标每个数组元素类似于普通的变量c[ 0 ] = 3;c[ 0 ] += 5; 注意事项 当通过循环遍历数组时下标永远不要低于0下标永远要比数组元素个数小 1当数组下标出错，Java 产生 ArrayIndexOutOfBoundsException 多维数组最常用的多维数组是二维数组 1int[ ][ ] a = new int[3][4]; 1234567891011121314class J_FillArray&#123; public static void main (String args[]) &#123; int[ ][ ] matrix = new int[4][5]; for (int row=0; row &lt; 4; row++) &#123; for (int col=0; col &lt; 5; col++) &#123; matrix[row][col] = row + col; &#125; // 内部for循环结束 &#125; // 外部for循环结束 &#125; // 方法main结束&#125; // 类J_FillArray结束 通过初始化语句创建数组 123456double[ ][ ] c = &#123; &#123;1.0, 2.0, 3.0, 4.0&#125;, &#123;0.0, 1.0, 0.0, 0.0&#125;, &#123;0.0, 0.0, 1.0, 0.0&#125; &#125;; 注意事项Java的多维数组实际上是数组的数组即创建以数组为元素的数组 1意味着: 二维数组的每一行可以具有不同的列数 示例 123456int a[ ][ ];a = new int[ 3 ][ ]; // allocate rowsa[ 0 ] = new int[ 3 ]; // allocate row 0a[ 1 ] = new int[ 2 ]; // allocate row 1a.length 行数a[ i ].length 第i行列数 要点 数组与字符串接口及接口声明 interface接口中的方法都是：public abstract接口中的数据都是：public static final接口可以直接多继承：extends 父接口列表 接口实现 在类中实现接口：implements 接口名列表在类中要改写接口中的所有抽象方法一个类可以实现多个接口一个类可以从父类继承的同时实现接口 接口应用 只关心功能的有无，不关心功能的具体实现 1234567数组的概念数组声明数组创建数组元素引用数组元素初始化字符串说明及初始化字符串处理 数组数组是相同类型的数据元素按顺序组成的一种复合数据类型。数组中的每个元素通过数组名加下标进行引用。数组分为一维数组和多维数组。 数组的特点： 123(1)一个数组中所有的元素应该是同一类型；(2)数组中的元素是有顺序的；(3)数组中的一个元素通过数组名和数组下标来确定。 数组的使用过程：123(1)声明数组(2)创建数组(3)使用数组元素 声明数组一维数组声明的格式： 12类型 数组名[ ]；或 类型[ ] 数组名；数组名为Java标识符。“[ ]”部分指明该变量是一个数组类型变量。其中不能有元素个数说明。 二维数组声明格式： 12类型 数组名[] []；或 类型 [] []数组名；类型 []数组名[]； 1234如： int a[];或 int[]a; String[]args;或 String args[] int a[][];或int [][]a;或 int []a[]; Person p[]; 创建数组创建数组—为数组分配内存空间。格式：数组名=new 类型[元素个数];例： 1234int []num;int myTwo[][];num=new int[3];myTwo=new int[2][3];myTwo=new int[2][]; 声明和创建数组可以合并 类型 数组名[]=new 类型[元素个数]; 例： 1int []num=new int[3]; 创建数组时，自动为数组元素初始化。 数组元素的使用数组元素的标识： 1234数组名[下标]下标使用范围从0开始到（元素个数-1）为止。其中下标为非负的整型常数或表达式，其数据类型只能为byte,short,int, 而不能为long。数组名[下标1][下标2] 12345678910111213141516class ArrayTest&#123; int arr[]; public static void main(String[]args) &#123; ArrayTest a=new ArrayTest(); a.arr=new int[3]; a.arr[0]=3; a.arr[1]=4; a.arr[2]=5; for (int i = 0; i&lt;3; i++) &#123; System.out.println (a.arr[i]); &#125; &#125;&#125; 数组初始化new分配内存时自动初始化数组 通常在创建数组时，Java会使每个数组元素初始化为一个默认值。在许多情况下，并不希望数组的初值为默认值，此时，就需要用赋值语句来对数组进行初始化。 静态初始化：声明数组时直接赋初值(不需要new)123int arr1[]=&#123;2,4,6,8&#125;;char [] arr2=&#123;‘字’,‘符’,‘数’,‘组’&#125;;String []arr3=&#123;&quot;how &quot;,&quot;are &quot;,&quot;you!&quot;&#125;; 元素个数由{}中给出的元素个数来确定 二维数组初始化1int arr3[][]=&#123;&#123;1,2,3,4&#125;,&#123;2,3,4&#125;,&#123;5,3&#125;&#125;; 思考和验证：这时可用数组元素有哪些呢？ 使用数组注意事项定义数组：无论用什么方式定义数组，都不能指定长度，int a[5];是错误的 使用数组中的元素：必须对数组引用变量赋一个有效的数组对象（通过new产生或是用{ }静态初始化产生）后，才可以引用数组中的每个元素。 获取数组的长度：数组名.length 字符串Java使用java.lang包中的类String来声明和创建一个字符串变量，因此字符串变量是类类型的变量，是一个对象。（要求理解） 字符串常量声明字符串变量 创建字符串（要求掌握） 可以将一个字符串常量直接赋值给字符串变量，如： 1String s;s=&quot;we are student!&quot;; 也可以使用String类的构造方法来创建字符串，如： String s;s=new String(“we are student!”); String类的构造方法 获取字符串长度：String对象的length()方法。 String s=”你好”;s.length()值为2。 例：字符串的声明与创建 12345678910111213141516171819class StringTest&#123; String name; String sex; void out() &#123; System.out.println (&quot;name:&quot;+name); System.out.println (&quot;sex:&quot;+sex); &#125; public static void main(String[]args) &#123; StringTest st=new StringTest(); char ch[]=&#123;&apos;b&apos;,&apos;o&apos;,&apos;y&apos;&#125;; st.name=new String(&quot;Rose&quot;); st.sex=new String(ch1); st.out(); &#125;&#125; 字符串比较==：比较两个字符串是不是同一个对象equals()方法：比较两个字符串的内容是否相同比较方法：s1.equals(s2)，s1和s2分别是两上字符串变量。 12345678910111213public static void main(String[]args) &#123; StringTest st=new StringTest(); char ch[]=&#123;&apos;b&apos;,&apos;o&apos;,&apos;y&apos;&#125;; st.name=new String(&quot;Rose&quot;); if(st.name==&quot;Rose&quot;) System.out.println (&quot;yes&quot;); else System.out.println (&quot;no&quot;); st.sex=new String(ch); st.out(); &#125; 字符串简介equalsIgnoreCase()返回值类型：boolean忽略大小写比较 startWith()、endWith()返回值类型：boolean检查字符串前缀、后缀是否为指定字符串 compareTo(String s)返回值类型：int按字典序比较当前字符串与s的大小，返回值&gt;0、=0、&lt;0 1234567891011121314151617181920212223class Sort&#123; public static void main(String[]args) &#123; String a[]=&#123;&quot;boy&quot;,&quot;apple&quot;,&quot;Applet&quot;,&quot;girl&quot;,&quot;Hat&quot;&#125;; for (int i=0;i&lt;a.length-1;i++) &#123; for(int j=i+1;j&lt;a.length;j++) &#123; if(a[j].compareTo(a[i])&lt;0) &#123; String temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; for (int i = 0; i&lt;a.length; i++) &#123; System.out.print(&quot; &quot;+a[i]); &#125; &#125;&#125; 字符串操作检索:indexOf()截取:substring()替换:replace() 字符串与数值转换字符串转为整数 Integer类中的parseInt()方法parseByte()、parseShort()、parseLong() 字符串转换为float或double型 Float类中的parseFloat()方法Double类中的parseDouble()方法 数值转换为字符串 String类中的valueOf()方法 对象的字符串表示 对象的toString()方法 StringTokenizer类分析字符串 Character类 字符串与字符、字节数组 面向对象程序设计回顾—类的定义 类的严格定义及修饰字 12345[类的修饰字] class 类名称 [extends 父类名称][implements 接口名称列表] &#123; 变量定义及初始化； 方法定义及方法体；&#125; 类体，其中定义了该类中所有的变量和该类所支持的方法，称为成员变量和成员方法。 123类的修饰字： [public] [abstract | final]缺省方式为 package 类的成员函数定义语法规范1234[方法修饰字] 返回类型 方法名称(参数1,参数2,…) [throws exceptionList]&#123;(statements;) //方法体：方法的内容&#125; [public | protected | private ] [static] [final | abstract] [native] [synchronized] 返回类型可以是任意的Java数据类型，当一个方法不需要返回值时，返回类型为void。 参数的类型可以是简单数据类型，也可以是引用数据类型（数组、类或接口），参数传递方式是值传递。 方法体是对方法的实现。它包括局部变量的声明以及所有合法的Java指令。局部变量的作用域只在该方法内部。 回顾—对象的初始化12345678（1）对象的生成 通过new操作符生成一个对象；例如： Car demoCar; demoCar = new Car();（2）对象的构造过程 为对象开辟空间，并对对象的成员变量进行缺省的初始化； 对成员变量进行指定的初始化； 调用构造方法。 重点不同访问修饰符的应用Java中类继承的定义难点类的继承特性 包“包”是由一组类和接口所组成的具有一定功能的集合简单地说，将一组功能相关的类和接口打包起来形成的整体，就是包两个类如果名字相同，只要所属的包不同，Java就会认为它们是不同的类 创建包在定义类或接口的源文件开始加入“package”关键字和包名，就将类或接口放到包里了如果两个java源文件的开头都有相同的包名，则意味着这两个源文件中的所有类和接口都属于同一个包 访问包中的类访问公开类的方法(1) 用类的全名（包名+类名）访问；(2) 导入包中的某个类；(3) 导入包中的所有类。如果某个类只访问一次，那么可以直接使用类的全名，形式是“包名.类名” 用“import”关键字导入一个类：1import PackageName.ClassName; 一次性导入所有类的方法：1import PackageName.*; 管理Java的包Java系统建议的文件存储方式就是按照包名将源文件和二进制代码文件分级存放将源文件放到与包名相同的路径下，包名对应子目录名 使用Java的包12345设定Rectangle.java放在“graphics”子目录下编译源文件的命令如下：javac graphics\Rectangle.java执行程序时，用小圆点“.”分隔包名和类：java graphics.Rectangle CLASSPATH参数如果你的Java包都放在一个固定的目录下，轻易不会改变它，那么你可以在操作系统中设置“CLASSPATH”环境变量编译和运行Java程序时，不需要指定包路径参数，系统会自动从环境变量中读取 封装封装把对象的所有组成部分组合在一起 封装定义程序如何引用对象的数据，封装实际上使用方法将类的数据隐藏起来，控制用户对类的修改和访问数据的程度。 封装性封装性与访问级控制类的一个优势在于类可以保护它的成员变量和成员函数不会被其它对象随意访问到在Java程序里，可以为成员变量和函数设定四级访问级：privateprotectedpublicdefault（缺省） 访问控制级别123456private（私有级）private是最严格的访问控制级私有变量只能在它所在的类内部被访问到它用于定义只在类内部使用的成员变量成员变量，如果从外界随意改变它的值可能会造成不稳定的情况成员函数，如果从外界调用，可能会危害到对象的状态或程序的运行 1234protected（保护级）被定为保护级的成员可以被它所属的类、所属类的子类，以及处于同一个包里的其它类访问到如果一个成员变量或成员函数可以被它的子类或相关的类访问，而不能被无关类访问的话，就可以用保护级保护级就像家庭秘密，可以让家庭成员知道，也不介意让几个亲密朋友知道，但你不想让任何外人知道 12345public（公开级）公开级是限制最少的访问级，任何类，不管它在哪个包里，都能够访问公开级的成员公开级使用最方便，实际使用得也最多需要注意的是：对于成员变量或成员函数，只有当你确认外界的类访问甚至修改它不会造成不希望的后果时，才使用公开级公开级类似于公开张贴的信息，其中没有个人或家庭隐私，你不介意任何人知道 123456default（缺省级）包访问级是成员的缺省访问级如果没有定义访问级，那么它就是包访问级权限：可以被属于同一个包的其它类所访问，但不能被其它包的类所访问如果这个类的子类在其它包，则子类不能继承和访问父类中包访问级的成员这一访问级假设在同一个包里的其它类都是可信任的朋友，但子类反而不能信任 类成员封装性总结继承继承性是面向对象程序设计语言的另一基本特征，通过继承可以实现代码的复用。继承而得到的类为子类，被继承的类为父类，父类包括所有直接或间接被继承的类。Java中不支持多重继承。通过在类的声明中加入extends子句来创建一个类的子类： 1234class SubClass extends SuperClass&#123;&#125; 子类可以继承父类中访问权限设定为public、 protected、 default的成员变量和方法，但是不能继承访问权限为private的成员变量和方法。一个类可以从另一个类中继承它的成员变量和函数，前者称为子类，后者称为父类。类的这种特点称为继承性 继承类的继承通过extends关键字来说明，extends关键字跟在类名称后面，形式如下： 1class SubClass extends FatherClass &#123; &#125; 其中SubClass是子类名，FatherClass是父类名 继承的特点类的继承性的特点在Java中，一个类只能有一个父类Java只支持单继承，而不支持多重继承单继承的类子代相承，会形成一棵继承树，结构较为清晰多重继承会形成一张复杂的继承网，结构复杂，容易出错如果需要多重继承，Java提供了一种接口技术，可以部分地实现多重继承的功能 类的继承性的特点在Java中定义的所有类都直接或间接地是Object类的子类。以Object类为根，所有Java类形成一棵类继承树 类的继承性的特点子类可以继承的部分：(1) 父类中公开级的成员；(2) 父类中保护级的成员；(3) 如果子类和父类在同一个包里，则子类继承父类中缺省的包访问级的成员； 子类不能继承的部分：(1) 父类中私有级的成员；(2) 如果不在同一个包里，则缺省级的成员；(3) 同名的成员函数或成员变量； 构造函数的继承特点构造函数是比较特殊的一类在继承时，构造函数不会被继承，也不会被覆盖父类和子类的构造函数依然是独立存在，并且分别发挥着作用 父类相当于一个硬球，子类则是在球外的包装构造对象时显然应当先构造最内部的硬球，也就是最顶端的父类之后再从里往外一层层地构造外包装，直到最后整个对象都构造起来如果父类的构造函数有参数，那么就需要用super关键字，它指代父类 类与对象3.1 面向对象的基本思想和基本概念3.2 案例3.3 类的声明与对象的创建3.4 继承3.5 包的使用3.6 编程实例实训三 面向对象程序设计习题三 面向对象的基本思想和基本概念大部分传统的高级程序设计语言(如C语言)都是过程化的语言，在软件开发的过程中采用自顶向下逐步细化的方法将整个程序描述为一个过程。对于小型的系统，这种方法是可行的，但是当系统规模很大，复杂度很高时，用过程化方法描述变得十分困难，面向对象的软件开发方法可以很好地解决这个问题。 目前，面向对象的方法在软件开发工作中得到了广泛的应用，越来越多的软件开发工具开始支持面向对象的开发方法。Java语言就是一种面向对象的程序设计语言，要充分利用Java语言的特性首先应该理解面向对象的基本思想。 面向对象的基本思想面向对象的基本思想认为系统是由若干个对象构成的，每个对象都有各自的内部状态和运动规律，不同对象之间通过消息传送相互作用和联系。 采用对象的观点看待所要解决的问题，并将其抽象为系统是极其自然与简单的，因为它符合人类的思维习惯，使得应用系统更容易理解。同时，由于应用系统是由相互独立的对象构成的，使得系统的修改可以局部化，因此系统更易于维护。 例如，对于一个企业的管理信息系统，将整个系统描述成一个过程是难以想像的，但可以分别描述各个部门的特性及工作流程，然后描述部门之间的联系。这里各个部门就是组成企业的对象，当然，在描述每个部门特性时可以采用同样的方法。 对象与类对象是面向对象方法中的一个重要概念。所谓对象，是指客观世界中事物在计算机领域中的抽象，用一组数据和施加于该组数据上的一组操作(行为)来描述。 对象的描述通常由三个部分组成： (1) 私有的数据结构。用于描述对象的内部状态。(2) 处理，称为操作或方法。它是施加于数据结构之上的。(3) 接口。这是对象可被共享的部分，消息通过接口调用相应的操作。接口规定哪些操作是允许的，它不提供操作是如何实现的信息。 实际上，采用面向对象方法进行系统分析与设计时要描述的并不是一个个具体的对象。对于一个具体的系统而言，可能存在很多具有相同特征的对象，而且通常系统中对象的数目是不确定的。 例如，对于一个学籍管理系统，存在许多学生对象，它们具有相同的结构特征和行为特征，只是表示内部状态的数据值不同。为了描述这种相同结构特征和行为特征的对象，面向对象方法引入了类的概念。这一点与人们在认识客观世界的事物时所采取的分类思想相同。人们在认识事物时总是将具有相同特征的事物归为一类，属于某类的一个事物具有该类事物的共同特征。 类是对一组具有相同特征的对象的抽象描述，所有这些对象都是这个类的实例。对于学籍管理系统，学生是一个类，而一个具体的学生则是学生类的一个实例。一个类的不同实例具有相同的操作或行为的集合和相同的信息结构或属性的定义，但属性值可以不同；不同的实例具有不同的对象标识。对于学生类中的每一个对象，描述它们所使用的数据结构相同，但是值不同。在程序设计语言中，类是一种数据类型，而对象是该类型的变量，变量名即是某个具体对象的标识。 因此，一个类的定义至少包含以下两个方面的描述： (1) 该类所有实例的属性或结构的定义。(2) 该类所有实例的操作(或行为)的定义。 类是构成Java语言程序的基本单位，一个完整的Java程序是由若干个类构成的，每个类由若干数据和方法构成，一个类的定义包含属性(数据)和方法(行为)两部分内容。 继承性人们在对客观世界的事物进行描述时，经常采取分类的方法。类是有层次的，即某个大类的事物可能分为若干小类，而这些小类可能又分为若干个更小的类。 面向对象思想采纳了事物分类的层次思想，在描述类的时候，某些类之间具有结构和行为的共性。例如，描述教师与学生时均需描述姓名、年龄、身高、体重等属性，将这些共性抽取出来，形成一个单独的类——人，用于描述教师类和学生类的共性。类人的结构特征和行为特征可以被多个相关的类共享，教师类和学生类继承了类人的结构和行为特征。 Java语言支持类的继承，可以从一个类中派生出一个新的类，原来的类称为超类或父类，新类称为超类的子类或派生类。子类的对象具有超类对象的特征，同时又有其自身特有的特征。子类又可以派生出新的子类，子类的子类也称为派生类。 利用类之间的继承关系，可以简化类的描述，提高软件代码的可重用性。在设计一个新类时，不必从头设计编写全部的代码，可以通过从已有的具有类似特性的类中派生出一个类，继承原有类中的部分特性，再加上所需的新特性。 另外，人们在对客观世界的事物进行分类时，一个事物可能属于多个类，具有多个类的特性。例如，一个黑人学生，他既属于学生类，又属于黑人类。这种情形在面向对象方法中称为多继承，即一个类同时从多个类中派生出来，此时类的层次结构是网状的。 Java语言为了不使语法过于复杂，不支持多继承，只允许子类有一个超类，称为单继承。不过，Java语言提供了接口机制，可以在一定程度上模拟多继承。 多态性多态性是面向对象系统的又一重要特性。所谓多态，即一个名词可具有多种语义，如一个方法名有多种功能，或者相同的接口有多种实现方法。 在Java语言中，多态性通过方法的重载、覆盖和接口来实现。方法的重载是指多个方法具有相同的名称 ，但各个方法的参数表不同，即参数的类型和参数的数量不同。 覆盖是指在类的派生过程中，子类与超类的方法不仅名称相同，参数也完全相同，但它们的功能不同，这时子类中的方法覆盖了超类中同名的方法。 接口实际上是一种特殊的类，只给出方法的名称、参数和返回值的类型，方法的具体实现在实现该接口的类中给出。 封装封装是一种信息隐藏技术，对象内部对用户是隐藏的，不可直接访问；用户只能见到对象封装界面上的信息，通过对象的外部接口访问对象。用户向对象发送消息后，对象根据收到的消息调用内部方法作出响应。封装的目的在于将对象的使用者和对象的设计者分开，使用者无需知道对象内部实现的细节，只需知道对象接收的消息即可。 Java语言通过类来实现封装，类中定义的属性和方法分为私有的和公有的，私有属性和方法不能在对象的外部访问，只能由类内的方法访问。而在对象的外部，只能访问对象的公有属性和方法，只需要知道公有属性的数据类型和名字以及公有方法的原型，至于这些方法是如何实现的对象外部并不需要知道。这就像人们在使用电视机时只需要通过遥控器来操作即可，至于电视机内部细节用户则无需知道，这里遥控器上的按钮实际上就是电视机的外部接口。 对象的封装特性可以提高模块之间的独立性，使得系统易于调试和维护。 类的声明与对象的创建类声明的基本语法 1．类的声明Java语言类声明的完整语法很复杂，下面先介绍最简单的形式： 123class 类名&#123;类体&#125; java的课程体系Java语法基础Java面向对象的编程Java的高级编程接口：4个专题Java图形GUI编程多线程编程I/O编程网络编程 Day01了解java的产生与发展理解java语言的特性理解java虚拟机jvm的特性和功能理解字节码和垃圾收集的概念列举出在java平台上实现代码安全的方法知道在java中定义类，包，applets和applications掌握编码，编译，运行java应用程序的步骤安装，搭建java开发运行环境第一个java程序带包的java程序JVM搜索类的顺序和类加载CLASSPATH的应用常用的java命令 Java的产生与发展Java的产生 Sun公司的Green项目基于c++开发的Oak语言Mosaic和Netscape到JavaHot浏览器Internet的蓬勃发展推动了java的发展(Applet)Java(爪哇) 名字的由来 Java的发展 Java的现状纯面向对象的语言平台无关性，一次编写，到处运行适合于基于Internet应用程序开发Java的地位确立IT产业很多大公司购买了java的许可证众多软件开发商已支持java软件产品Intranet是企业信息系统最佳的解决方案，java发挥了不可替代的作用Java的发展与其分支95.5.23 Oak改名为java98.12. java1.2，后来改名为java2陆续出现了java1.3,java1.42004.12 java1.5版本推出 命名为java5.0后来陆续出现java6.0,java7.0 Java的产生与发展Java的发展与其分支java在今天已形成了庞大的体系,经过十年发展,已有了3个平台标准三大技术平台都提供了相应的开发工具包(SDK:SoftWare Development Kits) java SE –标准版应用平台java EE–企业级应用平台java ME—微型版应用平台：应用在存储,运算很小的受限的平台 Java语言的特性什么是java?程序设计语言；开发环境；应用环境；部署环境Java的特性提供更简单的方式写程序无指针，无需做内存管理提供庞大的类库，纯粹面向对象设计支持静态和动态的代码继承和重用提供一个可解释执行的环境支持任何开发平台只写一次，到处使用支持多线程支持动态升级以上特性如何实现Java虚拟机：JVM垃圾收集：Garbage Collection代码安全：Code Security字节码文件：Verifying JVM与跨平台性:一次编写，到处运行：不同操作系统,不同数据库,不同的服务器数据类型也可以实现跨平台Java虚拟机的作用程序的开发及运行方式Java的工作方式：先编译后解释 Java是先编译后解释执行Java源文件先通过编译生成一个字节码文件bytecode字节码不与当前OS相关，结构中立的，是二进制文件。任何平台编译生成的字节码都是一样的。字节码文件不能直接执行，必须需要JVM的支撑才能运行JVM是sun开发的，字节码的结构也是sun定义的,他们之间有很好的接口JVM存在的意义实际上就是屏蔽掉底层平台的差异，为上层结构中立的字节码统一运行的环境，而JVM会将字节码转化成相应的底层平台的机器码执行java解释器功能是用JVM来实现的，java的解释器是在jvm中运行的 JVM的作用：对下是屏蔽掉了底层平台的差异，对于上层的字节码而言不需要关心它运行在什么平台上，由JVM去把底层平台的差异屏蔽掉对上为结构中立的字节码提供了统一的运行环境，实现了字节码的跨平台 Java的垃圾收集器Java的垃圾收集解除了程序员分配存储器的责任，它提供了一种系统级线程以便跟踪每一存储器的分配情况。在Java虚拟机的空闲周期，垃圾收集线程检查并释放那些可被释放的存储器。内存泄漏垃圾收集线程垃圾收集调用的方法： 1java.lang.System.gc()/java.lang.Runtime.gc() Java代码的安全性 字节码的作用字节码的结构是JVM特定指定的字节码不会破坏，篡改系统禁止运行时堆栈溢出 防止蠕虫病毒袭击参数类型正确类型转换正确 安装，搭建java开发运行环境 官方网站下载JDK 官方网站：http://java.sun.com 不同系统平台，JDK不一样，选择适合于自己平台的JDK JDK的安装Windows直接安装运行jdk的可执行exe文件Linux系统将JDK文件压缩包解压后放入opt目录，配置初始化文件的环境变量Windows下JDK安装后，会有2个文件夹生成JDK：java开发工具软件包，它包含了java的编译，调试，运行整个环境和包含了整个类库的软件包JRE：java运行环境JDK,JRE和JVM JDK，JRE和JVM jre是jdk的子集，在一套完整的jdk中就包含了jrejre只负责运行一个编译好的java程序（字节码文件bytecode）jdk它可以去编译，调试，运行整个操作过程都支持在jre内部有一个软件组件jvm就是java虚拟机 JDK的结构简介bin目录：java开发调试的命令, exe文件,连接库文件，编译器等等编译一个java文件：javac；运行一个字节码文件：javajre目录：jdk中自带的jresrc压缩文件：放置的是jdk类库的源码文件，按包结构组织的demo:：java代码的演示实例文件include：用于编译本地方法的文件docs：html格式的类库文档lib：类库文件Java程序开发环境配置在windows平台：autoexec.bat文件；使用对话框(右击我的电脑／属性／高级／环境变量／系统或用户的环境变量)操作Unix平台需要分shell：csh $HOME/.cshrc bsh/ksh $HOME/.profile环境变量： 12345678JAVA_HOME：保存jdk的安装目录windows : set JAVA_HOME=c:\programfiles\java\jdk1.5.0_09csh: setenv JAVA_HOME /opt/jdk1.5.0_09bsh/ksh: JAVA_HOME=/opt/jdk1.5.0_09CLASSPATH：系统搜索字节码（类文件.class）文件的搜索路径。设置系统在查找字节码文件时，它的搜索路径。windows: set CLASSPATH=.; %JAVA_HOME%\jre\lib\rt.jar;csh: setenv CLASSPATH .:$JAVA_HOME/jre/lib/rt.jarbsh/ksh: CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar PATH：设置命令的搜索路径，在执行命令时，操作系统就会在PATH设置的路径去查找命令的可执行文件。设置path不能覆盖原有的，可以使用特殊符号 1234windows：%PATH%; Linux：$PATH:windows: set PATH=%PATH%;%JAVA_HOME%\bin;csh: setenv PATH $PATH:$JAVA_HOME/binbsh/ksh: PATH=$PATH:$JAVA_HOME/bin Linux系统使用bsh/ksh时则需要export JAVA_HOME CLASSPATH PATH 将环境变量设置为全局的编辑，编译，调试，运行一个java程序 12345678写第一个java程序：HelloWorld.javapublic class HelloWorld&#123; public static void main(String[] args)&#123; String str=“Hello World!”; System.out.println(“The String is:：”+str); System.out.println(&quot;MyAge is: &quot;+age); &#125;&#125; 通过这个程序掌握以下概念一个java源文件中可以定义多个类，但最多只能有一个类用public来修饰，而且该public修饰的类名要与java源文件名一样。 一个java应用程序应该包含一个主方法，而且主方法的签名是固定不变的。主方法定义在哪个类中并不做固定安排。定义的所有的代码中，只看到类的定义。在类中去封装其他变量或方法。 编译HelloWorld.java程序 开始\运行\cmd进入dos,修改当前目录为d:\javacode\day01使用javac HelloWorld.java命令编译编译成功后，到day01程序目录下查看，发现有2个.class文件得出有效结论编译报错则根据错误提示找出错误位置然后修改程序重新编译举例来演示学习错误提示假如将String的S写为小写 ：string str=“HelloWorld!”;假如将out写为out：System.otu.println(“The String is: “+str);再次编译一下，查看错误提示，必须要会读错误提示分析错误提示，排除错误是基本的能力 包的概念，含义和使用运行HelloWorld程序： 包含有主方法的程序才可以运行,没有包含主方法的类是不能运行的开始\运行\cmd进入dos;使用cd d:\javacode\day01进入程序目录使用 java HelloWorld(包含有主方法的类的类名)来运行使用java Student就会报告错误提示没有主方法要求学员做HelloWorld程序并操作演示几种错误情况和调错 带包的java程序包的声明：package day01 package是关键字 day01是包名 包的概念和含义包名的命名符合标识符命名规则即可企业项目开发中,包的命名也有企业规范的如：com.shunshi.abs.model.来隔开每一部分，每一部分都是包结构com.shunshi这个是软件公司网址的url，可以区分确认哪个公司开发的软件产品 com.sun/com.ibm，这样包名不会产生冲突abs是项目名，model是项目中的模块/子模块名写MySecondJava.java程序使用包结构 package com.shunshi.corejava.day01使用包后，如何编译写MySecondJava.java，使用包声明： package corejava.day01; 编译程序：javac –d . MySecondJava.java JVM搜索类的顺序与类加载123-d选项的作用：把编译好的字节码放在你指定的目录下，所以需要指定目录如果源文件声明了包结构，那么在给定的目录位置下会按照包结构自动创建目录结构，编译好的字节码文件是放在最终的子目录下 为什么使用包？企业项目开发中方便管理不同的类用包来分门别类地组织不同模块功能的类使用包的好处：举例：航班机票预定项目 JVM搜索类的顺序与类加载使用包结构编译后，如何运行？使用java，注意：java corejava.day01.MySecondJava如何运行？类加载演示错误情况的发生 直接使用 java MySecondJava 则报告找不到这个类的定义的错误提示为什么找不到？从系统如何去找类来说，与jvm在查找类时的搜索顺序有关系直接进入包结构目录cd corejava\day01,使用java MySecondJava运行，则报告找不到类的定义同时给出错误原因（找到的类与要运行的类不一致） Java 常用命令为什么不一致呢？找到的是带包的，运行的是不带包的CLASSPATH的应用深刻理解java技术体系如何使用第三方的java技术 常用命令javac 选项 源文件名 编译java 源文件 -d查看javac命令到底有哪些选项，直接使用javac/javac -help命令回车java 选项 类名 [参数] 运行java程序jdb 选项 类名 [参数] 进行debug调试的命令javadoc 选项 包名 源文件名 生成jdk的api形式的程序文档 在java源文件中允许使用文档形式的注释 123单行注释 //注释内容多行注释 /*注释内容*/ 多行注释不能嵌套,但可以嵌套单行注释文档注释 /**注释内容*/ 出现在类的定义，方法的定义，属性的定义之前，用来说明类的含义，方法的含义，属性的含义使用javadoc命令给MySecondJava.java生成文档注释在MySecondJava.java中，类前，主方法前写一些文档注释使用javadoc命令将文件MySecondJava.java中的文档注释抽取出来生成程序文档。javadoc –d .\doc MySecondJava.java 分析程序文档结构和理解jdk的API文档 jar {ctxu}[vfm0Mi] [jar-file] [manifest-file] [-C directory] files 创建/展开/更新一个jar文件 jar文件：sun公司定义的一种文件格式，与zip格式相同，可以用普通的解压缩工具解开。jar文件压缩的一般是java的字节码文件,按照包结构组织好的.class文件。 12345创建jar文件: 将d:\corejava\day01中的1个.class文件打包成一个jar文件jar -cvf first.jar .\corejava 不与源文件放在一起 c 代表创建jar文件v 是可视化即可以看见创建过程和创建详细清单 f 代表可在后面指定jar文件名 解压生成后jar文件，有corejava和META-INF2个文件夹jar文件有什么作用？将开发的类打包jar文件给客户，客户得到后只需要设置classpath后就可以用了开发一个中间件，将中间件的程序打包成jar打包day01.jar（corejava\day01中的.class）给第三个程序MyThirdJava使用。写MyThirdJava.java程序 知道java的特殊符号熟悉java的标识符掌握java的关键字的使用理解java各数据类型的存储和使用原始数据类型基本数据类型的转换定义类，对象，成员变量和引用变量类的声明类变量与类成员变量创建类的对象实例和使用默认值描述引用变量与类对象的关系掌握表达式和运算符的使用 Java中的特殊符号12345注释单行注释：//多行注释：/* */ 这两种注释只能通过打开源文件来查看，写程序一定要写注释。注释与程序应是2:1多行注释：/** */ 1这个注释可以不打开源文件来查看，java中有一个javadoc工具，它的作用是将源文件中的/** */ 注释单独抽出来放在另一个文件中。 1例如： javadoc –d . Hello.java,执行后，会在当前目录下生成一个doc目录，里面文件就可查看注释了。 1234其他符号; 一个语句的结束&#123; &#125; 一个语句块空白字符 空格，tab,回车,换行等 Java标识符标识符：程序中的组件名字，包括类名，方法的参数名，变量名，方法名，包名等定义标识符的规则： 以_ ,$,字母开头； 只含有_,$,字母，数字; 没有长度限制，不能有空格； 不能使用java的关键字或保留字 大小写敏感 1234例如：_abc √, $ABC √,2A ×,A# ×,For√,顺时 √Java开发的命名习惯所有的命名要望文生义，这样才具有良好的可读性Total，Sum，ShunshiStudent， 1234类名，接口名：每个单词的首字母大写，其他字母小写 如类MyFirstJava，Player，Teacher属性，方法,，局部变量名：第一个单词全小写，从第二个单词开始以后每个单词首字母大写，其他字母小写 如方法 getName() setDoctorBirthday()常量：每个单词所有字母全部大写，单词之间用_来连接 java中使用final修饰 final int MARK_GREED=22;包名：所有字母全部小写 如package com.shunshi.corejava.day01 Java关键字关键字：对Java技术编译器有特殊的含义，可以被编译器识别执行 12345abstract do implements private throw boolean double import protected throws break else instanceof public transient byte extends int return true case false interface short try catch final long static void char finally native super volatile class float new switch while continue for null synchronized default if package this Java关键字特点 java关键字与c++很多相似，只要与c++一样的，它的含义都与c++中的相同有些关键字c++有，而java没有 sizeof 求出某种类型的变量的占内存的大小为什么c++有sizeof？因为不同机器内存占用空间大小不一样 16，32，64位，取决于操作系统平台。为什么Java不需要？因为有JVM。 java中的关键字都是小写的true、false和null为小写，而不是象在C++语言中那样为大写。严格地讲，它们不是关键字。 Java关键字有些关键字java没有取消保留下来，但它自己也不用它也不给程序员用goto和const不是Java编程语言中使用的关键字，而是保留字。什么是保留字？为什么保留下来但不能用?在java中final替代constgoto在c++代表无条件跳转，功能很好，但不能经常用，要谨慎。很多建议去掉goto关键字，没有理解goto真正含义。为什么c++到现在都没有删除掉goto?它有一个特殊使命Java中使用break代替goto跳出一层循环 ：break跳出多层循环：break out out是一个标号，可以跳到out标识处 1234break避免滥用goto，把goto功能削弱了，只能跳到外层循环java中加入新的关键字enum assertenum：枚举assert：断言 Java的原始数据类型boolean true/falsebyte 8位整型 1个字节short 16位整型 2个字节int 32位整型 4个字节long 64位整型 8个字节char 16位 unicode 字符 2个字节double 64位浮点数字型 8个字节float 32位浮点数字型 4个字节 boolean类型Java中定义boolean类型boolean b=true;Java中的boolean类型的取值只能是true,falseJava中的boolean类型不能与int通用，而在c++中可以C++中,0代表false,非0代表trueboolean与int通用好还是不好呢？不好举例说明 c++中的boolean与int通用 12int a=1;if(0&lt;a&lt;2) cout&lt;&lt;a&lt;&lt;endl; Integer 数据类型—byte,short,int,longJava中的4种整型类型 1234byte: 1个字节 –128(-27)-127(27-1)short: 2个字节 –32768(-215)-32767(215-1)int: 4个字节 –2147483648 (-231) -2147483647 (-231-1)long: 8个字节 –263-263-1 Java的不同整型占用内存空间的大小不一样 Java中整型的存储规则与c++一样， 但java整型没有无符号和有符号的区分，这与c++不一样。Java中所有整型都是有符号的，这样就可以求出每个整型能表示的范围。 以byte为例说明Byte是8位整型 1个字节 最多可表示28=256个数 从(-27)-128到127(27-1)为什么是-128-127而不是-127-128呢？与整型数据在内存的存储规则有关整型数据在内存空间中的存储方式 正整数（最高位为0）在内存中是存储原码 负整数（最高位为1）在内存中是存储其补码 补码是不考虑符号情况下原码取反后末位加1。以-5来分析补码分析一些特殊数字：8位全为1则是数字-1，8位全为0则是数字0不考虑符号位最大的数是01111111表示数字127，最小的数10000000表示数字-128 Integer 数据类型在内存的存储方式为什么用补码存储负数？方便二进制计算，例如-128+127=-1其他类型的整型在内存的存储方式与byte相同，只是空间更大。其他类型的整型表示数的范围如前面 整型数据表示long类型使用 l或L来表示int的不同进制：十六进制用0x或H表示 8进制用0或O表示 10进制用D或10表示默认类型为int char数据类型char类型123456 char 字符型为16位， 2个字节，与c++不一样,采用的是unicode编码，unicode编码是统一编码，可包含字母，数字，符号，中文文字等unicode码是采用16进制表示的 如‘\u0061’2个字节的unicode编码可以表示216个字符，字符使用单引号‘’来表示127个ASCII码全可表示 英文字符，控制字符，数字，标点符 表示其他语言的字符：中文，德语，法语，阿拉伯等一个char类型本质上是一个整型 char与short都是16位的，他们的差别？通过查询unicode编码集可以获取一个整型值对应的unicode字符unicode编码集包含了ASCII码集的在0-127内unicode编码值与ASCII码值一样，表示的字符也一样常见的ASCII码值 ：A:65 a:97 0:48通过unicode码得到码值可以将16进制转换为10进制 String类型简介Java中的转义字符 12\’ ：‘ 单引号 \” ： “双引号 \\ ：\顺斜杠 \n：换行 \t：tab制表符 \b：退格 \0：‘\u0000’ unicode码值为0的空字符 String类型String类型：字符串类型，它不是java的8种基本类型，是类的类型String是java的一个类，这个类的实例叫做String对象Java中字符串用””双引号来引用Java中的字符串类不是以‘\0’结尾 String类是Java中使用最多的类，它有很多有用的方法，查看jdk的api文档获得String类的对象变量String str1=“Hello”; String str2=new String(“ World!”); String可做什么操作使用+号来连接字符串String s1=“12”; int ia=3; int ib=4;System.out.println(s1+ia+ib); System.out.println(ia+ib+s1);char charAt(int)：返回参数int指示位置上的字符System.out.println(str1.charAt(0));String concat(String)：将当前String与参数String连接起来返回新串System.out.println(str1.concat(str2)); boolean contains(charSequence s)：判断一个字符串中是否包含参数的子串String str3=“Hello World!”; System.out.println(str3.contains(str1)); boolean equals(String)：比较2个字符串内容是否相等,不忽略大小写String s2=“Hello”; String s3=“Hello”; System.out.println(s2.equals(s3)); boolean equalsIgnoreCase(String)：比较2个字符串内容是否相等，忽略大小写String s4=“heLLo”; System.out.println(s4.equals(s3)); System.out.println(s4.equalsIgnoreCase(s3)); int indexOf(String/char)：获得参数字符/字符串在改字符串中的第一次出现的位置索引，假如找不到则返回-1System.out.println(str3.indexOf(“Wor”)); System.out.println(str3.indexOf(‘o’)); length()：获得字符串的长度System.out.println(str3.length());写TestString.java，演示上面String的功能 浮点型数据类型浮点数据类型：２种float：单精度，３２位 ４个字节 使用f或者F表示double：双精度 ６４位 ８个字节 默认类型 使用d或者D表示 浮点数举例 123float fa=123.4f;√ float fb=123.4;× 默认是double double直接赋给float精度丢失float fc=12.5E300F;√ float fd=(float)12.5E301; √double da=123D; double db=123.456d; double dc=123.45e301; 浮点数据类型的存储方式整型存储方式是精确存储浮点存储方式是近似存储：实数范围太大了，实数太多了，无法在内存中对应每一个实数的状态浮点数的近似存储在程序中的问题：写TestFloat.java实型值分母可为0，double d=0.0/0.0; System.out.println(d);编译正确double a=2.0,b=1.91,c=0.09;if(a-b==c) System.out.println(“ok”);else System.out.pringln(“no ok”);结果输出”on ok”。实型数值直接比较相等不安全，不要直接比较相等，但可以比较大小。 假如一定想要2个实型数值比较是否相等，可以考虑比较2个实型数的差是否在一个非常小的范围内想要输出“ok”，则if(Math.abs(a-b-c)&lt;(1e-6)) System.out.println(“ok”); Math类1234567891011121314lang包下的类，它里面定义了很多方法来实现常用的数学运算Math类中的方法都是静态的Math类中的方法：abs()：求绝对值sqrt()：求平方根pow()：求乘方cos(),sin(),tan(),ctan()：数学的三角函数运算random()：获得0-1之间的随机数在TestFloat.java中测试使用Math类中的方法Math.abs(-5)Math.sqrt(9)Math.pow(2,3)Math.random()*100：获得0-100之间的随机数 数据类型之间的转换数据类型之间的转换分为2种自动类型转换a类型转换为b类型时，a的取值范围是b的取值范围的完全子集 这就是自动类型转换在java的8种基本类型中，除boolean以外，其他7种类型都是可以相互转换的。7种原始类型之间可自动转换结构图 12byte→short→int→long→float→double char 顺着箭头方向可自动转换；逆着箭头方向则是强制转换强制类型转换：只要不能自动转换的，则只能是强制转换整型数据之间的强转：改变数据的符号；改变数值 int a=0x2aff; byte b=(byte)a; b为-1 强制转换的原理：从最低位开始取到目标类型长度为止整型之间的强转是保留二进制低位，去掉高位，需要考虑在内存中如何存储实型强转整型是保留整数，去掉小数，不考虑实型在内存中的如何存储写一个DataTypeTest.java程序演示数据类型转换 1234567891011121314151617181920byte+byte会自动提升为intbyte a1=1,a2=2;byte a3=a1+a2;×(精度丢失)+=不进行类型提升byte c=3; c=c+3; c+=3;System.out.println(c);默认整型为int,int，long提升为float有精度丢失float fa=37; System.out.println(fa); int ia=(int)fa; System.out.println(ia);long la=0xffffffffffL;float fb=la;System.out.println(fb);long lb=(long)fb; System.out.println(lb);整型之间的强转int a=0x2aff; byte b=(byte)a; System.out.println(b);float转换为double会有精度丢失float fe=1234.56f; double de=fe; System.out.println(de);float ff=(float)de; System.out.println(ff);整型除法System.out.println(5/2);System.out.println((float)5/2);char与int的转换char c1=‘A’; int iic=c1;System.out.println(iic);char c2=99; System.out.println(c2); Java中的特殊类型——对象为什么会有对象?早些时候的编程语言和初级程序员将每个变量看作相互无关的实体。例如，如果一个程序需处理某个日期，则要声明三个单独的整数：int day, month, year;尽管这种作法很容易理解，但它存在两个重大缺陷名称太多，会引起混乱忽略了各个变量之间的联系例如：若程序需同时记录几个日期，则需要三个不同的声明,要记录两个生日, 则要使用 12int myBirthDay, myBirthMonth, myBirthYear;int yourBirthDay, yourBirthMonth, yourBirthYear; 忽视了日、月和年之间的联系并把每个变量都作为一个独立的值，每个变量都是一个独立单元(在本例中为date)的一部分并被相应地处理Java的对象类型为克服上述两种缺陷，Java编程语言使用类来表示这种新类型Java除了８中基本类型，还有一种类类型或者叫做对象类型(或是一个类，或是一个接口)Java的类类型不是表达一个简单的数据，而是表达一个较复杂的数据(复合数据) 例如：描述一个学生，定义一个学生类，它包含学生的相关信息：姓名，性别，年龄，专业创建一个学生类 12345678910111213141516171819202122232425262728293031323334353637383940 class Student&#123; private String name; private boolean sex; private int age; private String major; public Student(String name,boolean sex,int age,String major)&#123; this.name=name; this.sex=sex; this.age=age; this.major=major; &#125; public void setName(String name)&#123; this.name=name; &#125; public void setSex(boolean sex)&#123; this.sex=sex; &#125; public void setAge(int age)&#123; this.age=age; &#125; public void setMajor(String major)&#123; this.major=major; &#125; public String getName()&#123; return name; &#125; public boolean getSex()&#123; return sex; &#125; public int getAge()&#123; return age; &#125; public String getMajor()&#123; return major; &#125;&#125;Student就是一个新的类型，就像int,float等一样可以用来定义变量例如：Student stu; 声明一个Student的变量stu，则它里面的name,sex,age,major也都隐含声明了，name,sex,age,major称为stu的成员变量。``` 类类型／对象类型的数据的存储方式与基本类型数据存储方式的差别类型创建一个Student对象：Student stu; stu=new Student(“LiDW’,true,22,”computer”);原始类型的声明 int x;x=7; float y=9.9f;把类看作一个类型的话，它的使用其实和基本类型int等一样，只不过赋值是赋的一个复杂的复合类型数据，是new出的对象存储形式的差别int x; x=7; 基本类型声明变量时就已经创建了变量并分配空间，无论它是否已经赋值，赋值只是将值放入已分配的空间Student stu;对象类型声明Student stu;时，在内存空间也给stu分配了空间。那分配了多少空间？Student中所有成员变量的空间大小和吗？不是取决于Student的大小，与Student的大小无关那stu是什么？在java中把stu叫做引用，这个引用与c++中的引用完全不一样Java中的引用与c++的指针相似，java中没有指针，只有引用，它保存的也是一个地址值(内存空间中的Student对象的地址)Java中的引用与c++的指针有差别C++中指针可被程序员操作：int p; p++,p–,p等等，所以很危险，不安全Java中不允许程序员对引用做操作，只能通过引用访问对象，但不能对引用进行++,–等操作，所以java语言更安全。123456789101112131415161718192021Java的引用需要多少个字节呢？引用无论什么类型都保存的是内存中的地址值地址值常见的是4个字节，相对来讲很固定的值地址值的长度严格来讲也取决于不同的机器平台，由机器的寻址空间决定的。例如常用的是32位机器，所以4个字节那么stu=new Student(“LiWD”,true,22,”computer”)又干什么？在内存空间中又开辟了一个区域专门用来保存该Student对象的数据赋值语句将开辟的对象空间的地址赋给stu，stu就指向这个对象综上所述，对象类型的存储方式即需要两个空间：引用空间，对象空间Java中的对象与引用的关系：可以打个比方来看看对象可以看作是充满氢气的气球，气球中的空气就是对象中的数据，气球我们无法直接拿到任何时候我们拿到气球都必须通过连接它的一根绳子，这跟绳子就可以看作是引用深入理解对象与引用的关系同一个气球可不可以有多根绳子连着它？可以 就像双胞胎牵同一个气球 Student stu1=new Student(“LiWD”,true,22,”computer”);Student stu2=stu1;123456789101112131415161718192021222324252627282930313233343536373839stu2,stu1保存的是相同的地址值，stu2,stu1指向同一个对象通过stu1修改了对象Student的数据值后，通过stu2访问的对象也就改了### 可不可能一根绳子同时栓着多个气球？不能如果一根绳子没有连任何气球，那么对于这个引用的访问有意义吗？没有意义Student stu3=null;定义了一个空引用，没有指向任何对象假如使用stu3去访问name,age等会报告空指针异常 NullPointerException如果某一个气球没有任何绳子栓着，那它怎么办？飞走了这个气球就无法访问了，变成垃圾。(垃圾占用空间，但我们无法访问)Student stu4=new Student(“LiWD”,true,22,”computer”); stu4=null;### Java的垃圾回收机制Java不让程序员管理内存一个系统级线程专门扫描内存，回收垃圾垃圾回收是自动进行的，程序员可以建议但不能控制，程序员调用java.lang.System.gc()来告诉JVM做垃圾回收。程序员建议后，也不一定就回收。一般java.lang.System.gc()语句放在前面程序已释放了很多垃圾后，则调用该语句执行的可能性大Java的垃圾回收并不是马上回收，jvm有一套算法来确定什么时候进行垃圾回收Java垃圾回收与c++内存释放的比较差异：打个比方C++内存释放：相当于学校食堂吃饭，吃饭后要将餐盘送到回收处，若你不做则大家会鄙视你。若大家都不做，则长时间就没有餐盘了。Java垃圾回收：相当于餐馆中吃饭，吃完了，只结帐就走了。餐馆自然有人来回收。无需自己把餐盘送到后台。理解对象对象无处不在;对象彼此联系;对象有属性;对象有方法&gt; There are students and a teacher in classroom## Java的运算符赋值运算符：一个简单的赋值=和11个复合赋值 =，*=，/=，%=，+=，-=，&lt;&lt;=(左移位)，&gt;&gt;=(右移位)，&gt;&gt;&gt;=，&amp;=(按位与)，^=(按位异或)，|=(按位或)123复合赋值运算不会产生自动类型的提升 byte b1=2; b1+=2;√ b1=b1+2;×比较运算符 ，&gt;=，&lt;，&lt;=,instanceof(比较类型)，= =，!=1234Java的数据类型中哪些是可用比较运算符来连接的算术运算符 +,-,*,/,%5/2， (float)5/21234## 移位运算符所有的移位运算只能针对整型数据操作 (右移,右移一位等于除2)，&lt;&lt;(左移,左移一位等于乘2)，&gt;&gt;&gt;(无符号右移)有符号的右移：则移走后最左边高位填补为原来的符号位有符号的左移：则移出去的不管，移进来用0来填补无符号右移：则移出去的不管，移进来都用0填补int a=68; a=a&lt;&lt;34; System.out.println(a); 超出了范围，移出后全为0？实际上不是这样的。a&lt;&lt;34等价于a&lt;&lt;(34%32)int in1=20;System.out.println(in1&gt;&gt;1); 10 System.out.println(in1&gt;&gt;&gt;1); 10int in2=-20;System.out.println(in2&gt;&gt;1); -10 System.out.println(in2&gt;&gt;&gt;1); 很大的数 位运算符&amp;(按位与)，|(按位或)，~(按位求反)，^(按位异或)例： int a=0x5a2b; int b=0x7332; a&amp;b a|b a^b位运算符什么时候用？用来干什么？例：int a=0x8a3d;`]]></content>
      <categories>
        <category>我的书籍</category>
      </categories>
      <tags>
        <tag>我的书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android应用基础知识]]></title>
    <url>%2F2018%2F05%2F01%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 来源：https://developer.android.google.cn/guide/ Android 简介Android 提供了一个内容丰富的应用框架，支持您在 Java 语言环境中为移动设备开发创新应用和游戏。在左侧导航窗格列出的文档中，提供了有关如何使用各种 Android API 开发应用的详细信息。 如果您是 Android 应用开发新手，则需了解以下有关 Android 应用框架的基本概念，这一点至关重要： 应用提供多个入口点Android 应用都是将各种可单独调用的不同组件加以组合开发而成。例如，组件可以是为用户界面提供一个屏幕的单个“Activity”，也可以是在后台独立执行工作的“服务”。 您可以使用 intent 从一个组件启动另一个组件。甚至，您还可以启动不同应用中的组件，例如，启动地图应用中的 Activity 以显示地址。此模式可为单个应用提供多个入口点，并使任何应用均能够像用户“默认设置”一样处理其他应用可能调用的操作。 应用可适应不同的设备Android 提供了一个自适应应用框架，可用以为不同的设备配置提供独特的资源。例如，您可以针对不同的屏幕尺寸创建不同的 XML 布局文件，系统将根据当前设备的屏幕尺寸确定要应用的布局。 如有任何应用功能需要相机等特定的硬件，则可在运行时查询设备功能的可用性。如有必要，您还可以声明您的应用所必需的功能，使 Google Play 商店等应用市场不得在不支持这些功能的设备上安装您的应用。 构建您的第一个应用欢迎从事 Android 应用开发！ 本课将介绍如何构建您的第一个 Android 应用。您将学习如何使用 Android Studio 创建 Android 项目和运行可调试版本的应用。您还将了解一些 Android 应用设计的基础知识，包括如何构建简单的界面和处理用户输入。 创建 Android 项目本课将向您介绍如何使用 Android Studio 创建新的 Android 项目并说明该项目中的一些文件。 在 Welcome to Android Studio 窗口中，点击 Start a new Android Studio project。 或者如果您已打开项目，请选择 File &gt; New Project。 在 New Project 屏幕中，输入以下值：Application Name：“My First App”Company Domain：“example.com”您可能需要更改项目位置，但无需更改其他选项。 点击 Next。 在 Target Android Devices 屏幕中，保留默认值并点击 Next。在 Add an Activity to Mobile 屏幕中，选择 Empty Activity，然后点击 Next。在 Configure Activity 屏幕中，保留默认值并点击 Finish。经过一些处理后，Android Studio 将打开 IDE。 下面让我们花一点时间回顾一下最重要的文件。 首先，请确保已打开 Project 窗口（选择 View &gt; Tool Windows &gt; Project），并从窗口顶部的下拉列表中选择 Android 视图。随后，您可以看到下列文件： app &gt; java &gt; com.example.myfirstapp &gt; MainActivity.java 这是主 Activity（您的应用的入口点）。当您构建和运行应用时，系统会启动此 Activity 的实例并加载其布局。 app &gt; res &gt; layout &gt; activity_main.xml 此 XML 文件会定义 Activity 界面的布局。它包含一个带有文本“Hello world!”的 TextView 元素。 app &gt; manifests &gt; AndroidManifest.xml manifest 文件描述应用的基本特性并定义其每个组件。 Gradle Scripts &gt; build.gradle 您会看到具有此名称的两个文件：一个用于项目，一个用于“应用”模块。每个模块均有自己的 build.gradle 文件，但此项目当前仅有一个模块。您将主要使用模块的 build.gradle 文件配置 Gradle 工具编译和构建您的应用的方式。如需了解有关此文件的更多信息，请参阅配置构建。 运行您的应用现在，您可以在真实设备或模拟器上运行应用。 在真实设备上运行 按照以下步骤设置您的设备： 使用一根 USB 电缆将您的设备连接到您的开发机器。如果您是在 Windows 上开发，可能需要为您的设备安装相应的 USB 驱动程序。 按照以下步骤操作，在 Developer options 中启用 USB debugging。首先，您必须启用开发者选项： 打开 Settings 应用。（仅在 Android 8.0 或更高版本上）选择 System。滚动到底部，然后选择 About phone。滚动到底部，点按 Build number 7 次。返回上一屏幕，在底部附近可找到 Developer options。打开 Developer options，然后向下滚动以找到并启用 USB debugging。 按照以下步骤操作，在您的设备上运行应用： 在 Android Studio 中，点击 Project 窗口中的 app 模块，然后选择 Run &gt; Run（或点击工具栏中的 Run ）。在 Select Deployment Target 窗口中，选择您的设备，然后点击 OK。Android Studio 会在您连接的设备上安装并启动应用。 至此，“hello world”将在您的设备上运行！要开始开发应用，请继续学习下一课。 在模拟器上运行按照以下步骤操作，在模拟器上运行应用： 在 Android Studio 中，点击 Project 窗口中的 app 模块，然后选择 Run &gt; Run（或点击工具栏中的 Run ）。 在 Select Deployment Target 窗口中，点击 Create New Virtual Device。 在 Select Hardware 屏幕中，选择电话设备（如 Pixel），然后点击 Next。 在 System Image 屏幕中，选择具有最高 API 级别的版本。如果您未安装该版本，将显示一个 Download 链接，因此，请点击该链接并完成下载。 点击 Next。 在 Android Virtual Device (AVD) 屏幕上，保留所有设置不变，然后点击 Finish。 返回到 Select Deployment Target 对话框中，选择您刚刚创建的设备，然后点击 OK。 Android Studio 会在模拟器上安装并启动应用。 构建简单的界面Android 应用的界面使用布局（ViewGroup 对象）和微件（View 对象）层次结构构建。布局是一种不可见的容器，用于控制其子视图在屏幕上的位置。微件是界面组件，例如按钮和文本框。 ViewGroup 对象如何在布局中形成分支并容纳 View 对象的图解 Android 为 ViewGroup 和 View 类提供了一个 XML 词汇，因此您的大多数界面都在 XML 文件中定义。 打开布局编辑器首先，请按照以下步骤设置您的工作区： 在 Android Studio 的 Project 窗口中，打开 app &gt; res &gt; layout &gt; activity_main.xml。要为布局编辑器留出更多空间，请选择 View &gt; Tool Windows &gt; Project 以隐藏 Project 窗口，或者点击 Android Studio 左侧的 Project ）。如果您的编辑器显示 XML 源代码，请点击窗口底部的 Design 标签。点击 Select Design Surface 并选择 Blueprint。点击工具栏中的 Show 并确保选中 Show Constraints。确保 Autoconnect 关闭。工具栏中的提示应为 Turn On Autoconnect （因为它现在处于关闭状态）。点击工具栏中的 Default Margins， 然后选择 16（您稍后仍然可以调整每个视图的外边距）。点击工具栏中的 Device in Editor， 然后选择 Pixel XL。 左下方的 Component Tree 窗口显示布局的视图层次结构。在本例中，根视图是 ConstraintLayout，仅包含一个 TextView 对象。 ConstraintLayout 是一种布局，它根据同级视图和父布局的约束条件为每个视图定义位置。这样一来，您可以创建具有扁平视图层次结构的简单布局和复杂布局。也就是说，它可以避免对嵌套布局（布局内的布局，如图 2 所示）的需求，嵌套布局会增加绘制界面所需的时间。 例如，您可以声明以下布局（在图 4 中）： 视图 A 显示在父布局上方 16dp 处。视图 A 显示在父布局左侧 16dp 处。视图 B 显示在视图 A 右侧 16dp 处。视图 B 与视图 A 的顶部对齐。在后面几部分中，您将构建一个与此布局类似的布局。 添加一个文本框首先，您需要移除布局中已有的内容。因此，请点击 Component Tree 窗口中的 TextView，然后按 Delete。 在左侧的 Palette 窗口中，点击左侧窗格中的 Text，然后将 Plain Text 拖放到设计编辑器中靠近布局顶部的位置。这是一个接受纯文本输入的 EditText 微件。 在设计编辑器中点击视图。现在，您可以在每个角上看到大小调整手柄（正方形），并在每个边上看到约束锚点（圆形）。 为了能更好地控制，您可能需要使用工具栏中的按钮放大编辑器。 点击并按住顶边上的锚点，将其向上拖动，直至锚点吸附到布局的顶部，然后释放。这是一个约束条件 - 它指定视图应位于距离布局顶部 16dp 的位置（因为您将默认外边距设置为 16dp）。类似地，从视图左侧创建一个约束条件，将其限制在布局左侧。 添加一个按钮按钮被限制在文本框及其基线的右侧 在 Palette 窗口中，点击左侧窗格中的 Widgets，然后将 Button 拖放到设计编辑器中靠近右侧的位置。 从按钮左侧创建一个约束条件，将其限制在文本框的右侧。 要在水平对齐中约束视图，您需要在文本基线之间创建一个约束条件。因此，请点击按钮，然后点击 Edit Baseline， 它将显示在设计编辑器中选定视图的正下方。基线锚点显示在按钮内部。点击并按住此锚点，然后将其拖动到文本框中显示的基线锚点。 注：您还可以使用顶部或底部边缘创建水平对齐，不过，按钮在其图像周围包含内边距，因此如果您按照这种方式对齐这些视图，视觉对齐将是错误的。 更改界面字符串要预览界面，请点击工具栏中的 Select Design Surface 并选择 Design。请注意，文本输入使用“Name”预填充，按钮标记为“Button”。现在，您将更改这些字符串。 打开 Project 窗口，然后打开 app &gt; res &gt; values &gt; strings.xml。 这是一个字符串资源文件，您应在这个文件中指定所有界面字符串。这样您可以在一个位置管理所有界面字符串，让字符串的查找、更新和本地化变得更加容易（与您的布局或应用代码中的硬编码字符串相比）。 点击编辑器窗口顶部的 Open editor。这将打开 Translations Editor，它为添加和编辑您的默认字符串提供了一个简单的界面，并且有助于保持您的所有已翻译字符串井然有序。 用于添加新字符串的对话框点击 Add Key， 以文本框“提示文本”的形式创建新字符串。为键名输入“edit_message”。为值输入“Enter a message”。点击 OK。再添加一个名称为“button_send”并且值为“Send”的键。 现在，您可以为每个视图设置这些字符串。点击标签栏中的 activity_main.xml 以返回布局文件，然后按照以下步骤添加字符串： 点击布局中的文本框，如果 Attributes 窗口在右侧还未显示，请点击右侧边栏上的 Attributes 。找到 text 属性（当前设为“Name”）并删除值。找到 hint 属性，然后点击文本框右侧的 Pick a Resource 。在出现的对话框中，双击列表中的 edit_message。现在，点击布局中的按钮，找到 text 属性，点击 Pick a Resource， 然后选择 button_send。 让文本框大小灵活调整要创建一个可以适应不同屏幕尺寸的布局，您现在将让文本框拉伸以填充剩余的所有水平空间（扣除按钮和所有外边距后的空间）。 首先，请点击工具栏中的 Show 并选择 Blueprint。 点击 Center Horizontally 的结果 点击以将宽度更改为 Match Constraints 现在，文本框将拉伸以填充剩余空间 选择两个视图（点击一个，按住 Shift 并点击另一个），然后右键点击任何一个视图并选择 Chain &gt; Create Horizontal Chain。 链是两个或更多视图之间的双向约束条件，它让您可以采用一致的方式放置链接的视图。 选择按钮并打开 Attributes 窗口。使用 Attributes 窗口顶部的视图检查器将右外边距设置为 16。现在，点击文本框以查看其属性。点击两次宽度指示器，确保将其设置为 Match Constraints，如图 9 中的标注 1 所示。“Match constraints”表示宽度将延长以符合水平约束条件和外边距的定义。因此，文本框将拉伸以填充水平空间（扣除按钮和所有外边距后的空间）。 运行应用如果已在上一课中将您的应用安装到设备上，只需点击工具栏中的 Apply Changes， 使用新布局更新应用。或者点击 Run， 安装并运行应用。 启动另一个 Activity响应 Send 按钮按照以下步骤操作，在 MainActivity.java 中添加一个由按钮调用的函数： 在文件 app &gt; java &gt; com.example.myfirstapp &gt; MainActivity.java 中，添加 sendMessage() 函数存根，如下所示： 123456789101112public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; /** Called when the user taps the Send button */ public void sendMessage(View view) &#123; // Do something in response to button &#125;&#125; 您可能会看到一条错误，因为 Android Studio 无法解析用作函数参数的 View 类。因此，请点击，将您的光标放置在 View 声明上，然后按 Alt + Enter（在 Mac 上，则按 Option + Return），执行快速修复。（如果出现一个菜单，请选择 Import class。） 现在，返回到 activity_main.xml 文件，从按钮调用此函数：在布局编辑器中点击以选择按钮。在 Attributes 窗口中，找到 onClick 属性并从下拉列表中选择 sendMessage [MainActivity]。 现在，当点按按钮时，系统将调用 sendMessage() 函数。 记下此函数中的详细信息，要让系统将此函数视为与 android:onClick 属性兼容，需要这些详细信息。具体来说，函数必须声明以下内容： 公共访问 空返回值 以 View 作为唯一参数（它是之前点击的 View 对象） 接下来，您需要填写此函数以读取文本字段的内容，并将该文本传递给另一个 Activity。 构建一个 IntentIntent 是指在相互独立的组件（如两个 Activity）之间提供运行时绑定功能的对象。Intent 表示一个应用“执行某项操作的意向”。您可以将 intent 用于各种任务，但在本课中，您的 intent 用于启动另一个 Activity。 在 MainActivity.java 中，添加 EXTRA_MESSAGE 常量和 sendMessage() 代码，如此处所示： 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; public static final String EXTRA_MESSAGE = &quot;com.example.myfirstapp.MESSAGE&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; /** Called when the user taps the Send button */ public void sendMessage(View view) &#123; Intent intent = new Intent(this, DisplayMessageActivity.class); EditText editText = (EditText) findViewById(R.id.editText); String message = editText.getText().toString(); intent.putExtra(EXTRA_MESSAGE, message); startActivity(intent); &#125;&#125; Android Studio 将再次遇到 Cannot resolve symbol 错误，因此，请按 Alt + Enter（在 Mac 上，则按 Option + Return）。您的导入应按如下所示方式结束： 12345import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.EditText; DisplayMessageActivity 仍有错误，但没关系；您将在下一部分中修复该错误。 下面是 sendMessage() 中的操作： Intent 构造函数采用两个参数： Context 是第一个参数（之所以使用 this 是因为 Activity 类是 Context 的子类） 应用组件的 Class，系统应将 Intent（在本例中，为应启动的 Activity）传递至该类。 putExtra() 函数将 EditText 的值添加到 intent。Intent 能够以名为 extra 的键值对形式携带数据类型。您的键是一个公共常量 EXTRA_MESSAGE，因为下一个 Activity 将使用该键来检索文本值。为 intent extra 定义键时最好使用应用的软件包名称作为前缀。这可以确保在您的应用与其他应用交互时这些键始终保持唯一。 startActivity() 函数将启动 Intent 指定的 DisplayMessageActivity 实例。现在，您需要创建该类。 创建第二个 Activity在 Project 窗口中，右键点击 app 文件夹并选择 New &gt; Activity &gt; Empty Activity。 在 Configure Activity 窗口中，为 Activity Name 输入“DisplayMessageActivity”，然后点击 Finish（保留所有其他属性设置为默认值）。 Android Studio 会自动执行三项操作： 创建 DisplayMessageActivity.java 文件。 创建对应的 activity_display_message.xml 布局文件。 在 AndroidManifest.xml 中添加必需的 元素。 如果运行应用并在第一个 Activity 上点按按钮，将启动第二个 Activity，但它为空。这是因为第二个 Activity 使用模板提供的空布局。 添加文本视图位于布局顶部中心的文本视图 新 Activity 包括一个空白的布局文件，因此，现在您需要在消息将要显示的位置添加一个文本视图。 打开文件 app &gt; res &gt; layout &gt; activity_display_message.xml。点击工具栏中的 Turn On Autoconnect （Autoconnect 随后应启用）。 在 Palette 窗口中，点击 Text，然后将 TextView 拖动到布局中 - 将其放置在靠近布局顶部中心的位置，使其吸附到出现的垂直线上。Autoconnect 将添加左侧和右侧约束条件，在水平中心放置视图。 再从文本视图的顶部创建一个约束条件，将其限制在布局顶部 也可以在 Attributes 窗口中展开 textAppearance 并更改属性（例如 textSize 和 textColor），对文本样式进行一些调整。 显示消息现在，您将修改第二个 Activity，以显示第一个 Activity 传递的消息。 在 DisplayMessageActivity.java 中，向 onCreate() 函数添加下列代码： 12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_display_message); // Get the Intent that started this activity and extract the string Intent intent = getIntent(); String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE); // Capture the layout&apos;s TextView and set the string as its text TextView textView = findViewById(R.id.textView); textView.setText(message);&#125; 按 Alt + Enter（在 Mac 上，则按 Option + Return）导入缺少的类。您的导入应按如下所示方式结束： 1234import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView; 添加向上导航您的应用中不是主入口的每个屏幕（所有不是主屏幕的屏幕）都应提供导航，以便用户在应用栏中点按“向上”按钮后可以返回应用层次结构中的逻辑父屏幕。 您需要做的全部工作是在 AndroidManifest.xml 文件中声明哪个 Activity 是逻辑父项。因此，请打开 app &gt; manifests &gt; AndroidManifest.xml 处的文件，找到 DisplayMessageActivity 的 标记，然后将其替换为以下代码： 12345678&lt;activity android:name=&quot;.DisplayMessageActivity&quot; android:parentActivityName=&quot;.MainActivity&quot; &gt; &lt;!-- The meta-data tag is required if you support API level 15 and lower --&gt; &lt;meta-data android:name=&quot;android.support.PARENT_ACTIVITY&quot; android:value=&quot;.MainActivity&quot; /&gt;&lt;/activity&gt;Android 系统现在会在应用栏中自动添加“向上”按钮。 运行应用现在，点击工具栏中的 Apply Changes，再次运行应用 。当应用打开后，在文本字段中键入一条消息，点按 Send 以在第二个 Activity 中查看显示的消息。 应用基础知识Android 应用采用 Java 编程语言编写。Android SDK 工具将您的代码 — 连同任何数据和资源文件 — 编译到一个 APK：Android 软件包，即带有 .apk 后缀的存档文件中。一个 APK 文件包含 Android 应用的所有内容，它是基于 Android 系统的设备用来安装应用的文件。 安装到设备后，每个 Android 应用都运行在自己的安全沙箱内： Android 操作系统是一种多用户 Linux 系统，其中的每个应用都是一个不同的用户；默认情况下，系统会为每个应用分配一个唯一的 Linux 用户 ID（该 ID 仅由系统使用，应用并不知晓）。系统为应用中的所有文件设置权限，使得只有分配给该应用的用户 ID 才能访问这些文件；每个进程都具有自己的虚拟机 (VM)，因此应用代码是在与其他应用隔离的环境中运行；默认情况下，每个应用都在其自己的 Linux 进程内运行。Android 会在需要执行任何应用组件时启动该进程，然后在不再需要该进程或系统必须为其他应用恢复内存时关闭该进程。Android 系统可以通过这种方式实现最小权限原则。也就是说，默认情况下，每个应用都只能访问执行其工作所需的组件，而不能访问其他组件。 这样便营造出一个非常安全的环境，在这个环境中，应用无法访问系统中其未获得权限的部分。 不过，应用仍然可以通过一些途径与其他应用共享数据以及访问系统服务： 可以安排两个应用共享同一 Linux 用户 ID，在这种情况下，它们能够相互访问彼此的文件。 为了节省系统资源，可以安排具有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一 VM（应用还必须使用相同的证书签署）。应用可以请求访问设备数据（如用户的联系人、短信、可装载存储装置 [SD 卡]、相机、蓝牙等）的权限。 用户必须明确授予这些权限。 如需了解详细信息，请参阅 使用系统权限。以上内容阐述了有关 Android 应用在系统内存在方式的基础知识。本文的其余部分将向您介绍以下内容： 用于定义应用的核心框架组件您用来声明组件和应用必需设备功能的清单文件与应用代码分离并允许您的应用针对各种设备配置适当优化其行为的资源应用组件应用组件是 Android 应用的基本构建基块。每个组件都是一个不同的点，系统可以通过它进入您的应用。 并非所有组件都是用户的实际入口点，有些组件相互依赖，但每个组件都以独立实体形式存在，并发挥特定作用 — 每个组件都是唯一的构建基块，有助于定义应用的总体行为。 共有四种不同的应用组件类型。每种类型都服务于不同的目的，并且具有定义组件的创建和销毁方式的不同生命周期。 以下便是这四种应用组件类型： ActivityActivity 表示具有用户界面的单一屏幕。例如，电子邮件应用可能具有一个显示新电子邮件列表的 Activity、一个用于撰写电子邮件的 Activity 以及一个用于阅读电子邮件的 Activity。 尽管这些 Activity 通过协作在电子邮件应用中形成了一种紧密结合的用户体验，但每一个 Activity 都独立于其他 Activity 而存在。 因此，其他应用可以启动其中任何一个 Activity（如果电子邮件应用允许）。 例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的 Activity，以便用户共享图片。Activity 作为 Activity 的子类实现，您可以在 Activity 开发者指南中了解有关它的更多详情。 服务服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。 服务不提供用户界面。 例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与 Activity 的交互。 诸如 Activity 等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。服务作为 Service 的子类实现，您可以在服务开发者指南中了解有关它的更多详情。 内容提供程序内容提供程序管理一组共享的应用数据。您可以将数据存储在文件系统、SQLite 数据库、网络上或您的应用可以访问的任何其他永久性存储位置。 其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。 例如，Android 系统可提供管理用户联系人信息的内容提供程序。 因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分（如 ContactsContract.Data），以读取和写入有关特定人员的信息。内容提供程序也适用于读取和写入您的应用不共享的私有数据。 例如，记事本示例应用使用内容提供程序来保存笔记。 内容提供程序作为 ContentProvider 的子类实现，并且必须实现让其他应用能够执行事务的一组标准 API。 如需了解详细信息，请参阅内容提供程序开发者指南。 广播接收器广播接收器是一种用于响应系统范围广播通知的组件。 许多广播都是由系统发起的 — 例如，通知屏幕已关闭、电池电量不足或已拍摄照片的广播。应用也可以发起广播 — 例如，通知其他应用某些数据已下载至设备，并且可供其使用。 尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知，在发生广播事件时提醒用户。 但广播接收器更常见的用途只是作为通向其他组件的“通道”，设计用于执行极少量的工作。 例如，它可能会基于事件发起一项服务来执行某项工作。广播接收器作为 BroadcastReceiver 的子类实现，并且每条广播都作为 Intent 对象进行传递。 如需了解详细信息，请参阅 BroadcastReceiver 类。 Android 系统设计的独特之处在于，任何应用都可以启动其他应用的组件。 例如，如果您想让用户使用设备的相机拍摄照片，很可能有另一个应用可以执行该操作，那么您的应用就可以利用该应用，而不是开发一个 Activity 来自行拍摄照片。 您不需要集成甚至链接到该相机应用的代码，而是只需启动拍摄照片的相机应用中的 Activity。 完成拍摄时，系统甚至会将照片返回您的应用，以便您使用。对用户而言，就好像相机真正是您应用的组成部分。 当系统启动某个组件时，会启动该应用的进程（如果尚未运行），并实例化该组件所需的类。 例如，如果您的应用启动相机应用中拍摄照片的 Activity，则该 Activity 会在属于相机应用的进程，而不是您的应用的进程中运行。因此，与大多数其他系统上的应用不同，Android 应用并没有单一入口点（例如，没有 main() 函数）。 由于系统在单独的进程中运行每个应用，且其文件权限会限制对其他应用的访问，因此您的应用无法直接启动其他应用中的组件， 但 Android 系统却可以。因此，要想启动其他应用中的组件，您必须向系统传递一则消息，说明您想启动特定组件的 Intent。 系统随后便会为您启动该组件。 启动组件四种组件类型中的三种 — Activity、服务和广播接收器 — 通过名为 Intent 的异步消息进行启动。Intent 会在运行时将各个组件相互绑定（您可以将 Intent 视为从其他组件请求操作的信使），无论组件属于您的应用还是其他应用。 Intent 使用 Intent 对象创建，它定义的消息用于启动特定组件或特定类型的组件 — Intent 可以是显式的，也可以是隐式的。 对于 Activity 和服务， Intent 定义要执行的操作（例如，“查看”或“发送”某个内容），并且可以指定要执行操作的数据的 URI（以及正在启动的组件可能需要了解的信息）。 例如， Intent 传达的请求可以是启动一个显示图像或打开网页的 Activity。 在某些情况下，您可以启动 Activity 来接收结果，在这种情况下，Activity 也会在 Intent 中返回结果（例如，您可以发出一个 Intent，让用户选取某位联系人并将其返回给您 — 返回 Intent 包括指向所选联系人的 URI）。 对于广播接收器， Intent 只会定义要广播的通知（例如，指示设备电池电量不足的广播只包括指示“电池电量不足”的已知操作字符串）。 Intent 不会启动另一个组件类型 - 内容提供程序，后者会在成为 ContentResolver 的请求目标时启动。 内容解析程序通过内容提供程序处理所有直接事务，使得通过提供程序执行事务的组件可以无需执行事务，而是改为在 ContentResolver 对象上调用方法。 这会在内容提供程序与请求信息的组件之间留出一个抽象层（以确保安全）。 每种类型的组件有不同的启动方法： 您可以通过将 Intent 传递到 startActivity() 或 startActivityForResult()（当您想让 Activity 返回结果时）来启动 Activity（或为其安排新任务）。您可以通过将 Intent 传递到 startService() 来启动服务（或对执行中的服务下达新指令）。 或者，您也可以通过将 Intent 传递到 bindService() 来绑定到该服务。您可以通过将 Intent 传递到 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast() 等方法来发起广播；您可以通过在 ContentResolver 上调用 query() 来对内容提供程序执行查询。如需了解有关 Intent 用法的详细信息，请参阅 Intent 和 Intent 过滤器文档。 以下文档中还提供了有关启动特定组件的详细信息： Activity、服务、BroadcastReceiver 和内容提供程序。 清单文件在 Android 系统启动应用组件之前，系统必须通过读取应用的 AndroidManifest.xml 文件（“清单”文件）确认组件存在。 您的应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。 除了声明应用的组件外，清单文件还有许多其他作用，如： 确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限根据应用使用的 API，声明应用所需的最低 API 级别声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕应用需要链接的 API 库（Android 框架 API 除外），如 Google 地图库其他功能声明组件清单文件的主要任务是告知系统有关应用组件的信息。例如，清单文件可以像下面这样声明 Activity：123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest ... &gt; &lt;application android:icon=&quot;@drawable/app_icon.png&quot; ... &gt; &lt;activity android:name=&quot;com.example.project.ExampleActivity&quot; android:label=&quot;@string/example_label&quot; ... &gt; &lt;/activity&gt; ... &lt;/application&gt;&lt;/manifest&gt; 在 元素中，android:icon 属性指向标识应用的图标所对应的资源。 在 元素中，android:name 属性指定 Activity 子类的完全限定类名，android:label 属性指定用作 Activity 的用户可见标签的字符串。 您必须通过以下方式声明所有应用组件： Activity 的 元素服务的 元素广播接收器的 元素内容提供程序的 元素您包括在源代码中，但未在清单文件中声明的 Activity、服务和内容提供程序对系统不可见，因此也永远不会运行。 不过，广播接收器可以在清单文件中声明或在代码中动态创建（如 BroadcastReceiver 对象）并通过调用 registerReceiver() 在系统中注册。 如需了解有关如何为您的应用构建清单文件的详细信息，请参阅 AndroidManifest.xml 文件文档。 声明组件功能如上文启动组件中所述，您可以使用 Intent 来启动 Activity、服务和广播接收器。 您可以通过在 Intent 中显式命名目标组件（使用组件类名）来执行此操作。 不过，Intent 的真正强大之处在于隐式 Intent 概念。 隐式 Intent 的作用无非是描述要执行的操作类型（还可选择描述您想执行的操作所针对的数据），让系统能够在设备上找到可执行该操作的组件，并启动该组件。 如果有多个组件可以执行 Intent 所描述的操作，则由用户选择使用哪一个组件。 系统通过将接收到的 Intent 与设备上的其他应用的清单文件中提供的 Intent 过滤器进行比较来确定可以响应 Intent 的组件。 当您在应用的清单文件中声明 Activity 时，可以选择性地加入声明 Activity 功能的 Intent 过滤器，以便响应来自其他应用的 Intent。 您可以通过将 元素作为组件声明元素的子项进行添加来为您的组件声明 Intent 过滤器。 例如，如果您开发的电子邮件应用包含一个用于撰写新电子邮件的 Activity，则可以像下面这样声明一个 Intent 过滤器来响应“send” Intent（以发送新电子邮件）：123456789101112&lt;manifest ... &gt; ... &lt;application ... &gt; &lt;activity android:name=&quot;com.example.project.ComposeEmailActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt; &lt;data android:type=&quot;*/*&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 然后，如果另一个应用创建了一个包含ACTION_SEND 操作的 Intent，并将其传递到 startActivity()，则系统可能会启动您的 Activity，以便用户能够草拟并发送电子邮件。 如需了解有关创建 Intent 过滤器的详细信息，请参阅 Intent 和 Intent 过滤器文档。 声明应用要求基于 Android 系统的设备多种多样，并非所有设备都提供相同的特性和功能。 为防止将您的应用安装在缺少应用所需特性的设备上，您必须通过在清单文件中声明设备和软件要求，为您的应用支持的设备类型明确定义一个配置文件。 其中的大多数声明只是为了提供信息，系统不会读取它们，但 Google Play 等外部服务会读取它们，以便当用户在其设备中搜索应用时为用户提供过滤功能。 例如，如果您的应用需要相机，并使用 Android 2.1（API 级别 7）中引入的 API，您应该像下面这样在清单文件中以要求形式声明这些信息：123456&lt;manifest ... &gt; &lt;uses-feature android:name=&quot;android.hardware.camera.any&quot; android:required=&quot;true&quot; /&gt; &lt;uses-sdk android:minSdkVersion=&quot;7&quot; android:targetSdkVersion=&quot;19&quot; /&gt; ...&lt;/manifest&gt; 现在，没有相机且 Android 版本低于 2.1 的设备将无法从 Google Play 安装您的应用。 不过，您也可以声明您的应用使用相机，但并不要求必须使用。 在这种情况下，您的应用必须将 required 属性设置为 “false”，并在运行时检查设备是否具有相机，然后根据需要停用任何相机功能。 设备兼容性文档中提供了有关如何管理应用与不同设备兼容性的详细信息。 应用资源Android 应用并非只包含代码 — 它还需要与源代码分离的资源，如图像、音频文件以及任何与应用的视觉呈现有关的内容。 例如，您应该通过 XML 文件定义 Activity 用户界面的动画、菜单、样式、颜色和布局。 使用应用资源能够在不修改代码的情况下轻松地更新应用的各种特性，并可通过提供备用资源集让您能够针对各种设备配置（如不同的语言和屏幕尺寸）优化您的应用。 对于您的 Android 项目中包括的每一项资源，SDK 构建工具都会定义一个唯一的整型 ID，您可以利用它来引用应用代码或 XML 中定义的其他资源中的资源。 例如，如果您的应用包含一个名为 logo.png 的图像文件（保存在 res/drawable/ 目录中），则 SDK 工具会生成一个名为 R.drawable.logo 的资源 ID，您可以利用它来引用该图像并将其插入您的用户界面。 提供与源代码分离的资源的其中一个最重要优点在于，您可以提供针对不同设备配置的备用资源。 例如，通过在 XML 中定义 UI 字符串，您可以将字符串翻译为其他语言，并将这些字符串保存在单独的文件中。 然后，Android 系统会根据向资源目录名称追加的语言限定符（如为法语字符串值追加 res/values-fr/）和用户的语言设置，对您的 UI 应用相应的语言字符串。 Android 支持许多不同的备用资源限定符。限定符是一种加入到资源目录名称中，用来定义这些资源适用的设备配置的简短字符串。 再举一例，您应该经常会根据设备的屏幕方向和尺寸为 Activity 创建不同的布局。 例如，当设备屏幕为纵向（长型）时，您可能想要一种垂直排列按钮的布局；但当屏幕为横向（宽型）时，应按水平方向排列按钮。 要想根据方向更改布局，您可以定义两种不同的布局，然后对每个布局的目录名称应用相应的限定符。 然后，系统会根据当前设备方向自动应用相应的布局。 应用资料提供资源您应该始终外部化应用资源，例如图像和代码中的字符串，这样有利于您单独维护这些资源。 此外，您还应该为特定设备配置提供备用资源，方法是将它们分组到专门命名的资源目录中。 在运行时，Android 会根据当前配置使用适当的资源。例如，您可能需要根据屏幕尺寸提供不同的 UI 布局，或者根据语言设置提供不同的字符串。 外部化应用资源后，即可使用在项目 R 类中生成的资源 ID 访问这些资源。有关如何在应用中使用资源，我们将在访问资源中讨论。 本文档介绍如何对 Android 项目中的资源进行分组，以及如何为特定的设备配置提供备用资源。 分组资源类型您应将各种资源放入项目 res/ 目录的特定子目录下。例如，以下是一个简单项目的文件层次结构：12345678910111213MyProject/ src/ MyActivity.java res/ drawable/ graphic.png layout/ main.xml info.xml mipmap/ icon.png values/ strings.xml 正如您在此示例中所看到的那样，res/ 目录包含所有资源（在子目录下）：一个图像资源、两个布局资源、启动器图标的 mipmap/ 目录以及一个字符串资源文件。资源目录名称非常重要，将在表 1 中进行介绍。 注：如需了解有关使用 mipmap 文件夹的详细信息，请参阅管理项目概览。 表 1. 项目 res/ 目录内支持的资源目录。 目录 资源类型animator/ 用于定义属性动画的 XML 文件。anim/ 定义渐变动画的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 animator/ 目录。）color/ 用于定义颜色状态列表的 XML 文件。请参阅颜色状态列表资源drawable/位图文件（.png、.9.png、.jpg、.gif）或编译为以下可绘制对象资源子类型的 XML 文件： 位图文件九宫格（可调整大小的位图）状态列表形状动画可绘制对象其他可绘制对象请参阅 可绘制对象资源。 mipmap/ 适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 mipmap/ 文件夹管理启动器图标的详细信息，请参阅管理项目概览。layout/ 用于定义用户界面布局的 XML 文件。 请参阅布局资源。menu/ 用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML 文件。请参阅菜单资源。raw/要以原始形式保存的任意文件。要使用原始 InputStream 打开这些资源，请使用资源 ID（即 R.raw.filename）调用 Resources.openRawResource()。 但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在 assets/ 目录下（而不是 res/raw/）。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。 values/包含字符串、整型数和颜色等简单值的 XML 文件。 其他 res/ 子目录中的 XML 资源文件是根据 XML 文件名定义单个资源，而 values/ 目录中的文件可描述多个资源。对于此目录中的文件， 元素的每个子元素均定义一个资源。例如， 元素创建 R.string 资源， 元素创建 R.color 资源。 由于每个资源均用其自己的 XML 元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。 例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定： arrays.xml，用于资源数组（类型化数组）。colors.xml：颜色值。dimens.xml：尺寸值。strings.xml：字符串值。styles.xml：样式。请参阅字符串资源、样式资源和更多资源类型。 xml/ 可以在运行时通过调用 Resources.getXML() 读取的任意 XML 文件。各种 XML 配置文件（如可搜索配置）都必须保存在此处。注意：切勿将资源文件直接保存在 res/ 目录内，这会导致出现编译错误。 如需了解有关某些资源类型的详细信息，请参阅资源类型文档。 保存在表 1 中定义的子目录下的资源是“默认”资源。即，这些资源定义应用的默认设计和内容。但是，采用 Android 技术的不同设备类型可能需要不同类型的资源。例如，如果设备的屏幕尺寸大于标准屏幕，则应提供不同的布局资源，以充分利用额外的屏幕空间。 或者，如果设备的语言设置不同，则应提供不同的字符串资源，以转换用户界面中的文本。 要为不同的设备配置提供这些不同资源，除了默认资源以外，您还需要提供备用资源。 提供备用资源 图 1. 两种不同的设备，均使用不同的布局资源。 几乎每个应用都应提供备用资源以支持特定的设备配置。 例如，对于不同的屏幕密度和语言，您应分别包括备用可绘制对象资源和备用字符串资源。 在运行时，Android 会检测当前设备配置并为应用加载合适的资源。 为一组资源指定特定于配置的备用资源： 在 res/ 中创建一个以 &lt;resources_name&gt;-&lt;config_qualifier&gt; 形式命名的新目录。 &lt;resources_name&gt; 是相应默认资源的目录名称（如表 1 中所定义）。 是指定要使用这些资源的各个配置的名称（如表 2 中所定义）。您可以追加多个 。以短划线将其分隔。 注意：追加多个限定符时，必须按照表 2 中列出的相同顺序放置它们。如果限定符的顺序错误，则该资源将被忽略。 将相应的备用资源保存在此新目录下。这些资源文件的名称必须与默认资源文件完全一样。例如，以下是一些默认资源和备用资源：1234567res/ drawable/ icon.png background.png drawable-hdpi/ icon.png background.png hdpi 限定符表示该目录中的资源适用于屏幕密度较高的设备。其中每个可绘制对象目录中的图像已针对特定的屏幕密度调整大小，但是文件名完全相同。 这样一来，用于引用 icon.png 或 background.png 图像的资源 ID 始终相同，但是 Android 会通过将设备配置信息与资源目录名称中的限定符进行比较，选择最符合当前设备的各个资源版本。 Android 支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。表 2 按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。 表 2. 配置限定符名称。 配置 限定符值 说明MCC 和 MNC 示例：mcc310mcc310-mnc004mcc208-mnc00等等移动国家代码 (MCC)，（可选）后跟设备 SIM 卡中的移动网络代码 (MNC)。例如，mcc310 是指美国的任一运营商，mcc310-mnc004 是指美国的 Verizon 公司，mcc208-mnc00 是指法国的 Orange 公司。 如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM 卡。 也可以单独使用 MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”限定符（稍后进行介绍）。 如果决定使用 MCC 和 MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。 另请参阅配置字段 mcc 和 mnc，这两个字段分别表示当前的移动国家代码和移动网络代码。 语言和区域 示例：123456enfren-rUSfr-rFRfr-rCA等等 语言通过由两个字母组成的 ISO 639-1 语言代码定义，可以选择后跟两个字母组成的 ISO 3166-1-alpha-2 区域码（前带小写字母“r”）。 这些代码不区分大小写；r 前缀用于区分区域码。 不能单独指定区域。 如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 有关针对其他语言本地化应用的完整指南，请参阅本地化。 另请参阅 locale 配置字段，该字段表示当前的语言区域。 布局方向 ldrtlldltr应用的布局方向。ldrtl 是指“布局方向从右到左”。ldltr 是指“布局方向从左到右”，这是默认的隐式值。 它适用于布局、图片或值等任何资源。 例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下：123456789res/ layout/ main.xml (Default layout) layout-ar/ main.xml (Specific layout for Arabic) layout-ldrtl/ main.xml (Any &quot;right-to-left&quot; language, except for Arabic, because the &quot;ar&quot; language qualifier has a higher precedence.) 注：要为应用启用从右到左的布局功能，必须将 supportsRtl 设置为 “true”，并将 targetSdkVersion 设置为 17 或更高版本。 此项为 API 级别 17 中新增配置。1smallestWidth sw&lt;N&gt;dp 示例：sw320dpsw600dpsw720dp等等屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。 具体来说，设备的 smallestWidth 是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用 UI 的可用宽度至少为 dp。 例如，如果布局要求屏幕区域的最小尺寸始终至少为 600dp，则可使用此限定符创建布局资源 res/layout-sw600dp/。仅当可用屏幕的最小尺寸至少为 600dp 时，系统才会使用这些资源，而不考虑 600dp 所代表的边是用户所认为的高度还是宽度。smallestWidth 是设备的固定屏幕尺寸特性；设备的 smallestWidth 不会随屏幕方向的变化而改变。 设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿 smallestWidth 轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。 因此，使用的值应该是布局所需要的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。 以下是一些可用于普通屏幕尺寸的值：12345678320，适用于屏幕配置如下的设备：240x320 ldpi（QVGA 手机）320x480 mdpi（手机）480x800 hdpi（高密度手机）480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备 smallestWidth 的值。 此项为 API 级别 13 中新增配置。 另请参阅 android:requiresSmallestWidthDp 属性和 smallestScreenWidthDp 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。 如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用宽度 wdp 示例：w720dpw1024dp等等指定资源应该使用的最小可用屏幕宽度，以 dp 为单位，由 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。 应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI 元素，考虑到这些 UI 元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。 此项为 API 级别 13 中新增配置。 另请参阅 screenWidthDp 配置字段，该字段存放当前屏幕宽度。 如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用高度 hdp 示例：h720dph1024dp等等指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 值定义。 在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。 应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。 此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI 元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。 非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。 此项为 API 级别 13 中新增配置。 另请参阅 screenHeightDp 配置字段，该字段存放当前屏幕宽度。 如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 屏幕尺寸 smallnormallargexlargesmall：尺寸类似于低密度 QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为 320x426 dp 单位。例如，QVGA 低密度屏幕和 VGA 高密度屏幕。normal：尺寸类似于中等密度 HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为 320x470 dp 单位。例如，WQVGA 低密度屏幕、HVGA 中等密度屏幕、WVGA 高密度屏幕。large：尺寸类似于中等密度 VGA 屏幕的屏幕。 大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。xlarge：明显大于传统中等密度 HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为 720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。 API 级别 9 中的新增配置。注：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。 注意：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统不会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。 此项为 API 级别 4 中新增配置。 如需了解详细信息，请参阅支持多种屏幕。 另请参阅 screenLayout 配置字段，该字段表示屏幕是小尺寸、标准尺寸还是大尺寸。 屏幕纵横比 longnotlonglong：宽屏，如 WQVGA、WVGA、FWVGAnotlong：非宽屏，如 QVGA、HVGA 和 VGA此项为 API 级别 4 中新增配置。 它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。 另请参阅 screenLayout 配置字段，该字段指示屏幕是否为宽屏。 圆形屏幕 roundnotroundround：圆形屏幕，例如圆形可穿戴式设备notround：方形屏幕，例如手机或平板电脑此项为 API 级别 23 中新增配置。 另请参阅 isScreenRound() 配置方法，其指示屏幕是否为宽屏。 屏幕方向 portlandport：设备处于纵向（垂直）land：设备处于横向（水平）如果用户旋转屏幕，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 另请参阅 orientation 配置字段，该字段指示当前的设备方向。 UI 模式 cardesktelevisionappliance watchcar：设备正在车载手机座上显示desk：设备正在桌面手机座上显示television：设备正在电视上显示，为用户提供“十英尺”体验，其 UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互appliance：设备用作不带显示屏的装置watch：设备配有显示屏，戴在手腕上此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。 如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读确定并监控插接状态和类型。 如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。 可以使用 UiModeManager 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 夜间模式 nightnotnightnight：夜间notnight：白天此项为 API 级别 8 中新增配置。 如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。 可以使用 UiModeManager 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 屏幕像素密度 (dpi) ldpimdpihdpixhdpixxhdpixxxhdpinodpitvdpianydpildpi：低密度屏幕；约为 120dpi。mdpi：中等密度（传统 HVGA）屏幕；约为 160dpi。hdpi：高密度屏幕；约为 240dpi。xhdpi：超高密度屏幕；约为 320dpi。此项为 API 级别 8 中新增配置xxhdpi：超超高密度屏幕；约为 480dpi。此项为 API 级别 16 中新增配置xxxhdpi：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多种屏幕”中的注释）；约为 640dpi。 此项为 API 级别 18 中新增配置nodpi：它可用于您不希望缩放以匹配设备密度的位图资源。tvdpi：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组， 主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和 hdpi 资源便已足够，系统将根据需要对其进行缩放。此项为 API 级别 13 中新增配置anydpi：此限定符适合所有屏幕密度，其优先级高于其他限定符。 这对于矢量可绘制对象很有用。 此项为 API 级别 21 中新增配置六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略 tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。123如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为 1.33*mdpi。例如，mdpi 屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。注：使用密度限定符并不表示资源仅适用于该密度的屏幕。 如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。 如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅支持多种屏幕。 触摸屏类型 notouchfingernotouch：设备没有触摸屏。finger：设备有一个专供用户通过手指直接与其交互的触摸屏。另请参阅 touchscreen 配置字段，该字段指示设备上的触摸屏类型。 键盘可用性 keysexposedkeyshiddenkeyssoftkeysexposed：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。 如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。keyshidden：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。keyssoft：设备已经启用软键盘（无论是否可见）。如果提供了 keysexposed 资源，但未提供 keyssoft 资源，那么只要系统已经启用软键盘，就会使用 keysexposed 资源，而不考虑键盘是否可见。 如果用户打开硬键盘，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 另请参阅配置字段 hardKeyboardHidden 和 keyboardHidden，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。 主要文本输入法 nokeysqwerty12keynokeys：设备没有用于文本输入的硬按键。qwerty：设备具有标准硬键盘（无论是否对用户可见）。12key：设备具有 12 键硬键盘（无论是否对用户可见）。另请参阅 keyboard 配置字段，该字段指示可用的主要文本输入法。 导航键可用性 navexposednavhiddennavexposed：导航键可供用户使用。navhidden：导航键不可用（例如，位于密封盖子后面）。如果用户显示导航键，它有可能在应用生命周期中发生改变。 如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 另请参阅 navigationHidden 配置字段，该字段指示导航键是否处于隐藏状态。123456789主要非触摸导航方法 nonavdpadtrackballwheel nonav：除了使用触摸屏以外，设备没有其他导航设施。dpad：设备具有用于导航的方向键。trackball：设备具有用于导航的轨迹球。wheel：设备具有用于导航的方向盘（不常见）。另请参阅 navigation 配置字段，该字段指示可用的导航方法类型。 平台版本（API 级别） 示例：v3v4v7等等设备支持的 API 级别。例如，v1 对应于 API 级别 1（带有 Android 1.0 或更高版本系统的设备），v4 对应于 API 级别 4（带有 Android 1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅 Android API 级别文档。 注：有些配置限定符是从 Android 1.0 才开始添加，因此并非所有版本的 Android 系统都支持所有限定符。使用新限定符会隐式添加平台版本限定符，因此较旧版本系统的设备必然会忽略它。 例如，使用 w600dp 限定符会自动包括 v13 限定符，因为可用宽度限定符是 API 级别 13 中的新增配置。为了避免出现任何问题，请始终包含一组默认资源（一组“不带限定符”的资源）。 如需了解详细信息，请参阅利用资源提供最佳设备兼容性部分。 限定符命名规则以下是一些关于使用配置限定符名称的规则： 您可以为单组资源指定多个限定符，并使用短划线分隔。例如，drawable-en-rUS-land 适用于横排美国英语设备。这些限定符必须遵循表 2 中列出的顺序。例如：错误：drawable-hdpi-port/正确：drawable-port-hdpi/不能嵌套备用资源目录。例如，您不能拥有 res/drawable/drawable-en/。值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。对于每种限定符类型，仅支持一个值。例如，若要对西班牙语和法语使用相同的可绘制对象文件，则您肯定不能拥有名为 drawable-rES-rFR/ 的目录，而是需要两个包含相应文件的资源目录，如 drawable-rES/ 和 drawable-rFR/。然而，实际上您无需将相同的文件都复制到这两个位置。相反，您可以创建指向资源的别名。 请参阅下面的创建别名资源。将备用资源保存到以这些限定符命名的目录中之后，Android 会根据当前设备配置在应用中自动应用这些资源。 每次请求资源时，Android 都会检查备用资源目录是否包含所请求的资源文件，然后查找最佳匹配资源（下文进行介绍）。 如果没有与特定设备配置匹配的备用资源，则 Android 会使用相应的默认资源（一组用于不含配置限定符的特定资源类型的资源）。 创建别名资源如果您想将某一资源用于多种设备配置（但是不想作为默认资源提供），则无需将同一资源放入多个备用资源目录中。 相反，您可以（在某些情况下）创建备用资源，充当保存在默认资源目录下的资源的别名。 注：并非所有资源都会提供相应机制让您创建指向其他资源的别名。 特别是，xml/ 目录中的动画资源、菜单资源、原始资源以及其他未指定资源均不提供此功能。 例如，假设您有一个应用图标 icon.png，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，您可以将用于二者的图像另存为 icon_ca.png（除 icon.png 以外的任何名称），并将其放入默认 res/drawable/ 目录中。然后，在 res/drawable-en-rCA/ 和 res/drawable-fr-rCA/ 中创建 icon.xml 文件，使用 元素引用 icon_ca.png 资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。） 可绘制对象要创建指向现有可绘制对象的别名，请使用 元素。例如：123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;@drawable/icon_ca&quot; /&gt; 如果将此文件另存为 icon.xml（例如，在备用资源目录中，另存为 res/drawable-en-rCA/），则会编译到可作为 R.drawable.icon 引用的资源中，但实际上它是 R.drawable.icon_ca 资源（保存在 res/drawable/ 中）的别名。 布局要创建指向现有布局的别名，请使用包装在 中的 元素。例如：1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;merge&gt; &lt;include layout=&quot;@layout/main_ltr&quot;/&gt;&lt;/merge&gt; 如果将此文件另存为 main.xml，则会编译到可作为 R.layout.main 引用的资源中，但实际上它是 R.layout.main_ltr 资源的别名。 字符串和其他简单值要创建指向现有字符串的别名，只需将所需字符串的资源 ID 用作新字符串的值即可。例如：123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;string name=&quot;hello&quot;&gt;Hello&lt;/string&gt; &lt;string name=&quot;hi&quot;&gt;@string/hello&lt;/string&gt;&lt;/resources&gt;R.string.hi 资源现在是 R.string.hello 的别名。 其他简单值的原理相同。 例如，颜色：12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;red&quot;&gt;#f00&lt;/color&gt; &lt;color name=&quot;highlight&quot;&gt;@color/red&lt;/color&gt;&lt;/resources&gt; 利用资源提供最佳设备兼容性要使应用支持多种设备配置，则务必为应用使用的每种资源类型提供默认资源，这一点非常重要。 例如，如果应用支持多种语言，请始终包含不带语言和区域限定符的 values/ 目录（用于保存字符串）。相反，如果您将所有字符串放入带有语言和区域限定符的目录中，则在语言设置不支持您的字符串的设备上运行应用时，应用将会崩溃。 但是，只要提供默认 values/ 资源，应用就会正常运行（即使用户不理解该语言，这也总比崩溃要好）。 同样，如果您根据屏幕方向提供不同的布局资源，则应选择一个方向作为默认方向。 例如，不要在 layout-land/ 和 layout-port/ 中分别提供横向和纵向的布局资源，而是保留其中之一作为默认设置，例如：layout/ 用于横向，layout-port/ 用于纵向。 提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 minSdkVersion 设置为 4，并使用夜间模式（night 或 notnight，API 级别 8 中新增配置）限定所有可绘制对象资源，则 API 级别 4 设备无法访问可绘制对象资源，而且会崩溃。在这种情况下，您可能希望 notnight 成为默认资源，为此，您应排除该限定符，使可绘制对象资源位于 drawable/ 或 drawable-night/ 中。 因此，为了提供最佳设备兼容性，请始终为应用正确运行所必需的资源提供默认资源。 然后，使用配置限定符为特定的设备配置创建备用资源。 这条规则有一个例外：如果应用的 minSdkVersion 为 4 或更高版本，则在提供带屏幕密度限定符的备用可绘制对象资源时，不需要默认可绘制对象资源。 即使没有默认可绘制对象资源，Android 也可以从备用屏幕密度中找到最佳匹配项并根据需要缩放位图。 但是，为了在所有类型的设备上提供最佳体验，您应该为所有三种类型的密度提供备用可绘制对象。 Android 如何查找最佳匹配资源当您请求要为其提供备用资源的资源时，Android 会根据当前的设备配置选择要在运行时使用的备用资源。为演示 Android 如何选择备用资源，假设以下可绘制对象目录分别包含相同图像的不同版本：12345678drawable/drawable-en/drawable-fr-rCA/drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/drawable-port-notouch-12key/同时，假设设备配置如下： 语言区域 = en-GB屏幕方向 = port屏幕像素密度 = hdpi触摸屏类型 = notouch主要文本输入法 = 12key 通过将设备配置与可用的备用资源进行比较，Android 从 drawable-en-port 中选择可绘制对象。 系统使用以下逻辑决定要使用的资源： 123456789101112图 2. Android 如何查找最佳匹配资源的流程图。淘汰与设备配置冲突的资源文件。drawable-fr-rCA/ 目录与 en-GB 语言区域冲突，因而被淘汰。drawable/drawable-en/drawable-fr-rCA/drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/drawable-port-notouch-12key/ 例外：屏幕像素密度是唯一一个未因冲突而被淘汰的限定符。 尽管设备的屏幕密度为 hdpi，但是 drawable-port-ldpi/ 未被淘汰，因为此时每个屏幕密度均视为匹配。如需了解详细信息，请参阅支持多种屏幕文档。 选择列表（表 2）中（下一个）优先级最高的限定符。（先从 MCC 开始，然后下移。）是否有资源目录包括此限定符？若无，请返回到第 2 步，看看下一个限定符。（在该示例中，除非达到语言限定符，否则答案始终为“否”。）若有，请继续执行第 4 步。淘汰不含此限定符的资源目录。在该示例中，系统会淘汰所有不含语言限定符的目录。123456drawable/drawable-en/drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/drawable-port-notouch-12key/ 例外：如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅支持多种屏幕。 返回并重复第 2 步、第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被淘汰：1234drawable-en/drawable-en-port/drawable-en-notouch-12key/剩下的目录是 drawable-en-port。 尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中（不过，仍会将不带语言限定符的资源目录包含在该池中）。 根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统不会使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。 注：限定符的优先顺序（表 2 中）比与设备完全匹配的限定符数量更加重要。例如，在上面的第 4 步中，列表剩下的最后选项包括三个与设备完全匹配的限定符（方向、触摸屏类型和输入法），而 drawable-en 只有一个匹配参数（语言）。但是，语言的优先顺序高于其他两个限定符，因此 drawable-port-notouch-12key 被淘汰。 如需了解有关如何在应用中使用资源的更多信息，请转至访问资源。 处理运行时变更有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。 发生这种变化时，Android 会重启正在运行的 Activity（先后调用 onDestroy() 和 onCreate()）。重启行为旨在通过利用与新设备配置匹配的备用资源自动重新加载您的应用，来帮助它适应新配置。 要妥善处理重启行为，Activity 必须通过常规的Activity 生命周期恢复其以前的状态，在 Activity 生命周期中，Android 会在销毁 Activity 之前调用 onSaveInstanceState()，以便您保存有关应用状态的数据。 然后，您可以在 onCreate() 或 onRestoreInstanceState() 期间恢复 Activity 状态。 要测试应用能否在保持应用状态完好的情况下自行重启，您应该在应用中执行各种任务时调用配置变更（例如，更改屏幕方向）。 您的应用应该能够在不丢失用户数据或状态的情况下随时重启，以便处理如下事件：配置发生变化，或者用户收到来电并在应用进程被销毁很久之后返回到应用。 要了解如何恢复 Activity 状态，请阅读 Activity 生命周期。 但是，您可能会遇到这种情况：重启应用并恢复大量数据不仅成本高昂，而且给用户留下糟糕的使用体验。 在这种情况下，您有两个其他选择： 在配置变更期间保留对象允许 Activity 在配置变更时重启，但是要将有状态对象传递给 Activity 的新实例。 自行处理配置变更阻止系统在某些配置变更期间重启 Activity，但要在配置确实发生变化时接收回调，这样，您就能够根据需要手动更新 Activity。 在配置变更期间保留对象如果重启 Activity 需要恢复大量数据、重新建立网络连接或执行其他密集操作，那么因配置变更而引起的完全重启可能会给用户留下应用运行缓慢的体验。 此外，依靠系统通过onSaveInstanceState() 回调为您保存的 Bundle，可能无法完全恢复 Activity 状态，因为它并非设计用于携带大型对象（例如位图），而且其中的数据必须先序列化，再进行反序列化，这可能会消耗大量内存并使得配置变更速度缓慢。 在这种情况下，如果 Activity 因配置变更而重启，则可通过保留 Fragment 来减轻重新初始化 Activity 的负担。此片段可能包含对您要保留的有状态对象的引用。 当 Android 系统因配置变更而关闭 Activity 时，不会销毁您已标记为要保留的 Activity 的片段。 您可以将此类片段添加到 Activity 以保留有状态的对象。 要在运行时配置变更期间将有状态的对象保留在片段中，请执行以下操作： 扩展 Fragment 类并声明对有状态对象的引用。在创建片段后调用 setRetainInstance(boolean)。将片段添加到 Activity。重启 Activity 后，使用 FragmentManager 检索片段。例如，按如下方式定义片段：123456789101112131415161718192021public class RetainedFragment extends Fragment &#123; // data object we want to retain private MyDataObject data; // this method is only called once for this fragment @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // retain this fragment setRetainInstance(true); &#125; public void setData(MyDataObject data) &#123; this.data = data; &#125; public MyDataObject getData() &#123; return data; &#125;&#125; 注意：尽管您可以存储任何对象，但是切勿传递与 Activity 绑定的对象，例如，Drawable、Adapter、View 或其他任何与 Context 关联的对象。否则，它将泄漏原始 Activity 实例的所有视图和资源。 （泄漏资源意味着应用将继续持有这些资源，但是无法对其进行垃圾回收，因此可能会丢失大量内存。） 然后，使用 FragmentManager 将片段添加到 Activity。在运行时配置变更期间再次启动 Activity 时，您可以获得片段中的数据对象。 例如，按如下方式定义 Activity：123456789101112131415161718192021222324252627282930313233public class MyActivity extends Activity &#123; private RetainedFragment dataFragment; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); // find the retained fragment on activity restarts FragmentManager fm = getFragmentManager(); dataFragment = (DataFragment) fm.findFragmentByTag(“data”); // create the fragment and data the first time if (dataFragment == null) &#123; // add the fragment dataFragment = new DataFragment(); fm.beginTransaction().add(dataFragment, “data”).commit(); // load the data from the web dataFragment.setData(loadMyData()); &#125; // the data is available in dataFragment.getData() ... &#125; @Override public void onDestroy() &#123; super.onDestroy(); // store the data in the fragment dataFragment.setData(collectMyLoadedData()); &#125;&#125; 在此示例中，onCreate() 添加了一个片段或恢复了对它的引用。此外，onCreate() 还将有状态的对象存储在片段实例内部。onDestroy() 对所保留的片段实例内的有状态对象进行更新。 自行处理配置变更如果应用在特定配置变更期间无需更新资源，并且因性能限制您需要尽量避免重启，则可声明 Activity 将自行处理配置变更，这样可以阻止系统重启 Activity。 注：自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源。 只能在您必须避免 Activity 因配置变更而重启这一万般无奈的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并不建议使用此方法。 要声明由 Activity 处理配置变更，请在清单文件中编辑相应的 元素，以包含 android:configChanges 属性以及代表要处理的配置的值。android:configChanges 属性的文档中列出了该属性的可能值（最常用的值包括 “orientation” 和 “keyboardHidden”，分别用于避免因屏幕方向和可用键盘改变而导致重启）。您可以在该属性中声明多个配置值，方法是用管道 | 字符分隔这些配置值。 例如，以下清单文件代码声明的 Activity 可同时处理屏幕方向变更和键盘可用性变更： 现在，当其中一个配置发生变化时，MyActivity 不会重启。相反，MyActivity 会收到对 onConfigurationChanged() 的调用。向此方法传递 Configuration 对象指定新设备配置。您可以通过读取 Configuration 中的字段，确定新配置，然后通过更新界面中使用的资源进行适当的更改。调用此方法时，Activity 的 Resources 对象会相应地进行更新，以根据新配置返回资源，这样，您就能够在系统不重启 Activity 的情况下轻松重置 UI 的元素。 注意：从 Android 3.2（API 级别 13）开始，当设备在纵向和横向之间切换时，“屏幕尺寸”也会发生变化。因此，在开发针对 API 级别 13 或更高版本（正如 minSdkVersion 和 targetSdkVersion 属性中所声明）的应用时，若要避免由于设备方向改变而导致运行时重启，则除了 “orientation” 值以外，您还必须添加 “screenSize” 值。 也就是说，您必须声明 android:configChanges=”orientation|screenSize”。但是，如果您的应用面向 API 级别 12 或更低版本，则 Activity 始终会自行处理此配置变更（即便是在 Android 3.2 或更高版本的设备上运行，此配置变更也不会重启 Activity）。 例如，以下 onConfigurationChanged() 实现检查当前设备方向： 12345678910@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); // Checks the orientation of the screen if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) &#123; Toast.makeText(this, &quot;landscape&quot;, Toast.LENGTH_SHORT).show(); &#125; else if (newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)&#123; Toast.makeText(this, &quot;portrait&quot;, Toast.LENGTH_SHORT).show(); &#125;&#125; Configuration 对象代表所有当前配置，而不仅仅是已经变更的配置。大多数时候，您并不在意配置具体发生了哪些变更，而且您可以轻松地重新分配所有资源，为您正在处理的配置提供备用资源。 例如，由于 Resources 对象现已更新，因此您可以通过 setImageResource() 重置任何 ImageView，并且使用适合于新配置的资源（如提供资源中所述）。 请注意，Configuration 字段中的值是与 Configuration 类中的特定常量匹配的整型数。有关要对每个字段使用哪些常量的文档，请参阅 Configuration 参考文档中的相应字段。 请谨记：在声明由 Activity 处理配置变更时，您有责任重置要为其提供备用资源的所有元素。 如果您声明由 Activity 处理方向变更，而且有些图像应该在横向和纵向之间切换，则必须在 onConfigurationChanged() 期间将每个资源重新分配给每个元素。 如果无需基于这些配置变更更新应用，则可不用实现 onConfigurationChanged()。在这种情况下，仍将使用在配置变更之前用到的所有资源，只是您无需重启 Activity。 但是，应用应该始终能够在保持之前状态完好的情况下关闭和重启，因此您不得试图通过此方法来逃避在正常 Activity 生命周期期间保持您的应用状态。 这不仅仅是因为还存在其他一些无法禁止重启应用的配置变更，还因为有些事件必须由您处理，例如用户离开应用，而在用户返回应用之前该应用已被销毁。 如需了解有关您可以在 Activity 中处理哪些配置变更的详细信息，请参阅 android:configChanges 文档和 Configuration 类。 本地化您的应用Android可在许多地区的许多设备上运行。为了覆盖大多数用户，您的应用应以适合使用您的应用的区域设置的方式处理文本，音频文件，数字，货币和图形。 本文档介绍了本地化Android应用的最佳做法。 您应具备Java编程语言的工作知识，熟悉Android资源加载，XML中用户界面元素的 声明，活动生命周期等开发注意事项以及国际化和本地化的一般原则。 尽量使用Android资源框架将应用程序的本地化方面与核心的基于Java的功能分开，这是一个很好的做法： 您可以将应用程序用户界面的大部分或全部内容放入资源文件中，如本文档和 提供资源中所述。另一方面，用户界面的行为是由基于Java的代码驱动的。例如，如果用户根据语言环境输入需要格式化或排序不同的数据，则可以使用Java编程语言以编程方式处理数据。本文档不包括如何本地化您的基于Java的代码。有关在您的应用中本地化字符串的简短指南，请参阅培训课程， 支持不同的语言。 概述：Android中的资源切换资源是文本字符串，布局，声音，图形以及您的Android应用所需的任何其他静态数据。应用程序可以包含多组资源，每组资源都针对不同的设备配置进行了自定义。当用户运行应用程序时，Android会自动选择并加载与设备最匹配的资源。 （本文档重点介绍本地化和区域设置，有关资源切换和您可以指定的所有配置类型（屏幕方向，触摸屏类型等）的完整说明，请参阅 提供替代资源。 当您编写应用程序时，可以为您的应用程序创建默认和替代资源以供使用。当用户运行您的应用时，Android系统会根据设备的区域设置选择要加载的资源。要创建资源，请将文件放置在项目res/目录的特定子目录中。 为什么默认资源很重要每当应用程序在您未提供区域设置特定文本的语言环境中运行时，Android会从中加载默认字符串 res/values/strings.xml。如果此缺省文件不存在，或者缺少应用程序需要的字符串，那么您的应用程序不会运行并显示错误。下面的例子说明了默认文本文件不完整时会发生什么。 例： 应用程序的基于Java的代码仅涉及两个字符串，text_a 而且text_b。这个程序包括一个本地化的资源文件（res/values-en/strings.xml定义）text_a和 text_b英语。此应用程序还包含一个默认资源文件（res/values/strings.xml），其中包含一个定义text_a，但不包括text_b： 当此应用在设置为英语的语言环境设备上启动时，该应用可能无问题地运行，因为它 res/values-en/strings.xml包含两个所需的文本字符串。但是，如果在设置为英语以外的语言的设备上启动此应用程序，用户将看到错误消息和强制关闭按钮。该应用程序无法加载。为防止出现这种情况，请确保res/values/strings.xml 文件存在，并确定每个需要的字符串。这种情况适用于所有类型的资源，而不仅仅是字符串：您需要创建一组默认资源文件，其中包含应用程序调用的所有资源 - 布局，可绘制，动画等。有关测试的信息，请参阅 测试默认值资源。 使用资源进行本地化如何创建默认资源将应用程序的默认文本放入 res/values/strings.xml。 文本字符串res/values/strings.xml应使用默认语言，这是您希望大多数应用用户说话的语言。 默认资源集还必须包含任何默认的可绘制和布局，并且可以包含其他类型的资源，如动画： res/drawable/（必需的目录至少保存一个图形文件，用于Google Play上应用的图标）res/layout/ （需要保存定义默认布局的XML文件的目录）res/anim/（如果您有任何 文件夹，则需要）res/anim-res/xml/（如果您有任何 文件夹，则需要）res/xml-res/raw/（如果您有任何 文件夹，则需要）res/raw-提示：在您的代码中，检查每个对Android资源的引用。确保为每个资源定义了一个默认资源。还要确保默认的字符串文件是完整的：本地化的 字符串文件可以包含字符串的一个子集，但是默认的字符串文件必须包含它们全部。 如何创建替代资源本地化应用程序的很大一部分是为不同语言提供替代文本。在某些情况下，您还可以提供其他图形，声音，布局和其他特定于语言环境的资源。 应用程序可以指定许多 目录，每个目录都有不同的限定符。要为不同的区域设置创建替代资源，请使用指定语言或语言区域组合的限定符。（资源目录的名称必须符合Provide Alternative Resources中所述的命名方案 ，否则您的应用程序无法编译。）res// 例： 假设你的应用的默认语言是英文。假设您还想将应用中的所有文本本地化为法文，并将您应用中的大部分文本（除应用标题外的所有文本）本地化为日文。在这种情况下，您可以创建三个备选strings.xml 文件，每个文件都存储在特定于语言环境的资源目录中： res/values/strings.xml包含应用程序使用的所有字符串的英文文本，包括名为字符串的文本title。res/values-fr/strings.xml包含所有字符串的法文文本，包括title。res/values-ja/strings.xml包含所有字符串除外的 日文文本title。如果您的基于Java的代码引用R.string.title，那么在运行时会发生以下情况： 如果设备设置为法语以外的任何语言，则Android会title从该res/values/strings.xml文件加载 。如果设备设置为法语，则Android会title从该 res/values-fr/strings.xml文件加载。请注意，如果设备设置为日语，Android会title在res/values-ja/strings.xml文件中查找 。但是由于该文件中不包含此类字符串，Android会回退到默认值，并title从res/values/strings.xml文件加载英文 。 哪些资源优先？如果多个资源文件与设备的配置相匹配，则Android会根据一组规则来决定要使用哪个文件。在可以在资源目录名称中指定的限定符中，语言环境几乎总是优先。 例： 假设一个应用程序包含一组默认图形和另外两组图形，每个图形均针对不同的设备设置进行了优化： res/drawable/包含默认图形。res/drawable-small-land-stylus/包含经过优化的图形，用于预期来自手写笔输入的设备，并且具有横向方向的QVGA低密度屏幕。res/drawable-ja/包含针对日语使用而优化的图形。如果应用程序在配置为使用日语的设备上运行，则Android会加载图形res/drawable-ja/，即使该设备恰好是需要从触控笔输入的设备，并且横向上具有QVGA低密度屏幕。 例外：在选择过程中唯一的优先于区域设置的限定符是MCC和MNC（移动国家代码和移动网络代码）。 例： 假设您有以下情况： 应用程序代码要求 R.string.text_a有两个相关的资源文件可用：res/values-mcc404/strings.xml，其中包含 text_a应用的默认语言，在这种情况下为英文。res/values-hi/strings.xml，其中包括 text_a印地文。该应用程序在具有以下配置的设备上运行：SIM卡连接到印度的移动网络（MCC 404）。语言设置为Hindi（hi）。即使设备配置为印地语，Android 也会text_a从 res/values-mcc404/strings.xml（英语）加载。这是因为在资源选择过程中，Android更喜欢MCC匹配的语言匹配。 选择过程并不总是像这些例子所表明的那样简单。请阅读Android如何找到最佳匹配资源，以获取更详细的流程描述。所有的限定符都按照提供替代资源表2中的优先顺序进行了描述和列出。 参考代码中的资源在您的应用程序的基于Java的代码中，您可以使用语法 或 。 有关更多信息，请参阅访问资源。R.resource_type.resource_nameandroid.R.resource_type.resource_name 管理本地化字符串将所有字符串移动到strings.xml中在构建应用程序时，不要硬编码任何字符串。相反，将所有字符串声明为默认strings.xml文件中的资源，这使得更新和本地化变得容易。strings.xml然后可以轻松提取，翻译文件中的字符串并将其集成到应用程序中（具有适当的限定符），而不会对编译代码进行任何更改。 如果您使用文本生成图像，请将这些字符串放入strings.xml，并在翻译后重新生成图像。 遵循Android用户界面字符串指南当你设计和开发的用户界面，请确保您密切关注如何你跟你的用户。一般来说，使用简洁且简洁的简洁压缩样式，并在整个UI中使用一致的样式。 确保您阅读并遵循材料设计建议书写风格和文字选择。这样做可以让您的应用看起来更加精美，并帮助用户更快地理解您的用户界面。 此外，尽可能使用Android标准术语，例如操作栏，选项菜单，系统栏，通知等UI元素。正确和一致地使用Android术语可以使翻译更轻松，并为用户带来更好的最终产品。 为声明字符串提供足够的上下文在您的strings.xml文件中声明字符串时，请确保描述使用字符串的上下文。这些信息对翻译非常重要，并可以提高翻译质量。它还可以帮助您更有效地管理您的字符串。 这里是一个例子： &lt;！ - 提交表单的动作。此文本位于可放置30个字符的按钮上 - &gt; 登录&lt;/ string&gt; 考虑提供上下文信息，其中可能包括： 这是什么字符串？何时何地呈现给用户？这是在布局？例如，按钮中的翻译比文本框中的翻译更不灵活。标记不应该翻译的消息部分字符串常常包含不应该翻译成其他语言的文本。常见示例可能是一段代码，一个值的占位符，一个特殊符号或名称。在准备翻译字符串时，请查找并标记应保持原样的文本，而无需翻译，以便翻译人员不会更改它。 要标记不应翻译的文本，请使用xliff:g 占位符标记。下面是一个示例标签，可确保在翻译过程中文本“％1 $ s”不会更改（否则可能会中断该消息）： &lt;xliff：g id = “time” example = “5 days” &gt; ％1 $ s &lt;/ xliff：g&gt; until holiday &lt;/ string&gt; 当您声明占位符标记时，请始终添加一个id属性，以说明占位符的用途。如果您的应用程序稍后替换了占位符值，请确保提供示例属性以阐明预期用途。 以下是一些占位符标签的例子：1&lt;resources xmlns：xliff = “urn：oasis：names：tc：xliff：document：1.2” &gt; &lt;！ - 一个特殊的unicode符号的示例占位符 - &gt; &lt;string name = “star_rating” &gt; 查看我们的5 &lt;xliff ：摹ID = “明星” &gt; \ u2605 &lt;/ XLIFF：g&gt;的&lt;/字符串&gt; &lt;！ -示例占位符一个一个网址- &gt; &lt;字符串名称= “app_homeurl” &gt; 请访问我们的&lt;XLIFF：摹ID = “application_homepage” &gt; http：//my/app/home.html &lt;/ xliff：g&gt;&lt;/字符串&gt; 1&lt;！ - 名称示例占位符 - &gt; &lt;string name = “prod_name” &gt; 在&lt;xliff：g id = “prod_gamegroup” &gt; Game Group &lt;/ xliff：g&gt; &lt;/ string&gt; &lt;！ - placeholder for a literal - &gt; &lt;string name = “promo_message” &gt; 请使用“ &lt;xliff：g id = ”promotion_code“ &gt; ABCDEFG &lt;/ xliff：g&gt; ”来获得折扣。&lt;/ string&gt; ... &lt;/ resources&gt; 本地化清单有关本地化和分发Android应用程序的完整概述，请参阅本地化核对表文档。 本地化提示设计您的应用程序以在任何语言环境中工作您不能假设用户运行您的应用的设备。该设备可能具有您未预期的硬件，或者可能设置为您不打算或者无法测试的语言环境。设计您的应用程序，使其正常运行或无论其运行在哪个设备上都会优雅地失败。 重要提示：确保您的应用包含一整套默认资源。 确保包含 res/drawable/和res/values/文件夹（文件夹名称中没有任何其他修饰符），其中包含您的应用程序需要的所有图像和文本。 如果某个应用程序即使缺少一个默认资源，也不会在设置为不受支持的区域设置的设备上运行。例如， res/values/strings.xml默认文件可能缺少应用程序需要的一个字符串：当应用程序在不支持的语言环境中运行并尝试加载时res/values/strings.xml，用户会看到一条错误消息和一个强制关闭按钮。 有关更多信息，请参阅测试默认资源。 设计灵活的布局如果您需要重新排列布局以适合特定语言（例如，德语的长词），则可以为该语言创建替代布局（例如res/layout-de/main.xml）。但是，这样做可能会让您的应用难以维护。最好创建一个更灵活的单一布局。 另一种典型情况是需要不同布局的语言。例如，您可能有一个联系表单，当应用程序以日语运行时应该包含两个名称字段，而当应用程序以其他语言运行时，应该包含三个名称字段。您可以通过以下两种方式之一处理： 根据语言或者可以编程启用或禁用的字段创建一个布局主布局包含另一个包含可更改字段的布局。第二个布局可以针对不同的语言有不同的配置。避免创建比您需要更多的资源文件和文本字符串您可能不需要为应用中的每个资源创建特定于语言环境的替代方案。例如，res/layout/main.xml文件中定义的布局 可能在任何语言环境中工作，在这种情况下，不需要创建任何替代布局文件。 另外，您可能不需要为每个字符串创建替代文本。例如，假设如下： 您应用的默认语言是美式英语。应用程序使用的每个字符串都是使用美国英语拼写定义的 res/values/strings.xml。对于一些重要的短语，你想提供英式英语拼写。当您的应用在英国的设备上运行时，您希望使用这些替代字符串。为此，您可以创建一个名为的小文件 res/values-en-rGB/strings.xml，其中仅包含应用程序在英国运行时应该不同的字符串。对于所有其他字符串，应用程序将回退到默认值并使用其中定义的内容res/values/strings.xml。 使用Android Context对象进行手动区域设置查找您可以使用ContextAndroid提供的对象查找语言环境： 字符串区域设置= 上下文。getResources （）。getConfiguration （）。区域设置。getDisplayName （）;使用应用翻译服务该应用翻译服务被整合到游戏控制台，它也是从访问Android的工作室。这是一种快速简便的方式，可以即时报价并向翻译公司下订单。您可以为应用UI字符串，Play商品详情文本，IAP名称和广告活动文本订购翻译为一种或多种语言。 测试本地化应用在设备上测试请记住，您正在测试的设备可能与其他地区的消费者可用的设备有很大不同。您设备上可用的区域设置可能与其他设备上可用的区域设置不同。此外，设备屏幕的分辨率和密度可能会有所不同，这可能会影响UI中字符串和绘图的显示。 要更改设备上的区域设置或语言，请使用设置应用程序。 在模拟器上测试有关使用模拟器的详细信息，请参阅Android模拟器。 创建和使用自定义区域设置“自定义”区域设置是Android系统图像未明确支持的语言/区域组合。您可以通过在模拟器中创建自定义语言环境来测试应用程序在自定义语言环境中的运行方式。有两种方法可以做到这一点： 使用可从应用程序选项卡访问的自定义区域设置应用程序。（创建自定义区域设置后，通过按住区域名称来切换到该区域。）如下所述，从adb shell更改为自定义区域设置。当您将模拟器设置为Android系统映像中不可用的语言环境时，系统本身将以其默认语言显示。但是，您的应用应该正确定位。 从adb shell更改模拟器语言环境通过使用adb shell来更改模拟器中的区域设置。 选择您想要测试的地区并确定其BCP-47语言标签，例如，加拿大法语将是fr-CA。启动一个模拟器。从主机上的命令行shell中运行以下命令：adb shell或者如果您连接了设备，请通过添加以下-e选项来指定您希望仿真器：adb -e shell在adb shell提示符（#）下，运行以下命令：用步骤1中的相应代码替换括号内的部分。setprop persist.sys.locale [BCP-47 language tag];stop;sleep 5;start例如，要用加拿大法语进行测试： setprop persist.sys.locale fr-CA;stop;sleep 5;start 这会导致模拟器重新启动。（它看起来像是完全重新启动，但不是。）主屏幕再次出现后，重新启动您的应用程序，并使用新的区域设置启动应用程序。 测试默认资源以下是如何测试应用程序是否包含所需的每个字符串资源： 将模拟器或设备设置为您的应用不支持的语言。例如，如果应用程序中有法文字符串 res/values-fr/但没有任何西班牙字符串 res/values-es/，则将模拟器的区域设置为西班牙语。（您可以使用自定义语言环境应用程序将模拟器设置为不支持的语言环境。）运行应用程序。如果应用程序显示错误消息和强制关闭按钮，则可能正在查找不可用的字符串。确保您的 res/values/strings.xml文件包含应用程序使用的每个字符串的定义。如果测试成功，请将其重复用于其他类型的配置。例如，如果应用程序具有调用的布局文件， res/layout-land/main.xml但不包含调用的文件 res/layout-port/main.xml，则将模拟器或设备设置为纵向方向并查看应用程序是否运行。 乱七八糟]]></content>
      <categories>
        <category>Developers</category>
      </categories>
      <tags>
        <tag>Developers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育系统APP(八)]]></title>
    <url>%2F2018%2F04%2F28%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 项目“课程”的模块2目录 学习目标1.1 掌握课程模块的开发，实现用VideoView完成视频的播放1.2 掌握课程模块的开发，实现用JSONObject完成Json数据的解析1.3 掌握课程模块的开发，实现用数据库保存播放记录 项目实操2.1 课程详情2.1.1 课程详情界面布局2.1.2 课程详情Item2.1.3 课程详情界面适配器和数据库2.1.4 课程详情界面逻辑代码 2.2 视频播放2.2.1 视频播放布局2.2.2 视频播放逻辑代码 2.3 播放记录2.3.1 播放记录布局2.3.2 播放记录item2.3.3 播放记录adapter2.3.4 播放记录逻辑代码 任务实施3.1 json解析3.2 播放网络视频 学习目标1.1掌握课程模块的开发，实现用VideoView完成视频的播放1.2掌握课程模块的开发，实现用JSONObject完成Json数据的解析1.3掌握课程模块的开发，实现用数据库保存播放记录 课程模块主要用于展示课程中的视频信息，当点击课程列表时会跳转到课程详情界面，在该界面中可以播放相应章节的视频。同时为了方便用户查看已学习的视频，还在“我”的界面中添加了一个播放记录。本章将对课程界面进行详细讲解。 项目实操课程详情课程详情界面布局把本章所需要的图片放入drawable文件夹中 在res包下新建一个资源包，命名为raw，放入视频文件video11.mp4 新建一个布局文件，命名为activity_video_list课程详情布局代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:background=&quot;@drawable/default_video_list_icon&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:gravity=&quot;center&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@drawable/video_list_intro_icon&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_intro&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;46dp&quot; android:layout_centerVertical=&quot;true&quot; android:background=&quot;#30B4FF&quot; android:gravity=&quot;center&quot; android:text=&quot;简 介&quot; android:textColor=&quot;#FFFFFF&quot; android:textSize=&quot;20sp&quot;/&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;1dp&quot; android:layout_height=&quot;48dp&quot; android:background=&quot;#C3C3C3&quot;/&gt; &lt;RelativeLayout android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@drawable/video_list_intro_icon&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_video&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;46dp&quot; android:layout_centerVertical=&quot;true&quot; android:background=&quot;#FFFFFF&quot; android:gravity=&quot;center&quot; android:text=&quot;视 频&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;20sp&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@+id/lv_video_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot; android:divider=&quot;#E4E4E4&quot; android:dividerHeight=&quot;1dp&quot; android:scrollbars=&quot;none&quot; android:visibility=&quot;gone&quot;/&gt; &lt;ScrollView android:id=&quot;@+id/sv_chapter_intro&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_chapter_intro&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:lineSpacingMultiplier=&quot;1.5&quot; android:padding=&quot;10dp&quot; android:text=&quot;安卓简介&quot; android:textColor=&quot;@android:color/black&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 课程详情Item课程详情界面里也有一个课程列表，这里我们用ListView就可以了。新建一个布局文件，命名为video_list_item。 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/white&quot; android:gravity=&quot;center_vertical&quot; android:paddingBottom=&quot;15dp&quot; android:paddingTop=&quot;15dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_left_icon&quot; android:layout_width=&quot;25dp&quot; android:layout_height=&quot;25dp&quot; android:src=&quot;@drawable/course_bar_icon&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_video_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginLeft=&quot;10dp&quot; android:gravity=&quot;center_vertical&quot; android:text=&quot;[第一节]Android简介&quot; android:textColor=&quot;#333333&quot; android:textSize=&quot;14sp&quot;/&gt;&lt;/LinearLayout&gt; 课程详情界面适配器和数据库先写一个视频的属性类，命名为VideoBean VideoBean.java123456789package cn.edu.gdmec.android.vicdemo.Bean;public class VideoBean &#123; public int chapterId;//章节Id public int videoId;//视频Id public String videoPath;//视频播放地址 public String title;//章节标题 public String secondTitle;//视频标题&#125; 写完属性类，我们来完善数据库的代码，为后面的播放记录做准备。打开Sqlite包下的SQLiteHelper.java，补充视频表的代码。 SQLiteHelper.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.edu.gdmec.android.vicdemo.Sqlite;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;public class SQLiteHelper extends SQLiteOpenHelper&#123; private static final int DB_VERSION = 1; public static String DB_NAME = &quot;bxg.db&quot;; public static final String U_USER_INFO = &quot;userInfo&quot;; public static final String U_VIDEO_PLAY_LIST=&quot;videoplaylist&quot;; /*public SQLiteHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125;*/ public SQLiteHelper(Context context)&#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; /** * 当这个SQLiteOpenHelper的子类类被实例化时会创建指定名的数据库，在onCreate中创建个人信息表 * **/ db.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + U_USER_INFO + &quot;( &quot; + &quot;_id INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + &quot;userName VARCHAR, &quot; + &quot;nickName VARCHAR, &quot; + &quot;sex VARCHAR, &quot; + &quot;signature VARCHAR, &quot; + &quot;qq VARCHAR &quot; + &quot;)&quot;); db.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + U_VIDEO_PLAY_LIST + &quot;( &quot; + &quot;_id INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + &quot;userName VARCHAR, &quot; //用户名 + &quot;chapterId INT, &quot; //章节 + &quot;videoId int, &quot; //小节id + &quot;videoPath VARCHAR,&quot; //视频地址 + &quot;title VARCHAR,&quot;//视频章节名称 + &quot;secondTitle VARCHAR&quot;//视频名单 + &quot;)&quot;); &#125; /** * 当数据库版本号增加才会调用此方法 **/ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + U_USER_INFO); db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + U_VIDEO_PLAY_LIST); onCreate(db); &#125;&#125; 到Utils包下的DBUtils.java中补充操作数据表的方法。 DBUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143package cn.edu.gdmec.android.vicdemo.utils;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.vicdemo.Bean.UserBean;import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;import cn.edu.gdmec.android.vicdemo.Sqlite.SQLiteHelper;public class DBUtils &#123; private static DBUtils instance = null; private static SQLiteHelper helper; private static SQLiteDatabase db; /** * 构造方法，只有当类被实例化时候调用 * 实例化SQLiteHelper类，从中得到一个课读写的数据库 **/ public DBUtils(Context context) &#123; helper = new SQLiteHelper(context); db = helper.getWritableDatabase(); &#125; /** * 得到这个类的实例 **/ public static DBUtils getInstance(Context context) &#123; if (instance == null) &#123; instance = new DBUtils(context); &#125; return instance; &#125; /** * 保存个人资料信息 **/ public void saveUserInfo(UserBean bean) &#123; ContentValues cv = new ContentValues(); cv.put(&quot;userName&quot;, bean.userName); cv.put(&quot;nickName&quot;, bean.nickName); cv.put(&quot;sex&quot;, bean.sex); cv.put(&quot;signature&quot;, bean.signature); cv.put(&quot;qq&quot;,bean.qq); //Convenience method for inserting a row into the database. //注意，我们是从数据库使用插入方法，传入表名和数据集完成插入 db.insert(SQLiteHelper.U_USER_INFO, null, cv); &#125; /** * 获取个人资料信息 **/ public UserBean getUserInfo(String userName) &#123; String sql = &quot;SELECT * FROM &quot; + SQLiteHelper.U_USER_INFO + &quot; WHERE userName=?&quot;; //?和下面数组内元素会逐个替换，可以多条件查询=?and =? //You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. Cursor cursor = db.rawQuery(sql, new String[]&#123;userName&#125;); UserBean bean = null; //Move the cursor to the next row. while (cursor.moveToNext()) &#123; bean = new UserBean(); //根据列索引获取对应的数值，因为这里查询结果只有一个，我们也不需要对模型UserBean进行修改， //直接将对应用户名的所有数据从表中动态赋值给bean bean.userName = cursor.getString(cursor.getColumnIndex(&quot;userName&quot;)); bean.nickName = cursor.getString(cursor.getColumnIndex(&quot;nickName&quot;)); bean.sex = cursor.getString(cursor.getColumnIndex(&quot;sex&quot;)); bean.signature = cursor.getString(cursor.getColumnIndex(&quot;signature&quot;)); bean.qq = cursor.getString(cursor.getColumnIndex(&quot;qq&quot;)); &#125; cursor.close(); return bean; &#125; /** * 修改个人资料信息,这里的key指代表字段，value表示数值 **/ public void updateUserInfo(String key, String value, String userName) &#123; ContentValues cv = new ContentValues(); cv.put(key, value); //Convenience method for updating rows in the database. db.update(SQLiteHelper.U_USER_INFO, cv, &quot;userName=?&quot;, new String[] &#123;userName&#125;); &#125; public void saveVideoPlayList(VideoBean videoBean, String userName)&#123; if (hasVideoPlay(videoBean.chapterId, videoBean.videoId, userName))&#123; boolean isDelete = delVideoPlay(videoBean.chapterId, videoBean.videoId, userName); if (!isDelete)&#123; return; &#125; &#125; ContentValues cv = new ContentValues(); cv.put(&quot;userName&quot;, userName); cv.put(&quot;chapterId&quot;, videoBean.chapterId); cv.put(&quot;videoId&quot;, videoBean.videoId); cv.put(&quot;videoPath&quot;, videoBean.videoPath); cv.put(&quot;title&quot;, videoBean.title); cv.put(&quot;secondTitle&quot;, videoBean.secondTitle); db.insert(SQLiteHelper.U_VIDEO_PLAY_LIST, null, cv); &#125; private boolean delVideoPlay(int chapterId, int videoId, String userName)&#123; boolean delSuccess = false; int row = db.delete(SQLiteHelper.U_VIDEO_PLAY_LIST, &quot; chapterId=? AND videoId=? AND userName=?&quot;, new String[]&#123;chapterId + &quot;&quot;, videoId + &quot;&quot;, userName&#125;); if (row &gt; 0)&#123; delSuccess = true; &#125; return delSuccess; &#125; private boolean hasVideoPlay(int chapterId, int videoId, String userName)&#123; boolean hasVideo = false; String sql = &quot;SELECT * FROM &quot; + SQLiteHelper.U_VIDEO_PLAY_LIST + &quot; WHERE chapterId=? AND videoId=? AND userName=?&quot;; Cursor cursor = db.rawQuery(sql, new String[]&#123;chapterId + &quot;&quot;, videoId + &quot;&quot;, userName&#125;); if (cursor.moveToNext())&#123; hasVideo = true; &#125; cursor.close(); return hasVideo; &#125; public List&lt;VideoBean&gt; getVideoHistory(String s)&#123; String sql = &quot;SELECT * FROM &quot; + SQLiteHelper.U_VIDEO_PLAY_LIST + &quot; WHERE userName=?&quot;; Cursor cursor = db.rawQuery(sql, new String[]&#123;s&#125;); List&lt;VideoBean&gt; vbl = new ArrayList&lt;&gt;(); VideoBean bean = null; while (cursor.moveToNext())&#123; bean = new VideoBean(); bean.chapterId = cursor.getInt(cursor.getColumnIndex(&quot;chapterId&quot;)); bean.videoId = cursor.getInt(cursor.getColumnIndex(&quot;videoId&quot;)); bean.videoPath = cursor.getString(cursor.getColumnIndex(&quot;videoPath&quot;)); bean.title = cursor.getString(cursor.getColumnIndex(&quot;title&quot;)); bean.secondTitle = cursor.getString(cursor.getColumnIndex(&quot;secondTitle&quot;)); vbl.add(bean); bean = null; &#125; cursor.close(); return vbl; &#125;&#125; 适配器代码：VideoListItemAdapter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package cn.edu.gdmec.android.vicdemo.adapter;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.graphics.Color;import android.text.TextUtils;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.ImageView;import android.widget.TextView;import android.widget.Toast;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.vicdemo.Activity.VideoPlayActivity;import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;import cn.edu.gdmec.android.vicdemo.R;import cn.edu.gdmec.android.vicdemo.utils.AnalysisUtils;import cn.edu.gdmec.android.vicdemo.utils.DBUtils;public class VideoListItemAdapter extends BaseAdapter &#123; private List&lt;VideoBean&gt; objects = new ArrayList&lt;VideoBean&gt;(); private int selectedPosition = -1; private DBUtils db; private Context context; private LayoutInflater layoutInflater; public VideoListItemAdapter(Context context) &#123; this.context = context; this.layoutInflater = LayoutInflater.from(context); db = DBUtils.getInstance(context); &#125; public void setData(List&lt;VideoBean&gt; vbl)&#123; this.objects = vbl; notifyDataSetChanged(); &#125; @Override public int getCount() &#123; return objects.size(); &#125; public void setSelectedPosition(int position)&#123; selectedPosition = position; &#125; @Override public VideoBean getItem(int position) &#123; return objects.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; if (convertView == null) &#123; convertView = layoutInflater.inflate(R.layout.video_list_item, null); convertView.setTag(new ViewHolder(convertView)); &#125; initializeViews((VideoBean)getItem(position), (ViewHolder) convertView.getTag(), position, convertView); return convertView; &#125; private void initializeViews(final VideoBean object, final ViewHolder holder, final int position, View convertView) &#123; holder.ivLeftIcon.setImageResource(R.drawable.course_bar_icon); holder.tvVideoTitle.setTextColor(Color.parseColor(&quot;#333333&quot;)); if (object != null)&#123; holder.tvVideoTitle.setText(object.secondTitle); if (selectedPosition == position)&#123; holder.ivLeftIcon.setImageResource(R.drawable.course_intro_icon);; holder.tvVideoTitle.setTextColor(Color.parseColor(&quot;$009958&quot;)); &#125;else &#123; holder.ivLeftIcon.setImageResource(R.drawable.course_bar_icon); holder.tvVideoTitle.setTextColor(Color.parseColor(&quot;#333333&quot;)); &#125; &#125; convertView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; setSelectedPosition(position); if (object != null)&#123; String videoPath = object.videoPath; notifyDataSetChanged(); if (TextUtils.isEmpty(videoPath))&#123; Toast.makeText(context, &quot;本地没有此视频，暂无法播放&quot;, Toast.LENGTH_SHORT).show(); &#125;else &#123; if (readLoginStatus())&#123; String userName = AnalysisUtils.readLoginUserName(context); db.saveVideoPlayList(objects.get(position), userName); &#125; //视频播放 Intent intent = new Intent(context, VideoPlayActivity.class); intent.putExtra(&quot;videoPath&quot;, videoPath); intent.putExtra(&quot;position&quot;, position); ((Activity) context).startActivityForResult(intent, 1); &#125; &#125; &#125; &#125;); &#125; private boolean readLoginStatus()&#123; SharedPreferences sp = context.getSharedPreferences(&quot;loginInfo&quot;, Context.MODE_PRIVATE); boolean isLogin = sp.getBoolean(&quot;isLogin&quot;, false); return isLogin; &#125; protected class ViewHolder &#123; private ImageView ivLeftIcon; private TextView tvVideoTitle; public ViewHolder(View view) &#123; ivLeftIcon = (ImageView) view.findViewById(R.id.iv_left_icon); tvVideoTitle = (TextView) view.findViewById(R.id.tv_video_title); &#125; &#125;&#125; 课程详情界面逻辑代码先把data.json文件放进assets文件夹。 VideoListActivity的逻辑代码 VideoListActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package cn.edu.gdmec.android.vicdemo.Activity;import android.app.Activity;import android.content.Intent;import android.graphics.Color;import android.os.Bundle;import android.view.View;import android.widget.ListView;import android.widget.ScrollView;import android.widget.TextView;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;import cn.edu.gdmec.android.vicdemo.R;import cn.edu.gdmec.android.vicdemo.adapter.VideoListItemAdapter;public class VideoListActivity extends Activity&#123; private TextView tvIntro; private TextView tvVideo; private ListView lvVideoList; private ScrollView svChapterIntro; private TextView tvChapterIntro; private List&lt;VideoBean&gt; videoList; private int chapterId; private String intro; private VideoListItemAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_video_list); chapterId = getIntent().getIntExtra(&quot;id&quot;, 0); intro = getIntent().getStringExtra(&quot;intro&quot;); initData(); initView(); &#125; //把json文件转换为字符串 private String read(InputStream is)&#123; BufferedReader reader = null; StringBuilder sb = null; String line = null; try&#123; sb = new StringBuilder(); reader = new BufferedReader(new InputStreamReader(is)); while ((line = reader.readLine()) != null)&#123; sb.append(line); sb.append(&quot;\n&quot;); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); return &quot;&quot;; &#125;finally &#123; if (is != null)&#123; try&#123; is.close(); if (reader != null)&#123; reader.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return sb.toString(); &#125; //解析json private void initData() &#123; JSONArray jsonArray; try&#123; InputStream is = getResources().getAssets().open(&quot;data.json&quot;); jsonArray = new JSONArray(read(is)); videoList = new ArrayList&lt;VideoBean&gt;(); for (int i = 0; i &lt; jsonArray.length(); i++)&#123; VideoBean bean = new VideoBean(); JSONObject jsonObj = jsonArray.getJSONObject(i); if (jsonObj.getInt(&quot;chapterId&quot;) == chapterId)&#123; bean.chapterId = jsonObj.getInt(&quot;chapterId&quot;); bean.videoId = Integer.parseInt(jsonObj.getString(&quot;videoId&quot;)); bean.title = jsonObj.getString(&quot;title&quot;); bean.secondTitle = jsonObj.getString(&quot;secondTitle&quot;); bean.videoPath = jsonObj.getString(&quot;videoPath&quot;); videoList.add(bean); &#125; bean = null; &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;catch (JSONException e)&#123; e.printStackTrace(); &#125; &#125; private void initView() &#123; tvIntro = (TextView) findViewById(R.id.tv_intro); tvVideo = (TextView) findViewById(R.id.tv_video); lvVideoList = (ListView) findViewById(R.id.lv_video_list); svChapterIntro = (ScrollView) findViewById(R.id.sv_chapter_intro); tvChapterIntro = (TextView) findViewById(R.id.tv_chapter_intro); adapter = new VideoListItemAdapter(this); lvVideoList.setAdapter(adapter); adapter.setData(videoList); tvChapterIntro.setText(intro); tvIntro.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); tvVideo.setBackgroundColor(Color.parseColor(&quot;#FFFFFF&quot;)); tvIntro.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;)); tvVideo.setTextColor(Color.parseColor(&quot;#000000&quot;)); tvIntro.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; lvVideoList.setVisibility(View.GONE); svChapterIntro.setVisibility(View.VISIBLE); tvIntro.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); tvVideo.setBackgroundColor(Color.parseColor(&quot;#FFFFFF&quot;)); tvIntro.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;)); tvVideo.setTextColor(Color.parseColor(&quot;#000000&quot;)); &#125; &#125;); tvVideo.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; lvVideoList.setVisibility(View.VISIBLE); svChapterIntro.setVisibility(View.GONE); tvIntro.setBackgroundColor(Color.parseColor(&quot;#FFFFFF&quot;)); tvVideo.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); tvIntro.setTextColor(Color.parseColor(&quot;#000000&quot;)); tvVideo.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;)); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; super.onActivityResult(requestCode,resultCode,data); if (data != null)&#123; int position = data.getIntExtra(&quot;position&quot;, 0); adapter.setSelectedPosition(position); lvVideoList.setVisibility(View.VISIBLE); svChapterIntro.setVisibility(View.GONE); tvIntro.setBackgroundColor(Color.parseColor(&quot;#FFFFFF&quot;)); tvVideo.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); tvIntro.setTextColor(Color.parseColor(&quot;#000000&quot;)); tvVideo.setTextColor(Color.parseColor(&quot;#FFFFFF&quot;)); &#125; &#125;&#125; 到CourseListItemAdapter.java中添加上跳转至视频详情页面的代码。CourseListItemAdapter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package cn.edu.gdmec.android.vicdemo.adapter;import android.content.Context;import android.content.Intent;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.vicdemo.Activity.VideoListActivity;import cn.edu.gdmec.android.vicdemo.Bean.CourseBean;import cn.edu.gdmec.android.vicdemo.R;public class CourseListItemAdapter extends RecyclerView.Adapter&lt;CourseListItemAdapter.ViewHolder&gt; &#123; private List&lt;CourseBean&gt; objects = new ArrayList&lt;CourseBean&gt;(); private Context context; private LayoutInflater layoutInflater; public CourseListItemAdapter(Context context) &#123; this.context = context; this.layoutInflater = LayoutInflater.from(context); &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View view=inflater.inflate(R.layout.course_list_item,parent,false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position)&#123; initializeViews(objects.get(position), holder); &#125; public void setData(List&lt;CourseBean&gt; objects)&#123; this.objects=objects; &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public int getItemCount() &#123; return objects.size(); &#125; private void initializeViews(final CourseBean object, ViewHolder holder) &#123; if (object != null)&#123; holder.tvCourseImgTitle.setText(object.imgTitle); holder.tvCourseTitle.setText(object.title); switch (object.id)&#123; case 1: holder.ivCourseImg.setImageResource(R.drawable.chapter_1_icon); break; case 2: holder.ivCourseImg.setImageResource(R.drawable.chapter_2_icon); break; case 3: holder.ivCourseImg.setImageResource(R.drawable.chapter_3_icon); break; case 4: holder.ivCourseImg.setImageResource(R.drawable.chapter_4_icon); break; case 5: holder.ivCourseImg.setImageResource(R.drawable.chapter_5_icon); break; case 6: holder.ivCourseImg.setImageResource(R.drawable.chapter_6_icon); break; case 7: holder.ivCourseImg.setImageResource(R.drawable.chapter_7_icon); break; case 8: holder.ivCourseImg.setImageResource(R.drawable.chapter_8_icon); break; case 9: holder.ivCourseImg.setImageResource(R.drawable.chapter_9_icon); break; case 10: holder.ivCourseImg.setImageResource(R.drawable.chapter_10_icon); break; &#125; holder.ivCourseImg.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(context, VideoListActivity.class); intent.putExtra(&quot;id&quot;, object.id); intent.putExtra(&quot;intro&quot;, object.intro); context.startActivity(intent); &#125; &#125;); &#125; &#125; protected class ViewHolder extends RecyclerView.ViewHolder &#123; private ImageView ivCourseImg; private TextView tvCourseImgTitle; private TextView tvCourseTitle; public ViewHolder(View view) &#123; super(view); ivCourseImg = (ImageView) view.findViewById(R.id.iv_course_img); tvCourseImgTitle = (TextView) view.findViewById(R.id.tv_course_img_title); tvCourseTitle = (TextView) view.findViewById(R.id.tv_course_title); &#125; &#125;&#125; 再到AndroidManifest.xml中声明activity 视频播放视频播放布局新建布局文件，命名为activity_video_play。 activity_video_play.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;VideoView android:id=&quot;@+id/videoView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt;&lt;/RelativeLayout&gt; 视频播放逻辑代码 VideoPlayActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.edu.gdmec.android.vicdemo.Activity;import android.app.Activity;import android.content.Intent;import android.content.pm.ActivityInfo;import android.os.Bundle;import android.text.TextUtils;import android.view.KeyEvent;import android.widget.MediaController;import android.widget.Toast;import android.widget.VideoView;import cn.edu.gdmec.android.vicdemo.R;public class VideoPlayActivity extends Activity &#123; private VideoView videoView; private MediaController controller; private String videoPath; private int position; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_video_play); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); videoPath = getIntent().getStringExtra(&quot;videoPath&quot;); position = getIntent().getIntExtra(&quot;position&quot;, 0); videoView = findViewById(R.id.videoView); controller = new MediaController(this); videoView.setMediaController(controller); play(); &#125; private void play() &#123; if(TextUtils.isEmpty(videoPath))&#123; Toast.makeText(this,&quot;本地没有此视频，暂无法播放&quot;, Toast.LENGTH_SHORT).show(); return; &#125; String uri = &quot;android.resource://&quot; + getPackageName() + &quot;/&quot; + R.raw.video11; videoView.setVideoPath(uri); videoView.start(); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event)&#123; Intent data = new Intent(); data.putExtra(&quot;position&quot;, position); setResult(RESULT_OK, data); return super.onKeyDown(keyCode, event); &#125;&#125; 到VideoListItemAdapter.java里补上跳转视频播放页面的代码。VideoListItemAdapter.java 12345//视频播放Intent intent = new Intent(context, VideoPlayActivity.class);intent.putExtra(&quot;videoPath&quot;, videoPath);intent.putExtra(&quot;position&quot;, position);((Activity) context).startActivityForResult(intent, 1); 到AndroidManifest.xml中声明activity 播放记录播放记录布局新建布局文件，命名为activity_play_history 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;include layout=&quot;@layout/main_title_bar&quot;/&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@+id/lv_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:divider=&quot;#E4E4E4&quot; android:dividerHeight=&quot;1dp&quot; android:scrollbars=&quot;none&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_none&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;暂无播放记录&quot; android:textColor=&quot;@android:color/darker_gray&quot; android:textSize=&quot;16sp&quot; android:visibility=&quot;gone&quot;/&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 播放记录item新建布局文件，命名为play_history_list_itemplay_history_list_item.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:background=&quot;@android:color/white&quot; android:gravity=&quot;center_vertical&quot; android:padding=&quot;10dp&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_video_icon&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;75dp&quot; android:src=&quot;@drawable/video_play_icon2&quot;/&gt; &lt;ImageView android:layout_width=&quot;30dp&quot; android:layout_height=&quot;30dp&quot; android:src=&quot;@android:drawable/ic_media_play&quot;/&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_gravity=&quot;center_vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_adapter_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:textSize=&quot;16sp&quot; android:textColor=&quot;#333333&quot; android:text=&quot;第1章 Android基础入门&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;TextView android:layout_marginTop=&quot;4dp&quot; android:id=&quot;@+id/tv_video_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:textSize=&quot;12sp&quot; android:textColor=&quot;#a3a3a3&quot; android:text=&quot;Android系统简介&quot; android:gravity=&quot;center_vertical&quot;/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 播放记录adapterPlayHistoryListItemAdapter.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package cn.edu.gdmec.android.vicdemo.adapter;import android.content.Context;import android.content.Intent;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.ImageView;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.vicdemo.Activity.VideoPlayActivity;import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;import cn.edu.gdmec.android.vicdemo.R;public class PlayHistoryListItemAdapter extends BaseAdapter &#123; private List&lt;VideoBean&gt; objects = new ArrayList&lt;VideoBean&gt;(); private Context context; private LayoutInflater layoutInflater; public PlayHistoryListItemAdapter(Context context) &#123; this.context = context; this.layoutInflater = LayoutInflater.from(context); &#125; public void setData(List&lt;VideoBean&gt; vbl)&#123; this.objects = vbl; notifyDataSetChanged(); &#125; @Override public int getCount() &#123; return objects.size(); &#125; @Override public VideoBean getItem(int position) &#123; return objects.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; if (convertView == null) &#123; convertView = layoutInflater.inflate(R.layout.play_history_list_item, null); convertView.setTag(new ViewHolder(convertView)); &#125; initializeViews((VideoBean)getItem(position), (ViewHolder) convertView.getTag(), convertView); return convertView; &#125; private void initializeViews(final VideoBean object, ViewHolder holder, final View convertView) &#123; if (object != null)&#123; holder.tvAdapterTitle.setText(object.title); holder.tvVideoTitle.setText(object.secondTitle); switch (object.chapterId)&#123; case 1: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon1); break; case 2: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon2); break; case 3: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon3); break; case 4: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon4); break; case 5: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon5); break; case 6: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon6); break; case 7: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon7); break; case 8: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon8); break; case 9: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon9); break; case 10: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon10); break; default: holder.ivVideoIcon.setImageResource(R.drawable.video_play_icon1); break; &#125; convertView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (object == null)&#123; return; &#125; Intent intent = new Intent(context, VideoPlayActivity.class); intent.putExtra(&quot;videoPath&quot;, object.videoPath); context.startActivity(intent); &#125; &#125;); &#125; &#125; protected class ViewHolder &#123; private ImageView ivVideoIcon; private TextView tvAdapterTitle; private TextView tvVideoTitle; public ViewHolder(View view) &#123; ivVideoIcon = (ImageView) view.findViewById(R.id.iv_video_icon); tvAdapterTitle = (TextView) view.findViewById(R.id.tv_adapter_title); tvVideoTitle = (TextView) view.findViewById(R.id.tv_video_title); &#125; &#125;&#125; 播放记录逻辑代码PlayHistoryActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.edu.gdmec.android.vicdemo.Activity;import android.app.Activity;import android.graphics.Color;import android.os.Bundle;import android.view.View;import android.widget.ListView;import android.widget.RelativeLayout;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.vicdemo.Bean.VideoBean;import cn.edu.gdmec.android.vicdemo.R;import cn.edu.gdmec.android.vicdemo.adapter.PlayHistoryListItemAdapter;import cn.edu.gdmec.android.vicdemo.utils.AnalysisUtils;import cn.edu.gdmec.android.vicdemo.utils.DBUtils;public class PlayHistoryActivity extends Activity &#123; private TextView tv_back; private TextView tv_main_title; private TextView tv_save; private RelativeLayout title_bar; private ListView lv_list; private TextView tv_none; private List&lt;VideoBean&gt; vbl; private DBUtils db; private PlayHistoryListItemAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_play_history); db = DBUtils.getInstance(this); vbl = new ArrayList&lt;VideoBean&gt;(); vbl = db.getVideoHistory(AnalysisUtils.readLoginUserName(this)); initView(); &#125; private void initView() &#123; tv_back = findViewById(R.id.tv_back); tv_main_title = findViewById(R.id.tv_main_title); tv_save = findViewById(R.id.tv_save); title_bar = findViewById(R.id.title_bar); lv_list = findViewById(R.id.lv_list); tv_none = findViewById(R.id.tv_none); tv_main_title.setText(&quot;播放记录&quot;); title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); if (vbl.size() == 0)&#123; tv_none.setVisibility(View.VISIBLE); &#125; adapter = new PlayHistoryListItemAdapter(this); adapter.setData(vbl); lv_list.setAdapter(adapter); tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; PlayHistoryActivity.this.fileList(); &#125; &#125;); &#125;&#125; MyinfoFragment.java里补上跳转视频播放页面的代码。 123//跳转到播放记录页面 Intent intent = new Intent(getActivity(), PlayHistoryActivity.class); getActivity().startActivity(intent); 到AndroidManifest.xml中声明activityAndroidManifest.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;cn.edu.gdmec.android.vicdemo&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/app_icon&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt; &lt;activity android:name=&quot;.Activity.SplashActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--添加实现类--&gt; &lt;activity android:name=&quot;.Activity.MainActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.RegisterActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.LoginActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.SettingActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.ModifyPswActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.FindPwdActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.UserInfoActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.ChangeUserInfoActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.ExercisesDetailActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.VideoListActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.VideoPlayActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.Activity.PlayHistoryActivity&quot;&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 任务实施json解析将res/assets包下的data.Json文件打开，把下面的json数据覆盖掉原来的数据，更改解析json数据的代码，把新的json数据解析出来并成功展示。 播放网络视频修改VideoView控件和AndroidManifest.xml的代码，使其能成功播放下面json数据里的网络视频。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173json数据：[&#123; &quot;chapterId&quot;: 1, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第1章 Android 基础入门&quot;, &quot;secondTitle&quot;: &quot;迷情巧克力&quot;, &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/PaGWXOMYz-rMWm-r9a2MvILINHMc0YBXe2i-dg__.mp4?ssig=acb6880de7200e266864581d97c0654d&amp;time_stamp=1524887992615&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=PaGWXOMYz-rMWm-r9a2MvILINHMc0YBXe2i-dg__&quot; &#125;, &#123; &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第1章 Android 基础入门&quot;, &quot;secondTitle&quot;: &quot;命运是什么&quot;, &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/KP7xXv0IllZsjnK1HjVlkbGfb5yWj7mPbaEOmQ__.mp4?ssig=7d445a22609119e57b50c8fa9a84a11b&amp;time_stamp=1524888071281&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=KP7xXv0IllZsjnK1HjVlkbGfb5yWj7mPbaEOmQ__&quot; &#125; ]&#125;, &#123; &quot;chapterId&quot;: 2, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第2章 Android UI开发&quot;, &quot;secondTitle&quot;: &quot;水银为什么是液体&quot;, &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/cnngO-Co7rFlVPzkS7qqoaxR7OFH72uvYDDiew__.mp4?ssig=b91b143afbaadb8472b57b17e0c213e5&amp;time_stamp=1524888092840&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=cnngO-Co7rFlVPzkS7qqoaxR7OFH72uvYDDiew__&quot; &#125;, &#123; &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第2章 Android UI开发&quot;, &quot;secondTitle&quot;: &quot;汽车的历史&quot;, &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/6S23U5PMRtOQzu99NeITYztd0xtKFW2xDYxwXQ__.mp4?ssig=afa07a802aca690154953446fc5de4d4&amp;time_stamp=1524888118545&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=6S23U5PMRtOQzu99NeITYztd0xtKFW2xDYxwXQ__&quot; &#125; ] &#125;, &#123; &quot;chapterId&quot;: 3, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第3章 Activity&quot;, &quot;secondTitle&quot;: &quot;汽车的历史&quot;, &quot;videoPath&quot;: &quot;https://gslb.miaopai.com/stream/6S23U5PMRtOQzu99NeITYztd0xtKFW2xDYxwXQ__.mp4?ssig=afa07a802aca690154953446fc5de4d4&amp;time_stamp=1524888118545&amp;cookie_id=&amp;vend=1&amp;os=3&amp;partner=1&amp;platform=2&amp;cookie_id=&amp;refer=miaopai&amp;scid=6S23U5PMRtOQzu99NeITYztd0xtKFW2xDYxwXQ__&quot; &#125;, &#123; &quot;chapterId&quot;: 3, &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第3章 Activity&quot;, &quot;secondTitle&quot;: &quot;Activity中的数据传递&quot;, &quot;videoPath&quot;: &quot;&quot; &#125; ] &#125;, &#123; &quot;chapterId&quot;: 4, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第4章 数据存储&quot;, &quot;secondTitle&quot;: &quot;文件存储&quot;, &quot;videoPath&quot;: &quot;&quot; &#125;, &#123; &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第4章 数据存储&quot;, &quot;secondTitle&quot;: &quot;XML序列化与SharedPreferences&quot;, &quot;videoPath&quot;: &quot;&quot; &#125; ] &#125;, &#123; &quot;chapterId&quot;: 5, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第5章 SQLite 数据库&quot;, &quot;secondTitle&quot;: &quot;SQLite数据库的使用&quot;, &quot;videoPath&quot;: &quot;&quot; &#125;, &#123; &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第5章 SQLite 数据库&quot;, &quot;secondTitle&quot;: &quot;ListView控件的使用&quot;, &quot;videoPath&quot;: &quot;&quot; &#125; ] &#125;, &#123; &quot;chapterId&quot;: 6, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第6章 广播接收者&quot;, &quot;secondTitle&quot;: &quot;内容提供者简介&quot;, &quot;videoPath&quot;: &quot;&quot; &#125;, &#123; &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第6章 广播接收者&quot;, &quot;secondTitle&quot;: &quot;内容提供者的访问&quot;, &quot;videoPath&quot;: &quot;&quot; &#125; ] &#125;, &#123; &quot;chapterId&quot;: 7, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第7章 服务&quot;, &quot;secondTitle&quot;: &quot;广播接收者与自定义广播&quot;, &quot;videoPath&quot;: &quot;&quot; &#125;, &#123; &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第7章 服务&quot;, &quot;secondTitle&quot;: &quot;广播类型与常用的广播接收者&quot;, &quot;videoPath&quot;: &quot;&quot; &#125; ] &#125;, &#123; &quot;chapterId&quot;: 8, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第8章 内容提供者&quot;, &quot;secondTitle&quot;: &quot;服务的创建与生命周期&quot;, &quot;videoPath&quot;: &quot;&quot; &#125;, &#123; &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第8章 内容提供者&quot;, &quot;secondTitle&quot;: &quot;服务的启动方式&quot;, &quot;videoPath&quot;: &quot;&quot; &#125; ] &#125;, &#123; &quot;chapterId&quot;: 9, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第9章 网络编程&quot;, &quot;secondTitle&quot;: &quot;访问网络&quot;, &quot;videoPath&quot;: &quot;&quot; &#125;, &#123; &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第9章 网络编程&quot;, &quot;secondTitle&quot;: &quot;数据的提交方式&quot;, &quot;videoPath&quot;: &quot;&quot; &#125; ] &#125;, &#123; &quot;chapterId&quot;: 10, &quot;data&quot;: [ &#123; &quot;videoId&quot;: &quot;1&quot;, &quot;title&quot;: &quot;第10章 高级编程&quot;, &quot;secondTitle&quot;: &quot;图形图像处理与动画&quot;, &quot;videoPath&quot;: &quot;&quot; &#125;, &#123; &quot;videoId&quot;: &quot;2&quot;, &quot;title&quot;: &quot;第10章 高级编程&quot;, &quot;secondTitle&quot;: &quot;多媒体、与Fragment&quot;, &quot;videoPath&quot;: &quot;&quot; &#125; ] &#125;] 总结 完解决方法VideoListActivity 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//解析json private void initData() &#123; //JSONArray jsonArray; JSONArray jsonArray,jsonArray1; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); List&lt;VideoBean&gt; list1 = new ArrayList&lt;VideoBean&gt;(); try&#123; InputStream is = getResources().getAssets().open(&quot;data.json&quot;); jsonArray = new JSONArray(read(is)); videoList = new ArrayList&lt;VideoBean&gt;(); for (int i = 0; i &lt; jsonArray.length(); i++)&#123; VideoBean bean = new VideoBean(); JSONObject jsonObj = jsonArray.getJSONObject(i); if (jsonObj.getInt(&quot;chapterId&quot;) == chapterId)&#123; bean.chapterId = jsonObj.getInt(&quot;chapterId&quot;); /*bean.videoId = Integer.parseInt(jsonObj.getString(&quot;videoId&quot;)); bean.title = jsonObj.getString(&quot;title&quot;); bean.secondTitle = jsonObj.getString(&quot;secondTitle&quot;); bean.videoPath = jsonObj.getString(&quot;videoPath&quot;); videoList.add(bean);*/ String ss =jsonObj.getString(&quot;data&quot;); jsonArray1 = new JSONArray(ss); for (int j=0;j&lt;jsonArray1.length();j++)&#123; JSONObject jsonObject = (JSONObject) jsonArray1.get(j); Iterator&lt;String&gt; iterator = jsonObject.keys(); while (iterator.hasNext())&#123; String key = iterator.next(); String value = jsonObject.getString(key); list.add(value); &#125; bean.videoId = Integer.parseInt(list.get(0)); bean.title = list.get(1); bean.secondTitle = list.get(2); bean.videoPath = list.get(3); videoList.add(bean); bean = new VideoBean(); list.clear(); Log.i(&quot;Ss&quot;,videoList.toString()); &#125; &#125; bean = null; &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;catch (JSONException e)&#123; e.printStackTrace(); &#125; &#125; VideoPlayActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package cn.edu.gdmec.android.vicdemo.Activity;import android.app.Activity;import android.content.Intent;import android.content.pm.ActivityInfo;import android.net.Uri;import android.os.Bundle;import android.text.TextUtils;import android.util.Log;import android.view.KeyEvent;import android.view.WindowManager;import android.widget.MediaController;import android.widget.Toast;import android.widget.VideoView;import cn.edu.gdmec.android.vicdemo.R;public class VideoPlayActivity extends Activity &#123; private VideoView videoView; private MediaController controller; private String videoPath; private int position;////传递视频详情界面点击的视频位置 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //设置界面全屏显示 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.activity_video_play); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); //获取从播放记录界面传递过来的视频地址 videoPath = getIntent().getStringExtra(&quot;videoPath&quot;); position = getIntent().getIntExtra(&quot;position&quot;, 0); videoView = findViewById(R.id.videoView); controller = new MediaController(this); videoView.setMediaController(controller); play(); &#125; private void play() &#123; if(TextUtils.isEmpty(videoPath))&#123; Toast.makeText(this,&quot;本地没有此视频，暂无法播放&quot;, Toast.LENGTH_SHORT).show(); return; &#125; //String uri = &quot;android.resource://&quot; + getPackageName() + &quot;/&quot; + R.raw.video11; Log.i(&quot;Video&quot;,videoPath); String uri = videoPath; Uri uri1 = Uri.parse(uri); videoView.setVideoURI(uri1); //videoView.setVideoPath(uri); videoView.start(); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event)&#123; //把视频详情界面传递过来的被点击视频的位置传递回去 Intent data = new Intent(); data.putExtra(&quot;position&quot;, position); setResult(RESULT_OK, data); return super.onKeyDown(keyCode, event); &#125;&#125; 大功告成！]]></content>
      <categories>
        <category>教育系统APP</category>
      </categories>
      <tags>
        <tag>教育系统APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育系统APP(七)]]></title>
    <url>%2F2018%2F04%2F27%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 回顾上一期任务 判断题数点击完选项之后，底部的文本控件要变换刚刚点击的题目的题号。注意：在里面用到adapter与Activity的信息回调，具体过程参考 保存答题状态当5道题都回答过一遍后，点击返回习题界面，习题下的文本标签要变成“已完成”。 教育系统APP(七)的发布-福利 解决上期任务 在ExercisesDetailActivity.java中添加 123456789101112131415adapter.setOnItemListener(new ExercisesDetailListItemAdapter.OnItemListener() &#123; @Override public void onItem(View view, int position) &#123; ff=ff+1; tv_di.setText(&quot;第&quot;+(position+1)+&quot;题完成，共&quot;+adapter.getItemCount()+&quot;题&quot;); if (ff==5)&#123; AnalysisUtils.saveExerciseStatus(ExercisesDetailActivity.this,id); Log.i(&quot;DD&quot;,id+&quot;&quot;); setResult(RESULT_OK); //ff = 0; &#125; &#125; &#125;); 别担心，添加完一定有红，是因为我们还有几个方法没写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package cn.edu.gdmec.android.boxuegu.activity;import android.app.Activity;import android.graphics.Color;import android.os.Bundle;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.util.Log;import android.view.View;import android.widget.ImageView;import android.widget.RelativeLayout;import android.widget.TextView;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.adapter.ExercisesDetailListItemAdapter;import cn.edu.gdmec.android.boxuegu.bean.ExercisesBean;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;public class ExercisesDetailActivity extends Activity &#123; private TextView tv_back; private TextView tv_main_title; private RelativeLayout title_bar; private TextView tv_save; private TextView tv_di; private int id; private String title; private RecyclerView rv_list; private List&lt;ExercisesBean&gt; ebl; private ExercisesDetailListItemAdapter adapter; // public int ff = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_exercises_detail); id = getIntent().getIntExtra(&quot;id&quot;,0); title = getIntent().getStringExtra(&quot;title&quot;); ebl = new ArrayList&lt;ExercisesBean&gt;(); initData(); initView(); &#125; private void initData() &#123; //从xml文件中获取习题数据 try &#123; InputStream is = getResources().getAssets().open(&quot;chapter&quot; + id + &quot;.xml&quot;); ebl = AnalysisUtils.getExercisesInfos(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void initView() &#123; tv_save = findViewById(R.id.tv_save); tv_back = findViewById(R.id.tv_back); tv_main_title = findViewById(R.id.tv_main_title); tv_main_title.setText(title); title_bar = findViewById(R.id.title_bar); title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); // tv_di = findViewById(R.id.tv_di); rv_list = findViewById(R.id.rv_list); rv_list.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)); tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ExercisesDetailActivity.this.finish(); &#125; &#125;); adapter = new ExercisesDetailListItemAdapter(ExercisesDetailActivity.this, new ExercisesDetailListItemAdapter.OnSelectListener() &#123; @Override public void onSelectA(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d) &#123; //判断如果答案不是1即A选项 if (ebl.get(position).answer != 1) &#123; ebl.get(position).select = 1; &#125; else &#123; ebl.get(position).select = 0; &#125; switch (ebl.get(position).answer) &#123; case 1: iv_a.setImageResource(R.drawable.exercises_right_icon); break; case 2: iv_a.setImageResource(R.drawable.exercises_error_icon); iv_b.setImageResource(R.drawable.exercises_right_icon); break; case 3: iv_a.setImageResource(R.drawable.exercises_error_icon); iv_c.setImageResource(R.drawable.exercises_right_icon); break; case 4: iv_a.setImageResource(R.drawable.exercises_error_icon); iv_d.setImageResource(R.drawable.exercises_right_icon); break; &#125; AnalysisUtils.setABCDEnable(false, iv_a, iv_b, iv_c, iv_d); &#125; @Override public void onSelectB(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d) &#123; //判断如果答案不是2即B选项 if (ebl.get(position).answer != 2) &#123; ebl.get(position).select = 2; &#125; else &#123; ebl.get(position).select = 0; &#125; switch (ebl.get(position).answer) &#123; case 1: iv_a.setImageResource(R.drawable.exercises_right_icon); iv_b.setImageResource(R.drawable.exercises_error_icon); break; case 2: iv_b.setImageResource(R.drawable.exercises_right_icon); break; case 3: iv_b.setImageResource(R.drawable.exercises_error_icon); iv_c.setImageResource(R.drawable.exercises_right_icon); break; case 4: iv_b.setImageResource(R.drawable.exercises_error_icon); iv_d.setImageResource(R.drawable.exercises_right_icon); break; &#125; AnalysisUtils.setABCDEnable(false, iv_a, iv_b, iv_c, iv_d); &#125; @Override public void onSelectC(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d) &#123; //判断如果答案不是3即C选项 if (ebl.get(position).answer != 3) &#123; ebl.get(position).select = 3; &#125; else &#123; ebl.get(position).select = 0; &#125; switch (ebl.get(position).answer) &#123; case 1: iv_a.setImageResource(R.drawable.exercises_right_icon); iv_c.setImageResource(R.drawable.exercises_error_icon); break; case 2: iv_b.setImageResource(R.drawable.exercises_right_icon); iv_c.setImageResource(R.drawable.exercises_error_icon); break; case 3: iv_c.setImageResource(R.drawable.exercises_right_icon); break; case 4: iv_c.setImageResource(R.drawable.exercises_error_icon); iv_d.setImageResource(R.drawable.exercises_right_icon); break; &#125; AnalysisUtils.setABCDEnable(false, iv_a, iv_b, iv_c, iv_d); &#125; @Override public void onSelectD(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d) &#123; //判断如果答案不是4即D选项 if (ebl.get(position).answer != 4) &#123; ebl.get(position).select = 4; &#125; else &#123; ebl.get(position).select = 0; &#125; switch (ebl.get(position).answer) &#123; case 1: iv_a.setImageResource(R.drawable.exercises_right_icon); iv_d.setImageResource(R.drawable.exercises_error_icon); break; case 2: iv_d.setImageResource(R.drawable.exercises_error_icon); iv_b.setImageResource(R.drawable.exercises_right_icon); break; case 3: iv_d.setImageResource(R.drawable.exercises_error_icon); iv_c.setImageResource(R.drawable.exercises_right_icon); break; case 4: iv_d.setImageResource(R.drawable.exercises_right_icon); break; &#125; AnalysisUtils.setABCDEnable(false, iv_a, iv_b, iv_c, iv_d); &#125; &#125;); adapter.setData(ebl); adapter.setOnItemListener(new ExercisesDetailListItemAdapter.OnItemListener() &#123; @Override public void onItem(View view, int position) &#123; ff=ff+1; tv_di.setText(&quot;第&quot;+(position+1)+&quot;题完成，共&quot;+adapter.getItemCount()+&quot;题&quot;); if (ff==5)&#123; AnalysisUtils.saveExerciseStatus(ExercisesDetailActivity.this,id); Log.i(&quot;DD&quot;,id+&quot;&quot;); setResult(RESULT_OK); //ff = 0; &#125; &#125; &#125;); rv_list.setAdapter(adapter); &#125;&#125; ExercisesDetailListItemAdapter.java 中添加代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284package cn.edu.gdmec.android.boxuegu.adapter;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.bean.ExercisesBean;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;public class ExercisesDetailListItemAdapter extends RecyclerView.Adapter&lt;ExercisesDetailListItemAdapter.ViewHolder&gt; &#123; private List&lt;ExercisesBean&gt; objects = new ArrayList&lt;ExercisesBean&gt;(); private ArrayList&lt;String&gt; selectedPosition = new ArrayList&lt;String&gt;(); private Context context; private LayoutInflater layoutInflater; private OnSelectListener onSelectListener; private OnItemListener onItemListener; public ExercisesDetailListItemAdapter(Context context, OnSelectListener onSelectListener) &#123; this.context = context; this.onSelectListener = onSelectListener; this.layoutInflater = LayoutInflater.from(context); &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View view = inflater.inflate(R.layout.exercises_detail_list_item, parent, false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; initializeViews(objects.get(position), holder, position); &#125; public void setData(List&lt;ExercisesBean&gt; objects) &#123; this.objects = objects; &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public int getItemCount() &#123; return objects.size(); &#125; private void initializeViews(ExercisesBean object, final ViewHolder holder, final int position) &#123; ExercisesBean bean = object; if (bean != null) &#123; holder.tvSubject.setText(bean.subject); holder.tvA.setText(bean.a); holder.tvB.setText(bean.b); holder.tvC.setText(bean.c); holder.tvD.setText(bean.d); &#125; if (!selectedPosition.contains(&quot;&quot; + position)) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); AnalysisUtils.setABCDEnable(true, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; else &#123; AnalysisUtils.setABCDEnable(false, holder.ivA, holder.ivB, holder.ivC, holder.ivD); switch (bean.select) &#123; case 0: if (bean.answer == 1) &#123; holder.ivA.setImageResource(R.drawable.exercises_right_icon); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 2) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_right_icon); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 3) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_right_icon); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 4) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_right_icon); &#125; break; case 1: holder.ivA.setImageResource(R.drawable.exercises_error_icon); if (bean.answer == 2) &#123; holder.ivB.setImageResource(R.drawable.exercises_right_icon); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 3) &#123; holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_right_icon); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 4) &#123; holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_right_icon); &#125; break; case 2: holder.ivB.setImageResource(R.drawable.exercises_error_icon); if (bean.answer == 1) &#123; holder.ivA.setImageResource(R.drawable.exercises_right_icon); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 3) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivC.setImageResource(R.drawable.exercises_right_icon); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 4) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_right_icon); &#125; break; case 3: holder.ivC.setImageResource(R.drawable.exercises_error_icon); if (bean.answer == 1) &#123; holder.ivA.setImageResource(R.drawable.exercises_right_icon); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 2) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_right_icon); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 4) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivD.setImageResource(R.drawable.exercises_right_icon); &#125; break; case 4: holder.ivD.setImageResource(R.drawable.exercises_error_icon); if (bean.answer == 1) &#123; holder.ivA.setImageResource(R.drawable.exercises_right_icon); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); &#125; else if (bean.answer == 2) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_right_icon); holder.ivC.setImageResource(R.drawable.exercises_c); &#125; else if (bean.answer == 3) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_right_icon); &#125; break; &#125; &#125; holder.ivA.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (onItemListener!=null)&#123; onItemListener.onItem(v,position); &#125; if (selectedPosition.contains(&quot;&quot; + position)) &#123; selectedPosition.remove(&quot;&quot; + position); &#125; else &#123; selectedPosition.add(position + &quot;&quot;); &#125; onSelectListener.onSelectA(position, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; &#125;); holder.ivB.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (onItemListener!=null)&#123; onItemListener.onItem(v,position); &#125; if (selectedPosition.contains(&quot;&quot; + position)) &#123; selectedPosition.remove(&quot;&quot; + position); &#125; else &#123; selectedPosition.add(position + &quot;&quot;); &#125; onSelectListener.onSelectB(position, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; &#125;); holder.ivC.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (onItemListener!=null)&#123; onItemListener.onItem(v,position); &#125; if (selectedPosition.contains(&quot;&quot; + position)) &#123; selectedPosition.remove(&quot;&quot; + position); &#125; else &#123; selectedPosition.add(position + &quot;&quot;); &#125; onSelectListener.onSelectC(position, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; &#125;); holder.ivD.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (onItemListener!=null)&#123; onItemListener.onItem(v,position); &#125; if (selectedPosition.contains(&quot;&quot; + position)) &#123; selectedPosition.remove(&quot;&quot; + position); &#125; else &#123; selectedPosition.add(position + &quot;&quot;); &#125; onSelectListener.onSelectD(position, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; &#125;); &#125; protected class ViewHolder extends RecyclerView.ViewHolder &#123; private TextView tvSubject; private ImageView ivA; private TextView tvA; private ImageView ivB; private TextView tvB; private ImageView ivC; private TextView tvC; private ImageView ivD; private TextView tvD; public ViewHolder(View view) &#123; super(view); tvSubject = (TextView) view.findViewById(R.id.tv_subject); ivA = (ImageView) view.findViewById(R.id.iv_a); tvA = (TextView) view.findViewById(R.id.tv_a); ivB = (ImageView) view.findViewById(R.id.iv_b); tvB = (TextView) view.findViewById(R.id.tv_b); ivC = (ImageView) view.findViewById(R.id.iv_c); tvC = (TextView) view.findViewById(R.id.tv_c); ivD = (ImageView) view.findViewById(R.id.iv_d); tvD = (TextView) view.findViewById(R.id.tv_d); &#125; &#125; public interface OnSelectListener &#123; void onSelectA(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d); void onSelectB(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d); void onSelectC(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d); void onSelectD(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d); &#125; public interface OnItemListener&#123; void onItem(View view,int position); &#125; public void setOnItemListener(OnItemListener onItemListener)&#123; this.onItemListener=onItemListener; &#125;&#125; ExercisesListItemAdapter.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package cn.edu.gdmec.android.boxuegu.adapter;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.activity.ExercisesDetailActivity;import cn.edu.gdmec.android.boxuegu.bean.ExercisesBean;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;public class ExercisesListItemAdapter extends BaseAdapter &#123; private List&lt;ExercisesBean&gt; objects = new ArrayList&lt;ExercisesBean&gt;(); private Context context; private LayoutInflater layoutInflater; public ExercisesListItemAdapter(Context context)&#123; this.context=context; this.layoutInflater=LayoutInflater.from(context); &#125; /** * 设置数据更新界面 */ public void setData(List&lt;ExercisesBean&gt; objects)&#123; this.objects = objects; notifyDataSetChanged(); &#125; // public void updateView(List&lt;ExercisesBean&gt; objects)&#123; this.objects = objects; this.notifyDataSetChanged(); &#125; @Override public int getCount() &#123; return objects == null ? 0 : objects.size(); &#125; /** * 根据position得到对应的Item的对象 */ @Override public ExercisesBean getItem(int position) &#123; return objects.get(position); &#125; /** * 根据position得到对应Item的对象 */ @Override public long getItemId(int position) &#123; return position; &#125; /** * 得到相应position对应的Item视图，position是当前Item的位置 * convertView参数就是滚出屏幕的Item的View * 第一次进入或滑动屏幕时候被调用 */ @Override public View getView(int position, View convertView, ViewGroup parent) &#123; if (convertView == null) &#123; convertView = layoutInflater.inflate(R.layout.exercises_list_item, null); convertView.setTag(new ViewHolder(convertView)); &#125; initializeViews((ExercisesBean) getItem(position), (ViewHolder) convertView.getTag(), position, convertView); return convertView; &#125; private void initializeViews(ExercisesBean object, ViewHolder holder, int position, View convertView) &#123; final ExercisesBean bean = getItem(position); if (bean != null) &#123; holder.tvOrder.setText(position + 1 + &quot;&quot;); holder.tvTitle.setText(bean.title); Log.i(&quot;readExercises&quot;,AnalysisUtils.readExerciseStatus(context,position+1)+&quot;&quot;); if (AnalysisUtils.readExerciseStatus(context,position+1))&#123; holder.tvContent.setText(&quot;已完成&quot;); &#125;else&#123; holder.tvContent.setText(bean.content); &#125; holder.tvOrder.setBackgroundResource(bean.background); convertView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (bean == null) &#123; return; &#125; //跳转到习题界面 Intent intent = new Intent(context, ExercisesDetailActivity.class); intent.putExtra(&quot;id&quot;, bean.id); intent.putExtra(&quot;title&quot;, bean.title); ((Activity) context).startActivityForResult(intent, 000); &#125; &#125;); &#125; &#125; protected class ViewHolder &#123; private TextView tvOrder; private TextView tvTitle; private TextView tvContent; public ViewHolder(View view) &#123; tvOrder = (TextView) view.findViewById(R.id.tv_order); tvTitle = (TextView) view.findViewById(R.id.tv_title); tvContent = (TextView) view.findViewById(R.id.tv_content); &#125; &#125;&#125; AnalysisUtils.java 中添加代码 1234567891011public static boolean readExerciseStatus(Context context,int i)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;, Context.MODE_PRIVATE); boolean isDone = sharedPreferences.getBoolean(&quot;isDone&quot;+i, false); return isDone;&#125;public static void saveExerciseStatus(Context context,int i)&#123; SharedPreferences sp = context.getSharedPreferences(&quot;loginInfo&quot;, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.putBoolean(&quot;isDone&quot;+i, true); editor.commit();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package cn.edu.gdmec.android.boxuegu.utils;import android.content.Context;import android.content.SharedPreferences;import android.util.Xml;import android.widget.ImageView;import org.xmlpull.v1.XmlPullParser;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.bean.ExercisesBean;public class AnalysisUtils &#123; //读取用户名 public static String readLoginUserName(Context context)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;,Context.MODE_PRIVATE); String userName=sharedPreferences.getString(&quot;loginUserName&quot;,&quot;&quot;); return userName; &#125; //读取登录状态 public static boolean readLoginStatus(Context context)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;,Context.MODE_PRIVATE); boolean isLogin=sharedPreferences.getBoolean(&quot;isLogin&quot;,false); return isLogin; &#125; //清除登录状态 public static void cleanLoginStatus(Context context)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;,Context.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putBoolean(&quot;isLogin&quot;,false); editor.putString(&quot;loginUserName&quot;,&quot;&quot;); editor.commit(); &#125; public static boolean readExerciseStatus(Context context,int i)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;, Context.MODE_PRIVATE); boolean isDone = sharedPreferences.getBoolean(&quot;isDone&quot;+i, false); return isDone; &#125; public static void saveExerciseStatus(Context context,int i)&#123; SharedPreferences sp = context.getSharedPreferences(&quot;loginInfo&quot;, Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.putBoolean(&quot;isDone&quot;+i, true); editor.commit(); &#125; public static List&lt;ExercisesBean&gt; getExercisesInfos(InputStream is) throws Exception&#123; XmlPullParser parser = Xml.newPullParser(); parser.setInput(is,&quot;utf-8&quot;); List&lt;ExercisesBean&gt; exercisesInfos=null; ExercisesBean exercisesInfo=null; int type = parser.getEventType(); while (type!=XmlPullParser.END_DOCUMENT)&#123; switch (type)&#123; case XmlPullParser.START_TAG: if (&quot;infos&quot;.equals(parser.getName()))&#123; exercisesInfos=new ArrayList&lt;ExercisesBean&gt;(); &#125;else if (&quot;exercises&quot;.equals(parser.getName()))&#123; exercisesInfo=new ExercisesBean(); String ids=parser.getAttributeValue(0); exercisesInfo.subjectId = Integer.parseInt(ids); &#125;else if (&quot;subject&quot;.equals(parser.getName()))&#123; String subject=parser.nextText(); exercisesInfo.subject = subject; &#125;else if (&quot;a&quot;.equals(parser.getName()))&#123; String a=parser.nextText(); exercisesInfo.a = a; &#125;else if (&quot;b&quot;.equals(parser.getName()))&#123; String b=parser.nextText(); exercisesInfo.b = b; &#125;else if (&quot;c&quot;.equals(parser.getName()))&#123; String c=parser.nextText(); exercisesInfo.c = c; &#125;else if (&quot;d&quot;.equals(parser.getName()))&#123; String d=parser.nextText(); exercisesInfo.d = d; &#125;else if (&quot;answer&quot;.equals(parser.getName()))&#123; String answer=parser.nextText(); exercisesInfo.answer = Integer.parseInt(answer); &#125; break; case XmlPullParser.END_TAG: if (&quot;exercises&quot;.equals(parser.getName()))&#123; exercisesInfos.add(exercisesInfo); exercisesInfo=null; &#125; break; &#125; type=parser.next(); &#125; return exercisesInfos; &#125; public static void setABCDEnable(boolean value, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d)&#123; iv_a.setEnabled(value); iv_b.setEnabled(value); iv_c.setEnabled(value); iv_d.setEnabled(value); &#125;&#125; Ok，大功告成！教育系统APP(七)掌握课程模块的开发，实现用ViewPager完成广告轮播图的展示掌握课程模块的开发，实现用RecyclerView完成课程列表的展示 项目实操课程界面-广告轮播图课程界面-课程列表 任务实施课程模块主要用于展示课程中的视频信息，当点击课程列表时会跳转到课程详情界面，在该界面中可以播放相应章节的视频。同时为了方便用户查看已学习的视频，还在“我”的界面中添加了一个播放记录。本章将对课程界面进行详细讲解。 课程界面-广告轮播图广告布局导入图片文件 广告轮播图底部有三个可变色的小圆点，我们先把小圆点的选择器给做了。在drawable文件夹下分别创建indicator_on.xml和indecator_off.xml。 indicator_on.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot;&gt; &lt;size android:height=&quot;6dp&quot; android:width=&quot;6dp&quot;&gt;&lt;/size&gt; &lt;solid android:color=&quot;#00ABF8&quot;&gt;&lt;/solid&gt;&lt;/shape&gt; indicator_off.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;oval&quot;&gt; &lt;size android:height=&quot;6dp&quot; android:width=&quot;6dp&quot;&gt;&lt;/size&gt; &lt;solid android:color=&quot;#737373&quot;&gt;&lt;/solid&gt;&lt;/shape&gt; 新建一个布局文件，命名为main_adbanner.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/rl_adBanner&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;160dp&quot; android:background=&quot;#eeeeee&quot;&gt; &lt;android.support.v4.view.ViewPager android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/vp_advertBanner&quot; android:background=&quot;@drawable/default_img&quot; android:gravity=&quot;center&quot; android:layout_marginBottom=&quot;1dp&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot;&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;LinearLayout android:gravity=&quot;center_horizontal&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;@android:color/transparent&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;View android:background=&quot;@drawable/indicator_off&quot; android:layout_marginLeft=&quot;5dp&quot; android:id=&quot;@+id/dots_1&quot; android:layout_width=&quot;5dp&quot; android:layout_height=&quot;5dp&quot;/&gt; &lt;View android:background=&quot;@drawable/indicator_off&quot; android:layout_marginLeft=&quot;5dp&quot; android:id=&quot;@+id/dots_2&quot; android:layout_width=&quot;5dp&quot; android:layout_height=&quot;5dp&quot;/&gt; &lt;View android:background=&quot;@drawable/indicator_off&quot; android:layout_marginLeft=&quot;5dp&quot; android:id=&quot;@+id/dots_3&quot; android:layout_width=&quot;5dp&quot; android:layout_height=&quot;5dp&quot;/&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 课程界面布局写完了轮播图的布局，我们来完成课程页面的布局。修改fragment_course.xml。fragment_course.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;include layout=&quot;@layout/main_adbanner&quot;&gt;&lt;/include&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;45dp&quot;&gt; &lt;ImageView android:layout_width=&quot;25dp&quot; android:layout_height=&quot;25dp&quot; android:src=&quot;@drawable/course_intro_icon&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;8dp&quot;/&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginLeft=&quot;5dp&quot; android:gravity=&quot;center_vertical&quot; android:text=&quot;Android 基础教程1-10章视频&quot; android:textSize=&quot;16sp&quot; android:textColor=&quot;@android:color/black&quot; android:textStyle=&quot;bold&quot;/&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;8dp&quot; android:background=&quot;#E4E4E4&quot;&gt; &lt;/View&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/rv_list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginBottom=&quot;55dp&quot; android:scrollbars=&quot;none&quot;&gt; &lt;!--android:divider=&quot;@null&quot; android:id=&quot;@+id/lv_list&quot; android:dividerHeight=&quot;0dp&quot;--&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; ViewPager先给ViewPager写一个适配器：在Adapter文件夹下新建一个java文件，命名为ADViewPagerAdapter.java。ADViewPagerAdapter.java 12345678910111213141516171819202122232425262728293031323334353637package cn.edu.gdmec.android.boxuegu.adapter;import android.content.Context;import android.support.v4.view.PagerAdapter;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import java.util.List;public class ADViewPagerAdapter extends PagerAdapter &#123; private Context context; private List&lt;ImageView&gt; list; public ADViewPagerAdapter(Context context, List&lt;ImageView&gt; list)&#123; this.context = context; this.list = list; &#125; @Override public int getCount() &#123; return list.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object)&#123; container.removeView(list.get(position)); &#125; @Override public Object instantiateItem(ViewGroup container, int position)&#123; container.addView(list.get(position)); return list.get(position); &#125;&#125; 接下来是CourseFragment.javaCourseFragment.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package cn.edu.gdmec.android.boxuegu.fragment;import android.app.Activity;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.v4.app.Fragment;import android.support.v4.view.ViewPager;import android.support.v7.widget.RecyclerView;import android.util.DisplayMetrics;import android.view.Display;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.RelativeLayout;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.adapter.ADViewPagerAdapter;public class CourseFragment extends Fragment &#123; private ViewPager vp_advertBanner; private View dots_1; private View dots_2; private View dots_3; private RelativeLayout rl_adBanner; private RecyclerView rv_list; public static final int MSG_AD_SLID = 002; private List&lt;ImageView&gt; viewList; private ADViewPagerAdapter viewPagerAdapter; private List&lt;View&gt; dots; private int oldPoints=0; private Thread thread; private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case MSG_AD_SLID: if (viewPagerAdapter.getCount() &gt; 0) &#123; if (vp_advertBanner.getCurrentItem() == viewList.size() - 1) &#123; vp_advertBanner.setCurrentItem(0); &#125; else &#123; vp_advertBanner.setCurrentItem(vp_advertBanner.getCurrentItem() + 1); &#125; &#125; break; &#125; &#125; &#125;; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_course, container, false); &#125; @Override public void onViewCreated(View view, Bundle savedInstanceState)&#123; super.onViewCreated(view, savedInstanceState); initView(view); setViewPager(); &#125; private void setViewPager()&#123; thread=new Thread()&#123; @Override public void run()&#123; super.run(); while(true)&#123; try&#123; sleep(1000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; handler.sendEmptyMessage(MSG_AD_SLID); &#125; &#125; &#125;; thread.start(); &#125; private void initView(View view )&#123; vp_advertBanner=view.findViewById(R.id.vp_advertBanner); rl_adBanner=view.findViewById(R.id.rl_adBanner); viewList = new ArrayList&lt;&gt;(); ImageView imageView1=new ImageView(getActivity()); ImageView imageView2=new ImageView(getActivity()); ImageView imageView3=new ImageView(getActivity()); imageView1.setImageResource(R.drawable.banner_1); imageView2.setImageResource(R.drawable.banner_2); imageView3.setImageResource(R.drawable.banner_3); viewList.add(imageView1); viewList.add(imageView2); viewList.add(imageView3); viewPagerAdapter = new ADViewPagerAdapter(getActivity(),viewList); vp_advertBanner.setAdapter(viewPagerAdapter); //圆点 dots = new ArrayList&lt;View&gt;(); dots_1 = (View)view.findViewById(R.id.dots_1); dots_2 = (View)view.findViewById(R.id.dots_2); dots_3 = (View)view.findViewById(R.id.dots_3); dots.add(dots_1); dots.add(dots_2); dots.add(dots_3); //第一个圆点设为黑色 dots.get(0).setBackgroundResource(R.drawable.indicator_on); vp_advertBanner.setOnPageChangeListener(new ViewPager.OnPageChangeListener()&#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; dots.get(oldPoints).setBackgroundResource(R.drawable.indicator_off); dots.get(position).setBackgroundResource(R.drawable.indicator_on); oldPoints=position; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); resetSize(); &#125; private void resetSize()&#123; int sw = getScreenWidth(getActivity()); int adLheight = sw / 2; ViewGroup.LayoutParams adlp = rl_adBanner.getLayoutParams(); adlp.width = sw; adlp.height = adLheight; rl_adBanner.setLayoutParams(adlp); &#125; private int getScreenWidth(Activity mContext)&#123; DisplayMetrics metrics = new DisplayMetrics(); Display display = mContext.getWindowManager().getDefaultDisplay(); display.getMetrics(metrics); return metrics.widthPixels; &#125;&#125; 课程界面-课程列表课程列表item新建布局文件，命名为course_list_item.xml。 course_list_item.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:background=&quot;@android:color/white&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;115dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_course_img&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;4dp&quot; android:paddingLeft=&quot;8dp&quot; android:paddingRight=&quot;4dp&quot; android:paddingTop=&quot;8dp&quot; android:src=&quot;@drawable/chapter_1_icon&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_course_img_title&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_marginBottom=&quot;4dp&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;6dp&quot; android:background=&quot;#30000000&quot; android:paddingBottom=&quot;2dp&quot; android:paddingRight=&quot;5dp&quot; android:paddingLeft=&quot;5dp&quot; android:paddingTop=&quot;2dp&quot; android:text=&quot;Android 基础入门&quot; android:textSize=&quot;12sp&quot; android:textColor=&quot;@android:color/white&quot;/&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id=&quot;@+id/tv_course_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:text=&quot;Android 基础视频第一章&quot; android:textColor=&quot;@android:color/black&quot; android:textSize=&quot;14sp&quot;/&gt;&lt;/LinearLayout&gt; 属性类在Bean包下新建一个Java文件，命名为CourseBean.java CourseBean.java1234567public class CourseBean &#123; public int id; public String imgTitle; public String title; public String intro; public String icon;&#125; 课程item的适配器右键course_list_item.xml，用Genrate Code生成adapter文件，把它放进adapter包下。CourseListItemAdapter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package cn.edu.gdmec.android.boxuegu.adapter;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.bean.CourseBean;public class CourseListItemAdapter extends RecyclerView.Adapter&lt;CourseListItemAdapter.ViewHolder&gt; &#123; private List&lt;CourseBean&gt; objects = new ArrayList&lt;CourseBean&gt;(); private Context context; private LayoutInflater layoutInflater; public CourseListItemAdapter(Context context) &#123; this.context = context; this.layoutInflater = LayoutInflater.from(context); &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View view=inflater.inflate(R.layout.course_list_item,parent,false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position)&#123; initializeViews(objects.get(position), holder); &#125; public void setData(List&lt;CourseBean&gt; objects)&#123; this.objects=objects; &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public int getItemCount() &#123; return objects.size(); &#125; private void initializeViews(CourseBean object, ViewHolder holder) &#123; if (object != null)&#123; holder.tvCourseImgTitle.setText(object.imgTitle); holder.tvCourseTitle.setText(object.title); switch (object.id)&#123; case 1: holder.ivCourseImg.setImageResource(R.drawable.chapter_1_icon); break; case 2: holder.ivCourseImg.setImageResource(R.drawable.chapter_2_icon); break; case 3: holder.ivCourseImg.setImageResource(R.drawable.chapter_3_icon); break; case 4: holder.ivCourseImg.setImageResource(R.drawable.chapter_4_icon); break; case 5: holder.ivCourseImg.setImageResource(R.drawable.chapter_5_icon); break; case 6: holder.ivCourseImg.setImageResource(R.drawable.chapter_6_icon); break; case 7: holder.ivCourseImg.setImageResource(R.drawable.chapter_7_icon); break; case 8: holder.ivCourseImg.setImageResource(R.drawable.chapter_8_icon); break; case 9: holder.ivCourseImg.setImageResource(R.drawable.chapter_9_icon); break; case 10: holder.ivCourseImg.setImageResource(R.drawable.chapter_10_icon); break; &#125; &#125; &#125; protected class ViewHolder extends RecyclerView.ViewHolder &#123; private ImageView ivCourseImg; private TextView tvCourseImgTitle; private TextView tvCourseTitle; public ViewHolder(View view) &#123; super(view); ivCourseImg = (ImageView) view.findViewById(R.id.iv_course_img); tvCourseImgTitle = (TextView) view.findViewById(R.id.tv_course_img_title); tvCourseTitle = (TextView) view.findViewById(R.id.tv_course_title); &#125; &#125;&#125; 课程数据在assets文件夹中放入chaptertitle.xml，显然之前放过了到Utils包下的AnalysisUtils.java中添加解析课程数据的方法。 AnalysisUtils.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static List&lt;CourseBean&gt; getCourseInfos(InputStream is) throws Exception&#123; XmlPullParser parser=Xml.newPullParser(); parser.setInput(is,&quot;utf-8&quot;); List&lt;CourseBean&gt; courseList=null; CourseBean courseInfo=null; int type=parser.getEventType(); while(type !=XmlPullParser.END_DOCUMENT)&#123; switch (type)&#123; case XmlPullParser.START_TAG: if (&quot;infos&quot;.equals(parser.getName()))&#123; courseList=new ArrayList&lt;CourseBean&gt;(); &#125;else if(&quot;course&quot;.equals(parser.getName()))&#123; courseInfo=new CourseBean(); String ids=parser.getAttributeValue(0); courseInfo.id=Integer.parseInt(ids); &#125; else if(&quot;imgtitle&quot;.equals(parser.getName()))&#123; String imgtitle=parser.nextText(); courseInfo.imgTitle=imgtitle; &#125; else if(&quot;title&quot;.equals(parser.getName()))&#123; String title=parser.nextText(); courseInfo.title=title; &#125; else if(&quot;intro&quot;.equals(parser.getName()))&#123; String intro=parser.nextText(); courseInfo.intro=intro; &#125; break; case XmlPullParser.END_TAG: if (&quot;course&quot;.equals(parser.getName()))&#123; courseList.add(courseInfo); courseInfo=null; &#125; break; &#125; type=parser.next(); &#125; return courseList; &#125; 课程列表逻辑代码回到CourseFragment.java,把获取数据和recyclerView的逻辑代码补上 CourseFragment.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package cn.edu.gdmec.android.boxuegu.fragment;import android.app.Activity;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.v4.app.Fragment;import android.support.v4.view.ViewPager;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.util.DisplayMetrics;import android.view.Display;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.RelativeLayout;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.adapter.ADViewPagerAdapter;import cn.edu.gdmec.android.boxuegu.adapter.CourseListItemAdapter;import cn.edu.gdmec.android.boxuegu.bean.CourseBean;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;public class CourseFragment extends Fragment &#123; private ViewPager vp_advertBanner; private View dots_1; private View dots_2; private View dots_3; private RelativeLayout rl_adBanner; private RecyclerView rv_list; public static final int MSG_AD_SLID = 002; private List&lt;ImageView&gt; viewList; private ADViewPagerAdapter viewPagerAdapter; private List&lt;View&gt; dots; private int oldPoints=0; private Thread thread; private List&lt;CourseBean&gt; rList; private CourseListItemAdapter adapter; private Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case MSG_AD_SLID: if (viewPagerAdapter.getCount() &gt; 0) &#123; if (vp_advertBanner.getCurrentItem() == viewList.size() - 1) &#123; vp_advertBanner.setCurrentItem(0); &#125; else &#123; vp_advertBanner.setCurrentItem(vp_advertBanner.getCurrentItem() + 1); &#125; &#125; break; &#125; &#125; &#125;; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_course, container, false); &#125; @Override public void onViewCreated(View view, Bundle savedInstanceState)&#123; super.onViewCreated(view, savedInstanceState); getCourseData(); initView(view); setViewPager(); &#125; private void getCourseData()&#123; try &#123; InputStream is = getActivity().getResources().getAssets().open(&quot;chaptertitle.xml&quot;); rList = AnalysisUtils.getCourseInfos(is); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void setViewPager()&#123; thread=new Thread()&#123; @Override public void run()&#123; super.run(); while(true)&#123; try&#123; sleep(1000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; handler.sendEmptyMessage(MSG_AD_SLID); &#125; &#125; &#125;; thread.start(); &#125; private void initView(View view )&#123; rv_list=view.findViewById(R.id.rv_list); adapter=new CourseListItemAdapter(getActivity()); adapter.setData(rList); rv_list.setLayoutManager(new GridLayoutManager(getActivity(),3)); rv_list.setAdapter(adapter); vp_advertBanner=view.findViewById(R.id.vp_advertBanner); rl_adBanner=view.findViewById(R.id.rl_adBanner); viewList = new ArrayList&lt;&gt;(); ImageView imageView1=new ImageView(getActivity()); ImageView imageView2=new ImageView(getActivity()); ImageView imageView3=new ImageView(getActivity()); imageView1.setImageResource(R.drawable.banner_1); imageView2.setImageResource(R.drawable.banner_2); imageView3.setImageResource(R.drawable.banner_3); viewList.add(imageView1); viewList.add(imageView2); viewList.add(imageView3); viewPagerAdapter = new ADViewPagerAdapter(getActivity(),viewList); vp_advertBanner.setAdapter(viewPagerAdapter); //圆点 dots = new ArrayList&lt;View&gt;(); dots_1 = (View)view.findViewById(R.id.dots_1); dots_2 = (View)view.findViewById(R.id.dots_2); dots_3 = (View)view.findViewById(R.id.dots_3); dots.add(dots_1); dots.add(dots_2); dots.add(dots_3); //第一个圆点设为黑色 dots.get(0).setBackgroundResource(R.drawable.indicator_on); vp_advertBanner.setOnPageChangeListener(new ViewPager.OnPageChangeListener()&#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123; dots.get(oldPoints).setBackgroundResource(R.drawable.indicator_off); dots.get(position).setBackgroundResource(R.drawable.indicator_on); oldPoints=position; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); resetSize(); &#125; private void resetSize()&#123; int sw = getScreenWidth(getActivity()); int adLheight = sw / 2; ViewGroup.LayoutParams adlp = rl_adBanner.getLayoutParams(); adlp.width = sw; adlp.height = adLheight; rl_adBanner.setLayoutParams(adlp); &#125; private int getScreenWidth(Activity mContext)&#123; DisplayMetrics metrics = new DisplayMetrics(); Display display = mContext.getWindowManager().getDefaultDisplay(); display.getMetrics(metrics); return metrics.widthPixels; &#125;&#125; 补充完成后，大功告成！ 任务实施-福利把课程列表显示从2列变为3列 由于任务过简单，就告诉你们~CourseFragment.java，其实你们会发现运行完就变3列了，那么是哪里改的呢？ 12345rv_list=view.findViewById(R.id.rv_list); adapter=new CourseListItemAdapter(getActivity()); adapter.setData(rList); rv_list.setLayoutManager(new GridLayoutManager(getActivity(),3)); rv_list.setAdapter(adapter); 总结大家是不是觉得之前的任务有点难呢？就给任务福利了，岁月静好~]]></content>
      <categories>
        <category>教育系统APP</category>
      </categories>
      <tags>
        <tag>教育系统APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育系统APP(六)]]></title>
    <url>%2F2018%2F04%2F26%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 回顾上一期任务 任务实施个人资料加上QQ号属性在个人资料下添加一个“QQ号”属性，初始状态文字显示“未添加”，点击进入修改页面，输入框的键盘类型只能为数字。（提示：editText.setInputType(InputType.TYPE_CLASS_NUMBER) ）输入框最多只能输入12位数字，点击保存后个人资料界面能正常显示保存后的结果。 教育系统APP(六)的发布 先解决上一次的问题-教育系统APP(五)DBUtils.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package cn.edu.gdmec.android.boxuegu.utils;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import cn.edu.gdmec.android.boxuegu.bean.UserBean;import cn.edu.gdmec.android.boxuegu.sqlite.SQLiteHelper;public class DBUtils &#123; private static DBUtils instance = null; private static SQLiteHelper helper; private static SQLiteDatabase db; /** * 构造方法，只有当类被实例化时候调用 * 实例化SQLiteHelper类，从中得到一个课读写的数据库 **/ public DBUtils(Context context) &#123; helper = new SQLiteHelper(context); db = helper.getWritableDatabase(); &#125; /** * 得到这个类的实例 **/ public static DBUtils getInstance(Context context) &#123; if (instance == null) &#123; instance = new DBUtils(context); &#125; return instance; &#125; /** * 保存个人资料信息 **/ public void saveUserInfo(UserBean bean) &#123; ContentValues cv = new ContentValues(); cv.put(&quot;userName&quot;, bean.userName); cv.put(&quot;nickName&quot;, bean.nickName); cv.put(&quot;sex&quot;, bean.sex); cv.put(&quot;signature&quot;, bean.signature); cv.put(&quot;qq&quot;,bean.qq); //Convenience method for inserting a row into the database. //注意，我们是从数据库使用插入方法，传入表名和数据集完成插入 db.insert(SQLiteHelper.U_USER_INFO, null, cv); &#125; /** * 获取个人资料信息 **/ public UserBean getUserInfo(String userName) &#123; String sql = &quot;SELECT * FROM &quot; + SQLiteHelper.U_USER_INFO + &quot; WHERE userName=?&quot;; //?和下面数组内元素会逐个替换，可以多条件查询=?and =? //You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. Cursor cursor = db.rawQuery(sql, new String[]&#123;userName&#125;); UserBean bean = null; //Move the cursor to the next row. while (cursor.moveToNext()) &#123; bean = new UserBean(); //根据列索引获取对应的数值，因为这里查询结果只有一个，我们也不需要对模型UserBean进行修改， //直接将对应用户名的所有数据从表中动态赋值给bean bean.userName = cursor.getString(cursor.getColumnIndex(&quot;userName&quot;)); bean.nickName = cursor.getString(cursor.getColumnIndex(&quot;nickName&quot;)); bean.sex = cursor.getString(cursor.getColumnIndex(&quot;sex&quot;)); bean.signature = cursor.getString(cursor.getColumnIndex(&quot;signature&quot;)); bean.qq = cursor.getString(cursor.getColumnIndex(&quot;qq&quot;)); &#125; cursor.close(); return bean; &#125; /** * 修改个人资料信息,这里的key指代表字段，value表示数值 **/ public void updateUserInfo(String key, String value, String userName) &#123; ContentValues cv = new ContentValues(); cv.put(key, value); //Convenience method for updating rows in the database. db.update(SQLiteHelper.U_USER_INFO, cv, &quot;userName=?&quot;, new String[] &#123;userName&#125;); &#125;&#125; SQLiteHelper.java123456789101112131415161718192021222324252627282930313233343536373839package cn.edu.gdmec.android.boxuegu.sqlite;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;public class SQLiteHelper extends SQLiteOpenHelper &#123; private static final int DB_VERSION = 1; public static String DB_NAME = &quot;bxg.db&quot;; public static final String U_USER_INFO = &quot;userInfo&quot;; public SQLiteHelper(Context context)&#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; /** * 当这个SQLiteOpenHelper的子类类被实例化时会创建指定名的数据库，在onCreate中创建个人信息表 * **/ db.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + U_USER_INFO + &quot;( &quot; + &quot;_id INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + &quot;userName VARCHAR, &quot; + &quot;nickName VARCHAR, &quot; + &quot;sex VARCHAR, &quot; + &quot;signature VARCHAR, &quot; + &quot;qq VARCHAR &quot; + &quot;)&quot;); &#125; /** * 当数据库版本号增加才会调用此方法 **/ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + U_USER_INFO); onCreate(db); &#125;&#125; UserBean.java123456789package cn.edu.gdmec.android.boxuegu.bean;public class UserBean &#123; public String userName;//用户名 public String nickName;//昵称 public String sex;//性别 public String signature;//签名 public String qq;//qq&#125; UserInfoActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248package cn.edu.gdmec.android.boxuegu.activity;import android.app.Activity;import android.content.DialogInterface;import android.content.Intent;import android.content.pm.ActivityInfo;import android.graphics.Color;import android.os.Bundle;import android.support.v7.app.AlertDialog;import android.text.TextUtils;import android.view.View;import android.widget.ImageView;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.bean.UserBean;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;import cn.edu.gdmec.android.boxuegu.utils.DBUtils;public class UserInfoActivity extends Activity implements View.OnClickListener&#123; //标题栏 private RelativeLayout title_bar; private TextView tv_back; private TextView tv_main_title; // private RelativeLayout rl_head; private ImageView iv_head_icon; private RelativeLayout rl_account;// private TextView tv_user_name; private RelativeLayout rl_nickName; private TextView tv_nick_name; private RelativeLayout rl_sex; private TextView tv_sex; private RelativeLayout rl_signature; private TextView tv_signature; private RelativeLayout rl_qq; private TextView tv_qq; // private String spUserName; private String new_info; private static final int CHANGE_NICKNAME = 1; private static final int CHANGE_SIGNATURE = 2; private static final int CHANGE_QQ = 3; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_user_info); //设置此界面为竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); spUserName= AnalysisUtils.readLoginUserName(this); initView(); initDate(); &#125; private void initDate() &#123; UserBean bean = null; //实例化DBUtils，同时调用其方法获取个人信息资料 bean = DBUtils.getInstance(this).getUserInfo(spUserName); //如果第一次进入，数据库没有保留用户信息 if (bean == null) &#123; bean = new UserBean(); bean.userName = spUserName; bean.nickName = &quot;问答精灵&quot;; bean.sex = &quot;男&quot;; bean.signature = &quot;这个人很懒，什么都没留下...&quot;; bean.qq = &quot;未添加&quot;; //保存到数据库 DBUtils.getInstance(this).saveUserInfo(bean); &#125; setValue(bean); &#125; private void initView() &#123; //个人资料界面 tv_back = findViewById(R.id.tv_back); tv_main_title = findViewById(R.id.tv_main_title); tv_main_title.setText(&quot;个人资料界面&quot;); title_bar = findViewById(R.id.title_bar); title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); /** * rl_head iv_head_icon * rl_account tv_user_name * rl_nickName tv_nick_name * rl_sex tv_sex * rl_signature tv_signature * rl_qq tv_qq */ rl_head=findViewById(R.id.rl_head); iv_head_icon=findViewById(R.id.iv_head_icon); rl_account=findViewById(R.id.rl_account); tv_user_name=findViewById(R.id.tv_user_name); rl_nickName=findViewById(R.id.rl_nickName); tv_nick_name=findViewById(R.id.tv_nick_name); rl_sex=findViewById(R.id.rl_sex); tv_sex=findViewById(R.id.tv_sex); rl_signature=findViewById(R.id.rl_signature); tv_signature=findViewById(R.id.tv_signature); rl_qq=findViewById(R.id.rl_qq); tv_qq=findViewById(R.id.tv_qq); // tv_back.setOnClickListener(this); rl_head.setOnClickListener(this); rl_account.setOnClickListener(this); rl_nickName.setOnClickListener(this); rl_sex.setOnClickListener(this); rl_signature.setOnClickListener(this); rl_qq.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_back: this.finish(); break; case R.id.rl_nickName: //昵称 String name = tv_nick_name.getText().toString(); Bundle bdName = new Bundle(); bdName.putString(&quot;content&quot;, name); //传递界面上的昵称数据 bdName.putString(&quot;title&quot;, &quot;昵称&quot;); bdName.putInt(&quot;flag&quot;, 1); //ActivityUserInfoActivity的Onclick()里昵称和签名响应加上跳转代码 enterActivityForResult(ChangeUserInfoActivity.class, CHANGE_NICKNAME, bdName);//跳转到修改界面 break; case R.id.rl_sex: String sex = tv_sex.getText().toString(); sexDialog(sex); break; case R.id.rl_signature: //签名 String signature = tv_signature.getText().toString(); Bundle bdSignature = new Bundle(); bdSignature.putString(&quot;content&quot;, signature); //传递界面上的签名数据 bdSignature.putString(&quot;title&quot;, &quot;签名&quot;); bdSignature.putInt(&quot;flag&quot;, 2); //ActivityUserInfoActivity的Onclick()里昵称和签名响应加上跳转代码 enterActivityForResult(ChangeUserInfoActivity.class, CHANGE_SIGNATURE, bdSignature); break; case R.id.rl_qq: String qq = tv_qq.getText().toString(); Bundle bdqq = new Bundle(); bdqq.putString(&quot;content&quot;, qq); //传递界面上的签名数据 bdqq.putString(&quot;title&quot;, &quot;QQ号&quot;); bdqq.putInt(&quot;flag&quot;, 3); //ActivityUserInfoActivity的Onclick()里昵称和签名响应加上跳转代码 enterActivityForResult(ChangeUserInfoActivity.class, CHANGE_QQ, bdqq); break; default: break; &#125; &#125; /** * 为界面空间设置值 **/ private void setValue(UserBean bean) &#123; tv_user_name.setText(bean.userName); tv_nick_name.setText(bean.nickName); tv_sex.setText(bean.sex); tv_signature.setText(bean.signature); tv_qq.setText(bean.qq); &#125; /** * 设置性别弹出框 **/ private void sexDialog(String sex) &#123; int sexFlag = 0; if (&quot;男&quot;.equals(sex)) &#123; sexFlag = 0; &#125; else if (&quot;女&quot;.equals(sex)) &#123; sexFlag = 1; &#125; final String items[] = &#123;&quot;男&quot;, &quot;女&quot;&#125;; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(&quot;性别&quot;); //sexFlag用来区分显示被选中项，如果sexFlag的值和在数组中的索引严格符合，下方which也可用sexFlag代替 builder.setSingleChoiceItems(items, sexFlag, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); Toast.makeText(UserInfoActivity.this, items[which], Toast.LENGTH_SHORT).show(); setSex(items[which]); &#125; &#125;); builder.create().show(); &#125; /** * 更新性别数据 **/ private void setSex(String sex) &#123; tv_sex.setText(sex); //更新数据库字段 DBUtils.getInstance(this).updateUserInfo(&quot;sex&quot;, sex, spUserName); &#125; /** * 其实就是把需要传递的数值放置于bundle中，bundle作为附加到intent中 * 获取回传数据是需要的跳转方法，第三个参数标示跳转是传递的数据 **/ public void enterActivityForResult(Class&lt;?&gt; to, int requestCode, Bundle b) &#123; Intent i = new Intent(this, to); i.putExtras(b); startActivityForResult(i, requestCode); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case CHANGE_NICKNAME: if (data != null) &#123; new_info = data.getStringExtra(&quot;nickName&quot;); if (TextUtils.isEmpty(new_info)) &#123; return; &#125; tv_nick_name.setText(new_info); //更新数据库中昵称字段 DBUtils.getInstance(UserInfoActivity.this).updateUserInfo(&quot;nickName&quot;, new_info, spUserName); &#125; break; case CHANGE_SIGNATURE: if (data != null) &#123; new_info = data.getStringExtra(&quot;signature&quot;); if (TextUtils.isEmpty(new_info)) &#123; return; &#125; tv_signature.setText(new_info); //更新数据库中签名字段 DBUtils.getInstance(UserInfoActivity.this).updateUserInfo(&quot;signature&quot;, new_info, spUserName); &#125; break; case CHANGE_QQ: if (data != null) &#123; new_info = data.getStringExtra(&quot;qq&quot;); if (TextUtils.isEmpty(new_info)) &#123; return; &#125; tv_qq.setText(new_info); //更新数据库中QQ字段 DBUtils.getInstance(UserInfoActivity.this).updateUserInfo(&quot;qq&quot;, new_info, spUserName); &#125; break; &#125; &#125;&#125; ChangeUserInfoActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190package cn.edu.gdmec.android.boxuegu.activity;import android.content.Intent;import android.content.pm.ActivityInfo;import android.graphics.Color;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.text.Editable;import android.text.Selection;import android.text.TextUtils;import android.text.TextWatcher;import android.view.View;import android.widget.EditText;import android.widget.ImageView;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;public class ChangeUserInfoActivity extends AppCompatActivity implements View.OnClickListener&#123; //标题栏 private TextView tv_back; private TextView tv_main_title; private TextView tv_save; private RelativeLayout rl_title_bar; // private EditText et_content; private ImageView iv_delete; private String title, content; private int flag; //flag为1时表示修改昵称，为2时表示修改签名，为3时表示修改QQ号 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_change_user_info); //设置此界面为竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); initView(); &#125; private void initView() &#123; tv_back = (TextView) findViewById(R.id.tv_back); tv_main_title = (TextView) findViewById(R.id.tv_main_title); tv_save = (TextView) findViewById(R.id.tv_save); rl_title_bar = (RelativeLayout) findViewById(R.id.title_bar); et_content = (EditText) findViewById(R.id.et_content); iv_delete = (ImageView) findViewById(R.id.iv_delete); //从个人资料界面传递过来的标题和内容 title = getIntent().getStringExtra(&quot;title&quot;); content = getIntent().getStringExtra(&quot;content&quot;); flag = getIntent().getIntExtra(&quot;flag&quot;, 0); tv_main_title.setText(title); tv_save.setVisibility(View.VISIBLE); rl_title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); tv_back.setOnClickListener(this); iv_delete.setOnClickListener(this); tv_save.setOnClickListener(this); if (!TextUtils.isEmpty(content))&#123; et_content.setText(content); et_content.setSelection(content.length()); &#125; contentListener(); &#125; /** * 监听个人资料修改界面输入的文字 **/ private void contentListener() &#123; et_content.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; Editable editable = et_content.getText(); int len = editable.length();//输入文本的长度 if (len &gt;= 0) &#123; iv_delete.setVisibility(View.VISIBLE); &#125; else &#123; iv_delete.setVisibility(View.GONE); &#125; switch (flag) &#123; case 1://昵称,最多8个文字，超过则截取多余文字 if (len &gt; 8) &#123; int selEndIndex = Selection.getSelectionEnd(editable); String str = editable.toString(); //截取新字符串 String newStr = str.substring(0, 8); et_content.setText(newStr); editable = et_content.getText(); //新字符串长度 int newLen = editable.length(); //旧光标位置超过新字符串长度 if (selEndIndex &gt; newLen) &#123; selEndIndex = editable.length(); &#125; //设置新光标所在位置 Selection.setSelection(editable, selEndIndex); &#125; break; case 2: //签名，做多16， if (len &gt; 16) &#123; int selEndIndex = Selection.getSelectionEnd(editable); String str = editable.toString(); String newStr = str.substring(0, 16); et_content.setText(newStr); editable = et_content.getText(); int newLen = editable.length(); if (selEndIndex &gt; newLen) &#123; selEndIndex = editable.length(); &#125; Selection.setSelection(editable, selEndIndex); &#125; break; case 3: //qq，做多16， if (len &gt; 12) &#123; int selEndIndex = Selection.getSelectionEnd(editable); String str = editable.toString(); String newStr = str.substring(0, 12); et_content.setText(newStr); editable = et_content.getText(); int newLen = editable.length(); if (selEndIndex &gt; newLen) &#123; selEndIndex = editable.length(); &#125; Selection.setSelection(editable, selEndIndex); &#125; break; default: break; &#125; &#125; @Override public void afterTextChanged(Editable editable) &#123; &#125; &#125;); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.tv_back: finish(); break; case R.id.iv_delete: et_content.setText(&quot;&quot;); break; case R.id.tv_save: Intent data = new Intent(); String etContent = et_content.getText().toString().trim(); switch (flag) &#123; case 1: if (!TextUtils.isEmpty(etContent)) &#123; data.putExtra(&quot;nickName&quot;, etContent); setResult(RESULT_OK, data); Toast.makeText(this, &quot;保存成功&quot;, Toast.LENGTH_SHORT).show(); ChangeUserInfoActivity.this.finish(); &#125; else &#123; Toast.makeText(this, &quot;昵称不能为空&quot;, Toast.LENGTH_SHORT).show(); &#125; break; case 2: if (!TextUtils.isEmpty(etContent)) &#123; data.putExtra(&quot;signature&quot;, etContent); setResult(RESULT_OK, data); Toast.makeText(this, &quot;保存成功&quot;, Toast.LENGTH_SHORT).show(); ChangeUserInfoActivity.this.finish(); &#125; else &#123; Toast.makeText(this, &quot;签名不能为空&quot;, Toast.LENGTH_SHORT).show(); &#125; break; case 3: if (!TextUtils.isEmpty(etContent)) &#123; data.putExtra(&quot;qq&quot;, etContent); setResult(RESULT_OK, data); Toast.makeText(this, &quot;保存成功&quot;, Toast.LENGTH_SHORT).show(); ChangeUserInfoActivity.this.finish(); &#125; else &#123; Toast.makeText(this, &quot;QQ号不能为空&quot;, Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125; &#125;&#125; ok，大功告成！教育系统APP(六)-“习题”的模块项目实操习题习题界面习题界面Adapter习题界面逻辑代码 习题详情习题详情界面 习题数据习题详情界面adapter习题详情逻辑代码 任务实施判断题数保存答题状态 学习目标掌握习题列表界面的开发，实现用ListView完成习题列表的展示掌握习题详情界面的开发，实现用RecyclerView完成习题详情的展示习题模块主要以习题的形式来检测学生对教材中知识点的掌握情况。当点击习题列表时会跳转到习题详情界面，在该界面中点击选项时会立即显示正确答案。本章将针对习题模块进行详细讲解。 项目实操习题习题界面导入图片 修改fragment_exercises.xml1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--练习界面布局--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;ListView android:id=&quot;@+id/lv_list&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:layout_marginBottom=&quot;55dp&quot; android:divider=&quot;#E4E4E4&quot; android:dividerHeight=&quot;1dp&quot;&gt; &lt;/ListView&gt;&lt;/LinearLayout&gt; 这是ListVIew的第一步。接下来实ListView中的每一列Item。在layout文件夹中创建一个布局文件，命名为exercise_list_item.xmlitem里放3个TextView控件，分别为习题序号、章节标题、习题数量。 exercise_list_item.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--练习列表项布局--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;horizontal&quot; android:paddingBottom=&quot;15dp&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingTop=&quot;15dp&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_order&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; android:background=&quot;@drawable/exercises_bg_1&quot; android:gravity=&quot;center&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;16sp&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_marginLeft=&quot;15dp&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;第一章Android基础入门&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;!--android:singleLine=&quot;true&quot;--&gt; &lt;TextView android:id=&quot;@+id/tv_content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;2dp&quot; android:text=&quot;共计5题&quot; android:textColor=&quot;#a3a3a3&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;!--android:singleLine=&quot;true&quot;--&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; ListView的列表和单列布局写完后，我们先来给我们的数据定一个属性类。在bean包中创建一个ExercisesBean类。 ExercisesBean.java12345678910111213141516package cn.edu.gdmec.android.boxuegu.bean;public class ExercisesBean &#123; public int id;//每章习题id public String title;//每章习题标题 public String content;//每章习题的数目 public int background;//每章习题前边的序号背景 public int subjectId;//每道习题的ID public String subject;//每道习题的题干 public String a;//每道题的A选项 public String b;//每道题的B选项 public String c;//每道题的C选项 public String d;//每道题的D选项 public int answer;//每道题的正确答案 public int select;//用户选中的那项&#125; 习题界面AdapterListView需要一个数据适配器对其进行数据适配，即Adapter。这是使用一个ListView的第三个步骤。我们可以在exercise_list_item.xml中用插件直接生成一个Adapter，里面自动帮我们写好了ViewHolder(可以减少缓存)。 新建一个Adapter包，把我们的Adapter移进去,在adapter包中，创建ExercisesListItemAdapter.java ExercisesListItemAdapter.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package cn.edu.gdmec.android.boxuegu.adapter;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.bean.ExercisesBean;public class ExercisesListItemAdapter extends BaseAdapter &#123; private List&lt;ExercisesBean&gt; objects = new ArrayList&lt;ExercisesBean&gt;(); private Context context; private LayoutInflater layoutInflater; public ExercisesListItemAdapter(Context context)&#123; this.context=context; this.layoutInflater=LayoutInflater.from(context); &#125; /** * 设置数据更新界面 */ public void setData(List&lt;ExercisesBean&gt; objects)&#123; this.objects = objects; notifyDataSetChanged(); &#125; // public void updateView(List&lt;ExercisesBean&gt; objects)&#123; this.objects = objects; this.notifyDataSetChanged(); &#125; @Override public int getCount() &#123; return objects == null ? 0 : objects.size(); &#125; /** * 根据position得到对应的Item的对象 */ @Override public ExercisesBean getItem(int position) &#123; return objects.get(position); &#125; /** * 根据position得到对应Item的对象 */ @Override public long getItemId(int position) &#123; return position; &#125; /** * 得到相应position对应的Item视图，position是当前Item的位置 * convertView参数就是滚出屏幕的Item的View * 第一次进入或滑动屏幕时候被调用 */ @Override public View getView(int position, View convertView, ViewGroup parent) &#123; if (convertView == null) &#123; convertView = layoutInflater.inflate(R.layout.exercises_list_item, null); convertView.setTag(new ViewHolder(convertView)); &#125; initializeViews((ExercisesBean) getItem(position), (ViewHolder) convertView.getTag(), position, convertView); return convertView; &#125; private void initializeViews(ExercisesBean object, ViewHolder holder, int position, View convertView) &#123; final ExercisesBean bean = getItem(position); if (bean != null) &#123; holder.tvOrder.setText(position + 1 + &quot;&quot;); holder.tvTitle.setText(bean.title); holder.tvOrder.setBackgroundResource(bean.background); convertView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (bean == null) &#123; return; &#125; //跳转到习题界面 &#125; &#125;); &#125; &#125; protected class ViewHolder &#123; private TextView tvOrder; private TextView tvTitle; private TextView tvContent; public ViewHolder(View view) &#123; tvOrder = (TextView) view.findViewById(R.id.tv_order); tvTitle = (TextView) view.findViewById(R.id.tv_title); tvContent = (TextView) view.findViewById(R.id.tv_content); &#125; &#125;&#125; 习题界面逻辑代码写完了适配器，我们来做ListView的第5步,我们回到fragment界面完善习题界面的逻辑代码。ExercisesFragment.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package cn.edu.gdmec.android.boxuegu.fragment;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ListView;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.adapter.ExercisesListItemAdapter;import cn.edu.gdmec.android.boxuegu.bean.ExercisesBean;public class ExercisesFragment extends Fragment &#123; private ListView lvList;//来源fragment_exercises private ExercisesListItemAdapter adapter; //适配器 private List&lt;ExercisesBean&gt; ebl; //列表集合 @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_exercises, null); &#125; @Override public void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); initData(); lvList = view.findViewById(R.id.lv_list); adapter = new ExercisesListItemAdapter(getActivity()); adapter.setData(ebl); lvList.setAdapter(adapter); &#125; private void initData()&#123; ebl = new ArrayList&lt;ExercisesBean&gt;(); for (int i=0;i&lt;10;i++)&#123; ExercisesBean bean = new ExercisesBean(); bean.id=(i+1); switch (i)&#123; case 0: bean.title=&quot;第1章 Android基础入门&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_1); break; case 1: bean.title=&quot;第2章 Android UI开发&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_2); break; case 2: bean.title=&quot;第3章 Activity&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_3); break; case 3: bean.title=&quot;第4章 数据存储&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_4); break; case 4: bean.title=&quot;第5章 SQLite数据库&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_1); break; case 5: bean.title=&quot;第6章 广播接收者&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_2); break; case 6: bean.title=&quot;第7章 服务&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_3); break; case 7: bean.title=&quot;第8章 内容提供者&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_4); break; case 8: bean.title=&quot;第9章 网络编程&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_1); break; case 9: bean.title=&quot;第10章 高级编程&quot;; bean.content=&quot;共计5题&quot;; bean.background=(R.drawable.exercises_bg_2); break; default: break; &#125; ebl.add(bean); &#125; &#125;&#125; 习题详情习题详情界面习题界面我们用ListView，习题详情我们来用一下RecyclerView。新建一个布局文件，命名为activity_exercises_detail.xml activity_exercises_detail.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--标题栏--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginTop=&quot;15dp&quot; android:text=&quot;选择题&quot; android:gravity=&quot;center&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16sp&quot; android:textStyle=&quot;bold&quot;/&gt; &lt;!--android:visibility=&quot;gone&quot;--&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/rv_list&quot; /&gt; &lt;!--&lt;ListView android:id=&quot;@+id/lv_list&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:divider=&quot;@null&quot;/&gt;--&gt; &lt;TextView android:id=&quot;@+id/tv_di&quot; android:text=&quot;第一页&quot; android:gravity=&quot;center&quot; android:textSize=&quot;20sp&quot; android:textColor=&quot;@android:color/black&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; 注意：很多同学的项目可能会出现找不到v7.widget.RecyclerView的情况。具体解决办法参考：https://blog.csdn.net/u011150924/article/details/52298445顺便截一下我自己的build.gradle(Moudle:app)的图给大家做参考 导入完成后，我们来给recyclerView写个item，没错，和ListView很相似。新建一个布局文件，命名为exercises_detail_list_item.xml exercises_detail_list_item.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--练习题目布局--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;vertical&quot; android:padding=&quot;15dp&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_subject&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:lineSpacingMultiplier=&quot;1.5&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;15dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_a&quot; android:layout_width=&quot;35dp&quot; android:layout_height=&quot;35dp&quot; android:src=&quot;@drawable/exercises_a&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_a&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;8dp&quot; android:lineSpacingMultiplier=&quot;1.5&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;15dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_b&quot; android:layout_width=&quot;35dp&quot; android:layout_height=&quot;35dp&quot; android:src=&quot;@drawable/exercises_b&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_b&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;8dp&quot; android:lineSpacingMultiplier=&quot;1.5&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;15dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_c&quot; android:layout_width=&quot;35dp&quot; android:layout_height=&quot;35dp&quot; android:src=&quot;@drawable/exercises_c&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_c&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;8dp&quot; android:lineSpacingMultiplier=&quot;1.5&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;15dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_d&quot; android:layout_width=&quot;35dp&quot; android:layout_height=&quot;35dp&quot; android:src=&quot;@drawable/exercises_d&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_d&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;8dp&quot; android:lineSpacingMultiplier=&quot;1.5&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 习题数据写完了item的布局，先别急着写适配器，我们下来解决题目数据的读取。创建一个文件夹assets，把项目资源中的XML文件都放进去。 我们需要一个XML数据解析方法来解析这些文件。到AnalysisUtils.java中添加一个getExercisesInfos（）方法。AnalysisUtils.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static List&lt;ExercisesBean&gt; getExercisesInfos(InputStream is) throws Exception&#123; XmlPullParser parser = Xml.newPullParser(); parser.setInput(is,&quot;utf-8&quot;); List&lt;ExercisesBean&gt; exercisesInfos=null; ExercisesBean exercisesInfo=null; int type = parser.getEventType(); while (type!=XmlPullParser.END_DOCUMENT)&#123; switch (type)&#123; case XmlPullParser.START_TAG: if (&quot;infos&quot;.equals(parser.getName()))&#123; exercisesInfos=new ArrayList&lt;ExercisesBean&gt;(); &#125;else if (&quot;exercises&quot;.equals(parser.getName()))&#123; exercisesInfo=new ExercisesBean(); String ids=parser.getAttributeValue(0); exercisesInfo.subjectId = Integer.parseInt(ids); &#125;else if (&quot;subject&quot;.equals(parser.getName()))&#123; String subject=parser.nextText(); exercisesInfo.subject = subject; &#125;else if (&quot;a&quot;.equals(parser.getName()))&#123; String a=parser.nextText(); exercisesInfo.a = a; &#125;else if (&quot;b&quot;.equals(parser.getName()))&#123; String b=parser.nextText(); exercisesInfo.b = b; &#125;else if (&quot;c&quot;.equals(parser.getName()))&#123; String c=parser.nextText(); exercisesInfo.c = c; &#125;else if (&quot;d&quot;.equals(parser.getName()))&#123; String d=parser.nextText(); exercisesInfo.d = d; &#125;else if (&quot;answer&quot;.equals(parser.getName()))&#123; String answer=parser.nextText(); exercisesInfo.answer = Integer.parseInt(answer); &#125; break; case XmlPullParser.END_TAG: if (&quot;exercises&quot;.equals(parser.getName()))&#123; exercisesInfos.add(exercisesInfo); exercisesInfo=null; &#125; break; &#125; type=parser.next(); &#125; return exercisesInfos;&#125; 再添加一个setABCDEnable（）方法。AnalysisUtils.java static void setABCDEnable(boolean value, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d)&#123;12345 iv_a.setEnabled(value); iv_b.setEnabled(value); iv_c.setEnabled(value); iv_d.setEnabled(value);&#125; 习题详情界面adapter习题详情界面的适配器不再继承BaseAdapter了，改为继承RecyclerView的RecyclerView.Adapter&lt;&gt;,里面填上自己的ViewHolder，下面是适配器的代码，大家可以观察一下跟ListView的适配器有哪些不同。还是从item界面用插件生成adapter，但是Code generator 生成的只有继承BaseAdapter的文件，所以需要一些修改。ExercisesDetailListItemAdapter.java 写到这里，注意了！你会发现会红，那是因为你没有添加依赖！ 1implementation &apos;com.android.support:recyclerview-v7:26.1.0&apos; 创建ExercisesDetailListItemAdapter.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269package cn.edu.gdmec.android.boxuegu.adapter;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TextView;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.bean.ExercisesBean;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;public class ExercisesDetailListItemAdapter extends RecyclerView.Adapter&lt;ExercisesDetailListItemAdapter.ViewHolder&gt; &#123; private List&lt;ExercisesBean&gt; objects = new ArrayList&lt;ExercisesBean&gt;(); private ArrayList&lt;String&gt; selectedPosition = new ArrayList&lt;String&gt;(); private Context context; private LayoutInflater layoutInflater; private OnSelectListener onSelectListener; public ExercisesDetailListItemAdapter(Context context, OnSelectListener onSelectListener) &#123; this.context = context; this.onSelectListener = onSelectListener; this.layoutInflater = LayoutInflater.from(context); &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View view = inflater.inflate(R.layout.exercises_detail_list_item, parent, false); return new ViewHolder(view); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; initializeViews(objects.get(position), holder, position); &#125; public void setData(List&lt;ExercisesBean&gt; objects) &#123; this.objects = objects; &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public int getItemCount() &#123; return objects.size(); &#125; private void initializeViews(ExercisesBean object, final ViewHolder holder, final int position) &#123; ExercisesBean bean = object; if (bean != null) &#123; holder.tvSubject.setText(bean.subject); holder.tvA.setText(bean.a); holder.tvB.setText(bean.b); holder.tvC.setText(bean.c); holder.tvD.setText(bean.d); &#125; if (!selectedPosition.contains(&quot;&quot; + position)) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); AnalysisUtils.setABCDEnable(true, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; else &#123; AnalysisUtils.setABCDEnable(false, holder.ivA, holder.ivB, holder.ivC, holder.ivD); switch (bean.select) &#123; case 0: if (bean.answer == 1) &#123; holder.ivA.setImageResource(R.drawable.exercises_right_icon); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 2) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_right_icon); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 3) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_right_icon); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 4) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_right_icon); &#125; break; case 1: holder.ivA.setImageResource(R.drawable.exercises_error_icon); if (bean.answer == 2) &#123; holder.ivB.setImageResource(R.drawable.exercises_right_icon); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 3) &#123; holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_right_icon); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 4) &#123; holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_right_icon); &#125; break; case 2: holder.ivB.setImageResource(R.drawable.exercises_error_icon); if (bean.answer == 1) &#123; holder.ivA.setImageResource(R.drawable.exercises_right_icon); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 3) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivC.setImageResource(R.drawable.exercises_right_icon); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 4) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivC.setImageResource(R.drawable.exercises_c); holder.ivD.setImageResource(R.drawable.exercises_right_icon); &#125; break; case 3: holder.ivC.setImageResource(R.drawable.exercises_error_icon); if (bean.answer == 1) &#123; holder.ivA.setImageResource(R.drawable.exercises_right_icon); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 2) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_right_icon); holder.ivD.setImageResource(R.drawable.exercises_d); &#125; else if (bean.answer == 4) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivD.setImageResource(R.drawable.exercises_right_icon); &#125; break; case 4: holder.ivD.setImageResource(R.drawable.exercises_error_icon); if (bean.answer == 1) &#123; holder.ivA.setImageResource(R.drawable.exercises_right_icon); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_c); &#125; else if (bean.answer == 2) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_right_icon); holder.ivC.setImageResource(R.drawable.exercises_c); &#125; else if (bean.answer == 3) &#123; holder.ivA.setImageResource(R.drawable.exercises_a); holder.ivB.setImageResource(R.drawable.exercises_b); holder.ivC.setImageResource(R.drawable.exercises_right_icon); &#125; break; &#125; &#125; holder.ivA.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (selectedPosition.contains(&quot;&quot; + position)) &#123; selectedPosition.remove(&quot;&quot; + position); &#125; else &#123; selectedPosition.add(position + &quot;&quot;); &#125; onSelectListener.onSelectA(position, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; &#125;); holder.ivB.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (selectedPosition.contains(&quot;&quot; + position)) &#123; selectedPosition.remove(&quot;&quot; + position); &#125; else &#123; selectedPosition.add(position + &quot;&quot;); &#125; onSelectListener.onSelectB(position, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; &#125;); holder.ivC.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (selectedPosition.contains(&quot;&quot; + position)) &#123; selectedPosition.remove(&quot;&quot; + position); &#125; else &#123; selectedPosition.add(position + &quot;&quot;); &#125; onSelectListener.onSelectC(position, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; &#125;); holder.ivD.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (selectedPosition.contains(&quot;&quot; + position)) &#123; selectedPosition.remove(&quot;&quot; + position); &#125; else &#123; selectedPosition.add(position + &quot;&quot;); &#125; onSelectListener.onSelectD(position, holder.ivA, holder.ivB, holder.ivC, holder.ivD); &#125; &#125;); &#125; protected class ViewHolder extends RecyclerView.ViewHolder &#123; private TextView tvSubject; private ImageView ivA; private TextView tvA; private ImageView ivB; private TextView tvB; private ImageView ivC; private TextView tvC; private ImageView ivD; private TextView tvD; public ViewHolder(View view) &#123; super(view); tvSubject = (TextView) view.findViewById(R.id.tv_subject); ivA = (ImageView) view.findViewById(R.id.iv_a); tvA = (TextView) view.findViewById(R.id.tv_a); ivB = (ImageView) view.findViewById(R.id.iv_b); tvB = (TextView) view.findViewById(R.id.tv_b); ivC = (ImageView) view.findViewById(R.id.iv_c); tvC = (TextView) view.findViewById(R.id.tv_c); ivD = (ImageView) view.findViewById(R.id.iv_d); tvD = (TextView) view.findViewById(R.id.tv_d); &#125; &#125; public interface OnSelectListener &#123; void onSelectA(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d); void onSelectB(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d); void onSelectC(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d); void onSelectD(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d); &#125;&#125; 添加依赖后进入build.gradle(Module.app)进行修改,注意进行理解，模仿！ 123456789dependencies &#123; implementation fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos; implementation &apos;com.android.support:recyclerview-v7:26.1.0&apos;&#125; 习题详情逻辑代码为了体现出RecyclerView的异同，我将习题详情显示改为横向显示。 创建ExercisesDetailActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190package cn.edu.gdmec.android.boxuegu.activity;import android.app.Activity;import android.graphics.Color;import android.os.Bundle;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.view.View;import android.widget.ImageView;import android.widget.RelativeLayout;import android.widget.TextView;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.adapter.ExercisesDetailListItemAdapter;import cn.edu.gdmec.android.boxuegu.bean.ExercisesBean;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;public class ExercisesDetailActivity extends Activity &#123; private TextView tv_back; private TextView tv_main_title; private RelativeLayout title_bar; private int id; private String title; private RecyclerView rv_list; private List&lt;ExercisesBean&gt; ebl; private ExercisesDetailListItemAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_exercises_detail); id = getIntent().getIntExtra(&quot;id&quot;,0); title = getIntent().getStringExtra(&quot;title&quot;); ebl = new ArrayList&lt;ExercisesBean&gt;(); initData(); initView(); &#125; private void initData() &#123; //从xml文件中获取习题数据 try &#123; InputStream is = getResources().getAssets().open(&quot;chapter&quot; + id + &quot;.xml&quot;); ebl = AnalysisUtils.getExercisesInfos(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; private void initView() &#123; tv_back = findViewById(R.id.tv_back); tv_main_title = findViewById(R.id.tv_main_title); tv_main_title.setText(title); title_bar = findViewById(R.id.title_bar); title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); // rv_list = findViewById(R.id.rv_list); rv_list.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)); tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ExercisesDetailActivity.this.finish(); &#125; &#125;); adapter = new ExercisesDetailListItemAdapter(ExercisesDetailActivity.this, new ExercisesDetailListItemAdapter.OnSelectListener() &#123; @Override public void onSelectA(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d) &#123; //判断如果答案不是1即A选项 if (ebl.get(position).answer != 1) &#123; ebl.get(position).select = 1; &#125; else &#123; ebl.get(position).select = 0; &#125; switch (ebl.get(position).answer) &#123; case 1: iv_a.setImageResource(R.drawable.exercises_right_icon); break; case 2: iv_a.setImageResource(R.drawable.exercises_error_icon); iv_b.setImageResource(R.drawable.exercises_right_icon); break; case 3: iv_a.setImageResource(R.drawable.exercises_error_icon); iv_c.setImageResource(R.drawable.exercises_right_icon); break; case 4: iv_a.setImageResource(R.drawable.exercises_error_icon); iv_d.setImageResource(R.drawable.exercises_right_icon); break; &#125; AnalysisUtils.setABCDEnable(false, iv_a, iv_b, iv_c, iv_d); &#125; @Override public void onSelectB(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d) &#123; //判断如果答案不是2即B选项 if (ebl.get(position).answer != 2) &#123; ebl.get(position).select = 2; &#125; else &#123; ebl.get(position).select = 0; &#125; switch (ebl.get(position).answer) &#123; case 1: iv_a.setImageResource(R.drawable.exercises_right_icon); iv_b.setImageResource(R.drawable.exercises_error_icon); break; case 2: iv_b.setImageResource(R.drawable.exercises_right_icon); break; case 3: iv_b.setImageResource(R.drawable.exercises_error_icon); iv_c.setImageResource(R.drawable.exercises_right_icon); break; case 4: iv_b.setImageResource(R.drawable.exercises_error_icon); iv_d.setImageResource(R.drawable.exercises_right_icon); break; &#125; AnalysisUtils.setABCDEnable(false, iv_a, iv_b, iv_c, iv_d); &#125; @Override public void onSelectC(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d) &#123; //判断如果答案不是3即C选项 if (ebl.get(position).answer != 3) &#123; ebl.get(position).select = 3; &#125; else &#123; ebl.get(position).select = 0; &#125; switch (ebl.get(position).answer) &#123; case 1: iv_a.setImageResource(R.drawable.exercises_right_icon); iv_c.setImageResource(R.drawable.exercises_error_icon); break; case 2: iv_b.setImageResource(R.drawable.exercises_right_icon); iv_c.setImageResource(R.drawable.exercises_error_icon); break; case 3: iv_c.setImageResource(R.drawable.exercises_right_icon); break; case 4: iv_c.setImageResource(R.drawable.exercises_error_icon); iv_d.setImageResource(R.drawable.exercises_right_icon); break; &#125; AnalysisUtils.setABCDEnable(false, iv_a, iv_b, iv_c, iv_d); &#125; @Override public void onSelectD(int position, ImageView iv_a, ImageView iv_b, ImageView iv_c, ImageView iv_d) &#123; //判断如果答案不是4即D选项 if (ebl.get(position).answer != 4) &#123; ebl.get(position).select = 4; &#125; else &#123; ebl.get(position).select = 0; &#125; switch (ebl.get(position).answer) &#123; case 1: iv_a.setImageResource(R.drawable.exercises_right_icon); iv_d.setImageResource(R.drawable.exercises_error_icon); break; case 2: iv_d.setImageResource(R.drawable.exercises_error_icon); iv_b.setImageResource(R.drawable.exercises_right_icon); break; case 3: iv_d.setImageResource(R.drawable.exercises_error_icon); iv_c.setImageResource(R.drawable.exercises_right_icon); break; case 4: iv_d.setImageResource(R.drawable.exercises_right_icon); break; &#125; AnalysisUtils.setABCDEnable(false, iv_a, iv_b, iv_c, iv_d); &#125; &#125;); adapter.setData(ebl); rv_list.setAdapter(adapter); &#125;&#125; 然后到ExercisesListItemAdapter.java中添加跳转页面的代码ExercisesListItemAdapter.java 12345//跳转到习题界面 Intent intent = new Intent(context, ExercisesDetailActivity.class); intent.putExtra(&quot;id&quot;, bean.id); intent.putExtra(&quot;title&quot;, bean.title); ((Activity) context).startActivityForResult(intent, 000); 到AndroidManifest.xml中声明ExercisesDetailActivity12345678910&lt;!--添加实现类--&gt; &lt;activity android:name=&quot;.activity.MainActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.LoginActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.RegisterActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.SettingActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.ModifyPswActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.FindPswActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.UserInfoActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.ChangeUserInfoActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.ExercisesDetailActivity&quot;&gt;&lt;/activity&gt; 如果有人有一些frgement刷新的小BUG 由于任务实施里需要用到回调，我们这里就先用startActivityForResult跳转（为了解决frgement刷新的小BUG）。也顺便给大家演示如何再adapter里使用startActivityForResult（）。再到MainActivity里添加回调方法。MainActivity.java12345678910111213141516@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (data!=null)&#123; boolean isLogin=data.getBooleanExtra(&quot;isLogin&quot;,false); if (isLogin)&#123; setSelectStatus(0); &#125; else &#123; setSelectStatus(2); &#125; &#125; if (requestCode == 000) &#123; setSelectStatus(1); &#125;&#125; 完成！可以运行了。 看看这次包结构的变化 任务实施判断题数点击完选项之后，底部的文本控件要变换刚刚点击的题目的题号。注意：在里面用到adapter与Activity的信息回调，具体过程参考https://blog.csdn.net/dl10210950/article/details/52918019 保存答题状态当5道题都回答过一遍后，点击返回习题界面，习题下的文本标签要变成“已完成”。 总结进步了哦~]]></content>
      <categories>
        <category>教育系统APP</category>
      </categories>
      <tags>
        <tag>教育系统APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育系统APP(五)]]></title>
    <url>%2F2018%2F04%2F25%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 回顾上一期任务任务实施修复fragment的小BUG在未登录状态下，点击“点击登陆”，登陆完成后，应该显示“我”的界面，并且正常显示用户名。 在登陆状态下，点击“设置”-&gt;点击退出登录，应该继续显示“我”的界面，并且正常显示用户名。 修改密保设置页面密保设置页面的按钮显示的是“验证”，这里应该是“设置”比较合理。把按钮上的文字改成“设置”，要求修改密码界面按钮依然是“验证”。 优化找回密码登陆界面的找回密码功能用的是初始化密码，要求改成设置新密码。注意：显示设置新密码框时，按钮的文字也要变化哦！ 教育系统APP(五)的发布 看看包包的结构，图片的包就不看了，蓝色为修改，绿色为新添加 先解决上一次的问题在未登录状态下，点击“点击登陆”，登陆完成后，应该显示“我”的界面，并且正常显示用户名。在登陆状态下，点击“设置”-&gt;点击退出登录，应该继续显示“我”的界面，并且正常显示用户名。解决这个问题，当我们登录后要保持刷新，以及fragment的刷新。 效果： MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163package cn.edu.gdmec.android.boxuegu.activity;import android.content.Intent;import android.content.pm.ActivityInfo;import android.graphics.Color;import android.os.Bundle;import android.support.v4.app.FragmentActivity;import android.view.KeyEvent;import android.view.View;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.fragment.CourseFragment;import cn.edu.gdmec.android.boxuegu.fragment.ExercisesFragment;import cn.edu.gdmec.android.boxuegu.fragment.MyinfoFragment;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;/*任务在主界面的Hello World位置显示：用户名+“登录成功”*/public class MainActivity extends FragmentActivity implements View.OnClickListener&#123; private TextView tv_main_title;//标题 private TextView tv_back;//返回按钮 private RelativeLayout title_bar; private RelativeLayout main_body; private TextView bottom_bar_text_course; private ImageView bottom_bar_image_course; private RelativeLayout bottom_bar_course_btn; private TextView bottom_bar_text_exercises; private ImageView bottom_bar_image_exercises; private RelativeLayout bottom_bar_exercises_btn; private TextView bottom_bar_text_myinfo; private ImageView bottom_bar_image_myinfo; private RelativeLayout bottom_bar_myinfo_btn; private LinearLayout main_bottom_bar; protected long exitTime; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setMain(); &#125; //给MainActivity加上退出清除登陆状态的方法。 // 连续点击返回两次则退出，两次点击间隔超过2秒则提示再按一次退出。 @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123; if ((System.currentTimeMillis() - exitTime) &gt; 2000) &#123; Toast.makeText(MainActivity.this, &quot;再按一次退出博学谷&quot;, Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); &#125; else &#123; this.finish(); if (AnalysisUtils.readLoginStatus(this)) &#123; AnalysisUtils.cleanLoginStatus(this); &#125; System.exit(0); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125; private void setMain() &#123; this.getSupportFragmentManager().beginTransaction().add(R.id.main_body,new MyinfoFragment()).commit(); setSelectStatus(2); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (data!=null)&#123; boolean isLogin=data.getBooleanExtra(&quot;isLogin&quot;,false); if (isLogin)&#123; setSelectStatus(0); &#125; else &#123; setSelectStatus(2); &#125; &#125; &#125; private void setSelectStatus(int index) &#123; switch (index)&#123; case 0: bottom_bar_image_course.setImageResource(R.drawable.main_course_icon_selected); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon); bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon); getSupportFragmentManager().beginTransaction().replace(R.id.main_body,new CourseFragment()).commit(); tv_main_title.setText(&quot;博学谷课程&quot;); break; case 1: bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon_selected); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_course.setImageResource(R.drawable.main_course_icon); bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon); getSupportFragmentManager().beginTransaction().replace(R.id.main_body,new ExercisesFragment()).commit(); tv_main_title.setText(&quot;博学谷习题&quot;); break; case 2: bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon_selected); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon); bottom_bar_image_course.setImageResource(R.drawable.main_course_icon); getSupportFragmentManager().beginTransaction().replace(R.id.main_body,new MyinfoFragment()).commit(); tv_main_title.setText(&quot;博学谷&quot;); break; &#125; &#125; private void initView() &#123; tv_main_title=findViewById(R.id.tv_main_title); title_bar=findViewById(R.id.title_bar); //底部导航栏 main_body = findViewById(R.id.main_body); bottom_bar_text_course = findViewById(R.id.bottom_bar_text_course); bottom_bar_image_course = findViewById(R.id.bottom_bar_image_course); bottom_bar_course_btn = findViewById(R.id.bottom_bar_course_btn); bottom_bar_text_exercises = findViewById(R.id.bottom_bar_text_exercises); bottom_bar_image_exercises = findViewById(R.id.bottom_bar_image_exercises); bottom_bar_exercises_btn = findViewById(R.id.bottom_bar_exercises_btn); bottom_bar_text_myinfo = findViewById(R.id.bottom_bar_text_myinfo); bottom_bar_image_myinfo = findViewById(R.id.bottom_bar_image_myinfo); bottom_bar_myinfo_btn = findViewById(R.id.bottom_bar_myinfo_btn); main_bottom_bar = findViewById(R.id.main_bottom_bar); bottom_bar_course_btn.setOnClickListener(this); bottom_bar_exercises_btn.setOnClickListener(this); bottom_bar_myinfo_btn.setOnClickListener(this); tv_main_title.setText(&quot;博学谷课程&quot;); title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bottom_bar_course_btn: //getSupportFragmentManager().beginTransaction().add(R.id.main_body,new CourseFragment()).commit(); setSelectStatus(0); break; case R.id.bottom_bar_exercises_btn: //getSupportFragmentManager().beginTransaction().add(R.id.main_body,new ExercisesFragment()).commit(); setSelectStatus(1); break; case R.id.bottom_bar_myinfo_btn: //getSupportFragmentManager().beginTransaction().add(R.id.main_body,new MyinfoFragment()).commit(); setSelectStatus(2); break; &#125; &#125;&#125; 修改密保设置页面 密保设置页面的按钮显示的是“验证”，这里应该是“设置”比较合理。把按钮上的文字改成“设置”，要求修改密码界面按钮依然是“验证”，这个已经解决。 优化找回密码解决找回密码功能用的是初始化密码，要求改成设置新密码。注意：显示设置新密码框时，按钮的文字也要变化哦！ 原来的效果： 更改后的效果： 这个是找回密码，那么就要在找回密码的布局进行添加。不过很高兴的是之前这个布局好像添加好了，不过要改一下个别几个。 activity_find_psw.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--找回密码--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--找回密码需要设置标题栏--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_user_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;35dp&quot; android:text=&quot;您的用户名是？&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:visibility=&quot;gone&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_user_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;@drawable/find_psw_icon&quot; android:hint=&quot;请输入您的用户名&quot; android:inputType=&quot;text&quot; android:paddingLeft=&quot;8dp&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#A3A3A3&quot; android:visibility=&quot;gone&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;15dp&quot; android:text=&quot;您的姓名是？&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_validate_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;@drawable/find_psw_icon&quot; android:hint=&quot;请输入要验证的姓名&quot; android:inputType=&quot;text&quot; android:paddingLeft=&quot;8dp&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#A3A3A3&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_reset_psw&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;15dp&quot; android:text=&quot;输入您的新密码&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:visibility=&quot;gone&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_reset_psw&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;@drawable/login_psw_bg&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:hint=&quot;请输入要设置的新密码&quot; android:inputType=&quot;textPassword&quot; android:paddingLeft=&quot;8dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;18sp&quot; android:visibility=&quot;gone&quot;/&gt; &lt;Button android:id=&quot;@+id/btn_validate&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;@drawable/register_selector&quot; android:text=&quot;验 证&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; /&gt;&lt;/LinearLayout&gt; 接下来修改功能类：FindPswActivity.java在打之前会发现有些是写过实例的，但是之前却没有显示出来，如果够细心的你，会发现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package cn.edu.gdmec.android.boxuegu.activity;import android.app.Activity;import android.content.SharedPreferences;import android.os.Bundle;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;import cn.edu.gdmec.android.boxuegu.utils.MD5Utils;public class FindPswActivity extends Activity implements View.OnClickListener &#123; private TextView tv_back; private TextView tv_main_title; private RelativeLayout title_bar; private TextView tv_user_name; private EditText et_user_name; private EditText et_validate_name; private TextView tv_reset_psw; private TextView et_reset_psw; private Button btn_validate; private String from; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_find_psw); from=getIntent().getStringExtra(&quot;from&quot;); initView(); &#125; private void initView() &#123; tv_back=findViewById(R.id.tv_back); tv_main_title=findViewById(R.id.tv_main_title); title_bar=findViewById(R.id.title_bar); tv_user_name=findViewById(R.id.tv_user_name); et_user_name=findViewById(R.id.et_user_name); et_validate_name=findViewById(R.id.et_validate_name); tv_reset_psw=findViewById(R.id.tv_reset_psw); et_reset_psw=findViewById(R.id.et_reset_psw); btn_validate=findViewById(R.id.btn_validate); if (&quot;security&quot;.equals(from))&#123; tv_main_title.setText(&quot;设置密保&quot;); &#125;else&#123; tv_main_title.setText(&quot;找回密码&quot;); tv_user_name.setVisibility(View.VISIBLE); et_user_name.setVisibility(View.VISIBLE); &#125; tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; FindPswActivity.this.finish(); &#125; &#125;); btn_validate.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.btn_validate: submit(); break; &#125; &#125; private void submit() &#123; // validate String validateName = et_validate_name.getText().toString().trim(); if (&quot;security&quot;.equals(from)) &#123; //设置密保 if (TextUtils.isEmpty(validateName)) &#123; Toast.makeText(this, &quot;请输入要验证的姓名&quot;, Toast.LENGTH_SHORT).show(); return; &#125; else &#123; Toast.makeText(this, &quot;密保设置成功&quot;, Toast.LENGTH_SHORT).show(); //保存到 saveSecurity(validateName); FindPswActivity.this.finish(); return; &#125; &#125;else &#123; final String name=et_user_name.getText().toString().trim(); String sp_security=readSecurity(name); if (TextUtils.isEmpty(name))&#123; Toast.makeText(this,&quot;请输入您的用户名&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (!isExistUserName(name))&#123; Toast.makeText(this,&quot;您输入的用户名不存在&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (TextUtils.isEmpty(validateName))&#123; Toast.makeText(this,&quot;请输入要验证的姓名&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (!validateName.equals(sp_security))&#123; Toast.makeText(this,&quot;输入的密保不正确&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else &#123; /*tv_reset_psw.setVisibility(View.VISIBLE); tv_reset_psw.setText(&quot;初始密码：123456&quot;); savePsw(name);*/ //输入密保正确，重新给用户设置一个密码 tv_reset_psw.setVisibility(View.VISIBLE); et_reset_psw.setVisibility(View.VISIBLE); btn_validate.setText(&quot;设置&quot;); btn_validate.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String resetPsw = et_reset_psw.getText().toString().trim(); //暂时仅验证不为空 if (!TextUtils.isEmpty(resetPsw)) &#123; savePsw(name, resetPsw); FindPswActivity.this.finish(); &#125; else &#123; Toast.makeText(FindPswActivity.this, &quot;请输入要设置的新密码&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125; &#125; &#125; /** * 保存初始化密码 **/ private void savePsw(String name, String resetPsw)&#123; /*String md5Psw= MD5Utils.md5(&quot;123456&quot;); SharedPreferences sharedPreferences = getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putString(name,md5Psw); editor.commit();*/ String md5Psw = MD5Utils.md5(resetPsw); SharedPreferences sp = getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.putString(name, md5Psw); editor.commit(); &#125; private boolean isExistUserName(String name)&#123; boolean hasUserName=false; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); String spPsw=sharedPreferences.getString(name,&quot;&quot;); if (!TextUtils.isEmpty(spPsw))&#123; hasUserName=true; &#125; return hasUserName; &#125; /** * 读取密保 **/ private String readSecurity(String name)&#123; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); String security=sharedPreferences.getString(name+&quot;_security&quot;,&quot;&quot;); return security; &#125; /** * 保存密保名字 **/ private void saveSecurity(String validateName) &#123; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); SharedPreferences.Editor editor=sharedPreferences.edit(); editor.putString(AnalysisUtils.readLoginUserName(this)+&quot;_security&quot;,validateName); editor.commit(); &#125;&#125; 搞定之前的项目了。最后看看此时包的结构，蓝色为修改，绿色为新添加 个人资料模块-新任务(这次的比较容易)学习目标项目实操个人资料界面，布局，用户信息表个人资料界面逻辑代码 个人资料修改，个人资料修改界面，个人资料修改界面逻辑代码 任务实施个人资料加上QQ号属性 学习目标掌握SQLite数据库的使用，能够实现使用数据库保存用户信息。掌握个人资料界面的创建，并能实现个人资料的修改。 个人资料模块主要用于展示用户的基本信息，同时用户可以队个人资料中的昵称，性别和签名进行修改。本章将针对个人资料模块进行详细讲解。 项目实操个人资料界面布局创建一个新的布局文件，命名为activity_user_info。QQ号属性也写上去，进行显示，但是任务要求保存功能效果。 activity_user_info.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--标题栏--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_head&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;60dp&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:text=&quot;头 像&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;ImageView android:id=&quot;@+id/iv_head_icon&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:src=&quot;@drawable/default_icon&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E4E4E4&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_account&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;60dp&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:text=&quot;用户名&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_user_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;5dp&quot; android:text=&quot;用户名&quot; android:textColor=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E4E4E4&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_nickName&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;60dp&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:text=&quot;昵 称&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_nick_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;5dp&quot; android:text=&quot;昵称&quot; android:textColor=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E4E4E4&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_sex&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;60dp&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:text=&quot;性 别&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_sex&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;5dp&quot; android:singleLine=&quot;true&quot; android:text=&quot;男&quot; android:textColor=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E4E4E4&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_signature&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;60dp&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:text=&quot;签 名&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_signature&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;5dp&quot; android:textColor=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;!--android:text=&quot;你们好&quot;--&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E4E4E4&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_qq&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;60dp&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:text=&quot;Q Q&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_qq&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;5dp&quot; android:singleLine=&quot;true&quot; android:text=&quot;未添加&quot; android:textColor=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E4E4E4&quot; /&gt;&lt;/LinearLayout&gt; 用户信息表对于各个用户信息，我们需要用一个Bean类来存放这些属性。新建一个包，命名为Bean。 在bean包下创建一个Java类，命名为UserBean。写上需要用到的属性。 UserBean.java12345678package cn.edu.gdmec.android.boxuegu.bean;public class UserBean &#123; public String userName;//用户名 public String nickName;//昵称 public String sex;//性别 public String signature;//签名&#125; 接下来是数据库类。新建一个Sqlite包。在Sqlite包中建一个Java类，命名为SQLiteHelper。SQLiteHelper.java1234567891011121314151617181920212223242526272829303132333435363738package cn.edu.gdmec.android.boxuegu.sqlite;import android.content.Context;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;public class SQLiteHelper extends SQLiteOpenHelper &#123; private static final int DB_VERSION = 1; public static String DB_NAME = &quot;bxg.db&quot;; public static final String U_USER_INFO = &quot;userInfo&quot;; public SQLiteHelper(Context context)&#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; /** * 当这个SQLiteOpenHelper的子类类被实例化时会创建指定名的数据库，在onCreate中创建个人信息表 * **/ db.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + U_USER_INFO + &quot;( &quot; + &quot;_id INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + &quot;userName VARCHAR, &quot; + &quot;nickName VARCHAR, &quot; + &quot;sex VARCHAR, &quot; + &quot;signature VARCHAR &quot; + &quot;)&quot;); &#125; /** * 当数据库版本号增加才会调用此方法 **/ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + U_USER_INFO); onCreate(db); &#125;&#125; 接下来创建一个数据库工具类，用于读取、保存、修改用户信息。在utils包里建一个Java类，命名为DBUtils。 DBUtils.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package cn.edu.gdmec.android.boxuegu.utils;import android.content.ContentValues;import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import cn.edu.gdmec.android.boxuegu.bean.UserBean;import cn.edu.gdmec.android.boxuegu.sqlite.SQLiteHelper;public class DBUtils &#123; private static DBUtils instance = null; private static SQLiteHelper helper; private static SQLiteDatabase db; /** * 构造方法，只有当类被实例化时候调用 * 实例化SQLiteHelper类，从中得到一个课读写的数据库 **/ public DBUtils(Context context) &#123; helper = new SQLiteHelper(context); db = helper.getWritableDatabase(); &#125; /** * 得到这个类的实例 **/ public static DBUtils getInstance(Context context) &#123; if (instance == null) &#123; instance = new DBUtils(context); &#125; return instance; &#125; /** * 保存个人资料信息 **/ public void saveUserInfo(UserBean bean) &#123; ContentValues cv = new ContentValues(); cv.put(&quot;userName&quot;, bean.userName); cv.put(&quot;nickName&quot;, bean.nickName); cv.put(&quot;sex&quot;, bean.sex); cv.put(&quot;signature&quot;, bean.signature); //Convenience method for inserting a row into the database. //注意，我们是从数据库使用插入方法，传入表名和数据集完成插入 db.insert(SQLiteHelper.U_USER_INFO, null, cv); &#125; /** * 获取个人资料信息 **/ public UserBean getUserInfo(String userName) &#123; String sql = &quot;SELECT * FROM &quot; + SQLiteHelper.U_USER_INFO + &quot; WHERE userName=?&quot;; //?和下面数组内元素会逐个替换，可以多条件查询=?and =? //You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. Cursor cursor = db.rawQuery(sql, new String[]&#123;userName&#125;); UserBean bean = null; //Move the cursor to the next row. while (cursor.moveToNext()) &#123; bean = new UserBean(); //根据列索引获取对应的数值，因为这里查询结果只有一个，我们也不需要对模型UserBean进行修改， //直接将对应用户名的所有数据从表中动态赋值给bean bean.userName = cursor.getString(cursor.getColumnIndex(&quot;userName&quot;)); bean.nickName = cursor.getString(cursor.getColumnIndex(&quot;nickName&quot;)); bean.sex = cursor.getString(cursor.getColumnIndex(&quot;sex&quot;)); bean.signature = cursor.getString(cursor.getColumnIndex(&quot;signature&quot;)); &#125; cursor.close(); return bean; &#125; /** * 修改个人资料信息,这里的key指代表字段，value表示数值 **/ public void updateUserInfo(String key, String value, String userName) &#123; ContentValues cv = new ContentValues(); cv.put(key, value); //Convenience method for updating rows in the database. db.update(SQLiteHelper.U_USER_INFO, cv, &quot;userName=?&quot;, new String[] &#123;userName&#125;); &#125;&#125; 个人资料界面逻辑代码UserInfoActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226package cn.edu.gdmec.android.boxuegu.activity;import android.app.Activity;import android.content.DialogInterface;import android.content.Intent;import android.content.pm.ActivityInfo;import android.graphics.Color;import android.os.Bundle;import android.support.v7.app.AlertDialog;import android.text.TextUtils;import android.view.View;import android.widget.ImageView;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.bean.UserBean;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;import cn.edu.gdmec.android.boxuegu.utils.DBUtils;public class UserInfoActivity extends Activity implements View.OnClickListener&#123; //标题栏 private RelativeLayout title_bar; private TextView tv_back; private TextView tv_main_title; // private RelativeLayout rl_head; private ImageView iv_head_icon; private RelativeLayout rl_account;// private TextView tv_user_name; private RelativeLayout rl_nickName; private TextView tv_nick_name; private RelativeLayout rl_sex; private TextView tv_sex; private RelativeLayout rl_signature; private TextView tv_signature; private RelativeLayout rl_qq; private TextView tv_qq; // private String spUserName; private String new_info; private static final int CHANGE_NICKNAME = 1; private static final int CHANGE_SIGNATURE = 2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_user_info); //设置此界面为竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); spUserName= AnalysisUtils.readLoginUserName(this); initView(); initDate(); &#125; private void initDate() &#123; UserBean bean = null; //实例化DBUtils，同时调用其方法获取个人信息资料 bean = DBUtils.getInstance(this).getUserInfo(spUserName); //如果第一次进入，数据库没有保留用户信息 if (bean == null) &#123; bean = new UserBean(); bean.userName = spUserName; bean.nickName = &quot;问答精灵&quot;; bean.sex = &quot;男&quot;; bean.signature = &quot;这个人很懒，什么都没留下...&quot;; bean.qq= &quot;未添加&quot;; //保存到数据库 DBUtils.getInstance(this).saveUserInfo(bean); &#125; setValue(bean); &#125; private void initView() &#123; //个人资料界面 tv_back = findViewById(R.id.tv_back); tv_main_title = findViewById(R.id.tv_main_title); tv_main_title.setText(&quot;个人资料界面&quot;); title_bar = findViewById(R.id.title_bar); title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); /** * rl_head iv_head_icon * rl_account tv_user_name * rl_nickName tv_nick_name * rl_sex tv_sex * rl_signature tv_signature * rl_qq tv_qq */ rl_head=findViewById(R.id.rl_head); iv_head_icon=findViewById(R.id.iv_head_icon); rl_account=findViewById(R.id.rl_account); tv_user_name=findViewById(R.id.tv_user_name); rl_nickName=findViewById(R.id.rl_nickName); tv_nick_name=findViewById(R.id.tv_nick_name); rl_sex=findViewById(R.id.rl_sex); tv_sex=findViewById(R.id.tv_sex); rl_signature=findViewById(R.id.rl_signature); tv_signature=findViewById(R.id.tv_signature); rl_qq=findViewById(R.id.rl_qq); tv_qq=findViewById(R.id.tv_qq); // tv_back.setOnClickListener(this); rl_head.setOnClickListener(this); rl_account.setOnClickListener(this); rl_nickName.setOnClickListener(this); rl_sex.setOnClickListener(this); rl_signature.setOnClickListener(this); rl_qq.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_back: this.finish(); break; case R.id.rl_nickName: //昵称 String name = tv_nick_name.getText().toString(); Bundle bdName = new Bundle(); bdName.putString(&quot;content&quot;, name); //传递界面上的昵称数据 bdName.putString(&quot;title&quot;, &quot;昵称&quot;); bdName.putInt(&quot;flag&quot;, 1); //ActivityUserInfoActivity的Onclick()里昵称和签名响应加上跳转代码 break; case R.id.rl_sex: String sex = tv_sex.getText().toString(); sexDialog(sex); break; case R.id.rl_signature: //签名 String signature = tv_signature.getText().toString(); Bundle bdSignature = new Bundle(); bdSignature.putString(&quot;content&quot;, signature); //传递界面上的签名数据 bdSignature.putString(&quot;title&quot;, &quot;签名&quot;); bdSignature.putInt(&quot;flag&quot;, 2); //ActivityUserInfoActivity的Onclick()里昵称和签名响应加上跳转代码 break; default: break; &#125; &#125; /** * 为界面空间设置值 **/ private void setValue(UserBean bean) &#123; tv_user_name.setText(bean.userName); tv_nick_name.setText(bean.nickName); tv_sex.setText(bean.sex); tv_signature.setText(bean.signature); tv_qq.setText(bean.qq); &#125; /** * 设置性别弹出框 **/ private void sexDialog(String sex) &#123; int sexFlag = 0; if (&quot;男&quot;.equals(sex)) &#123; sexFlag = 0; &#125; else if (&quot;女&quot;.equals(sex)) &#123; sexFlag = 1; &#125; final String items[] = &#123;&quot;男&quot;, &quot;女&quot;&#125;; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(&quot;性别&quot;); //sexFlag用来区分显示被选中项，如果sexFlag的值和在数组中的索引严格符合，下方which也可用sexFlag代替 builder.setSingleChoiceItems(items, sexFlag, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); Toast.makeText(UserInfoActivity.this, items[which], Toast.LENGTH_SHORT).show(); setSex(items[which]); &#125; &#125;); builder.create().show(); &#125; /** * 更新性别数据 **/ private void setSex(String sex) &#123; tv_sex.setText(sex); //更新数据库字段 DBUtils.getInstance(this).updateUserInfo(&quot;sex&quot;, sex, spUserName); &#125; /** * 其实就是把需要传递的数值放置于bundle中，bundle作为附加到intent中 * 获取回传数据是需要的跳转方法，第三个参数标示跳转是传递的数据 **/ public void enterActivityForResult(Class&lt;?&gt; to, int requestCode, Bundle b) &#123; Intent i = new Intent(this, to); i.putExtras(b); startActivityForResult(i, requestCode); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); switch (requestCode) &#123; case CHANGE_NICKNAME: if (data != null) &#123; new_info = data.getStringExtra(&quot;nickName&quot;); if (TextUtils.isEmpty(new_info)) &#123; return; &#125; tv_nick_name.setText(new_info); //更新数据库中昵称字段 DBUtils.getInstance(UserInfoActivity.this).updateUserInfo(&quot;nickName&quot;, new_info, spUserName); &#125; break; case CHANGE_SIGNATURE: if (data != null) &#123; new_info = data.getStringExtra(&quot;signature&quot;); if (TextUtils.isEmpty(new_info)) &#123; return; &#125; tv_signature.setText(new_info); //更新数据库中签名字段 DBUtils.getInstance(UserInfoActivity.this).updateUserInfo(&quot;signature&quot;, new_info, spUserName); &#125; break; &#125; &#125;&#125; MyinfoFragment.java中，找到跳转到个人资料界面的地方，添加跳转方法。 MyinfoFragment1234567891011121314151617181920212223242526272829303132@Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.ll_head: if (AnalysisUtils.readLoginStatus(getActivity()))&#123; //跳转到个人资料界面 Intent intent=new Intent(getActivity(), UserInfoActivity.class); getActivity().startActivity(intent); &#125;else &#123; //跳转到登录界面 Intent intent = new Intent(getActivity(), LoginActivity.class); getActivity().startActivityForResult(intent,1); &#125; break; case R.id.rl_course_history: if (AnalysisUtils.readLoginStatus(getActivity()))&#123; //跳转到播放记录页面 &#125;else &#123; Toast.makeText(getActivity(),&quot;您未登录，请先登录&quot;,Toast.LENGTH_SHORT).show(); &#125; break; case R.id.rl_setting: if (AnalysisUtils.readLoginStatus(getActivity()))&#123; //跳转到设置界面 Intent intent=new Intent(getActivity(), SettingActivity.class); getActivity().startActivityForResult(intent,1); &#125;else &#123; Toast.makeText(getActivity(),&quot;您未登录，请先登录&quot;,Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125; AndroidManifest.xml中声明ActivityAndroidManifest.xml1&lt;activity android:name=&quot;.activity.UserInfoActivity&quot;&gt;&lt;/activity&gt; 个人资料修改个人资料修改界面修改界面需用到图片info_delete.png 新建布局文件，命名为activity_change_user_infoactivity_change_user_info.xml1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#eeeeee&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/main_title_bar&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;EditText android:id=&quot;@+id/et_content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@android:color/white&quot; android:gravity=&quot;center_vertical&quot; android:singleLine=&quot;true&quot; android:paddingLeft=&quot;10dp&quot; android:textColor=&quot;#737373&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;ImageView android:id=&quot;@+id/iv_delete&quot; android:layout_width=&quot;27dp&quot; android:layout_height=&quot;27dp&quot; android:layout_marginLeft=&quot;-40dp&quot; android:src=&quot;@drawable/info_delete&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 修改完信息后要保存，在标题栏加了个“保存”TextView。到main_title_bar.xml中tv_main_title按钮的下方，加个“保存”。main_title_bar.xml 123456789101112&lt;TextView android:id=&quot;@+id/tv_save&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;30dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;20dp&quot; android:layout_marginTop=&quot;20dp&quot; android:layout_alignParentRight=&quot;true&quot; android:visibility=&quot;gone&quot; android:text=&quot;保存&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;16sp&quot;/&gt; 相信之前也写好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--标题栏与返回键的创建，独立在main_title_bar.xml中--&gt;&lt;!--标题栏设置高度为50dp，宽度为match_parent,设置背景颜色为通明为@android:color/transparent--&gt;&lt;!--RelativeLayout为相对布局--&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/title_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;@android:color/transparent&quot;&gt; &lt;!--设置返回键TextView为高度50dp,宽度为50dp;id为android:id=&quot;@+id/tv_back&quot;--&gt; &lt;!--layout_alignParentLeft为与父控件左对齐--&gt; &lt;!--layout_centerVertical为控件垂直居中--&gt; &lt;!--标题栏界面中的返回键在按下与弹起时，返回键会有明显的区别，这种效果通过背景选择器进行实现--&gt; &lt;TextView android:id=&quot;@+id/tv_back&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:background=&quot;@drawable/go_back_selector&quot;/&gt; &lt;!--设置id为android:id=&quot;@+id/tv_main_title--&gt; &lt;!--该TextView为显示文本--&gt; &lt;!--layout_centerInparent为居中显示--&gt; &lt;TextView android:id=&quot;@+id/tv_main_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; android:layout_centerInParent=&quot;true&quot;/&gt; &lt;!--到main_title_bar.xml中tv_main_title按钮的下方，加个“保存”--&gt; &lt;TextView android:id=&quot;@+id/tv_save&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;30dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;20dp&quot; android:layout_marginTop=&quot;20dp&quot; android:layout_alignParentRight=&quot;true&quot; android:visibility=&quot;gone&quot; android:text=&quot;保存&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;16sp&quot;/&gt;&lt;/RelativeLayout&gt; 个人资料修改界面逻辑代码生成ChangeUserInfoActivity，生成控件实例化代码。 资料修改界面的完整代码：ChangeUserInfoActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package cn.edu.gdmec.android.boxuegu.activity;import android.content.Intent;import android.content.pm.ActivityInfo;import android.graphics.Color;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.text.Editable;import android.text.Selection;import android.text.TextUtils;import android.text.TextWatcher;import android.view.View;import android.widget.EditText;import android.widget.ImageView;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;public class ChangeUserInfoActivity extends AppCompatActivity implements View.OnClickListener&#123; //标题栏 private TextView tv_back; private TextView tv_main_title; private TextView tv_save; private RelativeLayout rl_title_bar; // private EditText et_content; private ImageView iv_delete; private String title, content; private int flag; //flag为1时表示修改昵称，为2时表示修改签名 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_change_user_info); //设置此界面为竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); initView(); &#125; private void initView() &#123; tv_back = (TextView) findViewById(R.id.tv_back); tv_main_title = (TextView) findViewById(R.id.tv_main_title); tv_save = (TextView) findViewById(R.id.tv_save); rl_title_bar = (RelativeLayout) findViewById(R.id.title_bar); et_content = (EditText) findViewById(R.id.et_content); iv_delete = (ImageView) findViewById(R.id.iv_delete); //从个人资料界面传递过来的标题和内容 title = getIntent().getStringExtra(&quot;title&quot;); content = getIntent().getStringExtra(&quot;content&quot;); flag = getIntent().getIntExtra(&quot;flag&quot;, 0); tv_main_title.setText(title); tv_save.setVisibility(View.VISIBLE); rl_title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); tv_back.setOnClickListener(this); iv_delete.setOnClickListener(this); tv_save.setOnClickListener(this); if (!TextUtils.isEmpty(content))&#123; et_content.setText(content); et_content.setSelection(content.length()); &#125; contentListener(); &#125; /** * 监听个人资料修改界面输入的文字 **/ private void contentListener() &#123; et_content.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence charSequence, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; Editable editable = et_content.getText(); int len = editable.length();//输入文本的长度 if (len &gt;= 0) &#123; iv_delete.setVisibility(View.VISIBLE); &#125; else &#123; iv_delete.setVisibility(View.GONE); &#125; switch (flag) &#123; case 1://昵称,最多8个文字，超过则截取多余文字 if (len &gt; 8) &#123; int selEndIndex = Selection.getSelectionEnd(editable); String str = editable.toString(); //截取新字符串 String newStr = str.substring(0, 8); et_content.setText(newStr); editable = et_content.getText(); //新字符串长度 int newLen = editable.length(); //旧光标位置超过新字符串长度 if (selEndIndex &gt; newLen) &#123; selEndIndex = editable.length(); &#125; //设置新光标所在位置 Selection.setSelection(editable, selEndIndex); &#125; break; case 2: //签名，做多16， if (len &gt; 16) &#123; int selEndIndex = Selection.getSelectionEnd(editable); String str = editable.toString(); String newStr = str.substring(0, 16); et_content.setText(newStr); editable = et_content.getText(); int newLen = editable.length(); if (selEndIndex &gt; newLen) &#123; selEndIndex = editable.length(); &#125; Selection.setSelection(editable, selEndIndex); &#125; break; default: break; &#125; &#125; @Override public void afterTextChanged(Editable editable) &#123; &#125; &#125;); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.tv_back: finish(); break; case R.id.iv_delete: et_content.setText(&quot;&quot;); break; case R.id.tv_save: Intent data = new Intent(); String etContent = et_content.getText().toString().trim(); switch (flag) &#123; case 1: if (!TextUtils.isEmpty(etContent)) &#123; data.putExtra(&quot;nickName&quot;, etContent); setResult(RESULT_OK, data); Toast.makeText(this, &quot;保存成功&quot;, Toast.LENGTH_SHORT).show(); ChangeUserInfoActivity.this.finish(); &#125; else &#123; Toast.makeText(this, &quot;昵称不能为空&quot;, Toast.LENGTH_SHORT).show(); &#125; break; case 2: if (!TextUtils.isEmpty(etContent)) &#123; data.putExtra(&quot;signature&quot;, etContent); setResult(RESULT_OK, data); Toast.makeText(this, &quot;保存成功&quot;, Toast.LENGTH_SHORT).show(); ChangeUserInfoActivity.this.finish(); &#125; else &#123; Toast.makeText(this, &quot;签名不能为空&quot;, Toast.LENGTH_SHORT).show(); &#125; break; &#125; &#125; &#125;&#125; UserInfoActivity的Onclick()里昵称和签名响应加上跳转代码 12345678910111213141516171819202122232425262728293031323334@Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.tv_back: this.finish(); break; case R.id.rl_nickName: //昵称 String name = tv_nick_name.getText().toString(); Bundle bdName = new Bundle(); bdName.putString(&quot;content&quot;, name); //传递界面上的昵称数据 bdName.putString(&quot;title&quot;, &quot;昵称&quot;); bdName.putInt(&quot;flag&quot;, 1); //ActivityUserInfoActivity的Onclick()里昵称和签名响应加上跳转代码 enterActivityForResult(ChangeUserInfoActivity.class, CHANGE_NICKNAME, bdName);//跳转到修改界面 break; case R.id.rl_sex: String sex = tv_sex.getText().toString(); sexDialog(sex); break; case R.id.rl_signature: //签名 String signature = tv_signature.getText().toString(); Bundle bdSignature = new Bundle(); bdSignature.putString(&quot;content&quot;, signature); //传递界面上的签名数据 bdSignature.putString(&quot;title&quot;, &quot;签名&quot;); bdSignature.putInt(&quot;flag&quot;, 2); //ActivityUserInfoActivity的Onclick()里昵称和签名响应加上跳转代码 enterActivityForResult(ChangeUserInfoActivity.class, CHANGE_SIGNATURE, bdSignature); break; default: break; &#125; &#125; 再到AndroidManifest.xml中声明activity 1&lt;activity android:name=&quot;.activity.ChangeUserInfoActivity&quot;&gt;&lt;/activity&gt; 这次的包结构 任务实施个人资料加上QQ号属性在个人资料下添加一个“QQ号”属性，初始状态文字显示“未添加”，点击进入修改页面，输入框的键盘类型只能为数字。（提示：editText.setInputType(InputType.TYPE_CLASS_NUMBER) ）输入框最多只能输入12位数字，点击保存后个人资料界面能正常显示保存后的结果。 总结这是走好Android的五步！]]></content>
      <categories>
        <category>教育系统APP</category>
      </categories>
      <tags>
        <tag>教育系统APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育系统APP(四)]]></title>
    <url>%2F2018%2F04%2F24%2F1%2F</url>
    <content type="text"><![CDATA[“我”的模块掌握修改密码功能的开发，实现用户密码的修改掌握设置密保功能的开发，并且通过密保可以找回用户密码 挑战任务初次打开页面都是Fragment_1，请修改相关代码，让初始打开的页面为Fragment_3，别忘了底部导航栏也要变颜色哦 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注 解决方案改MainActivity.java即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package cn.edu.gdmec.android.boxuegu.activity;import android.content.pm.ActivityInfo;import android.graphics.Color;import android.os.Bundle;import android.support.v4.app.FragmentActivity;import android.view.View;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.RelativeLayout;import android.widget.TextView;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.fragment.CourseFragment;import cn.edu.gdmec.android.boxuegu.fragment.ExercisesFragment;import cn.edu.gdmec.android.boxuegu.fragment.MyinfoFragment;/*任务在主界面的Hello World位置显示：用户名+“登录成功”*/public class MainActivity extends FragmentActivity implements View.OnClickListener&#123; private RelativeLayout main_body; private TextView bottom_bar_text_course; private ImageView bottom_bar_image_course; private RelativeLayout bottom_bar_course_btn; private TextView bottom_bar_text_exercises; private ImageView bottom_bar_image_exercises; private RelativeLayout bottom_bar_exercises_btn; private TextView bottom_bar_text_myinfo; private ImageView bottom_bar_image_myinfo; private RelativeLayout bottom_bar_myinfo_btn; private LinearLayout main_bottom_bar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); //把Fragment加到Activity里的代码如下 /* FragmentManager manager = getSupportFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); transaction.add(R.id.main_body,new CourseFragment()).commit();*/ setMain(); &#125; private void setMain() &#123; this.getSupportFragmentManager().beginTransaction().add(R.id.main_body,new MyinfoFragment()).commit(); setSelectStatus(2); &#125; private void setSelectStatus(int index) &#123; switch (index)&#123; case 0: bottom_bar_image_course.setImageResource(R.drawable.main_course_icon_selected); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon); bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon); break; case 1: bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon_selected); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_course.setImageResource(R.drawable.main_course_icon); bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon); break; case 2: bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon_selected); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon); bottom_bar_image_course.setImageResource(R.drawable.main_course_icon); break; &#125; &#125; private void initView() &#123; main_body = findViewById(R.id.main_body); bottom_bar_text_course = findViewById(R.id.bottom_bar_text_course); bottom_bar_image_course = findViewById(R.id.bottom_bar_image_course); bottom_bar_course_btn = findViewById(R.id.bottom_bar_course_btn); bottom_bar_text_exercises = findViewById(R.id.bottom_bar_text_exercises); bottom_bar_image_exercises = findViewById(R.id.bottom_bar_image_exercises); bottom_bar_exercises_btn = findViewById(R.id.bottom_bar_exercises_btn); bottom_bar_text_myinfo = findViewById(R.id.bottom_bar_text_myinfo); bottom_bar_image_myinfo = findViewById(R.id.bottom_bar_image_myinfo); bottom_bar_myinfo_btn = findViewById(R.id.bottom_bar_myinfo_btn); main_bottom_bar = findViewById(R.id.main_bottom_bar); bottom_bar_course_btn.setOnClickListener(this); bottom_bar_exercises_btn.setOnClickListener(this); bottom_bar_myinfo_btn.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bottom_bar_course_btn: getSupportFragmentManager().beginTransaction().add(R.id.main_body,new CourseFragment()).commit(); setSelectStatus(0); break; case R.id.bottom_bar_exercises_btn: getSupportFragmentManager().beginTransaction().add(R.id.main_body,new ExercisesFragment()).commit(); setSelectStatus(1); break; case R.id.bottom_bar_myinfo_btn: getSupportFragmentManager().beginTransaction().add(R.id.main_body,new MyinfoFragment()).commit(); setSelectStatus(2); break; &#125; &#125;&#125; APP（四)博学谷项目“我”的模块 学习目标掌握修改密码功能的开发，实现用户密码的修改；掌握设置密保功能的开发，并且通过密保可以找回用户密码。 项目实操“我”的界面设置修改密码设置密保和找回密码任务实施修复fragment的小BUG修改密保设置页面优化找回密码 “我”的模块主要时以设置用户以及保证用户安全为主。当用户登录成功后，可以修改密码以及设置密保，且只有设置过密保的帐户才可以找回密码。 “我”的界面首先是资源图片，“我”的界面要用到的图片有myinfo_login_bg、course_history_icon、iv_right_arrow、myinfo_setting_icon 老样子，将它们放到drawable下 然后是布局代码，在我们上一次课创的fragment_myinfo里加上代码fragment_myinfo.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/ll_head&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;240dp&quot; android:background=&quot;@drawable/myinfo_login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_head_icon&quot; android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginTop=&quot;75dp&quot; android:src=&quot;@drawable/default_icon&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_user_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginTop=&quot;10dp&quot; android:text=&quot;点击登录&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:layout_marginTop=&quot;20dp&quot; android:background=&quot;#E3E3E3&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_course_history&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:background=&quot;#F7F8F8&quot; android:gravity=&quot;center_vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_course_history_icon&quot; android:layout_width=&quot;20dp&quot; android:layout_height=&quot;20dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;25dp&quot; android:src=&quot;@drawable/course_history_icon&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;25dp&quot; android:layout_toRightOf=&quot;@id/iv_course_history_icon&quot; android:text=&quot;播放记录&quot; android:textColor=&quot;#A3A3A3&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;ImageView android:layout_width=&quot;15dp&quot; android:layout_height=&quot;15dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;25dp&quot; android:src=&quot;@drawable/iv_right_arrow&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E3E3E3&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_setting&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:background=&quot;#F7F8F8&quot; android:gravity=&quot;center_vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_userInfo_icon&quot; android:layout_width=&quot;20dp&quot; android:layout_height=&quot;20dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;25dp&quot; android:src=&quot;@drawable/myinfo_setting_icon&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;25dp&quot; android:layout_toRightOf=&quot;@id/iv_userInfo_icon&quot; android:text=&quot;设置&quot; android:textColor=&quot;#A3A3A3&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;ImageView android:layout_width=&quot;15dp&quot; android:layout_height=&quot;15dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;25dp&quot; android:src=&quot;@drawable/iv_right_arrow&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E3E3E3&quot; /&gt;&lt;/LinearLayout&gt; 修改完成后，我们试着运行一下，点击底部导航栏中的“我”，一个毫无互动的页面就出来啦。 “我”的界面能显示后，我们来写个工具类。由于项目多次用到sharedPreferences共享参数去存储用户的登录状态或清除登录状态，“我”的界面也要求用到读取用户姓名的方法，所以我们干脆把这三个方法都扔到AnalysisUtils里面吧。在Utils包中新建一个Java类，名为AnalysisUtils。 创建完成后，我们在里面写上readLoginStatus()、clearLoginStatus()、readLoginUserName()三个方法。 AnalysisUtils.java1234567891011121314151617181920212223242526272829package cn.edu.gdmec.android.boxuegu.utils;import android.content.Context;import android.content.SharedPreferences;public class AnalysisUtils &#123; //读取用户名 public static String readLoginUserName(Context context)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;,Context.MODE_PRIVATE); String userName=sharedPreferences.getString(&quot;loginUserName&quot;,&quot;&quot;); return userName; &#125; //读取登录状态 public static boolean readLoginStatus(Context context)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;,Context.MODE_PRIVATE); boolean isLogin=sharedPreferences.getBoolean(&quot;isLogin&quot;,false); return isLogin; &#125; //清除登录状态 public static void cleanLoginStatus(Context context)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;,Context.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putBoolean(&quot;isLogin&quot;,false); editor.putString(&quot;loginUserName&quot;,&quot;&quot;); editor.commit(); &#125;&#125; 以后我们要用到这些方法的时候，调用一下就好啦。写完工具类后，我们来继续完善“我”的页面的代码。给MyinfoFragment加上View.OnClickListener接口。 1public class MyinfoFragment extends Fragment implements View.OnClickListener&#123; 在冒红的地方alt+回车生成onClick()方法，把要响应的id加上去。 MyinfoFragment.java1234567891011@Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.ll_head: break; case R.id.rl_course_history: break; case R.id.rl_setting: break; &#125; &#125; 别忘了监听器。 MyinfoFragment.java12345678910111213141516@Overridepublic void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); llHead = (LinearLayout) view.findViewById(R.id.ll_head); ivHeadIcon = (ImageView) view.findViewById(R.id.iv_head_icon); tvUserName = (TextView) view.findViewById(R.id.tv_user_name); rlCourseHistory = (RelativeLayout) view.findViewById(R.id.rl_course_history); ivCourseHistoryIcon = (ImageView) view.findViewById(R.id.iv_course_history_icon); rlSetting = (RelativeLayout) view.findViewById(R.id.rl_setting); ivUserInfoIcon = (ImageView) view.findViewById(R.id.iv_userInfo_icon); llHead.setOnClickListener(this); rlCourseHistory.setOnClickListener(this); rlSetting.setOnClickListener(this);&#125; “我”的界面的头像部分，要实现两个功能 打开“我”的界面后要判断是否已登录，已登录显示用户名，未登录显示“点击登陆”。 头像部分点击后，会判断是否登录，如果登录了，则跳转到个人资料界面，如果没登录，则跳转到login页面。先来完成第一个功能 我们在onViewCreate()里写个if else判断语句，根据当前登录状态来显示同像下相应的文本。判断的内容就可以调用我们刚才写过的工具类啦。 MyinfoFragment.java12345678910111213141516171819202122@Overridepublic void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); llHead = (LinearLayout) view.findViewById(R.id.ll_head); ivHeadIcon = (ImageView) view.findViewById(R.id.iv_head_icon); tvUserName = (TextView) view.findViewById(R.id.tv_user_name); rlCourseHistory = (RelativeLayout) view.findViewById(R.id.rl_course_history); ivCourseHistoryIcon = (ImageView) view.findViewById(R.id.iv_course_history_icon); rlSetting = (RelativeLayout) view.findViewById(R.id.rl_setting); ivUserInfoIcon = (ImageView) view.findViewById(R.id.iv_userInfo_icon); if (AnalysisUtils.readLoginStatus(getActivity()))&#123; tvUserName.setText(AnalysisUtils.readLoginUserName(getActivity())); &#125;else &#123; tvUserName.setText(&quot;点击登录&quot;); &#125; llHead.setOnClickListener(this); rlCourseHistory.setOnClickListener(this); rlSetting.setOnClickListener(this);&#125; 然后在onClick()方法里给头像部分的点击以及其他按钮加上判断。 MyinfoFragment.java12345678910111213141516171819202122232425262728@Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.ll_head: if (AnalysisUtils.readLoginStatus(getActivity()))&#123; //跳转到个人资料界面 &#125;else &#123; //跳转到登录界面 Intent intent = new Intent(getActivity(), LoginActivity.class); getActivity().startActivityForResult(intent,1); &#125; break; case R.id.rl_course_history: if (AnalysisUtils.readLoginStatus(getActivity()))&#123; //跳转到播放记录页面 &#125;else &#123; Toast.makeText(getActivity(),&quot;您未登录，请先登录&quot;,Toast.LENGTH_SHORT).show(); &#125; break; case R.id.rl_setting: if (AnalysisUtils.readLoginStatus(getActivity()))&#123; //跳转到设置界面 &#125;else &#123; Toast.makeText(getActivity(),&quot;您未登录，请先登录&quot;,Toast.LENGTH_SHORT).show(); &#125; break; &#125;&#125; 注意：未登录时，点击登陆打开登陆页面后，需要MainActivity更新状态并显示，所以用startActivityForResult()方法打开。老样子，这边用startActivityForResult（）打开，MainActivity就要加上onActivityForResult()方法来执行响应。 在MainActivity里按ctrl+O，再打“onActivity”几个字母，找到onActivityForResult方法，点击生成代码。 1234@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data);&#125; 再给它加上代码：判断从LoginActivity传过来登陆状态，并执行响应动作。 MainActivity.java12345678910111213@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (data!=null)&#123; boolean isLogin=data.getBooleanExtra(&quot;isLogin&quot;,false); if (isLogin)&#123; setSelectStatus(0); &#125; else &#123; setSelectStatus(2); &#125; &#125;&#125; Ok,为了方便检验效果，我们给MainActivity加上退出清除登陆状态的方法。连续点击返回两次则退出，两次点击间隔超过2秒则提示再按一次退出。 MainActivity.java12345678910111213141516171819protected long exitTime; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123; if ((System.currentTimeMillis() - exitTime) &gt; 2000) &#123; Toast.makeText(MainActivity.this, &quot;再按一次退出博学谷&quot;, Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); &#125; else &#123; this.finish(); if (AnalysisUtils.readLoginStatus(this)) &#123; AnalysisUtils.cleanLoginStatus(this); &#125; System.exit(0); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125; 然后我们运行下程序，登陆完成后，“我”的界面应该显示用户名。这时候大家会发现，点击“点击登陆”，登陆完成后，显示的是下图的页面，再点一下底部导航栏后，又正常显示了。但是完成上一节任务的会不一样哦~ 这就是常见的fragment刷新问题啦，把它当作一个小BUG，做为今天的“任务实施”吧，解决它。 设置接下来我们来做设置界面。新建一个布局文件，名为activity_setting。 加上布局代码。activity_setting.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--这个标题显示 设置--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#E3E3E3&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_modify_psw&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#F7F8F8&quot; android:gravity=&quot;center_vertical&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;25dp&quot; android:text=&quot;修改密码&quot; android:textColor=&quot;#A3A3A3&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;ImageView android:layout_width=&quot;15dp&quot; android:layout_height=&quot;15dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:paddingRight=&quot;25dp&quot; android:src=&quot;@drawable/iv_right_arrow&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E3E3E3&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_security_setting&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#F7F8F8&quot; android:gravity=&quot;center_vertical&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;25dp&quot; android:text=&quot;设置密保&quot; android:textColor=&quot;#A3A3A3&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;ImageView android:layout_width=&quot;15dp&quot; android:layout_height=&quot;15dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:paddingRight=&quot;25dp&quot; android:src=&quot;@drawable/iv_right_arrow&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E3E3E3&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#E3E3E3&quot; /&gt; &lt;RelativeLayout android:id=&quot;@+id/rl_exit_login&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#F7F8F8&quot; android:gravity=&quot;center_vertical&quot; android:paddingLeft=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;25dp&quot; android:text=&quot;退出登录&quot; android:textColor=&quot;#A3A3A3&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/RelativeLayout&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#E3E3E3&quot; /&gt;&lt;/LinearLayout&gt; 创建一个新activity给tv_main_title设个文本。给title_bar加个背景。加上View.onClickListener接口。Alt+回车生成onClick()代码。在onClick()中加上设置界面要用到的几个按钮。给几个按钮加上监听器。 SettingActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.edu.gdmec.android.boxuegu.activity;import android.app.Activity;import android.content.Intent;import android.graphics.Color;import android.os.Bundle;import android.view.View;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;public class SettingActivity extends Activity implements View.OnClickListener&#123; private TextView tv_back; private TextView tv_main_title; private TextView tv_save; private RelativeLayout title_bar; private RelativeLayout rl_modify_psw; private RelativeLayout rl_security_setting; private RelativeLayout rl_exit_login; public static SettingActivity instance=null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_setting); instance=this; initView(); &#125; private void initView()&#123; tv_back=findViewById(R.id.tv_back); tv_main_title=findViewById(R.id.tv_main_title); tv_save=findViewById(R.id.tv_save); title_bar=findViewById(R.id.title_bar); rl_modify_psw=findViewById(R.id.rl_modify_psw); rl_security_setting=findViewById(R.id.rl_security_setting); rl_exit_login=findViewById(R.id.rl_exit_login); tv_main_title.setText(&quot;设置&quot;); title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); tv_back.setOnClickListener(this); rl_modify_psw.setOnClickListener(this); rl_security_setting.setOnClickListener(this); rl_exit_login.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.tv_back: SettingActivity.this.finish(); break; case R.id.rl_modify_psw: //修改密码界面 break; case R.id.rl_security_setting: //设置密保界面 break; case R.id.rl_exit_login: //退出登录，即清除登录状态 Toast.makeText(this,&quot;退出登录成功&quot;,Toast.LENGTH_SHORT).show(); AnalysisUtils.cleanLoginStatus(this); Intent data=new Intent(); data.putExtra(&quot;isLogin&quot;,false); setResult(RESULT_OK,data); finish(); break; &#125; &#125;&#125; MyinfoFragmrnt.java里把跳转代码加上。 12345678910111213141516171819202122232425262728@Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.ll_head: if (AnalysisUtils.readLoginStatus(getActivity()))&#123; //跳转到个人资料界面 &#125;else &#123; //跳转到登录界面 &#125; break; case R.id.rl_course_history: if (AnalysisUtils.readLoginStatus(getActivity()))&#123; //跳转到播放记录页面 &#125;else &#123; Toast.makeText(getActivity(),&quot;您未登录，请先登录&quot;,Toast.LENGTH_SHORT).show(); &#125; break; case R.id.rl_setting: if (AnalysisUtils.readLoginStatus(getActivity()))&#123; //跳转到设置界面 Intent intent=new Intent(getActivity(), SettingActivity.class); getActivity().startActivityForResult(intent,1); &#125;else &#123; Toast.makeText(getActivity(),&quot;您未登录，请先登录&quot;,Toast.LENGTH_SHORT).show(); &#125; break; &#125;&#125; 别忘了到AndroidManifest.xml声明下SettingActivity，运行程序，在“我”的界面点击设置弹出设置页面。 修改密码首先是修改密码界面的布局代码新建一个布局文件,名为activity_modify_psw 直接上代码。activity_modify_psw.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--修改密码--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/register_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/main_title_bar&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_original_psw&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/register_user_name_bg&quot; android:layout_marginTop=&quot;35dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:gravity=&quot;center_vertical&quot; android:hint=&quot;请输入原始密码&quot; android:inputType=&quot;textPassword&quot; android:paddingLeft=&quot;8dp&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot; android:singleLine=&quot;true&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_new_psw&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/register_user_name_bg&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:gravity=&quot;center_vertical&quot; android:hint=&quot;请输入新密码&quot; android:inputType=&quot;textPassword&quot; android:paddingLeft=&quot;8dp&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_new_psw_again&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/register_user_name_bg&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:gravity=&quot;center_vertical&quot; android:hint=&quot;请再次输入新密码&quot; android:inputType=&quot;textPassword&quot; android:paddingLeft=&quot;8dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_save&quot; android:layout_gravity=&quot;center_horizontal&quot; android:textSize=&quot;18sp&quot; android:textColor=&quot;@android:color/white&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_marginTop=&quot;15dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:background=&quot;@drawable/register_selector&quot; android:text=&quot;保 存&quot;/&gt;&lt;/LinearLayout&gt; 生成activity文件，ModifyPswActivity.java注意：在submit方法中，密码修改成功之后除了把当前页面关了，还要把设置界面也关了，所以用到instance 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package cn.edu.gdmec.android.boxuegu.activity;import android.app.Activity;import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.text.TextUtils;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;import cn.edu.gdmec.android.boxuegu.utils.MD5Utils;public class ModifyPswActivity extends Activity implements View.OnClickListener &#123; private TextView tv_back; private TextView tv_main_title; private TextView tv_save; private RelativeLayout title_bar; private EditText et_original_psw; private EditText et_new_psw; private EditText et_new_psw_again; private Button btn_save; private String userName; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_modify_psw); initView(); userName = AnalysisUtils.readLoginUserName(this); &#125; private void initView() &#123; tv_back=findViewById(R.id.tv_back); tv_main_title=findViewById(R.id.tv_main_title); tv_save=findViewById(R.id.tv_save); title_bar=findViewById(R.id.title_bar); et_original_psw=findViewById(R.id.et_original_psw); et_new_psw=findViewById(R.id.et_new_psw); et_new_psw_again=findViewById(R.id.et_new_psw_again); btn_save=findViewById(R.id.btn_save); tv_main_title.setText(&quot;修改密码&quot;); btn_save.setOnClickListener(this); tv_back.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.btn_save: submit(); break; case R.id.tv_back: finish(); break; &#125; &#125; private void submit() &#123; String psw=et_original_psw.getText().toString().trim(); String newPsw=et_new_psw.getText().toString().trim(); String again=et_new_psw_again.getText().toString().trim(); if (TextUtils.isEmpty(psw))&#123; Toast.makeText(this,&quot;请输入原始密码&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (!MD5Utils.md5(psw).equals(readPsw()))&#123; Log.i(&quot;MD5Utils.md5(psw)&quot;,&quot;&quot;+MD5Utils.md5(psw)); Log.i(&quot;readPsw&quot;,&quot;&quot;+readPsw()); Toast.makeText(this,&quot;输入的密码与原始密码不一致&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (MD5Utils.md5(newPsw).equals(readPsw()))&#123; Toast.makeText(this,&quot;输入的新密码与原始密码不能一致&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (TextUtils.isEmpty(psw))&#123; Toast.makeText(this,&quot;请输入密码&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (TextUtils.isEmpty(again))&#123; Toast.makeText(this,&quot;请再次输入新密码&quot;,Toast.LENGTH_SHORT).show(); &#125;else if (!newPsw.equals(again))&#123; Toast.makeText(this,&quot;再次输入的新密码不一致&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else &#123; Toast.makeText(this,&quot;新密码设置成功&quot;, Toast.LENGTH_SHORT).show(); modifyPsw(newPsw);// Intent intent=new Intent(ModifyPswActivity.this,LoginActivity.class); startActivity(intent); //关闭设置页面 //在submit方法中，密码修改成功之后除了把当前页面关了，还要把设置界面也关了，所以用到instance SettingActivity.instance.finish(); //关闭修改密码页面 ModifyPswActivity.this.finish(); &#125; &#125; private void modifyPsw(String newPsw) &#123; String md5psw= MD5Utils.md5(newPsw); SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putString(userName,md5psw); editor.commit(); &#125; private String readPsw() &#123; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); String spPsw=sharedPreferences.getString(userName,&quot;&quot;); Log.i(&quot;username&quot;,userName); Log.i(&quot;spPsw&quot;,spPsw); return spPsw; &#125;&#125; 注意：在submit方法中，密码修改成功之后除了把当前页面关了，还要把设置界面也关了，所以用到instance SettingActivity.java，给它创个instance SettingActivity.java1234567891011121314151617public class SettingActivity extends Activity implements View.OnClickListener&#123; private TextView tv_back; private TextView tv_main_title; private TextView tv_save; private RelativeLayout title_bar; private RelativeLayout rl_modify_psw; private RelativeLayout rl_security_setting; private RelativeLayout rl_exit_login; public static SettingActivity instance=null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_setting); instance=this; initView(); &#125; 在onclick()中写上跳转方法。 SettingActivity.java12345678910111213141516171819202122232425@Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.tv_back: SettingActivity.this.finish(); break; case R.id.rl_modify_psw: //修改密码界面 Intent intent=new Intent(SettingActivity.this,ModifyPswActivity.class); startActivity(intent); break; case R.id.rl_security_setting: //设置密保界面 break; case R.id.rl_exit_login: //退出登录，即清除登录状态 Toast.makeText(this,&quot;退出登录成功&quot;,Toast.LENGTH_SHORT).show(); AnalysisUtils.cleanLoginStatus(this); Intent data=new Intent(); data.putExtra(&quot;isLogin&quot;,false); setResult(RESULT_OK,data); finish(); break; &#125;&#125; 最后到AndroidManifest.xml声明下activity，运行程序，可看到效果 设置密保和找回密码设置密保和找回密码页面需要用到的图片资源为find_psw_icon.png 新建布局文件，名为activity_find_psw。 布局文件的代码：activity_find_psw.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--找回密码--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--找回密码需要设置标题栏--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_user_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;35dp&quot; android:text=&quot;您的用户名是？&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:visibility=&quot;gone&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_user_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;@drawable/find_psw_icon&quot; android:hint=&quot;请输入您的用户名&quot; android:inputType=&quot;text&quot; android:paddingLeft=&quot;8dp&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#A3A3A3&quot; android:visibility=&quot;gone&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;15dp&quot; android:text=&quot;您的姓名是？&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_validate_name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;@drawable/find_psw_icon&quot; android:hint=&quot;请输入要验证的姓名&quot; android:inputType=&quot;text&quot; android:paddingLeft=&quot;8dp&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#A3A3A3&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_reset_psw&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;15dp&quot; android:text=&quot;请输入新密码&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; android:visibility=&quot;gone&quot;/&gt; &lt;Button android:id=&quot;@+id/btn_validate&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;@drawable/register_selector&quot; android:text=&quot;验 证&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot; /&gt;&lt;/LinearLayout&gt; 生成Activity文件，FindPswActivity.java FindPswActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package cn.edu.gdmec.android.boxuegu.activity;import android.app.Activity;import android.content.SharedPreferences;import android.os.Bundle;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.utils.AnalysisUtils;import cn.edu.gdmec.android.boxuegu.utils.MD5Utils;public class FindPswActivity extends Activity implements View.OnClickListener &#123; private TextView tv_back; private TextView tv_main_title; private RelativeLayout title_bar; private TextView tv_user_name; private EditText et_user_name; private EditText et_validate_name; private TextView tv_reset_psw; private Button btn_validate; private String from; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_find_psw); from=getIntent().getStringExtra(&quot;from&quot;); initView(); &#125; private void initView() &#123; tv_back=findViewById(R.id.tv_back); tv_main_title=findViewById(R.id.tv_main_title); title_bar=findViewById(R.id.title_bar); tv_user_name=findViewById(R.id.tv_user_name); et_user_name=findViewById(R.id.et_user_name); et_validate_name=findViewById(R.id.et_validate_name); tv_reset_psw=findViewById(R.id.tv_reset_psw); btn_validate=findViewById(R.id.btn_validate); if (&quot;security&quot;.equals(from))&#123; tv_main_title.setText(&quot;设置密保&quot;); &#125;else&#123; tv_main_title.setText(&quot;找回密码&quot;); tv_user_name.setVisibility(View.VISIBLE); et_user_name.setVisibility(View.VISIBLE); &#125; tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; FindPswActivity.this.finish(); &#125; &#125;); btn_validate.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.btn_validate: submit(); break; &#125; &#125; private void submit() &#123; // validate String validateName = et_validate_name.getText().toString().trim(); if (&quot;security&quot;.equals(from)) &#123; //设置密保 if (TextUtils.isEmpty(validateName)) &#123; Toast.makeText(this, &quot;请输入要验证的姓名&quot;, Toast.LENGTH_SHORT).show(); return; &#125; else &#123; Toast.makeText(this, &quot;密保设置成功&quot;, Toast.LENGTH_SHORT).show(); //保存到 saveSecurity(validateName); FindPswActivity.this.finish(); return; &#125; &#125;else &#123; final String name=et_user_name.getText().toString().trim(); String sp_security=readSecurity(name); if (TextUtils.isEmpty(name))&#123; Toast.makeText(this,&quot;请输入您的用户名&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (!isExistUserName(name))&#123; Toast.makeText(this,&quot;您输入的用户名不存在&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (TextUtils.isEmpty(validateName))&#123; Toast.makeText(this,&quot;请输入要验证的姓名&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (!validateName.equals(sp_security))&#123; Toast.makeText(this,&quot;输入的密保不正确&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else &#123; tv_reset_psw.setVisibility(View.VISIBLE); tv_reset_psw.setText(&quot;初始密码：123456&quot;); savePsw(name); &#125; &#125; &#125; /** * 保存初始化密码 **/ private void savePsw(String name) &#123; String md5Psw= MD5Utils.md5(&quot;123456&quot;); SharedPreferences sharedPreferences = getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putString(name,md5Psw); editor.commit(); &#125; private boolean isExistUserName(String name)&#123; boolean hasUserName=false; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); String spPsw=sharedPreferences.getString(name,&quot;&quot;); if (!TextUtils.isEmpty(spPsw))&#123; hasUserName=true; &#125; return hasUserName; &#125; /** * 读取密保 **/ private String readSecurity(String name)&#123; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); String security=sharedPreferences.getString(name+&quot;_security&quot;,&quot;&quot;); return security; &#125; /** * 保存密保名字 **/ private void saveSecurity(String validateName) &#123; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); SharedPreferences.Editor editor=sharedPreferences.edit(); editor.putString(AnalysisUtils.readLoginUserName(this)+&quot;_security&quot;,validateName); editor.commit(); &#125;&#125; 把找回密码和设置密保都放在一个Activity里了，所以我们要到登录界面和设置界面添加跳转方法。到LoginActivity的init()方法里找到tv_find_psw.setOnClickListener。 LoginActivity.java123456789//找回密码控件的点击事件tv_find_psw.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //跳转到找回密码界面（此页面暂未创建） Intent intent=new Intent(LoginActivity.this,FindPswActivity.class); startActivity(intent); &#125;&#125;); SettingActivity的onClick()方法里添加跳转代码 12345678910111213141516171819202122232425262728@Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.tv_back: SettingActivity.this.finish(); break; case R.id.rl_modify_psw: //修改密码界面 Intent intent=new Intent(SettingActivity.this,ModifyPswActivity.class); startActivity(intent); break; case R.id.rl_security_setting: //设置密保界面 Intent intent1=new Intent(SettingActivity.this,FindPswActivity.class); intent1.putExtra(&quot;from&quot;,&quot;security&quot;); startActivity(intent1); break; case R.id.rl_exit_login: //退出登录，即清除登录状态 Toast.makeText(this,&quot;退出登录成功&quot;,Toast.LENGTH_SHORT).show(); AnalysisUtils.cleanLoginStatus(this); Intent data=new Intent(); data.putExtra(&quot;isLogin&quot;,false); setResult(RESULT_OK,data); finish(); break; &#125;&#125; 最后到AndroidManifest.xml声明下activity AndroidManifest.xml1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;cn.edu.gdmec.android.boxuegu&quot;&gt; &lt;!--原为android:theme=&quot;@style/AppTheme&quot;--&gt; &lt;!--去除ActionBar标题栏--&gt; &lt;!--添加应用图标，app_icon--&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/app_icon&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt; &lt;activity android:name=&quot;.activity.SplashActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--添加实现类--&gt; &lt;activity android:name=&quot;.activity.MainActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.LoginActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.RegisterActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.SettingActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.ModifyPswActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.FindPswActivity&quot;&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 任务实施修复fragment的小BUG在未登录状态下，点击“点击登陆”，登陆完成后，应该显示“我”的界面，并且正常显示用户名。 在登陆状态下，点击“设置”-&gt;点击退出登录，应该继续显示“我”的界面，并且正常显示用户名。 修改密保设置页面密保设置页面的按钮显示的是“验证”，这里应该是“设置”比较合理。把按钮上的文字改成“设置”，要求修改密码界面按钮依然是“验证”。 优化找回密码登陆界面的找回密码功能用的是初始化密码，要求改成设置新密码。注意：显示设置新密码框时，按钮的文字也要变化哦！ 更改后的效果： 总结这是走好Android的四步！]]></content>
      <categories>
        <category>教育系统APP</category>
      </categories>
      <tags>
        <tag>教育系统APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育系统APP(三)]]></title>
    <url>%2F2018%2F04%2F23%2F1%2F</url>
    <content type="text"><![CDATA[挑战任务回顾教育系统APP(二)以及教育系统APP(三) 检验登录和注册模块。请修改MainActivity和LoginActivity，欢迎界面调转入主界面后，自动跳转入登录界面，登录成功后，返回主界面，在主界面的Hello World位置显示：用户名+“登录成功”。 解决方法 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注 解决任务看看一下AndroidManifest.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;cn.edu.gdmec.android.boxuegu&quot;&gt; &lt;!--原为android:theme=&quot;@style/AppTheme&quot;--&gt; &lt;!--去除ActionBar标题栏--&gt; &lt;!--添加应用图标，app_icon--&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/app_icon&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt; &lt;activity android:name=&quot;.activity.SplashActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--添加实现类--&gt; &lt;activity android:name=&quot;.activity.MainActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.LoginActivity&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.RegisterActivity&quot;&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 然后在MainActivity中编写代码，activity_main.xml添加一下显示,把helloWord改为显示账号： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--任务：检验登录和注册模块--&gt;&lt;!--在主界面的Hello World位置显示：用户名+“登录成功”--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:gravity=&quot;center&quot;&gt; &lt;TextView android:id=&quot;@+id/et_user_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;hello&quot; android:layout_gravity=&quot;center&quot;/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233package cn.edu.gdmec.android.boxuegu.activity;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;/*任务在主界面的Hello World位置显示：用户名+“登录成功”*/public class MainActivity extends AppCompatActivity &#123; private TextView et_user_name; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); et_user_name = findViewById(R.id.et_user_name); Intent intent=new Intent(MainActivity.this,LoginActivity.class); startActivityForResult(intent,1); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (data!=null)&#123; String userName = data.getStringExtra(&quot;userName&quot;); //if (!TextUtils.isEmpty(userName))&#123; Toast.makeText(MainActivity.this,&quot;登陆成功：&quot;+userName, Toast.LENGTH_SHORT).show(); et_user_name.setText(userName); //&#125; &#125; &#125;&#125; 最后在LoginActivity下： 1data.putExtra(&quot;userName&quot;,userName); 教育系统APP(三) 主界面学习目标:掌握注册和登录模块的开发，能够实现模块切换功能。 主页面,挑战任务 学习目标主界面有三个模块，分别为课程模块、习题模块、用户模块。用户点击底部导航栏可以实现三个模块的跳转。主界面用于做三个模块的切换。使用Fragment做为三个模块界面的载体。 任务实施放置图片资源本次实验要用到的图片资源有6个，分别为main_exercises_icon.png、main_course_icon.png、main_my_icon.pngmain_exercises_icon_selected.png、main_course_icon_selected.png、main_my_icon_selected.png把要用到的图片资源放进drawrable文件夹中。 activity_main布局MainActivity页面主要包括两个区域：放Fragment的main_body底部导航栏main_bottom_baractivity_main.xml的完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:background=&quot;@android:color/white&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--标题栏--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot;/&gt; &lt;!--放置Fragment的main_body--&gt; &lt;RelativeLayout android:id=&quot;@+id/main_body&quot; android:background=&quot;@android:color/white&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id=&quot;@+id/main_bottom_bar&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;#F2F2F2&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;55dp&quot;&gt; &lt;RelativeLayout android:layout_weight=&quot;1&quot; android:id=&quot;@+id/bottom_bar_course_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/bottom_bar_text_course&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginBottom=&quot;3dp&quot; android:gravity=&quot;center&quot; android:singleLine=&quot;true&quot; android:text=&quot;课 程&quot; android:textColor=&quot;#666666&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;ImageView android:layout_width=&quot;27dp&quot; android:layout_height=&quot;27dp&quot; android:layout_above=&quot;@+id/bottom_bar_text_course&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;3dp&quot; android:id=&quot;@+id/bottom_bar_image_course&quot; android:src=&quot;@drawable/main_course_icon&quot;/&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:id=&quot;@+id/bottom_bar_exercises_btn&quot; android:layout_weight=&quot;1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/bottom_bar_text_exercises&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginBottom=&quot;3dp&quot; android:gravity=&quot;center&quot; android:singleLine=&quot;true&quot; android:text=&quot;习 题&quot; android:textColor=&quot;#666666&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;ImageView android:layout_width=&quot;27dp&quot; android:layout_height=&quot;27dp&quot; android:layout_above=&quot;@+id/bottom_bar_text_exercises&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;3dp&quot; android:id=&quot;@+id/bottom_bar_image_exercises&quot; android:src=&quot;@drawable/main_exercises_icon&quot;/&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:layout_weight=&quot;1&quot; android:id=&quot;@+id/bottom_bar_myinfo_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/bottom_bar_text_myinfo&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginBottom=&quot;3dp&quot; android:gravity=&quot;center&quot; android:singleLine=&quot;true&quot; android:text=&quot;我&quot; android:textColor=&quot;#666666&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;ImageView android:layout_width=&quot;27dp&quot; android:layout_height=&quot;27dp&quot; android:layout_above=&quot;@+id/bottom_bar_text_myinfo&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;3dp&quot; android:id=&quot;@+id/bottom_bar_image_myinfo&quot; android:src=&quot;@drawable/main_my_icon&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 实例化控件点一下MainActivity 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity &#123; private RelativeLayout main_body; private TextView bottom_bar_text_course; private ImageView bottom_bar_image_course; private RelativeLayout bottom_bar_course_btn; private TextView bottom_bar_text_exercises; private ImageView bottom_bar_image_exercises; private RelativeLayout bottom_bar_exercises_btn; private TextView bottom_bar_text_myinfo; private ImageView bottom_bar_image_myinfo; private RelativeLayout bottom_bar_myinfo_btn; private LinearLayout main_bottom_bar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125; private void initView() &#123; main_body = findViewById(R.id.main_body); bottom_bar_text_course = findViewById(R.id.bottom_bar_text_course); bottom_bar_image_course = findViewById(R.id.bottom_bar_image_course); bottom_bar_course_btn = findViewById(R.id.bottom_bar_course_btn); bottom_bar_text_exercises = findViewById(R.id.bottom_bar_text_exercises); bottom_bar_image_exercises = findViewById(R.id.bottom_bar_image_exercises); bottom_bar_exercises_btn = findViewById(R.id.bottom_bar_exercises_btn); bottom_bar_text_myinfo = findViewById(R.id.bottom_bar_text_myinfo); bottom_bar_image_myinfo = findViewById(R.id.bottom_bar_image_myinfo); bottom_bar_myinfo_btn = findViewById(R.id.bottom_bar_myinfo_btn); main_bottom_bar = findViewById(R.id.main_bottom_bar); &#125;&#125; 控件实例化的部分就完成啦。 底部导航栏状态的切换方法底部导航栏在点击切换时，会有变色的效果。 给MainActivity加一个setSelectStatus（）方法。 12345678910111213141516171819202122232425262728private void setSelectStatus(int index) &#123; switch (index)&#123; case 0: bottom_bar_image_course.setImageResource(R.drawable.main_course_icon_selected); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon); bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon); break; case 1: bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon_selected); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_course.setImageResource(R.drawable.main_course_icon); bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon); break; case 2: bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon_selected); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon); bottom_bar_image_course.setImageResource(R.drawable.main_course_icon); break; &#125;&#125; 在setSelectStatus（）方法里用参数index来判断当前选的按钮。 底部导航栏的响应导航栏颜色切换效果的方法写好了，接下来是点击响应的方法。先给MainActivity加上View.OnClickListener接口 1public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; Alt+回车生成onClick() 方法在生成的onClick（）方法中加上导航栏区域的响应。 1234567891011121314@Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bottom_bar_course_btn: setSelectStatus(0); break; case R.id.bottom_bar_exercises_btn: setSelectStatus(1); break; case R.id.bottom_bar_myinfo_btn: setSelectStatus(2); break; &#125;&#125; 别忘了给三个RelativeLayout控件加上监听器，我的习惯是在initView（）方法里加。 123bottom_bar_course_btn.setOnClickListener(this);bottom_bar_exercises_btn.setOnClickListener(this);bottom_bar_myinfo_btn.setOnClickListener(this); 至此，底部导航栏的代码就完成了。 1234567891011121314151617private void initView() &#123; main_body = findViewById(R.id.main_body); bottom_bar_text_course = findViewById(R.id.bottom_bar_text_course); bottom_bar_image_course = findViewById(R.id.bottom_bar_image_course); bottom_bar_course_btn = findViewById(R.id.bottom_bar_course_btn); bottom_bar_text_exercises = findViewById(R.id.bottom_bar_text_exercises); bottom_bar_image_exercises = findViewById(R.id.bottom_bar_image_exercises); bottom_bar_exercises_btn = findViewById(R.id.bottom_bar_exercises_btn); bottom_bar_text_myinfo = findViewById(R.id.bottom_bar_text_myinfo); bottom_bar_image_myinfo = findViewById(R.id.bottom_bar_image_myinfo); bottom_bar_myinfo_btn = findViewById(R.id.bottom_bar_myinfo_btn); main_bottom_bar = findViewById(R.id.main_bottom_bar); bottom_bar_course_btn.setOnClickListener(this); bottom_bar_exercises_btn.setOnClickListener(this); bottom_bar_myinfo_btn.setOnClickListener(this);&#125; 三个fragment的创建我们还是用Fragment的方法来做三个模块的界面吧。首先新建3个布局文件。fragment_course.xmlfragment_exercises.xmlfragment_myinfo.xml布局文件的内容都相似，一个大大的TextView，里面写着Fragment_1/2/3。记得改背景颜色和字体颜色。 fragment_course.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Fragment_1&quot; android:textColor=&quot;@android:color/black&quot; android:textSize=&quot;50sp&quot;/&gt;&lt;/LinearLayout&gt; fragment_exercises.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Fragment_2&quot; android:textColor=&quot;@android:color/black&quot; android:textSize=&quot;50sp&quot;/&gt;&lt;/LinearLayout&gt; fragment_myinfo.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Fragment_3&quot; android:textColor=&quot;@android:color/black&quot; android:textSize=&quot;50sp&quot;/&gt;&lt;/LinearLayout&gt; 建一个Fragment包，把三个Fragment放进去CourseFragment.java12345678910111213141516171819202122232425package cn.edu.gdmec.android.boxuegu.fragment;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import cn.edu.gdmec.android.boxuegu.R;public class CourseFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_course, null); &#125; @Override public void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); &#125;&#125; ExercisesFragment.java12345678910111213141516171819202122232425package cn.edu.gdmec.android.boxuegu.fragment;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import cn.edu.gdmec.android.boxuegu.R;public class ExercisesFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_exercises, null); &#125; @Override public void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); &#125;&#125; MyinfoFragment.java12345678910111213141516171819202122232425package cn.edu.gdmec.android.boxuegu.fragment;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import cn.edu.gdmec.android.boxuegu.R;public class MyinfoFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_myinfo, null); &#125; @Override public void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); &#125;&#125; 三个fragment的显示和切换Fragment用的是android.support.v4.app.Fragment接下来我们在MainActivity里把AppCompatActivity改为FragmentActivity。 1public class MainActivity extends FragmentActivity implements View.OnClickListener&#123; 把Fragment加到Activity里的代码如下 123FragmentManager manager = getSupportFragmentManager();FragmentTransaction transaction = manager.beginTransaction();transaction.add(R.id.main_body,new CourseFragment()).commit(); 我们写一个setMain（）方法，用于打开初始页面 1234private void setMain() &#123; this.getSupportFragmentManager().beginTransaction().add(R.id.main_body,new CourseFragment()).commit(); setSelectStatus(0);&#125; 这里面用的是连写，跟上面Fragment加到Activity的代码是一样效果的，这个看个人习惯。 在onCreate()方法里调用 12345678@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setMain();&#125; 点击底部导航栏时，要切换响应的fragment，我们在onClick()方法里加上Fragment切换的方法。 1234567891011121314151617@Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bottom_bar_course_btn: getSupportFragmentManager().beginTransaction().add(R.id.main_body,new CourseFragment()).commit(); setSelectStatus(0); break; case R.id.bottom_bar_exercises_btn: getSupportFragmentManager().beginTransaction().add(R.id.main_body,new ExercisesFragment()).commit(); setSelectStatus(1); break; case R.id.bottom_bar_myinfo_btn: getSupportFragmentManager().beginTransaction().add(R.id.main_body,new MyinfoFragment()).commit(); setSelectStatus(2); break; &#125;&#125; 完整的MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package cn.edu.gdmec.android.boxuegu.activity;import android.content.pm.ActivityInfo;import android.graphics.Color;import android.os.Bundle;import android.support.v4.app.FragmentActivity;import android.view.View;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.RelativeLayout;import android.widget.TextView;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.fragment.CourseFragment;import cn.edu.gdmec.android.boxuegu.fragment.ExercisesFragment;import cn.edu.gdmec.android.boxuegu.fragment.MyinfoFragment;/*任务在主界面的Hello World位置显示：用户名+“登录成功”*/public class MainActivity extends FragmentActivity implements View.OnClickListener&#123; private RelativeLayout main_body; private TextView bottom_bar_text_course; private ImageView bottom_bar_image_course; private RelativeLayout bottom_bar_course_btn; private TextView bottom_bar_text_exercises; private ImageView bottom_bar_image_exercises; private RelativeLayout bottom_bar_exercises_btn; private TextView bottom_bar_text_myinfo; private ImageView bottom_bar_image_myinfo; private RelativeLayout bottom_bar_myinfo_btn; private LinearLayout main_bottom_bar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); //把Fragment加到Activity里的代码如下 /* FragmentManager manager = getSupportFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); transaction.add(R.id.main_body,new CourseFragment()).commit();*/ setMain(); &#125; private void setMain() &#123; this.getSupportFragmentManager().beginTransaction().add(R.id.main_body,new MyinfoFragment()).commit(); setSelectStatus(2); &#125; private void setSelectStatus(int index) &#123; switch (index)&#123; case 0: bottom_bar_image_course.setImageResource(R.drawable.main_course_icon_selected); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon); bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon); break; case 1: bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon_selected); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_course.setImageResource(R.drawable.main_course_icon); bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon); break; case 2: bottom_bar_image_myinfo.setImageResource(R.drawable.main_my_icon_selected); bottom_bar_text_myinfo.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); bottom_bar_text_course.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_exercises.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_image_exercises.setImageResource(R.drawable.main_exercises_icon); bottom_bar_image_course.setImageResource(R.drawable.main_course_icon); break; &#125; &#125; private void initView() &#123; main_body = findViewById(R.id.main_body); bottom_bar_text_course = findViewById(R.id.bottom_bar_text_course); bottom_bar_image_course = findViewById(R.id.bottom_bar_image_course); bottom_bar_course_btn = findViewById(R.id.bottom_bar_course_btn); bottom_bar_text_exercises = findViewById(R.id.bottom_bar_text_exercises); bottom_bar_image_exercises = findViewById(R.id.bottom_bar_image_exercises); bottom_bar_exercises_btn = findViewById(R.id.bottom_bar_exercises_btn); bottom_bar_text_myinfo = findViewById(R.id.bottom_bar_text_myinfo); bottom_bar_image_myinfo = findViewById(R.id.bottom_bar_image_myinfo); bottom_bar_myinfo_btn = findViewById(R.id.bottom_bar_myinfo_btn); main_bottom_bar = findViewById(R.id.main_bottom_bar); bottom_bar_course_btn.setOnClickListener(this); bottom_bar_exercises_btn.setOnClickListener(this); bottom_bar_myinfo_btn.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bottom_bar_course_btn: getSupportFragmentManager().beginTransaction().add(R.id.main_body,new CourseFragment()).commit(); setSelectStatus(0); break; case R.id.bottom_bar_exercises_btn: getSupportFragmentManager().beginTransaction().add(R.id.main_body,new ExercisesFragment()).commit(); setSelectStatus(1); break; case R.id.bottom_bar_myinfo_btn: getSupportFragmentManager().beginTransaction().add(R.id.main_body,new MyinfoFragment()).commit(); setSelectStatus(2); break; &#125; &#125;&#125; 好了，完成，这里没有新添加的activity的类。接下来进行挑战任务！ 挑战任务初次打开页面都是Fragment_1，请修改相关代码，让初始打开的页面为Fragment_3，别忘了底部导航栏也要变颜色哦 总结这是走好Android的三步！]]></content>
      <categories>
        <category>教育系统APP</category>
      </categories>
      <tags>
        <tag>教育系统APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育系统APP(二)]]></title>
    <url>%2F2018%2F04%2F22%2F1%2F</url>
    <content type="text"><![CDATA[注册与登录界面设计思路 当我们面临制作登录和注册功能的实现时，我们需要先设计登录界面的布局和注册界面的布局，做到有完整的思路时才开始实现其功能效果会更好。 我们需要做个标题栏，登陆界面，实现登陆界面的功能代码块，注册界面，实现测试界面的功能模块即可完成。 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注 学习目标掌握注册和登录模块的开发，能够实现用户登录功能。 项目实操注册界面知识点 标题栏的创建，ImageView、EditText、Button控件的使用，haredPreferences的使用，setResult（RESULT_OK，data）方法的使用，MD5加密算法 技能点掌握注册界面的设计和逻辑构思，掌握标题栏的创建以及常用控件的使用 通过SharedPreferences实现数据的存取功能，通过setResult(RESULT_OK,data)方法实现界面间数据的回传，通过MD5加密算法实现密码加密功能，实现注册功能 任务实施标题栏，创建标题栏界面布局文件，创建背景选择器，注册界面，创建注册界面Activity ，导入图片资源到drawable中，编写布局文件 activity_register.xml，创建背景选择器register_selector.xml，MD5加密算法，创建utils包，创建MDUtils类 注册界面逻辑代码声明用于操作控件的Activity私有属性，获取界面控件，保存注册信息到SharedPreferences中，Activity的onCreate中调用init() 登录界面标题栏的引用EditText、Button控件SharedPreferences的使用setResult(RESULT_OK,data)使用Intent使用 技能点掌握登录界面的设计和逻辑构思通过SharedPreferences实现数据的存取功能通过setResult(RESULT_DATA,data)方法实现界面间数据传递通过Intent实现Actitivty间跳转 挑战任务展示一下包结构绿色表示新的添加哦~ 项目实操注册界面主要用于输入用户注册信息，在注册界面中用户需要输入用户名、密码、再次输入密码，当点击“注册”按钮时进行注册。使用本地数据存储用户信息，注册成功后将用户名和密码保存在SharedPrefereces中，以便于后续用户登录。为保证账户的安全，在保存密码时采用MD5加密算法，这种算法不可逆，具有一定的安全性。 标题栏鼠标右键点击res/layout，new-&gt;xml-layout XML file，创建main_title_bar.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--标题栏与返回键的创建，独立在main_title_bar.xml中--&gt;&lt;!--标题栏设置高度为50dp，宽度为match_parent,设置背景颜色为通明为@android:color/transparent--&gt;&lt;!--RelativeLayout为相对布局--&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/title_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;@android:color/transparent&quot;&gt; &lt;!--设置返回键TextView为高度50dp,宽度为50dp;id为android:id=&quot;@+id/tv_back&quot;--&gt; &lt;!--layout_alignParentLeft为与父控件左对齐--&gt; &lt;!--layout_centerVertical为控件垂直居中--&gt; &lt;!--标题栏界面中的返回键在按下与弹起时，返回键会有明显的区别，这种效果通过背景选择器进行实现--&gt; &lt;TextView android:id=&quot;@+id/tv_back&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:background=&quot;@drawable/go_back_selector&quot;/&gt; &lt;!--设置id为android:id=&quot;@+id/tv_main_title--&gt; &lt;!--该TextView为显示文本--&gt; &lt;!--layout_centerInparent为居中显示--&gt; &lt;TextView android:id=&quot;@+id/tv_main_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; android:layout_centerInParent=&quot;true&quot;/&gt; &lt;!--到main_title_bar.xml中tv_main_title按钮的下方，加个“保存”--&gt; &lt;TextView android:id=&quot;@+id/tv_save&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;30dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginRight=&quot;20dp&quot; android:layout_marginTop=&quot;20dp&quot; android:layout_alignParentRight=&quot;true&quot; android:visibility=&quot;gone&quot; android:text=&quot;保存&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;16sp&quot;/&gt;&lt;/RelativeLayout&gt; 将图片iv_back_selected.png和iv_back.png 粘贴到drawable中鼠标右键drawable，new-&gt;drawable resource file，创建go_back_selector.xml。 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--建立go_back_selector.xml背景选择器--&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--android:state_pressed=&quot;true&quot;为是否按下，如一个按钮触摸或者点击--&gt; &lt;!--当按下时显示灰色图片（iv_back_selected.png），当按钮弹起时显示白色图片（iv_back.png）--&gt; &lt;item android:drawable=&quot;@drawable/iv_back_selected&quot; android:state_pressed=&quot;true&quot;/&gt; &lt;item android:drawable=&quot;@drawable/iv_back&quot;/&gt;&lt;/selector&gt; 注册界面 创建注册界面Activity 鼠标右键activity包，new-&gt;activity-&gt;Empty Activity，创建RegisterActivity 导入图片资源到drawable中register_bg.pngdefault_icon.pnguser_name_icon.pngpsw_icon.pngregister_user_name_bg.pngregister_psw_bg.pngregister_psw_again_bg.png 编写布局文件 activity_register.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--注册界面--&gt;&lt;!--这里的布局是放置 1 个 ImageView 控件，用于显示用户头像；3 个 EditText 控件，用于输入用户名、密码、再次输入密码；1 个 Button 控件作为注册按钮--&gt;&lt;!--修改 activity_register.xml 为 LinearLayout 布局--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/activity_register&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/register_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/main_title_bar&quot;&gt;&lt;/include&gt;&lt;!--引入标题栏--&gt; &lt;ImageView android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginTop=&quot;25dp&quot; android:src=&quot;@drawable/default_icon&quot;/&gt; &lt;!--三个编辑框--&gt; &lt;EditText android:id=&quot;@+id/et_user_name&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;35dp&quot; android:background=&quot;@drawable/register_user_name_bg&quot; android:drawableLeft=&quot;@drawable/user_name_icon&quot; android:drawablePadding=&quot;10dp&quot; android:gravity=&quot;center_vertical&quot; android:hint=&quot;请输入用户名&quot; android:paddingLeft=&quot;8dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_psw&quot; android:layout_width=&quot;fill_parent&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:background=&quot;@drawable/register_psw_bg&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:hint=&quot;请输入密码&quot; android:inputType=&quot;textPassword&quot; android:paddingLeft=&quot;8dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_psw_again&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:background=&quot;@drawable/register_psw_again_bg&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:hint=&quot;请再次输入密码&quot; android:inputType=&quot;textPassword&quot; android:paddingLeft=&quot;8dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;Button android:id=&quot;@+id/btn_register&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;@drawable/register_selector&quot; android:text=&quot;注 册&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot;/&gt;&lt;/LinearLayout&gt; 创建背景选择器register_selector.xml将register_icon_normal.png,register_icon_selected.png贴入drawable中在drawable创建register_selector.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;!--register_icon_normal.png为按钮不点击的样式，点击显示灰色图片register_icon_selected.png--&gt; &lt;item android:drawable=&quot;@drawable/register_icon_selected&quot; android:state_pressed=&quot;true&quot;/&gt; &lt;item android:drawable=&quot;@drawable/register_icon_normal&quot;/&gt;&lt;/selector&gt; MD5加密算法MD5的全称是Message_Digest Algorithm 5（信息-摘要算法第5版），MD5简单来说就是吧任意长度的字符串变成固定长度（通常是128位）的十六进制字符串。 创建utils包鼠标右键utils包，new-&gt;java class，创建MD5Utils类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.edu.gdmec.android.boxuegu.utils;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * Created by Jack on 2018/3/27. * 创建一个md5()方法 * 过 MessageDigest 的 getInstance()方法 * 获取数据加密对象 digest，然后通过该对象的 digest()方法对密码进行加密 * 由于注册登录涉及密码 * 我们需要对用户的密码进行 MD5 算法加密 * MD5 的全称是 Message-Digest Algorithm 5（信息--摘要算法） * MD5 算法简单来说就是把任意长度的字符串变换成固定长度（通常是128位）的16进制字符串 * 且此算法不可逆 */public class MD5Utils &#123; // md5 加密的算法 public static String md5(String text)&#123; MessageDigest digest = null; try &#123; //获取数据指纹对象 digest = MessageDigest.getInstance(&quot;md5&quot;); //字节数组 byte[] result = digest.digest(text.getBytes()); //16进制转换 StringBuffer sb = new StringBuffer(); //获取所有字节进行转换 for (byte b: result)&#123; //使用『与算法』，java使用unicode字符，所以每个字符占位两个 // 需要与两位16进制最大值进行与运算，获取number值 int number = b &amp; 0xff; //number值转换字符串 String hex = Integer.toHexString(number); if (hex.length() == 1)&#123; //若转换后的字符长度等于1则进行字符串拼接 sb.append(&quot;0&quot;+hex); &#125;else &#123; sb.append(hex); &#125; &#125; return sb.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); //发送异常return空字符串 return &quot;&quot;; &#125; &#125;&#125; 注册界面逻辑代码声明用于操作控件的Activity私有属性 123456789101112//标题private TextView tv_main_title;//返回按钮private TextView tv_back;//注册按钮private Button btn_register;//用户名，密码，再次输入的密码的控件private EditText et_user_name,et_psw,et_psw_again;//用户名，密码，再次输入的密码的控件的获取值private String userName,psw,pswAgain;//标题布局private RelativeLayout rl_title_bar; 获取界面控件在RegisterAcitivity中创建界面控件的初始化方法init()，用于获取注册界面锁要用到的控件以及实现控件的点击事件。注意有两个私有类方法getEditString()和isExistUserName(String userName)写在init()后面的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private void init() &#123; //从main_title_bar.xml 页面布局中获取对应的UI控件 tv_main_title=findViewById(R.id.tv_main_title); tv_main_title.setText(&quot;注册&quot;); tv_back=findViewById(R.id.tv_back); //布局根元素 rl_title_bar=findViewById(R.id.title_bar); rl_title_bar.setBackgroundColor(Color.TRANSPARENT); //从activity_register.xml 页面中获取对应的UI控件 btn_register=findViewById(R.id.btn_register); et_user_name=findViewById(R.id.et_user_name); et_psw=findViewById(R.id.et_psw); et_psw_again=findViewById(R.id.et_psw_again); tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //返回键 RegisterActivity.this.finish(); &#125; &#125;); //注册按钮 btn_register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //获取输入在相应控件中的字符串 getEditString(); //判断输入框内容 if(TextUtils.isEmpty(userName))&#123; Toast.makeText(RegisterActivity.this, &quot;请输入用户名&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(TextUtils.isEmpty(psw))&#123; Toast.makeText(RegisterActivity.this, &quot;请输入密码&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(TextUtils.isEmpty(pswAgain))&#123; Toast.makeText(RegisterActivity.this, &quot;请再次输入密码&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(!psw.equals(pswAgain))&#123; Toast.makeText(RegisterActivity.this, &quot;输入两次的密码不一样&quot;, Toast.LENGTH_SHORT).show(); return; /** *从SharedPreferences中读取输入的用户名，判断SharedPreferences中是否有此用户名 */ &#125;else if(isExistUserName(userName))&#123; Toast.makeText(RegisterActivity.this, &quot;此账户名已经存在&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else&#123; Toast.makeText(RegisterActivity.this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); //把账号、密码和账号标识保存到sp里面 /** * 保存账号和密码到SharedPreferences中 */ saveRegisterInfo(userName, psw); //注册成功后把账号传递到LoginActivity.java中 // 返回值到loginActivity显示 Intent data = new Intent(); data.putExtra(&quot;userName&quot;, userName); setResult(RESULT_OK, data); //RESULT_OK为Activity系统常量，状态码为-1， //表示此页面下的内容操作成功将data返回到上一页面，如果是用back返回过去的则不存在用setResult传递data值 RegisterActivity.this.finish(); &#125; &#125; &#125;); &#125; /** * 获取控件中的字符串 */ private void getEditString()&#123; userName=et_user_name.getText().toString().trim(); psw=et_psw.getText().toString().trim(); pswAgain=et_psw_again.getText().toString().trim(); &#125; /** * 从SharedPreferences中读取输入的用户名，判断SharedPreferences中是否有此用户名 */ private boolean isExistUserName(String userName)&#123; boolean has_userName=false; //mode_private SharedPreferences sp = getSharedPreferences( ); // &quot;loginInfo&quot;, MODE_PRIVATE SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //获取密码 String spPsw=sp.getString(userName, &quot;&quot;);//传入用户名获取密码 //如果密码不为空则确实保存过这个用户名 if(!TextUtils.isEmpty(spPsw)) &#123; has_userName=true; &#125; return has_userName; &#125; 保存注册信息到SharedPreferences中在REgisterActivity中创建一个saveRegisterInfo()方法，讲注册成功的用户名和密码(经过MD5加密)保存到SharedPreferences中。 123456789101112private void saveRegisterInfo(String userName,String psw)&#123; String md5Psw = MD5Utils.md5(psw);//把密码用MD5加密 //loginInfo表示文件名, mode_private SharedPreferences sp = getSharedPreferences( ); SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //获取编辑器， SharedPreferences.Editor editor -&gt; sp.edit(); SharedPreferences.Editor editor=sp.edit(); //以用户名为key，密码为value保存在SharedPreferences中 //key,value,如键值对，editor.putString(用户名，密码）; editor.putString(userName, md5Psw); //提交修改 editor.commit(); editor.commit();&#125; Activity的onCreate中调用init()123456789@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //设置页面布局 ,注册界面 setContentView(R.layout.activity_register); //设置此界面为竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); init();&#125; RegisterActivity 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package cn.edu.gdmec.android.boxuegu.activity;import android.content.Intent;import android.content.SharedPreferences;import android.content.pm.ActivityInfo;import android.graphics.Color;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.utils.MD5Utils;public class RegisterActivity extends AppCompatActivity &#123; //标题 private TextView tv_main_title; //返回按钮 private TextView tv_back; //注册按钮 private Button btn_register; //用户名，密码，再次输入的密码的控件 private EditText et_user_name,et_psw,et_psw_again; //用户名，密码，再次输入的密码的控件的获取值 private String userName,psw,pswAgain; //标题布局 private RelativeLayout rl_title_bar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //设置页面布局 ,注册界面 setContentView(R.layout.activity_register); //设置此界面为竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); init(); &#125; private void init() &#123; //从main_title_bar.xml 页面布局中获取对应的UI控件 tv_main_title=findViewById(R.id.tv_main_title); tv_main_title.setText(&quot;注册&quot;); tv_back=findViewById(R.id.tv_back); //布局根元素 rl_title_bar=findViewById(R.id.title_bar); rl_title_bar.setBackgroundColor(Color.TRANSPARENT); //从activity_register.xml 页面中获取对应的UI控件 btn_register=findViewById(R.id.btn_register); et_user_name=findViewById(R.id.et_user_name); et_psw=findViewById(R.id.et_psw); et_psw_again=findViewById(R.id.et_psw_again); tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //返回键 RegisterActivity.this.finish(); &#125; &#125;); //注册按钮 btn_register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //获取输入在相应控件中的字符串 getEditString(); //判断输入框内容 if(TextUtils.isEmpty(userName))&#123; Toast.makeText(RegisterActivity.this, &quot;请输入用户名&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(TextUtils.isEmpty(psw))&#123; Toast.makeText(RegisterActivity.this, &quot;请输入密码&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(TextUtils.isEmpty(pswAgain))&#123; Toast.makeText(RegisterActivity.this, &quot;请再次输入密码&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(!psw.equals(pswAgain))&#123; Toast.makeText(RegisterActivity.this, &quot;输入两次的密码不一样&quot;, Toast.LENGTH_SHORT).show(); return; /** *从SharedPreferences中读取输入的用户名，判断SharedPreferences中是否有此用户名 */ &#125;else if(isExistUserName(userName))&#123; Toast.makeText(RegisterActivity.this, &quot;此账户名已经存在&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else&#123; Toast.makeText(RegisterActivity.this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); //把账号、密码和账号标识保存到sp里面 /** * 保存账号和密码到SharedPreferences中 */ saveRegisterInfo(userName, psw); //注册成功后把账号传递到LoginActivity.java中 // 返回值到loginActivity显示 Intent data = new Intent(); data.putExtra(&quot;userName&quot;, userName); setResult(RESULT_OK, data); //RESULT_OK为Activity系统常量，状态码为-1， //表示此页面下的内容操作成功将data返回到上一页面，如果是用back返回过去的则不存在用setResult传递data值 RegisterActivity.this.finish(); &#125; &#125; &#125;); &#125; /** * 获取控件中的字符串 */ private void getEditString()&#123; userName=et_user_name.getText().toString().trim(); psw=et_psw.getText().toString().trim(); pswAgain=et_psw_again.getText().toString().trim(); &#125; /** * 从SharedPreferences中读取输入的用户名，判断SharedPreferences中是否有此用户名 */ private boolean isExistUserName(String userName)&#123; boolean has_userName=false; //mode_private SharedPreferences sp = getSharedPreferences( ); // &quot;loginInfo&quot;, MODE_PRIVATE SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //获取密码 String spPsw=sp.getString(userName, &quot;&quot;);//传入用户名获取密码 //如果密码不为空则确实保存过这个用户名 if(!TextUtils.isEmpty(spPsw)) &#123; has_userName=true; &#125; return has_userName; &#125; /** * 保存账号和密码到SharedPreferences中SharedPreferences */ private void saveRegisterInfo(String userName,String psw)&#123; String md5Psw = MD5Utils.md5(psw);//把密码用MD5加密 //loginInfo表示文件名, mode_private SharedPreferences sp = getSharedPreferences( ); SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //获取编辑器， SharedPreferences.Editor editor -&gt; sp.edit(); SharedPreferences.Editor editor=sp.edit(); //以用户名为key，密码为value保存在SharedPreferences中 //key,value,如键值对，editor.putString(用户名，密码）; editor.putString(userName, md5Psw); //提交修改 editor.commit(); editor.commit(); &#125;&#125; 登录界面登录界面主要用输入登录信息，当点击“登录”按钮时需要在ShatredPreferences中查询输入的用户名是否有对应的密码，如果有则用此密码与当前输入的密码(需要MD5加密)进行比对，如果信息一致，则登录成功，并吧登录成功的状态和用户名保存到SharedPreferences中，便于后续判断登录状态和获取用户名。 创建登录界面鼠标右键activity包，new-&gt;activity-&gt;Empty Activity，创建LoginAcitivity导入图片资源到drawable中login_bg.pnglogin_user_name_bg.pnglogin_psw_bg.png 编写界面布局 activity_login.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--登录界面--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--标题栏--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot;&gt;&lt;/include&gt; &lt;ImageView android:id=&quot;@+id/iv_head&quot; android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:layout_marginTop=&quot;25dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/default_icon&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_user_name&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_marginTop=&quot;35dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/login_user_name_bg&quot; android:drawableLeft=&quot;@drawable/user_name_icon&quot; android:drawablePadding=&quot;10dp&quot; android:paddingLeft=&quot;8dp&quot; android:gravity=&quot;center_vertical&quot; android:hint=&quot;请输入用户名&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_psw&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:background=&quot;@drawable/login_psw_bg&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:paddingLeft=&quot;8dp&quot; android:gravity=&quot;center_vertical&quot; android:hint=&quot;请输入密码&quot; android:inputType=&quot;textPassword&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;Button android:id=&quot;@+id/btn_login&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_marginTop=&quot;15dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/register_selector&quot; android:text=&quot;登 录&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot;/&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:gravity=&quot;center_horizontal&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_register&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center_horizontal&quot; android:padding=&quot;8dp&quot; android:text=&quot;立即注册&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;!--layout_weight=&quot;1&quot; layout_width=&quot;0dp&quot;实现均分效果--&gt; &lt;TextView android:id=&quot;@+id/tv_find_psw&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center_horizontal&quot; android:padding=&quot;8dp&quot; android:text=&quot;找回密码?&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 登录界面的逻辑代码声明用于操作控件的Activity私有属性12345678910//标题 private TextView tv_main_title; //返回键,显示的注册，找回密码 private TextView tv_back,tv_register,tv_find_psw; //登录按钮 private Button btn_login; //获取的用户名，密码，加密密码 private String userName,psw,spPsw; //用户名和密码的输入框 private EditText et_user_name,et_psw; 获取界面控件创建初始化方法init()，用于获取登录界面所要用的空间，并设置登录按钮、返回按钮、立刻注册、找回密码点击事件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//获取界面控件 private void init() &#123; //从main_title_bar中获取的id tv_main_title=findViewById(R.id.tv_main_title); tv_main_title.setText(&quot;登录&quot;); tv_back=findViewById(R.id.tv_back); //从activity_login.xml中获取的 tv_register=findViewById(R.id.tv_register); tv_find_psw=findViewById(R.id.tv_find_psw); btn_login=findViewById(R.id.btn_login); et_user_name=findViewById(R.id.et_user_name); et_psw=findViewById(R.id.et_psw); //返回键的点击事件 tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //登录界面销毁 LoginActivity.this.finish(); &#125; &#125;); //立即注册控件的点击事件 tv_register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //为了跳转到注册界面，并实现注册功能 Intent intent=new Intent(LoginActivity.this,RegisterActivity.class); startActivityForResult(intent, 1); &#125; &#125;); //找回密码控件的点击事件 tv_find_psw.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //跳转到找回密码界面（此页面暂未创建） /*Intent intent=new Intent(LoginActivity.this,FindPwdActivity.class); startActivity(intent);*/ &#125; &#125;); //登录按钮的点击事件 btn_login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //开始登录，获取用户名和密码 getText().toString().trim(); userName=et_user_name.getText().toString().trim(); psw=et_psw.getText().toString().trim(); //对当前用户输入的密码进行MD5加密再进行比对判断, MD5Utils.md5( ); psw 进行加密判断是否一致 String md5Psw= MD5Utils.md5(psw); // md5Psw ; spPsw 为 根据从SharedPreferences中用户名读取密码 // 定义方法 readPsw为了读取用户名，得到密码 spPsw=readPsw(userName); // TextUtils.isEmpty if(TextUtils.isEmpty(userName))&#123; Toast.makeText(LoginActivity.this, &quot;请输入用户名&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(TextUtils.isEmpty(psw))&#123; Toast.makeText(LoginActivity.this, &quot;请输入密码&quot;, Toast.LENGTH_SHORT).show(); return; // md5Psw.equals(); 判断，输入的密码加密后，是否与保存在SharedPreferences中一致 &#125;else if(md5Psw.equals(spPsw))&#123; //一致登录成功 Toast.makeText(LoginActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); //保存登录状态，在界面保存登录的用户名 定义个方法 saveLoginStatus boolean 状态 , userName 用户名; saveLoginStatus(true, userName); //登录成功后关闭此页面进入主页 Intent data=new Intent(); //datad.putExtra( ); name , value ; data.putExtra(&quot;isLogin&quot;,true); data.putExtra(&quot;userName&quot;,userName); //RESULT_OK为Activity系统常量，状态码为-1 // 表示此页面下的内容操作成功将data返回到上一页面，如果是用back返回过去的则不存在用setResult传递data值 setResult(RESULT_OK,data); //销毁登录界面 LoginActivity.this.finish(); //跳转到主界面，登录成功的状态传递到 MainActivity 中 //startActivity(new Intent(LoginActivity.this, MainActivity.class)); return; &#125;else if((spPsw!=null&amp;&amp;!TextUtils.isEmpty(spPsw)&amp;&amp;!md5Psw.equals(spPsw)))&#123; Toast.makeText(LoginActivity.this, &quot;输入的用户名和密码不一致&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else&#123; Toast.makeText(LoginActivity.this, &quot;此用户名不存在&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125; 从SharedPreferences中根据用户名读取密码12345678910/** *从SharedPreferences中根据用户名读取密码 */ private String readPsw(String userName)&#123; //getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); //&quot;loginInfo&quot;,mode_private; MODE_PRIVATE表示可以继续写入 SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //sp.getString() userName, &quot;&quot;; return sp.getString(userName , &quot;&quot;); &#125; 保存登录状态到SharedPreferences中由于在后续创建主界面时，需要根据登录状态来设置界面的图标和用户名，因此需要创建saveLogiinStatus()方法，在登录成功后吧登录状态和用户名保存到SharedPrefereces中。 12345678910111213private void saveLoginStatus(boolean status,String userName)&#123; //saveLoginStatus(true, userName); //loginInfo表示文件名 SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //获取编辑器 SharedPreferences.Editor editor=sp.edit(); //存入boolean类型的登录状态 editor.putBoolean(&quot;isLogin&quot;, status); //存入登录状态时的用户名 editor.putString(&quot;loginUserName&quot;, userName); //提交修改 editor.commit(); &#125; 获取回传数据重写onActivityResult()方法，通过data.getStringExtra()方法获取注册成功的一个用户名，并将其显示在用户名控件上。 重写类方法的便捷操作： 选择菜单Code-&gt;Override Methods 或者按快捷键Ctrl+o，然后输入方法名onActivityResult，Android Studio会智能查找到，按回车自动把冲写代码加入。 1234567891011121314151617181920212223242526/** * 注册成功的数据返回至此 * @param requestCode 请求码 * @param resultCode 结果码 * @param data 数据 */ @Override //显示数据， onActivityResult //startActivityForResult(intent, 1); 从注册界面中获取数据 //int requestCode , int resultCode , Intent data // LoginActivity -&gt; startActivityForResult -&gt; onActivityResult(); protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; //super.onActivityResult(requestCode, resultCode, data); super.onActivityResult(requestCode, resultCode, data); if(data!=null)&#123; //是获取注册界面回传过来的用户名 // getExtra().getString(&quot;***&quot;); String userName=data.getStringExtra(&quot;userName&quot;); if(!TextUtils.isEmpty(userName))&#123; //设置用户名到 et_user_name 控件 et_user_name.setText(userName); //et_user_name控件的setSelection()方法来设置光标位置 et_user_name.setSelection(userName.length()); &#125; &#125; &#125; LoginActivity 完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package cn.edu.gdmec.android.boxuegu.activity;import android.content.Intent;import android.content.SharedPreferences;import android.content.pm.ActivityInfo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.boxuegu.R;import cn.edu.gdmec.android.boxuegu.utils.MD5Utils;public class LoginActivity extends AppCompatActivity &#123; //标题 private TextView tv_main_title; //返回键,显示的注册，找回密码 private TextView tv_back,tv_register,tv_find_psw; //登录按钮 private Button btn_login; //获取的用户名，密码，加密密码 private String userName,psw,spPsw; //用户名和密码的输入框 private EditText et_user_name,et_psw; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); //设置此界面为竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); init(); &#125; //获取界面控件 private void init() &#123; //从main_title_bar中获取的id tv_main_title=findViewById(R.id.tv_main_title); tv_main_title.setText(&quot;登录&quot;); tv_back=findViewById(R.id.tv_back); //从activity_login.xml中获取的 tv_register=findViewById(R.id.tv_register); tv_find_psw=findViewById(R.id.tv_find_psw); btn_login=findViewById(R.id.btn_login); et_user_name=findViewById(R.id.et_user_name); et_psw=findViewById(R.id.et_psw); //返回键的点击事件 tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //登录界面销毁 LoginActivity.this.finish(); &#125; &#125;); //立即注册控件的点击事件 tv_register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //为了跳转到注册界面，并实现注册功能 Intent intent=new Intent(LoginActivity.this,RegisterActivity.class); startActivityForResult(intent, 1); &#125; &#125;); //找回密码控件的点击事件 tv_find_psw.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //跳转到找回密码界面（此页面暂未创建） /*Intent intent=new Intent(LoginActivity.this,FindPwdActivity.class); startActivity(intent);*/ &#125; &#125;); //登录按钮的点击事件 btn_login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //开始登录，获取用户名和密码 getText().toString().trim(); userName=et_user_name.getText().toString().trim(); psw=et_psw.getText().toString().trim(); //对当前用户输入的密码进行MD5加密再进行比对判断, MD5Utils.md5( ); psw 进行加密判断是否一致 String md5Psw= MD5Utils.md5(psw); // md5Psw ; spPsw 为 根据从SharedPreferences中用户名读取密码 // 定义方法 readPsw为了读取用户名，得到密码 spPsw=readPsw(userName); // TextUtils.isEmpty if(TextUtils.isEmpty(userName))&#123; Toast.makeText(LoginActivity.this, &quot;请输入用户名&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(TextUtils.isEmpty(psw))&#123; Toast.makeText(LoginActivity.this, &quot;请输入密码&quot;, Toast.LENGTH_SHORT).show(); return; // md5Psw.equals(); 判断，输入的密码加密后，是否与保存在SharedPreferences中一致 &#125;else if(md5Psw.equals(spPsw))&#123; //一致登录成功 Toast.makeText(LoginActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); //保存登录状态，在界面保存登录的用户名 定义个方法 saveLoginStatus boolean 状态 , userName 用户名; saveLoginStatus(true, userName); //登录成功后关闭此页面进入主页 Intent data=new Intent(); //datad.putExtra( ); name , value ; data.putExtra(&quot;isLogin&quot;,true); data.putExtra(&quot;userName&quot;,userName); //RESULT_OK为Activity系统常量，状态码为-1 // 表示此页面下的内容操作成功将data返回到上一页面，如果是用back返回过去的则不存在用setResult传递data值 setResult(RESULT_OK,data); //销毁登录界面 LoginActivity.this.finish(); //跳转到主界面，登录成功的状态传递到 MainActivity 中 //startActivity(new Intent(LoginActivity.this, MainActivity.class)); return; &#125;else if((spPsw!=null&amp;&amp;!TextUtils.isEmpty(spPsw)&amp;&amp;!md5Psw.equals(spPsw)))&#123; Toast.makeText(LoginActivity.this, &quot;输入的用户名和密码不一致&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else&#123; Toast.makeText(LoginActivity.this, &quot;此用户名不存在&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125; /** *从SharedPreferences中根据用户名读取密码 */ private String readPsw(String userName)&#123; //getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); //&quot;loginInfo&quot;,mode_private; MODE_PRIVATE表示可以继续写入 SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //sp.getString() userName, &quot;&quot;; return sp.getString(userName , &quot;&quot;); &#125; /** *保存登录状态和登录用户名到SharedPreferences中 */ private void saveLoginStatus(boolean status,String userName)&#123; //saveLoginStatus(true, userName); //loginInfo表示文件名 SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //获取编辑器 SharedPreferences.Editor editor=sp.edit(); //存入boolean类型的登录状态 editor.putBoolean(&quot;isLogin&quot;, status); //存入登录状态时的用户名 editor.putString(&quot;loginUserName&quot;, userName); //提交修改 editor.commit(); &#125; /** * 注册成功的数据返回至此 * @param requestCode 请求码 * @param resultCode 结果码 * @param data 数据 */ @Override //显示数据， onActivityResult //startActivityForResult(intent, 1); 从注册界面中获取数据 //int requestCode , int resultCode , Intent data // LoginActivity -&gt; startActivityForResult -&gt; onActivityResult(); protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; //super.onActivityResult(requestCode, resultCode, data); super.onActivityResult(requestCode, resultCode, data); if(data!=null)&#123; //是获取注册界面回传过来的用户名 // getExtra().getString(&quot;***&quot;); String userName=data.getStringExtra(&quot;userName&quot;); if(!TextUtils.isEmpty(userName))&#123; //设置用户名到 et_user_name 控件 et_user_name.setText(userName); //et_user_name控件的setSelection()方法来设置光标位置 et_user_name.setSelection(userName.length()); &#125; &#125; &#125;&#125; 回顾包结构哦~ 挑战任务检验登录和注册模块。请修改MainActivity和LoginActivity，欢迎界面调转入主界面后，自动跳转入登录界面，登录成功后，返回主界面，在主界面的Hello World位置显示：用户名+“登录成功”。 总结这是走好Android的第二步！]]></content>
      <categories>
        <category>教育系统APP</category>
      </categories>
      <tags>
        <tag>教育系统APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育系统APP(一)]]></title>
    <url>%2F2018%2F04%2F21%2F1%2F</url>
    <content type="text"><![CDATA[AndroidStudio制作欢迎界面与应用图标 &amp; Android-如何显示版本号并制作3秒跳转页本项目使用Android Studio 3.0.1作为开发工具，完成第一个任务。今天做点击APP，进入欢迎界面，三秒后跳转主页，显示Helloworld，即可大功告成。点击APP的应用图标需要更换，不许使用系统默认图标。 欢迎界面与应用图标，显示版本号并制作3秒跳转页 学习目标掌握欢迎界面与应用图标以及显示版本号并制作3秒跳转页的效果功能。 包结构： 需要创建一个 SplashActivity.java 的类，和一个 activity_splash.xml 的布局文件。 需要两种图片 app_icon.png 以及 launch_bg.png ,把它们放入到 drawable 文件夹中。 activity_splash.xml创建了一个activity_splash.xml布局文件，为欢迎界面布局，首先修改为 RelativeLayout 布局 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--添加一张欢迎界面的背景--&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width = &quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/launch_bg&quot;&gt; &lt;!--显示版本号--&gt; &lt;TextView android:id=&quot;@+id/tv_version&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;14sp&quot; android:layout_centerInParent=&quot;true&quot;/&gt;&lt;/RelativeLayout&gt; SplashActivity.java创建 SplashActivity.java 类，欢迎界面实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.edu.gdmec.android.boxuegu;import android.content.Intent;import android.content.pm.ActivityInfo;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.widget.TextView;import java.util.Timer;import java.util.TimerTask;public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); //设置此界面为 // 竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); init(); &#125; private void init() &#123; TextView tv_version = findViewById(R.id.tv_version); try &#123; PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),0); tv_version.setText(&quot;version:&quot;+packageInfo.versionName); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); tv_version.setText(&quot;version&quot;); &#125; //利用timer让此界面延迟3秒后跳转，timer有一个线程，该线程不断执行task Timer timer = new Timer(); TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; //发送intent实现页面跳转，第一个参数为当前页面的context，第二个参数为要跳转的主页 Intent intent = new Intent(SplashActivity.this,MainActivity.class); startActivity(intent); //跳转后关闭当前欢迎页面 SplashActivity.this.finish(); &#125; &#125;; //调度执行timerTask，第二个参数传入延迟时间（毫秒） timer.schedule(timerTask,3000); &#125;&#125; AndroidManifest.xml在清单文件 AndroidManifest.xml 中配置欢迎界面，将应用入口修改为欢迎界面，再去除 ActionBar 效果 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;cn.edu.gdmec.android.boxuegu&quot;&gt; &lt;!--原为android:theme=&quot;@style/AppTheme&quot;--&gt; &lt;!--去除ActionBar标题栏--&gt; &lt;!--添加应用图标，app_icon--&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/app_icon&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt; &lt;activity android:name=&quot;.SplashActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--添加实现类--&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 总结这是走好Android的第一步！ 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>教育系统APP</category>
      </categories>
      <tags>
        <tag>教育系统APP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发工程师]]></title>
    <url>%2F2018%2F04%2F20%2F1%2F</url>
    <content type="text"><![CDATA[Java开发工程师掌握要点 JAVA软件工程师/高级软件工程师（1）熟练java语言，具有一定的软件工程基础； （2）可根据开发规范与流程独立完成程序的设计、编码、测试以及相关文档； （3）可对系统进行分析、设计、调优； （4）具有良好的解决问题、Debug能力； （5）具有良好沟通能力和编码习惯。 内容 Java语言的形成与发展，Java语言特点，Java程序工作方式，JDK实用程序，Java程序类型，Java语言编码规范 Java程序的结构，表达式规则，流程控制语句，数组与字符串 面向对象求解概述，类与对象，类的组合与嵌套，继承，多态 静态变量和静态方法，抽象类和抽象方法，最终类和最终方法，包，修饰符和访问控制，接口 Java类库，Java语言包（java.lang），Java实用程序包（java.util），Java文本包（java.text），Java数学包（java.math） 程序异常概念，异常与异常类，异常处理，异常处理原则 Java流式输入输出概述，字节流类，字符流类，缓冲流类，对象流类，文件操作 数据库基础知识，建立Access数据库实例，SQL语言入门，JDBC与数据库访问 案例提出，案例分析，类的设计，编码实现 JDK开发工具，Eclipse继承开发环境 总结 本文讲了AndroidStudio环境安装与配置，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发进阶从小工到专家前言]]></title>
    <url>%2F2018%2F04%2F19%2F1%2F</url>
    <content type="text"><![CDATA[前言点击来看的朋友，这本书很好，可以作为一个秘籍作为保存。笔记记录为了更好的学习。目录： 四大组件 UI-View与动画 APP多线程 HTTP网络请求 SQLite数据库 性能优化 代码规范 Git版本控制 单元测试 六大原则与设计模式 重构 从码农练成工程师这本书共有12章。]]></content>
      <categories>
        <category>Android开发进阶从小工到专家读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发进阶从小工到专家读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发工程师文集-Android知识点讲解]]></title>
    <url>%2F2018%2F04%2F18%2F1%2F</url>
    <content type="text"><![CDATA[前言Android开发工程师文集-Android知识点讲解-记录美好生活 WebView讲解一般通过Intent调用系统的浏览器：123Uri uri = Uri.parse(url);Intent intent = new Intent(Intent.ACTION_VIEW,uri);startActivity(intent); 什么是WebView，其实单词的字面理解就可以了，可以知道Android中提供了这个元素来显示页面。 接下来，需要你创建布局文件，关于WebView的即可：12345&lt;WebView android:id=&quot;@+id/WebView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&lt;/WebView&gt; 如果用到WebView，就要用到loadUrl()的方法来进行调用，加载我们所需的页面。这个方法可以调用web资源，也可以调用本地我们直接写好的资源。1231. webView.loadUrl(&quot;http://janshu.com&quot;);2. webView.loadUrl(&quot;本地资源&quot;);3. webView.requestFocus(); 这个是什么意思呢，表示直接打开 webView.setWebViewClient(new WebViewClient());1234public boolean shouldOverrideUrlLoading(WebView view,String url)&#123; view.loadUrl(url); return true;&#125; 使用Javascript打开123WebView webView = findViewById(R.id.webview);WebSttings webSettings = webView.getSettings();webSettings.setJavaScriptEnabled(true); 了解一下onKeyDown()的方法,进行退出程序：12345678910111213public boolean onKeyDown(int keyCode, keyEvent event)&#123; if(keyCode==KeyEvent.KEYCODE_BACK)&#123; if(webView.canGoBack())&#123; webView.goBack(); return true; &#125; else &#123; System.exit(0);//退出程序 &#125; &#125; return super.onKeyDown(keyCode, event);&#125; 用下面的来显示加载过程： setWebChromeClient()-&gt;new WebChromeClient() ProgressDialog开启进度条的显示：12345678910private void openDialog(int newProgress)&#123; if(dialog==null)&#123; dialog=new ProgressDialog(MainActivity.this); dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTL); dialog.setProgress(newProgress); dialog.show(); &#125; else&#123; dialog.setProgress(newProgress);&#125; 关闭进度条：123456private void closeDialog()&#123; if(dialog!=null&amp;&amp;dialog.isShowing())&#123; dialog.dismiss(); dialog=null; &#125;&#125; Fragment12FragmentManager fragmentManager = getFragmentManager();FragementTransaction beginTransaction = fragmentManager.beginTransaction(); 动态是最常用的，可以通过add(),remove(),replace(),commit(),addToBackStack()的方法处理Fragment Fragment的生命周期它的生命周期会受到Activity的影响 启动Fragment: onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() 关掉： onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume()onPause()-&gt;onStop() 重启： onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume()onPause()-&gt;onStop()onStart()-&gt;onResume() 启动第二个Fragment: onPause()-&gt;onStop()-&gt;onDestroyView()-&gt;onDestroy()-&gt;onDetach()-&gt;onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() 顶部导航ViewPager12345&lt;android.support.v4.view.ViewPager android:id=&quot;@+id/pager&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot;/&gt; 如果觉得不错，那就点个赞吧！❤️ 总结 Android开发工程师文集-Android知识点讲解-记录美好生活，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android开发工程师文集</category>
      </categories>
      <tags>
        <tag>Android开发工程师文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android精通教程V]]></title>
    <url>%2F2018%2F04%2F12%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Android精通教程V的概述，希望你们喜欢 前言如果你想学习Android开发，那你就要了解Java编程，这是基础，也是重点，如果没学Java语法就先学习，再来学Android，别问可不可以先学Android，都告诉了，先学Java对吧！ Android开发的基本了解Android开发主要了解这四种重要组件： activity为用户界面，就是说activity可以构成用户界面。 ContentProvider是为了设备中存储的数据，通过创建ContentProvider来实现数据共享。 Service是运行在后台的任务，无需用户直接与之交互。 Intent是一种行为描述机制（如选择照片，打电话等）。在Android中，几乎一切都是通过Intent来实现的，这给我们提供了大量替换或重用组件的机会。描述Android项目结构AndroidManifest.xml：是一个xml文件，描述了被构建的应用程序。assets：文件夹是为了存放需要打包到应用程序的静态文件。bin：文件夹是为了存放编译过后的应用程序。gen：文件夹为了存放生成的源代码。libs：文件夹是存放第三方包的jar文件。src：文件夹是程序的Java源代码。res：文件夹存放的是应用程序的资源。在res文件夹中：res/drawable/：存放的是图像res/layout/：存放是基于xml的文件。res/menu/：存放的是基于xml的菜单文件。res/raw/：存放的是通用的文件。res/valuse/：存放的是字符串。res/xml/：是通用的xml的文件。在bin文件夹中：bin/classes/：存放的是编译后的Java类文件。在AndroidManifest.xml文件中：1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;cn.edu.gdmec.android.androidstudiodemo&quot;&gt; &lt;!--原为android:theme=&quot;@style/AppTheme&quot;--&gt; &lt;!--去除ActionBar标题栏--&gt; &lt;!--添加应用图标，app_icon--&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/app_icon&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--添加实现类--&gt; &lt;activity android:name=&quot;.######&quot;&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 了解一下build.gradle(app)12345678910111213141516171819202122232425262728apply plugin: &apos;com.android.application&apos;android &#123; compileSdkVersion 26 defaultConfig &#123; applicationId &quot;cn.edu.gdmec.android.androidstudiodemo&quot; minSdkVersion 19 targetSdkVersion 26 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;&#125; 了解基本布局的部件TextView：了解android:typeface,android:textStyle,android:textColor.EditText：编辑框android:autoText,android:capitalize,android:digitas,android:singleLine.内边距：android:paddingLeft,android:paddingRight,android:paddingTop,android:paddingBottomRelativeLayout布局：android:layout_alignParentTop,android:layout_alignParentBottom,android:layout_alignParentLeft,android:layout_alignParentRight,android:layout_centerHorizontal,android:layout_centerVertical,android:centerHorizontal,android:layout_centerInParent.android:layout_above,android:layout_below,android:layout_toLeftOf,android:layout_toRightOf,android:layout_alignTop, android:layout_alignBottom,android:layout_alignLeft,android:layout_alignRight,android:layout_alignBaseline.TableLayout布局：android:stretchColumns,android:shrinkColumns,android:collapseColumns.1234567891011121314151617181920212223242526//TableLayout&lt;TableLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:stretchColumns=&quot;1&quot;&gt; &lt;TableRow&gt; &lt;TextView android:text=&quot;姓名:&quot;/&gt; &lt;EditText android:id=&quot;@+id/xm&quot; android:layout_span=&quot;3&quot;/&gt; &lt;/TableRow&gt; &lt;View android:layout_height=&quot;2px&quot; android:background=&quot;#000000&quot;/&gt; &lt;TableRow&gt; &lt;Button android:id=&quot;@+id/xx&quot; android:layout_column=&quot;2&quot; android:text=&quot;消除&quot;/&gt; &lt;Button android:id=&quot;@+id/submit&quot; android:text=&quot;发送&quot;/&gt; &lt;/TableRow&gt;&lt;/TableLayout&gt; 适配器12Sting[] items=&#123;&quot;h&quot;,&quot;j&quot;,&quot;k&quot;,&quot;a&quot;,&quot;s&quot;,&quot;d&quot;,&quot;b&quot;&#125;;new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,items); 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayoutxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot;android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt;&lt;TextView android:id=&quot;@+id/selection&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;ListView android:id=&quot;@android:id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:drawSelectiorOnTop=&quot;false&quot;/&gt;&lt;/LinearLayout&gt; 1234567891011121314public class ListViewDemo extends ListActivity&#123; TextView selection; String[] items=&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setListAdapter(new ArrayAdapter&lt;String&gt;(this,android.R.layout_simple_list_item_1,items)); selection= findViewById(R.id.selection);&#125; public void onListItemClick(ListView parent,View v,int position,long id)&#123; selection.setText(items[position]); &#125;&#125; 网格GridView：android:numColumns,android:verticalSpacing,android:horizontalSpacing,android:columnWidth,android:stretchMode.1234567891011121314151617//适配器&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;TextView android:id=&quot;@+id/selection&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;AutoCompleTextView android:id=&quot;@+id/auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:completionThreshold=&quot;3&quot;/&gt;&lt;/LinearLayout&gt; 1234567891011121314151617public class AutoCompleteDemo extends Activity implements TextWatcher&#123; TextView selection; AutoCompleteTextView auto; String[] items=&#123;&quot;aaav&quot;,&quot;bbbv&quot;,&quot;cccv&quot;,&quot;dddv&quot;,&quot;eeev&quot;,&quot;fffv&quot;,&quot;gggv&quot;&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); selection=findViewById(R.id.selection); auto=findViewById(R.id.auto); auto.addTextChangedListener(this); auto.setAdapter(new ArrayAdapter&lt;String&gt;(this,android.R.layout_simple_item_1,items));&#125; public void onTextChanged(CharSequence s, int start, int before, int count)&#123; selection.setText(auto.getText());&#125;&#125; GalleryGallery：android:spacing,android:spinnerSelector,android:drawSelectorOnTop123456789101112131415161718192021//适配器&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://echema.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt;&lt;ImageView android:id=&quot;@+id/icon&quot; android:layout_width=&quot;20px&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;2px&quot; android:paddingRight=&quot;2px&quot; android:paddingTop=&quot;2px&quot; android:src=&quot;@drawable/image&quot;/&gt;&lt;TextView android:id=&quot;@+id/label&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;20sp&quot;/&gt;&lt;/LinearLayout&gt; 1234567891011121314public class Demo extends ListActivity&#123; TextView selection; String[] items = &#123; &quot;aaaa&quot;,&quot;asdg&quot;,&quot;bsdes&quot;,&quot;slfl&quot;,&quot;wete&quot;,&quot;wetwd&quot;,&quot;sdfefs&quot;&#125;;@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setListAdapter(new ArrayAdapter&lt;String&gt;(this, R.layout.simple,R.id.label,items)); selection=findViewById(R.id.selection);&#125;public void onListItemClick(ListView parent,View v,int position,long id)&#123; selection.setText(items[position]); &#125;&#125; 1234567891011121314151617181920212223242526//动态的列表public class Demo extends ListActivity&#123; TextView selection; String[] items = &#123; &quot;aaaa&quot;,&quot;asdg&quot;,&quot;bsdes&quot;,&quot;slfl&quot;,&quot;wete&quot;,&quot;wetwd&quot;,&quot;sdfefs&quot;&#125;;@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setListAdapter(new IconAdapter()); selection=findViewById(R.id.selection);&#125;public void onListItemClick(ListView parent,View v,int position,long id)&#123; selection.setText(items[position]); &#125;class IconAdapter extends ArrayAdapter &#123; IconAdapter()&#123; super(Demo.this,R.layout.simple,items); &#125; public View getView(int position, View convertView, ViewGrop parent)&#123; LayoutInflater inflater=getLayoutInflater(); View simple = inflater.inflate(R.layout.simple,parent,false); TextView label=simple.findViewById(R.id.simple); label.setText(items[position]); ImageView icon = simple.findViewById(R.id.icon); icon.setImageResource(R.drawable.icon);&#125; 日期与时间DatePicker和DatePickerDialog-&gt;DatePickerDialog–&gt;OnDateChangedListener和OnDateSetListenerTimePicker和TimePickerDialog-&gt;TimePickerDialog–&gt;OnTimeChangedListener和OnTimeSetListener主要示例代码：1Calendar dateTime = Calendar.getInstance(); 123456789//日期DatePickerDialog.OnDateSetListener d=new DatePickerDialog.OnDateSetListener()&#123; public void onDateSet(DatePicker view, int year, int monthOfYear, int dayOfMonth)&#123; dateTime.set(Calendar.YEAR,year); dateTime.set(Calendar.MONTH,monthOfYear); dateTime.set(Calendar.DAY_OF_MONTH,dayOfMonth); updateLabel(); &#125;&#125;; 12345678//时间TimePickerDialog.OnTimeSetListener t=new TimePickerDialog.OnTimeSetListener()&#123; public void onTimeSet(TimePicker view, int hourOfDay, int minute)&#123; dateTime.set(Calendar.HOUR_OF_DAY,hourOfDay); dateTime.set(Calender.MINUTE,minute); updateLabel(); &#125;&#125;; 1234567//日期的点击按钮Button btn=findViewById(R.id.date);btn.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v)&#123; new DatePickerDialog(Demo.this,d,dateTime.get(Calendar.YEAR),dateTime.get(Calendar.MONTH),dateTime.get(Calendar.DAY_OF_MONTH)).show(); &#125;&#125;); 1234567//时间的点击按钮Button btn=findViewById(R.id.time);btn.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v)&#123; new TimePickerDialog(Demo.this,t,dateTime.get(Calendar.HOUR_OF_DAY),dateTime.get(Calendar.MINUTE),true).show(); &#125;&#125;); 12//显示CalendardateTimetv.getTime();// dtl.format(); 创建时钟DigitalClock或AnalogClock12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;AnalogClock android:id=&quot;@+id/analogclock&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_alginParentTop=&quot;true&quot;/&gt; &lt;DigitalClock android:id=&quot;@+id/digitalclock&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_below=&quot;@id/analogclock&quot;/&gt;&lt;/RelativeLayout&gt; 进度条（android.widget.ProgressBar）进度条可以是水平的，也可以是旋转轮，你可以用incrementProgressBy()来增加进度，也可以用setProgress()来增加进度。 进度条有很多样式，Android提供了这些： Widget.ProgressBar.Horizontal Widget.ProgressBar.Small Widget.ProgressBar.Large Widget.ProgressBar.Inverse等。 android.widget.SeekBar这个是ProgressBar的扩展，这个是可以滑动选择的进度形式。 用户可以通过 SeekBar.OnSeekBarChangeListener来操作滑块的位置。 适配器-android.widget.Adapter它的子类有：arrayadapter,baseadpter,cursoradapter,listadapter,simpleadapter,spinneradapter WebViewandroid.webkit.WebView这里的WebView是显示网页的视图，当我们要在WebView中加载网页的时候，，我们要在android manifest.xml中添加权限。1&lt;uses-permission android：name = “android.permission.INTERNET” /&gt; 如何用代码，以下显示：123Uri uri = Uri.parse(url);Intent intent = new Intent(Intent.ACTION_VIEW, uri);startActivity(intent); 显示12WebView webview = new WebView(this); setContentView(webview); 进行加载：1webview.loadUrl(url); 显示框1234567public void onClick(View view)&#123; if(view==button1)&#123; new AlertDialog.Builder(this).setTitle(&quot;Message&quot;).setMessage(&quot;ok&quot;).setNeutralButton(&quot;Close&quot;, new DialogInterface.OnClickListener()&#123; public void onClick(DialogInterface dialog, int in)&#123; &#125; &#125;).show();&#125; 总结 本文讲了Android精通教程V，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android精通教程</category>
      </categories>
      <tags>
        <tag>Android精通教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发工程师文集-Activity生命周期，启动方式，Intent相关介绍，Activity详细讲解]]></title>
    <url>%2F2018%2F04%2F11%2F1%2F</url>
    <content type="text"><![CDATA[作为一个Activity，就是一个界面，当我们在手机上打开一个APP时，你看到的页面就是基于Activity生成的。 前言大家好，我是 Vic，今天给大家带来Android开发工程师文集-Activity生命周期，启动方式，Intent相关介绍，Activity详细讲解的概述，希望你们喜欢 Activity是什么作为一个Activity，就是一个界面，当我们在手机上打开一个APP时，你看到的页面就是基于Activity生成的。 那么你再点击一个按钮跳转到另一个界面时，就是又一个Activity界面，由Activity可以分出很多的知识点。 如，Activity的生命周期，activity的启动方式，还有如果两个activity的数据交互，就是页面和页面之间的数据交互，如，你在另一个界面上输入的数据，保存到另一个页面上，进行显示效果；activity的启动相关知识。 activity生命周期逻辑首先调用onCreate()的方法来创建一个Activity，然后调用onStart()的方法和onResume()的方法，我们才能看到创建的界面。如：activity -&gt; onCreate()-onStart()-onResume()凡是调用完这三个方法，才能看见页面即是activity。12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);&#125;@Overrideprotected void onStart()&#123; super.onStart();&#125;@Overrideprotected void onResume()&#123; super.onResume();&#125; 12345678910111213141516@Overrideprotected void onRestart()&#123; super.onRestart();&#125;@Overrideprotected void onPause()&#123; super.onPause();&#125;@Overrideprotected void onStop()&#123; super.onStop();&#125;@Overrideprotected void onDestroy()&#123; super.onDestroy();&#125; 如果点击back，就是手机上有个返回键，回退，那么会启动那些方法呢，答，会启动 onPause()-&gt;onStop()-&gt;onDestroy()方法。然后你打开的界面就会退回你打开界面时之前的效果，就是返回到你没点击APP手机页面效果。 整个启动到退回(从创建到销毁)：onCreate()-&gt;Created-&gt;onStart()-&gt;Started-&gt;onResume()-&gt;Resumed-&gt;onPause()-&gt;Paused-&gt;onStop()-&gt;Stopped-&gt;onDestroy()-&gt;Destroyed onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestory() 可见状态：onCreate()-&gt;onStart()-&gt;onResume() 不可见状态：onPause()-&gt;onStop() 销毁状态：onDestory() 从一个页面跳转到另一个页面两个activity进行交互，周期是怎么样的呢，交互就是一个页面跳转到另一个页面效果。 调用了哪些方法：MainActivity onCreate()-&gt;MainActivity onStart()-&gt;MainActivity onResume()-&gt;MainActivity() onPause()-&gt;SecondActivity onCreate()-&gt;SecondActivity onStart()-&gt;SecondActivity onReume()-&gt;MainActivity onStop() 这样更看得懂了哦~MainActivity onCreate()-&gt;MainActivity onStart()-&gt;MainActivity onResume()MainActivity() onPause()SecondActivity onCreate()-&gt;SecondActivity onStart()-&gt;SecondActivity onReume()MainActivity onStop() 如果显示第二个页面，再点击back，那么就会回到第一个界面了。 那么这个过程调用了什么方法：SecondActivity onPause()-&gt;MainActivity onRestart()-&gt;MainActivity onStart()-&gt;MainActivity onResume()-&gt;SecondActivity onStop()-&gt;SecondActivity onDestroy() 这样更看得懂了哦~MainActivity onCreate()-&gt;MainActivity onStart()-&gt;MainActivity onResume()MainActivity() onPause()SecondActivity onCreate()-&gt;SecondActivity onStart()-&gt;SecondActivity onReume()MainActivity onStop()SecondActivity onPause()MainActivity onRestart()-&gt;MainActivity onStart()-&gt;MainActivity onResume()SecondActivity onStop()-&gt;SecondActivity onDestroy() 在这里你会注意到 onPause() 这个方法，当跳转到别的界面的时候，会先调用onPause()的方法，MainActivity跳转到SecondActivity时会先调用 MainActivity onPause()的方法，那么SecondActivity跳转到MainActivity的时候回用 SecondActivity onPause()的方法。 问：如果在这里你会问 onRestart()的这个方法，你这个靠英语理解一下就可知道的，重新启动，那么会问为什么不onCreate()的方法，因为MainActivity()的这个已经创建了，所以就不用而用onRestart()的方法。 onPause()这个方法是代表停止状态，如果第一个界面跳转另一个界面，先停止第一个界面的状态，这样另一个界面的打开，就会保证了没有第一个界面的如何效果，因为被暂停了嘛。 MainActivity onStop()放在 SecondActivity onCreate() 之前会导致什么呢，会出现闪退效果的。onStop()调用，后台运行，不会销毁。 竖屏与横屏周期什么是竖屏与横屏周期，就是手机上有横屏看，和竖屏看的效果，周期也是有不一样的。 调用的方法，由竖屏变化横屏：onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestory()onCreate()-&gt;onStart()-&gt;onResume() 竖屏与横屏切换会闪屏效果，这是创建到销毁到创建的效果。 Activity的启动方式一种是直接，一种是匿名。不同的启动方式有什么不同的效果呢。 直接启动方式：12Intent intent = new Intent(MainActivity.this,SecondActivity.class):startActivity(intent); 当使用隐式时，我们需要知道如何处理它。 setComponent(ComponentName) 跳转浏览器12345Intent intent = new Intent();intent.setAction(Intent.ACTION_VIEW);Uri url = Uril.parse(&quot;http://jianshu.com&quot;);intent.setData(url);startActivity(intent); 跳转相册1234Intent intent = new Intent();intent.setAction(Intent.ACTION_GET_CONTENT);intent.setType(&quot;image/*&quot;);startActivity(intent); 发送信息12345Intent intent = new Intent();intent.setAction(Intent.ACTION_SEND);intent.setType(&quot;text/plain&quot;);intent.putExtra(Intent.EXTRA_TEXT,&quot;I am a vic&quot;):startActivity(intent); 打开电话12345Intent intent = new Intent();intent.setAction(Intent.ACTION_VIEW);Uri url=Uri.parse(&quot;tel:123456789&quot;);intent.setData(url):startActivity(intent); Intent相关介绍Intent是要执行的操作的抽象描述。 ACTION_VIEW：显示关于标识符为“1”的人的信息tel：123 - 显示填入给定号码的电话拨号程序type ：数据的显式类型ACTION_ANSWER：处理来电ACTION_BATTERY_LOW：设备电池电量不足ACTION_GET_CONTENT：允许用户选择特定类型的数据并将其返回ACTION_HEADSET_PLUG：插入有线耳机或拔下插头setData：设置数据setAction ：设置要执行的一般操作等。 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了Android开发工程师文集-Activity生命周期，启动方式，Intent相关介绍，Activity详细讲解，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android开发工程师文集</category>
      </categories>
      <tags>
        <tag>Android开发工程师文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jeskson]]></title>
    <url>%2F2018%2F04%2F10%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 记录 AndroidAndroid基础知识FragmentActivityService广播BinderWebView安全漏洞 异步消息处理机制 HandlerIntentServiceAsyncTaskHandlerThread View相关技术View的渲染和绘制事件分发ListView Android构建Android编译打包Proguard混淆GitGradle渠道包 开源框架源码网络框架：Retrofit,Okhttp,Volley图片框架：Glide,Fresco,UILIOC框架：Dagger2,Butterknife 热门前言Android插件化RxJavaAndroid热更新进程保活 技术要求和面试前的准备良好的开发习惯独立思考的能力主动并且善于沟通 掌握1.熟悉常用的设计模式，数据结构； 2.有Android软件开发经营，熟悉Android移动端开发技术； 3.有扎实的Java语言基础，熟悉掌握Android各种UI布局和控件，能够熟悉自定义UI控件； 4.熟悉掌握HTTP以及Socket编程，对Android程序性能优化，内存优化有一定的经验。 高级基本知识点 深入知识点 基本知识点的细节 系统核心机制 面试要求1.礼貌：态度谦虚2.听懂问题直接回答 感悟按照简历 AndroidAndroid职业教程Android UiAutomator2.0入门实战与Android的第一次亲密接触超快的Android模拟器GenymotionAndroid-重识activityAndroid面试解密-Layout_weightAndroid-Widget桌面小组件Android的各种Drawable讲解Android基础-初始SQLiteAndroid攻城狮的第一，二，三门课 微信小程序微信小程序开发入门教程 自学网极客学院小程序视频教程入门微信小程序开发https://www.imooc.com/learn/974微信小程序入门与实战 常用组件API开发技巧项目实战 数据库MySQL开发技巧（一） 技能浅谈搜索引擎_SEO 前端响应式布局bootstrap快速入门css定位 position十天精通CSS3基于bootstrap的网页开发ES6快速入门JavaScript入门篇 后端Spring入门篇]]></content>
      <categories>
        <category>Jeskson</category>
      </categories>
      <tags>
        <tag>Jeskson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发工程师文集-1小时学会Widget小组件开发]]></title>
    <url>%2F2018%2F04%2F10%2F1%2F</url>
    <content type="text"><![CDATA[Web Widget,中文译名被称作是微件,是一小块可以在任意一个基于HTML的Web页面上执行的代码，它的表现形式可能是视频，地图，新闻，小游戏等等。它的根本思想来源于代码复用，通常情况下，Widget的代码形式包含了DHTML,JavaScript以及Adobe Flash。 前言大家好，我是 Vic，今天给大家带来Android开发工程师文集-1 小时学会Widget小组件开发的概述，希望你们喜欢 学会用Widget (小组件)Widget小组件很方便，很快捷，可以个性化，自己定制，相关功能，可以实时更新最新内容。 Widget布局，Widget配置，AppWidgetProvider与Configuration Activity Android Widget xml布局类型：AppWidget Provider123456789&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; //引用的布局文件 android:initialLayout=&quot;@layout/widget&quot; android:minHeight=&quot;50dp&quot; android:minWidth=&quot;100dp&quot; //设置更新时间 android:updatePerioMillis=&quot;66666666&quot;&gt;&lt;/appwidget-provide&gt; 12345678910111213141516171819202122public class WidgetProvider extends AppWidgetProvider &#123; @Override public void onDeleted(Context context,int[] appWidgetIds)&#123; super.onDeleted(context,appWidgetIds);&#125; @Override public void onDisabled(Context context)&#123; super.onDisabled(context); &#125; @Override public void onEnabled(Context context)&#123; super.onEnabled(context); &#125; @Override public void onReceive(Context context,Intent intent)&#123; super.onReceive(context,intent); &#125; @Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds)&#123; super.onUpdate(context,appWidgetManager,appWidgetIds);&#125;&#125; 123456789101112131415161718//TimerService extends ServiceTimer timer=new Timer();timer.shedule(new TimerTask()&#123; @Override public void run()&#123; updateTime(); &#125; &#125;,0,1000);&#125;//onDestroypublic void onDestroy()&#123; super.onDestroy(); timer=null;&#125;//updateTime();private void updateTime()&#123; String time = simpletime.format(new Date());&#125; Widget就是个桌面小组件，有了Widget，我们可以直接在桌面上进行各种操作。 Widget使用 AndroidManifest中声明AppWidget xml中定义AppWidget配置文件 layout中定义Widget布局文件 创建类继承AppWidgetProvider类 1234//清单文件中&lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@layout/widget_setting&quot;/&gt; 12345678910111213//onUpdate()重点@Overridepublic void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; super.onUpdate(context, appWidgetManager, appWidgetIds); RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); //Intent intent = new Intent(); Intent intent = new Intent(); intent.setClass(context, TestWidget.class); intent.setAction(WIDGET_BTN_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0); remoteViews.setOnClickPendingIntent(R.id.widget_btn, pendingIntent); appWidgetManager.updateAppWidget(appWidgetIds, remoteViews); &#125; 123456//清单文件 &lt;intent-filter&gt; &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@xml/widget_provider&quot;/&gt; 总结 本文讲了Android开发工程师文集-1 小时学会Widget小组件开发，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android开发工程师文集</category>
      </categories>
      <tags>
        <tag>Android开发工程师文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语1]]></title>
    <url>%2F2018%2F04%2F09%2F1%2F</url>
    <content type="text"><![CDATA[翻译： 由于互联网的广泛使用和计算机技术的发展，因特网对通信方式产生了很大的影响。如图所示尽管我们面对的事实是互联网对我们面对吗的接触造成了威胁，但我仍然认为电子通信不能代替面对面的合作。 我认为有三个原因可以解释我的论点，首先，人们脸上的表情起着关键的作用，真实地传达人们感情。从表情上看，人们不是更多的误解。其次，面对面的接触提供了一个很好的机会来进行直接的眼神交流，这就保证了谈话的真实性。最后，与面对面的交流帮助父母了解他们的孩子，并促进亲子关系，不可否认的是，互联网消除了距离的障碍，给我们的日常交流带来了极大的便利。但是电子通讯毕竟不能代替面对面的交流。 Can Electronic Communication Replace Face-to-Face Contact?Due to the wide use of Internet and the development of computer technology, the Internet hes greatly affected the ways of communication.As is vividly depicted in the picture, although we are confronting the face that the Internet has posed a threat to our face-to-face contact, I still believe electronic communication cannot replace face-to-face contact. Three reasons, I believe, can account for my argument.Firstly, expressions on people’s face play a key role in conveying people’s feelings truthfully. Judging from the expressions, People can have a better understanding about what people mean to express instead of more misunderstandings. Secondly, face-to-face contact offers a good opportunity to make a direct eye contact, which ensures the honesty of conversations. Lastly, contacting face-to-face helps parents know more about their children and facilitates parent-child relationship. Personally, there is no denying that the Internet eliminates the barrier of distance and brings great convenience to our daily communication. But electronic communication, after all, cannot take the place of face-to-face contact. 翻译1.I wrote my first finished story when I was about six. It was about a small animal, a rabbit, I mean. 当我六岁的时候，我写了第一个完整的故事，这个故事是关于一只小动物，也就是兔子的故事。 2.I consider myself very lucky indeed to be able to support myself by writing. 我感觉自己很幸运，因为我可以通过写作养活自己。 3.The ideas come first, so it really depends on the idea thar grabs me next. 首先是自己的想法，下本书真的取决于下个让自己着迷的想法。 4.I’ve no idea where the ideas came from and I hope I’ll never find out. 我不知道这些想法来源于哪儿，并且希望自己永远都不要发现。 5.In the study, teachers were not told the amount of sleep students received when completing weekly performance reports. 在研究中，当老师们在完成每周表现报告时，老师们不会被告知学生接受的睡眠数量。 6.”Just staying up late can cause increased academic difficulty and attention problems for otherwise healthy, well-functioning kids,” said Gahan Fallone. 对于健康正常的孩子来说，熬夜会增加学业困难以及注意力的问题。 7.The message is simple: Getting kids to bed on time is as important as getting them to school on time. 孩子准时上床睡觉与他们准时去上学一样重要。 8.Partricia Pania never wanted to be a national public figure. All she wanted to be was a mother and a homemaker. 她从没想要成为一个公众人物，她只想做一个母亲和家庭主妇。 9.But her life was turned upside down when a motorist, distracted by his cell phone, ran a stop sign and crashed into the side of her car. The impact killed her 2-year-old daughter. 但是她的生活被彻底颠覆了，一个开汽车的人受电话的影响而分心，在停车标志处没能停下来，撞到了她车的一边，使她两岁的女儿丧失生命。 10.In her first speech, Pania got off to a shaky start. She was visibly trembling and her voice was soft and uncertain. 在她第一次演讲时，她一开始就感到不安，明显在颤抖，而且声音很轻，并且不坚定。 11.Her campaign increased public awareness of the problem and prompted over 300 cities and several states to consider restrictions on cell phone use. 她的演讲增强了公众对该问题的认识，促使300多个城市和几个州考虑驾驶限制使用手机。 12.There’re actually hundreds of kinds of cold viruses out there. You never konw which one you will get, so there isn’t a cure for each one. 有成百上千种病毒存在，你从来都不知道你感染的是哪一种，因此并不是每种病毒都有一种治愈方法。 13.You fell terrible because you can’t breathe well, but your body is actually eating the virus. Your temperature rises and you get a fever, but the heat of your body is killing the virus. You also have a running nose to stop the virus from getting to your cells. You may feel miserable, but actually your wonderful body is doing everything it can to kill the cold. 你可能会感觉很痛苦，因为你不能很好地呼吸，但是你的身体正在努力杀死病毒，你温度升高，发烧了，但是你身体的温度正在杀死病毒，流鼻涕阻止病毒进入你的细胞，你可能感到很悲惨，但实际上你奇妙的身体正在尽一切可能杀死感冒病毒。 14.Some scientists say taking medicines when you have a cold is actually bad for you. 一些科学家认为感冒时吃药对身体确实不好。 要点 由空格前的 is very 判断空格处缺少形容词充当表语。 由空格前的 is no 可知空格处填入名词。 由 a 和后面的名词 level 可知，空格处为形容词。 由空格后的 and 可知，空格处应填写与textbooks,business letters并列的名词词组。 由and,空格与 compositions 一样，可数名词复数或不可数名词。 write ___ notes 填形容词。 由空格前完整句子，应为副词和介词短语充当句子状语。 a 空格为单数名词。 由空格前的that,后为定语从句，空格处缺少定语从句的谓语，因此填写动词或动词词组。 作文“Would you like tea or coffee?” This is that diners are often asked. Many westerners prefer coffee while Chinese people tend to choose tea. According to a legend, it is an ancient Chinese emperor who discovered the tea five thousand years ago and used it to treat illnesses. During the Ming and Qing Dynasties, tea houses were pervasive all over the country. Tea drinking was introduced into Japan in the 6th century, but it was not until the 17th century and 18th century that tea drinking was introduced into Europe and America. Nowadays, tea is one of the most popular beverage in the world. It is not noly a national drink of Chinese, but also an essential part of Chinese traditions and culture.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio制作“我”的界面，设置，修改密码，设置密保和找回密码]]></title>
    <url>%2F2018%2F04%2F07%2F1%2F</url>
    <content type="text"><![CDATA[学习目标 掌握修改密码功能的开发，和实现用户密码的修改； 掌握设置密保的功能开发，通过密保我们可以找回用户的密码，来保证用户的安全。 具体布局将不在展示，只说明一些功能模块的实现。 前言大家好，我是 Vic，今天给大家带来AndroidStudio制作“我”的界面，设置，修改密码，设置密保和找回密码的概述，希望你们喜欢学习目标 掌握修改密码功能的开发，和实现用户密码的修改； 掌握设置密保的功能开发，通过密保我们可以找回用户的密码，来保证用户的安全。 具体布局将不在展示，只说明一些功能模块的实现。 工具类对于一个项目来说，项目中将多次用到sharedPreferences共享参数，去存储用户的登录状态或清除登录状态，“我”的界面也要求用到读取用户姓名的方法，所以我们干脆把这三个方法都扔到AnalysisUtils里面吧。 在Utils包中新建一个Java类，名为AnalysisUtils。123456789101112131415161718192021222324public class AnalysisUtils &#123; //读取用户名 public static String readLoginUserName(Context context)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;,Context.MODE_PRIVATE); String userName=sharedPreferences.getString(&quot;loginUserName&quot;,&quot;&quot;); return userName; &#125; //读取登录状态 public static boolean readLoginStatus(Context context)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;,Context.MODE_PRIVATE); boolean isLogin=sharedPreferences.getBoolean(&quot;isLogin&quot;,false); return isLogin; &#125; //清除登录状态 public static void cleanLoginStatus(Context context)&#123; SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;loginInfo&quot;,Context.MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putBoolean(&quot;isLogin&quot;,false); editor.putString(&quot;loginUserName&quot;,&quot;&quot;); editor.commit(); &#125;&#125; 我的界面我的界面的头像部分，要实现两个功能： 打开“我”的界面后，要进行判断是否已登录，已登录显示用户名，未登录显示“点击登陆”。 头像点击后，会判断是否登录，如果登录了，则跳转到个人资料界面，如果没登录，则跳转到login登录的页面。 完成第一个功能onViewCreate()里写个if else判断语句，根据当前登录状态来显示同像下相应的文本。12345if (AnalysisUtils.readLoginStatus(getActivity()))&#123; tv_user_name.setText(AnalysisUtils.readLoginUserName(getActivity())); &#125;else &#123; tv_user_name.setText(&quot;点击登录&quot;);&#125; 登陆未登录时，点击登陆,打开登陆页面后，需要MainActivity更新状态并显示，所以用startActivityForResult()方法打开。 老样子，用startActivityForResult（）打开，MainActivity就要加上onActivityForResult()方法来执行响应。 接下来看看相关代码：123456789101112131415161718//onActivityResult(); @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); //判断从LoginActivity传过来登陆状态，并执行响应动作。 if (data!=null)&#123; boolean isLogin=data.getBooleanExtra(&quot;isLogin&quot;,false); //从登录活动获得isLogin==true,从设置活动获得isLogin==false，他们的请求码都是1 //之后还可以根据请求码和结果码完成更多需求 if (isLogin)&#123; //0 setSelectStatus(0); &#125;else &#123; //我 setSelectStatus(2); &#125; &#125;&#125; 退出清除登陆状态连续点击返回两次则退出，两次点击间隔超过2秒则提示再按一次退出。1234567891011121314151617181920 protected long exitTime; //给MainActivity加上退出清除登陆状态的方法。 // 连续点击返回两次则退出，两次点击间隔超过2秒则提示再按一次退出。 @Override public boolean onKeyDown(int keyCode,KeyEvent event)&#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN)&#123; if ((System.currentTimeMillis()-exitTime) &gt; 2000)&#123; Toast.makeText(MainActivity.this,&quot;再按一次退出博学谷&quot;,Toast.LENGTH_SHORT).show(); exitTime=System.currentTimeMillis(); &#125;else &#123; this.finish(); if (AnalysisUtils.readLoginStatus(this))&#123; AnalysisUtils.cleanLoginStatus(this); &#125; System.exit(0); &#125; return true; &#125; return super.onKeyDown(keyCode,event);&#125; 设置页面功能模块实例化：1234567891011121314151617private void initView()&#123; rl_modify_psw=findViewById(R.id.rl_modify_psw); rl_security_setting=findViewById(R.id.rl_security_setting); rl_exit_login=findViewById(R.id.rl_exit_login); //标题栏 title_bar=findViewById(R.id.title_bar); tv_back=findViewById(R.id.tv_back); tv_main_title=findViewById(R.id.tv_main_title); //给tv_main_title设置个文本，给title_bar加个背景 tv_main_title.setText(&quot;设置&quot;); title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;)); //添加监听器 tv_back.setOnClickListener(this); rl_modify_psw.setOnClickListener(this); rl_security_setting.setOnClickListener(this); rl_exit_login.setOnClickListener(this);&#125; 修改密码12345678910111213141516private void initView() &#123; //标题栏 title_bar=findViewById(R.id.title_bar); tv_back=findViewById(R.id.tv_back); tv_main_title=findViewById(R.id.tv_main_title); //modify et_original_psw=findViewById(R.id.et_original_psw); et_new_psw=findViewById(R.id.et_new_psw); et_new_psw_again=findViewById(R.id.et_new_psw_again); btn_save=findViewById(R.id.btn_save); //tv_main_title 修改密码 tv_main_title.setText(&quot;修改密码&quot;); //响应 btn_save.setOnClickListener(this); tv_back.setOnClickListener(this);&#125; 1234567891011121314151617181920212223242526272829303132333435private void submit() &#123; String psw=et_original_psw.getText().toString().trim(); String newPsw=et_new_psw.getText().toString().trim(); String again=et_new_psw_again.getText().toString().trim(); if (TextUtils.isEmpty(psw))&#123; Toast.makeText(this,&quot;请输入原始密码&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (!MD5Utils.md5(psw).equals(readPsw()))&#123; Log.i(&quot;MD5Utils.md5(psw)&quot;,&quot;&quot;+MD5Utils.md5(psw)); Log.i(&quot;readPsw&quot;,&quot;&quot;+readPsw()); Toast.makeText(this,&quot;输入的密码与原始密码不一致&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (MD5Utils.md5(newPsw).equals(readPsw()))&#123; Toast.makeText(this,&quot;输入的新密码与原始密码不能一致&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (TextUtils.isEmpty(psw))&#123; Toast.makeText(this,&quot;请输入密码&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (TextUtils.isEmpty(again))&#123; Toast.makeText(this,&quot;请再次输入新密码&quot;,Toast.LENGTH_SHORT).show(); &#125;else if (!newPsw.equals(again))&#123; Toast.makeText(this,&quot;再次输入的新密码不一致&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else &#123; Toast.makeText(this,&quot;新密码设置成功&quot;, Toast.LENGTH_SHORT).show(); modifyPsw(newPsw);// Intent intent=new Intent(ModifyPswActivity.this,LoginActivity.class); startActivity(intent); //关闭设置页面 //在submit方法中，密码修改成功之后除了把当前页面关了，还要把设置界面也关了，所以用到instance SettingActivity.instance.finish(); //关闭修改密码页面 ModifyPswActivity.this.finish(); &#125;&#125; 123456//modifypswString md5psw=MD5Utils.md5(newPsw);SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE);SharedPreferences.Editor editor = sharedPreferences.edit();editor.putString(userName,md5psw);editor.commit(); 123456//readPswSharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE);String spPsw=sharedPreferences.getString(userName,&quot;&quot;);Log.i(&quot;username&quot;,userName);Log.i(&quot;spPsw&quot;,spPsw);return spPsw; 设置密保和找回密码主要功能代码：1234567891011121314151617181920212223242526272829303132333435363738394041/** * 保存初始化密码 **/ private void savePsw(String name, String resetPsw)&#123; /*String md5Psw= MD5Utils.md5(&quot;123456&quot;); SharedPreferences sharedPreferences = getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); SharedPreferences.Editor editor = sharedPreferences.edit(); editor.putString(name,md5Psw); editor.commit();*/ String md5Psw = MD5Utils.md5(resetPsw); SharedPreferences sp = getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); editor.putString(name, md5Psw); editor.commit(); &#125; private boolean isExistUserName(String name)&#123; boolean hasUserName=false; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); String spPsw=sharedPreferences.getString(name,&quot;&quot;); if (!TextUtils.isEmpty(spPsw))&#123; hasUserName=true; &#125; return hasUserName; &#125; /** * 读取密保 **/ private String readSecurity(String name)&#123; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); String security=sharedPreferences.getString(name+&quot;_security&quot;,&quot;&quot;); return security; &#125; /** * 保存密保名字 **/ private void saveSecurity(String validateName) &#123; SharedPreferences sharedPreferences=getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); SharedPreferences.Editor editor=sharedPreferences.edit(); editor.putString(AnalysisUtils.readLoginUserName(this)+&quot;_security&quot;,validateName); editor.commit(); &#125; 保存功能代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void submit() &#123; // validate String validateName = et_validate_name.getText().toString().trim(); if (&quot;security&quot;.equals(from)) &#123; //设置密保 if (TextUtils.isEmpty(validateName)) &#123; Toast.makeText(this, &quot;请输入要验证的姓名&quot;, Toast.LENGTH_SHORT).show(); return; &#125; else &#123; Toast.makeText(this, &quot;密保设置成功&quot;, Toast.LENGTH_SHORT).show(); //保存到 saveSecurity(validateName); FindPwdActivity.this.finish(); return; &#125; &#125;else &#123; final String name=et_user_name.getText().toString().trim(); String sp_security=readSecurity(name); if (TextUtils.isEmpty(name))&#123; Toast.makeText(this,&quot;请输入您的用户名&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (!isExistUserName(name))&#123; Toast.makeText(this,&quot;您输入的用户名不存在&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (TextUtils.isEmpty(validateName))&#123; Toast.makeText(this,&quot;请输入要验证的姓名&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else if (!validateName.equals(sp_security))&#123; Toast.makeText(this,&quot;输入的密保不正确&quot;,Toast.LENGTH_SHORT).show(); return; &#125;else &#123; //输入密保正确，重新给用户设置一个密码 tv_reset_psw.setVisibility(View.VISIBLE); et_reset_psw.setVisibility(View.VISIBLE); btn_validate.setText(&quot;确认&quot;); btn_validate.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String resetPsw = et_reset_psw.getText().toString().trim(); //暂时仅验证不为空 if (!TextUtils.isEmpty(resetPsw)) &#123; savePsw(name, resetPsw); FindPwdActivity.this.finish(); &#125; else &#123; Toast.makeText(FindPwdActivity.this, &quot;请输入要设置的新密码&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125; &#125; &#125; 修复fragment在未登录状态下，点击“点击登录”按钮，登录完成后，应该显示“我”的界面，并且正常显示用户名。1getSupportFragmentManager().beginTransaction().replace(R.id.main_body,new CourseFragment()).commit(); 把该代码放入到fragment刷新中。 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了AndroidStudio制作“我”的界面，设置，修改密码，设置密保和找回密码，界面的布局介绍，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android Studio实战练习V2</category>
      </categories>
      <tags>
        <tag>Android Studio实战练习V2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio制作个人资料界面模块以及SQLite数据库的使用]]></title>
    <url>%2F2018%2F04%2F06%2F1%2F</url>
    <content type="text"><![CDATA[学习目标 掌握SQLite数据库的使用，能够实现用数据库来保存用户的信息； 学会运用好个人资料，以及个人资料的修改功能实现； 个人资料包括用户名，昵称，性别，签名，QQ号或个人社交账号的记录等。 前言大家好，我是 Vic，今天给大家带来AndroidStudio制作个人资料界面模块以及SQLite数据库的使用的概述，希望你们喜欢学习目标 掌握SQLite数据库的使用，能够实现用数据库来保存用户的信息； 学会运用好个人资料，以及个人资料的修改功能实现； 个人资料包括用户名，昵称，性别，签名，QQ号或个人社交账号的记录等。 数据库的创建数据库类 该类继承 extends SQLiteOpenHelper1234//核心代码private static final int DB_VERSION = 1;public static String DB_NAME = &quot;bxg.db&quot;;public static final String U_USER_INFO = &quot;userInfo&quot;; 123public SQLiteHelper(Context context)&#123; super(context, DB_NAME, null, DB_VERSION);&#125; 1234567891011121314@Override public void onCreate(SQLiteDatabase db) &#123; /** * 当这个SQLiteOpenHelper的子类类被实例化时会创建指定名的数据库，在onCreate中创建个人信息表 * **/ db.execSQL(&quot;CREATE TABLE IF NOT EXISTS &quot; + U_USER_INFO + &quot;( &quot; + &quot;_id INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + &quot;userName VARCHAR, &quot; + &quot;nickName VARCHAR, &quot; + &quot;sex VARCHAR, &quot; + &quot;signature VARCHAR, &quot; + &quot;qq VARCHAR &quot; + &quot;)&quot;);&#125; 12345678/** * 当数据库版本号增加才会调用此方法 **/ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + U_USER_INFO); onCreate(db); &#125; 创建一个数据库工具类，用于读取、保存、修改用户信息12345678/*** 构造方法，只有当类被实例化时候调用* 实例化SQLiteHelper类，从中得到一个读写的数据库**/ public DBUtils(Context context) &#123; helper = new SQLiteHelper(context); db = helper.getWritableDatabase(); &#125; 123456789/*** 得到这个类的实例**/public static DBUtils getInstance(Context context) &#123; if (instance == null) &#123; instance = new DBUtils(context); &#125; return instance;&#125; 123456789101112//保存个人资料信息public void saveUserInfo(UserBean bean) &#123; ContentValues cv = new ContentValues(); cv.put(&quot;userName&quot;, bean.userName); cv.put(&quot;nickName&quot;, bean.nickName); cv.put(&quot;sex&quot;, bean.sex); cv.put(&quot;signature&quot;, bean.signature); cv.put(&quot;qq&quot;,bean.qq); //Convenience method for inserting a row into the database. //注意，我们是从数据库使用插入方法，传入表名和数据集完成插入 db.insert(SQLiteHelper.U_USER_INFO, null, cv); &#125; 123456789101112131415161718192021//获取个人资料信息public UserBean getUserInfo(String userName) &#123; String sql = &quot;SELECT * FROM &quot; + SQLiteHelper.U_USER_INFO + &quot; WHERE userName=?&quot;; //?和下面数组内元素会逐个替换，可以多条件查询=?and =? //You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. Cursor cursor = db.rawQuery(sql, new String[]&#123;userName&#125;); UserBean bean = null; //Move the cursor to the next row. while (cursor.moveToNext()) &#123; bean = new UserBean(); //根据列索引获取对应的数值，因为这里查询结果只有一个，我们也不需要对模型UserBean进行修改， //直接将对应用户名的所有数据从表中动态赋值给bean bean.userName = cursor.getString(cursor.getColumnIndex(&quot;userName&quot;)); bean.nickName = cursor.getString(cursor.getColumnIndex(&quot;nickName&quot;)); bean.sex = cursor.getString(cursor.getColumnIndex(&quot;sex&quot;)); bean.signature = cursor.getString(cursor.getColumnIndex(&quot;signature&quot;)); bean.qq = cursor.getString(cursor.getColumnIndex(&quot;qq&quot;)); &#125; cursor.close(); return bean;&#125; 12345678//修改个人资料信息,这里的key指代表字段，value表示数值public void updateUserInfo(String key, String value, String userName) &#123; ContentValues cv = new ContentValues(); cv.put(key, value); //Convenience method for updating rows in the database. db.update(SQLiteHelper.U_USER_INFO, cv, &quot;userName=?&quot;, new String[] &#123;userName&#125;);&#125; 嗯，接下来好像没什么了。就这样！大概界面可设计自行设计： 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了AndroidStudio制作个人资料界面模块以及SQLite数据库的使用，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android Studio实战练习V2</category>
      </categories>
      <tags>
        <tag>Android Studio实战练习V2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语2]]></title>
    <url>%2F2018%2F04%2F05%2F1%2F</url>
    <content type="text"><![CDATA[翻译：人们普遍认为网络对教育产生了巨大影响。事实的确如此。然而，正如漫画所示，这样的一种事实同时也让一些人理所当然地认为教育就是学习获取信息。 事实上，教育涉及很多其他方面的能力，如逻辑思维能力，个人沟通能力，适应能力等。通过学习一些课程，学生可以培养一种逻辑思维方式，这的确对他们的日常生活起到很重要的作用。学生举办的一些有意义的活动有助于培养他们的沟通能力，这种能力的培养也是教育的主要目的之一。随着社会的快速改变和越来越多的挑战涌现，适应能力已经成为现代学生的必备素质之一。 总之，在很大程度上，网络对教育的发展做出了重大贡献，这是个不争的事实。同时，人们也该充分意识到教育到底是什么。 The Impact of the Internet on EducationIt is widely believed that the Internet has exerted great influence on education. So it is. As shown in the picture, however, such a fact, at the same time, has caused that some people take it for granted that education means learning to obtion information. As a matter of fact, education involves many other abilities, such as logical thinking ability, individual communication ability, adaptive capacity etc. By learing some courses, students can cultivate a logical thinking style which definitely plays an important role in their daily life. Some meaningful activities, held by students, are conducive to develop their communication ability, which is one of the main aims of education. As for adaptive capacity, it has become one of the indispensable qualities for modern students as the society changes so rapidly and an increasing number of challenges spring up. To conclude, we can’t deny the fact that the Internet, to a large extent, makes great contributions to the development of education. People, meanwhile, should be fully aware of what the education really is. 翻译：人们普遍认为网络对教育产生了巨大影响。事实的确如此。然而，正如漫画所示，这样的一种事实同时也让一些人理所当然地认为教育就是学习获取信息。 事实上，教育涉及很多其他方面的能力，如逻辑思维能力，个人沟通能力，适应能力等。通过学习一些课程，学生可以培养一种逻辑思维方式，这的确对他们的日常生活起到很重要的作用。学生举办的一些有意义的活动有助于培养他们的沟通能力，这种能力的培养也是教育的主要目的之一。随着社会的快速改变和越来越多的挑战涌现，适应能力已经成为现代学生的必备素质之一。 总之，在很大程度上，网络对教育的发展做出了重大贡献，这是个不争的事实。同时，人们也该充分意识到教育到底是什么。 翻译 I’d like directions to go to Norwalk. I believe there is an interesting museum there. 我想去Norwalk,我认为那里有一座很有趣的博物馆。 They are near each other, aren’t they? they are actually in opposite directions. 他们很近吗？他们位于相反的方向。 They are really pretty little towns with lots of old houses and beautiful tree-lined streets. 他们都是很美丽的小城，有很多老房子，还有绿树成荫的美丽街道。 She joined the Peace Corps after she graduated from the college because she wanted to do something to help other people. 她大学毕业后加入了和平公司，因为她想做一些事情帮助别人 She had been brought up on a farm, so the Peace Corps assigned her to an agricultural project. 她在农场成长，因此和平公司派她去参与一个农业项目。 She tried several jobs, but they seemed very boring to her. She couldn’t get Brazil out of her mind. Finally, one day she got on a plane and went back to Brazil. 她尝试了好几份工作，但都感觉很无聊，她无法忘记巴西，最终她乘飞机飞回了巴西。 And she makes a little extra money by sending stories to newspapers in the States. 她通过给美国报社写一些故事赚取外快。 Results of a recent Harris poll on free time shows that the average work week for many Americans is 50 hours.there’s little time left for leisure activities for many Americans. 关于空闲时间的哈里斯民意调查结果显示，许多美国人平均每周工作50个小时。 The result of a Harris poll showed that reading was the most popular spare time activity in the US. This was followed by watching TV. 哈里斯民意调查结果显示阅读在美国是最受欢迎的业余活动，看电视次之。 The most popular outdoor activity for Americans was gardening. In the UK, it was going to the pub. 美国最受欢迎的户外活动是园艺，英国最受欢迎的户外活动是泡吧。 要点 由于空格前的动词ate既可以为及物动词，又可以为不及物动词，空格处为名词或副词。 pants ___ skirts 并列，故为连词 ___ and uninformative 并列的形容词 the ___ 此处为名词 are ___ by ，空格为动词的过去分词 Norms ___ + 完整句子，空格为动词 they ___ 为谓语动词 notice ___ from norms ,空格为名词或名词词组 might be ___ 为形容词 both ___ 为名词，由形容词 both 作文许多人喜欢中餐。在中国，烹饪不仅被视为一种技能，而且也被视为一种艺术。精心准备的中餐既可口又好看。烹饪技艺和配料在中国各地差别很大。但好的烹饪都有一个共同点，总是要考虑到颜色，味道，口感和营养。由于食物对健康至关重要，好的厨师总是努力在谷物，肉类和蔬菜之间取得平衡，所以中餐既味美又健康。 Many people like Chinese food. In China, cooking is taken not only as a craftsmanship, but also an art. A carefully-prepared Chinese cuisine is both delicious and good-looking. Cooking skills and ingredients significantly vary from place to place in China. However, good Chinese cuisine always have many things in common, such as color, flavor, taste and nutrition. Because food is of great importance to people’s health, a good cooker is always trying to strike a balance among grain, meat and vegetable. That’s why Chinese food is simultaneously tasty and healthy.]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发工程师文集-layout_weight讲解]]></title>
    <url>%2F2018%2F04%2F04%2F1%2F</url>
    <content type="text"><![CDATA[LinearLayout中的layout_weight属性，先分配控件的尺寸，再分配weight的，如果给控件设置文本信息，那么如果该控件宽度为 wrap_content, 就先排这个文本信息，然后再按weight分配。 前言大家好，我是 Vic，今天给大家带来Android开发工程师文集-layout_weight讲解的概述，希望你们喜欢 Layout_weight的相关代码展示123456789101112131415161718&lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;25dp&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:background=&quot;#000000&quot;/&gt;&lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;25dp&quot; android:layout_weight=&quot;2&quot; android:gravity=&quot;center&quot; android:background=&quot;#f0f0f0&quot;/&gt;&lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;25dp&quot; android:layout_weight=&quot;3&quot; android:gravity=&quot;center&quot; android:background=&quot;#a3a3a3&quot;/&gt; 控件占格比例为1:2:31android:baselineAligned=&quot;false&quot; 这个属性，表示不基于同一水平面上。 特性LinearLayout中的layout_weight属性，先分配控件的尺寸，再分配weight的，如果给控件设置文本信息，那么如果该控件宽度为 wrap_content, 就先排这个文本信息，然后再按weight分配。 如果宽度为 match_parent 的话，分配和上述差不多，只是它的比例算法不一样。 weightSum 这个可以设置整个父控件的比例，android:weightSum=&quot;3&quot; , 表示为3个分配，那么下面的布局就是分3分，可1:2,2:1等。 要点：总的宽度减去设置的宽度，进行分配。 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了Android开发工程师文集-layout_weight讲解，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android开发工程师文集</category>
      </categories>
      <tags>
        <tag>Android开发工程师文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发工程师文集-相关控件的讲解，五大布局]]></title>
    <url>%2F2018%2F04%2F03%2F1%2F</url>
    <content type="text"><![CDATA[目录 TextView EditText AutoCompleteTextView为控件自动显示输入文本时出现的提示信息。 MultiAutoCompleteTextView ToggleButton Intent跳转 四大组件 CheckBox与RadioButton 五大布局 前言大家好，我是 Vic，今天给大家带来Android开发工程师文集-相关控件的讲解，五大布局的概述，希望你们喜欢 TextView控件TextView控件有哪些属性：1234567android:id-&gt;控件的idandroid:layout_width-&gt;控件的宽度android:layout_height-&gt;控件的高度android:text-&gt;文本内容android:textSize-&gt;文本的大小android:textColor-&gt;文本的颜色android:background-&gt;控件的背景，可设置颜色或图片 EditText控件EditText控件有哪些属性：12345678910android:id-&gt;android:layout_width:android:layout_height:android:text:android:textSize:android:textColor:android:background://android:hint-&gt;输入提示android:inputType-&gt;输入的类型 设置颜色 在xml中是android:textColor 在Activity中是setTextColor AutoCompleteTextViewAutoCompleteTextView为控件自动显示输入文本时出现的提示信息。相关属性：android:completionThreshold=&quot;2&quot; 示例代码：12345678private String[] strings=&#123; &quot;数据1&quot;,&quot;数据2&quot;,....&#125;;//初始化控件//需要适配器//初始化数据源//adpter-autocompleteTextViewautocompleteTextView = findViewById(R.id.autocompleteTextView);ArrayAdapter&lt;String&gt; adapter=new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,strings);autocompleteTextView.setAdapter(adapter); MultiAutoCompleteTextView主要为可多选择值而已。这里主要用分隔符，可输入多个值12multiAutoCompleteTextView = findViewById(R.id.multiAutoCompleteTextView);multiAutoCompleteTextView.setAdapter(adapter); 注意要设置分隔符1multiAutoCompleteTextView.setTokenizer(new multiAutoCompleteTextView.CommaTokenizer()); ToggleButton这个ToggleButton有两种状态，一种是被选中，一种是没有被选中。 可以理解为是电灯的开关效果，该属性有：123android:checked=&quot;true&quot;android:textOff=&quot;off&quot;android:textOn=&quot;on&quot; 主要实现的方法：12345@Overridepublic void onCheckedChanged(CompoundButton, buttonView, boolean isChecked)&#123; //图片的切换 imgpicture.setBackgroundResource(isChecked?R.drawable.one:R.drawable.two);&#125; Intent跳转12341. startActivity(intent);2. startActivityForResult(intent,requestCode);onActivityResult();//MainActivityonResult(); 接下来只学startActivityForresult():12Intent intent = new Intent(MainActivity.this,SecondActivity.class);startActivityForResult(intent,1); 同在MainActivity中创建onActivityResult()方法：接收返回来的数据1234@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; super.onActivityResult(requestCode, resultCode, data);&#125; 那么在SecondActivity中创建onResult()的方法：回传Intent的对象，回传数据123Intent data=new Intent();data.putExtra(&quot;data&quot;,name);setResult(2,data); 在MainActivity中的onActivityResult():1234567@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; super.onActivityResult(requestCode, resultCode, data); if(requestCode == 1 &amp;&amp; resultCode == 2)&#123; String name = data.getStringExtra(&quot;data&quot;); tv.setText(name);&#125; 四大组件Android的四大组件 Activity Service BroadcastReceiver Content Provider 再次学习一下activity的生命周期 onCreate(); onStart(); onResume(); onPause(); onStop(); onDestroy(); onRestart(); activity的四种状态： 活动状态 暂停状态 停止状态 销毁状态 一个activity的一生： onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestroy() 启动到后台再前台： onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume() 设置个小窗口的启动模式周期： onResume()为获取焦点onPause()为失去焦点 onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onResume() CheckBox与RadioButton1234//核心if(isChecked)&#123; String text = checkBox.getText().toString();&#125; 这里讲RadioButton,注意RadioGroup就行。1234567891011//核心@Overridepublic void onCheckedChanged(RadioGroup group, int checkedId)&#123; switch(checkedId)&#123; case R.id.button1: break; case R.id.button2: break; default: &#125;&#125; 当然这里你也可以用RadioButton来监听，但是个人认为RadioGroup比较方便吧！ 五大布局LinearLayout：12345678android:orientation=&quot;&quot;1. vertical2. horizontalandroid:gravity=&quot;&quot;center,bottom,left,rightandroid:layout_gravity=&quot;&quot;android:layout_weight=&quot;&quot;//android:layout_height=&quot;match_parent&quot;的比例为反，用android:layout_weight=&quot;&quot;的话 layout_gravity调整该布局相对父布局的位置 gravity是调整该布局中子布局的位置 水平的LinearLayout要从左边开始依次放置布局 layout_gravity只有在LinearLayout布局中 RelativeLayout：相对布局，我们只要知道相应的属性就行：12android:layout_alignParentLeft=&quot;true&quot;android:layout_alignParentTop=&quot;true&quot; 123android:layout_centerInParent=&quot;true&quot;android:layout_centerHorizontal=&quot;true&quot;android:layout_centerVertical=&quot;true&quot; 12android:layout_marginLeft=&quot;50dp&quot;android:layout_marginBottom=&quot;50dp&quot; 12345android:layout_toRightOf=&quot;@+id/button1&quot;android:layout_toLeftOf=&quot;@+id/button2&quot;android:layout_below=&quot;@+id/button1&quot;//android:layout_alignBaseline=&quot;@+id/button1&quot; 1android:gravity=&quot;&quot; 这些根据英文意思就了解了。 FrameLayout：先放的在下面，都在左上方。 AbsoluteLayout： android:layout_x=”50dip”android:layout_y=”50dip” TableLayout： TableRow-View 重要的属性：1234//都是从0开始的索引列android:collapseColumns=&quot;1,2&quot;//隐藏android:shrinkColumns=&quot;1,2&quot;//收缩android:strechColumns=&quot;1,2&quot;//拉伸 12android:layout_column=&quot;1&quot;//显示在第二列android:layout_span=&quot;2&quot;//这个表示一个空间占据两列 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了Android开发工程师文集-相关控件的讲解，五大布局，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android开发工程师文集</category>
      </categories>
      <tags>
        <tag>Android开发工程师文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐一些学习软件编程的网站]]></title>
    <url>%2F2018%2F04%2F02%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来推荐一些学习软件编程的网站的概述，希望你们喜欢 给大家推荐一些学习软件编程的网站，综合了个个人的学习网站，包括自己收藏的，有用的网站。（个人推荐而已，如果你还有更好的，可以推荐哦~） 学习软件不是一件很容易的事，作为一名程序员，我们每天除了睡觉，吃饭，就是打代码。一直以来，我们的老师都说，你们将会看到学校凌晨4点的夜景，不然，我身边的朋友，同学一到大学就是熬夜的夜猫子。 作为一名程序员，我们一直都很低调地敲代码，可是谁知道代码员的辛苦？我们每天敲着老师布置的代码，一遍又一遍，我很想说我们只是在做苦力活，理想是美好的，现实是残酷的，我们的学习状态如下图 开始敲代码时，我们会很激动，因为我们做着高逼格的事情，可以万万没想到的是，代码错误 是不是想跟我一样，销毁吧代码，拜拜。 但是，作为未来领先人物，我们学习软件，掌握了现代先进的高逼格技术，理想还是要有的，万一实现了呢？ 相信用不了多久你就会升职加薪当上总经理，当上CEO,迎娶白富美，走向人生巅峰@你 相信用不了多久你就会升职加薪当上总经理，当上CEO,迎娶高富帅，走向人生巅峰@你 以下推荐好的学习网站绝对适合零基础的学员学习，如果您是非计算机专业，想做软件开发的朋友，或者想成为高逼格的同学，那么就看看下面的推荐吧！ 慕课网 输入网址：http://www.imooc.com/ 极客学院 输入网址：http://www.jikexueyuan.com 网易云课堂 输入网址：http://study.163.com 传智播客学习网站 输入网址：http://www.itcast.cn w3school 输入网址：http://www.w3school.com.cn/ 好了，小编就推荐到这了，相信学会这些网站的视频知识，你不牛逼都不行了。 仅仅代表个人推荐的好的网站而已。 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了推荐一些学习软件编程的网站，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发进阶从小工到专家第一章四大组件]]></title>
    <url>%2F2018%2F04%2F01%2F1%2F</url>
    <content type="text"><![CDATA[前言点击来看的朋友，这本书很好，可以作为一个秘籍作为保存。笔记记录为了更好的学习。为了方便学习，记录下了重点笔记。Android中最重要的就是四大组件，就是Activity,Service,ContentProvider和Broadcast。这四个组件分工明确，共同构成了可重用，灵活，低耦合的Android系统。 Activity负责UI元素的加载与页面之间的跳转，代表了一个页面单元； Service负责与UI无关的工作，如在后台执行耗时操作等； ContentProvider负责存储，共享数据，使得数据可以在多个应用之间共享； Broadcast是各个组件，应用之间进行通信，简化了Android开发中的通信问题。 ActivityActivity在应用中的表现就是一个用户界面，它会加载指定的布局文件来显示各种UI元素。如：TextView,Button,ImageView,ListView等。-这些UI元素设置事件处理函数，使得用户可以与这些UI进行交互。同时，Activity可以在不同的Activity之间跳转，将不同的页面串连在一起，共同完成特定的操作流程。 每个应用都是由一个或者多个Activity组成，它是Android应用程序中不可缺少的部分。 应用启动时会加载一个默认的Activity,这个Activity在AndroidManifest.xml中会被设置为如下的： 1234&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&lt;/intent-filter&gt; 每个activity都有生命周期，在不同的阶段中会回调不同的生命周期函数,activity的生命如下： onCreate() 这个是见过最多的函数，我们创建继承Activity都会生成这个函数。 onStart() 这个函数在activity的onCreate函数调用之后被调用，此时的activity还处在不可见的状态，它的下一个状态就是activity变得可见的时候。 onResume() 这个函数在activity变为可见时被调用，执行完onResume之后，activity就会请求AMS渲染它所管理的视图，此时activity一定位于返回栈的栈顶，并且处于运行状态。 onPause() 这个函数在系统准备去启动或者恢复另一个activity时调用，也就是在activity即将从可见状态变为不可见时，我们通常会在这个函数中将一些消耗CPU的资源释放掉，以及保存一些关键数据。 onStop() 这个函数在Activity完全不可见时调用。它和onPause()函数的主要区别在于，如果新启动的Activity是一个对话框式的Activity，那么onPause()函数会得到执行，而onStop()函数并不会执行。 onDestroy() 这个函数在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。 onRestart() 这个函数在activity由停止状态重新变为运行状态之前调用，也就是activity被重新启动。 从onCreate()函数到onDestroy()函数运行的时期就是一个Activity的完整生命周期。一般情况下。我们会在一个Activity的onCreate()函数中完成各种初始化操作，而在onDestroy()函数中完成释放内存的操作。然而并不是各个时期activity都是可见的，只有onResume()函数和onStop()函数之间的activity是可见的，在activity可见期内，用户可以与activity进行交互，完成所需的功能。 onCreate -&gt; onStart() -&gt; onResume() -&gt; 活动运行中 -&gt; onPause() 活动不再可见 -&gt; onStop() -&gt; onDestroy() -&gt; 关闭活动 Activity的构成Activity的构成并不是一个activity对象再加上一个布局文件那么简单，在activity和开发人员素质的视图之间还隔着两层。实际上视图会被设置给一个window类，这个window中含有一个DecorView,这个DecorView才是整个窗口的顶级视图。开发人员设置的布局会被设置到这个DecorView的mContentParent布局中，也就是说Android中实际上内置了一些系统布局文件xml，我们在xml中定义的视图最终会被设置到这些系统布局的特定节点之下，这样就形成了整个DecorView中。 我们的activity之下有一个PhoneWindow,这个PhoneWindow是window的实现类，然后window之下包含一个DecorView，DecorView实际上是页面的顶级视图，它从一些系统布局中加载，并且在运行时将开放人员设置给activity的布局资源添加到系统布局的mContentParent中，这样一来，用户界面就被添加到系统布局中了，而系统布局会为我们设置好标题栏区域。 Activity-&gt;PhoneWindow-&gt;DecorView-&gt;DefaultLayout-&gt;ViewGroup:mContentParent-&gt;自己的xml Activity的4种启动模式每个应用程序都是由一个或者多个activity组成，因此，Android内部使用通过回退栈来管理activity实例。栈是一种后进先出的集合，对于Android来说，当前显示的activity就在栈顶，当用户点击后退键或者点击应用上的返回按钮，系统就会将栈顶的activity出栈，此时原来栈顶下activity就会变为栈顶显示到设置上。 然而事情可能并不是那么简单，在一些特殊情况下我们可能需要对activity实例做一些特殊的处理，例如，为了避免重复创建activity，我们要求一个activity只有一个实例，好在Android系统为我们提供了这些功能，也就是我们说的4启动模式，用户可以在AndroidManifext.xml中注册activity时2设置它的启动模式。 12345&lt;activity android:name=&quot;.MyActivity&quot; android:launchMode=&quot;singleTask&quot; android:label=&quot;@string/app_name&quot;&lt;/activity&gt; Activity的4种启动模式，有standard,singleTop,singleTask,singleInstance。 standard(标准启动模式)这是Activity的标准启动模式，也是activity的默认启动模式。在这种模式启动的Activity可以被多次实例化，即在同一个任务栈中可以存在多个activity实例，每个实例都会出来了一个intent对象。 如果activityA的启动模式为standard，并且已经有一个activityA被启动，在该activityA中调用startActivity时会启动一个新的activityA实例。 singleTop如果一个以singleTop模式启动的activity的实例已经存在于任务的栈顶，那么再启动这个activity时，不会创建新的实例，而是重用位于栈顶的那个实例，并且会调用该实例的onNewIntent()函数将Intent对象传递到这个实例中。 activityA的启动模式为singleTop,并且activityA的一个实例已经存在栈顶中。那么再调用startActivity启动另一个activityA时，不会再次创建activityA的实例，而是重用原来的实例，并且调用原来实例的onNewIntent()函数，此时任务栈中还是这一个activityA的实例。 如果以singleTop模式启动的activity的一个实例已经存在于任务栈中，但是不在栈顶，那么它的行为和standard模式相同也会创建一个新的实例。 singleTasksingleTask模式是常用的启动模式，如果一个activity设置了该启动模式，那么在一个任务栈中只能有一个该activity的实例，如果任务栈中还没有该activity，会新创建一个实例并放在栈顶。 但是，如果已经存在activity，系统会销毁处在该activity上的所有activity，最终让该activity实例处于栈顶。最终让该activity实例处于栈顶，同时回调该activity的onNewIntent()函数并不会执行。 singleInstance设置了singleInstance模式的activity会在一个独立的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被实例启动的其他activity会自动运行于另一个任务中。当再次启动该activity实例时，会重用已存在的任务和实例。并且会调用该实例的onNewIntent()函数，将Intent实例传递到该实例中。 和singleTask不同的是，同一时刻在系统中只会存在一个这样的activity实例，而singleTask模式的activity是可以有多个实例的，只要这些activity在不同的任务栈中即可。 应用A启动了一个启动模式为singleTask的activityA，应用B又通过Intent想要启动一个activityA，此时由于应用A和应用B都有自己的任务栈，因此，在这两个任务中分别都有一个activityA示例，而singleInstance能够保证activity在系统中只有一个实例，不管多少应用要启动该activity，这个activity有且只有一个。 FragmentActivity与Fragment为了更好地运用越来越大的屏幕控件，从Android3.0版本引入了Fragment,它可以像activity一样包含布局。不同的是Fragment是被嵌套在activity中使用，它作为一个更大粒度的UI单元。如果需要兼容低于Android3.0的系统，那么开放人员需要引用Android-support-v4的jar包才能使用Fragment功能。 就目前开放来说，使用Fragment已经成为流行的开发方式，尽管在它的support v4中有各种各样的Bug。 Service与AIDLService是Android中实现程序后台运行的解决方案，它非常适合于执行那些不需要和用户交互而且还要求长期运行的任务。但不要被“后台”二字所迷惑，Service默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在ui线程中，因此，不要在service中执行耗时的操作，除非你在service中创建了子线程来完成耗时操作。 service的运行不依赖于任何用户界面，即使程序被切换到后台或者用户打开了另外一个应用程序，Service仍然能够保持正常运行，这也正是service的使用场景。当某个应用程序进程被杀掉时，所有依赖于该进程的service也会停止运行。 service的生命周期相对activity来说简单得多，只有3个，分别为onCreat,onStartCommand和onDestory。 一旦在项目的任何位置调用了Context的startService()函数，相依的服务就会启动起来，首次创建时会调用onCreate函数，然后回调onStartCommand()函数。 服务启动了之后会一直保持运行状态，直到stopService()或stopSelf()函数被调用。 虽然每调用一次startService()函数，onStartCommand()就会执行一次，但实际上每个服务都只会存在一个实例。 所以不管你调用了多少次startService()函数，只需调用一个stopService()或stopSelf()函数，服务就会被停止。 通常的Service大致如下：123456789101112131415161718192021public class MyService extends Service &#123;@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123;doMyJob(intent);return super.onStartCommand(intent, flags, startId);&#125;private void doMyJob(Intent intent)&#123;new Thread()&#123;@Overridepublic void run() &#123;&#125;&#125;.start();&#125;@Nullable@Overridepublic IBinder onBind(Intent intent) &#123;return null;&#125;&#125; 与activity一样，service也需要在AndroidManifest.xml中进行注册：1&lt;service android:name=&quot;.service.MyService&quot; /&gt; 上述示例表示注册一个在应用包service目录下的myservice服务，注册之后，当用户调用startService(new Intent(mContext,MyService.class))时会调用onStartCommand函数，我们在该函数中调用doMyJob,而在doMyJob中我们创建了一个线程来执行耗时操作，以避免阻塞UI线程。当我们的Service完成使命时，需要stopService来停止该服务。 IntentService完成一个简单的后台任务需要这么麻烦，Android显然早就知道了这一点。因此，提供了一个IntentService来完成这样的操作，IntentService将用户的请求执行在一个子线程中，用户只需要覆写onHandleIntent函数，并且在该函数中完成自己的耗时操作即可。 需要注意的是，在任务执行完毕之后IntentService会调用stopSelf自我销毁，它适用于完成一些短期的耗时任务。 123456789public class MyIntentService extends IntentService &#123;MyIntentService()&#123;super(MyIntentService.class.getName());&#125;@Overrideprotected void onHandleIntent(Intent intent) &#123;&#125;&#125; 运行在前台的ServiceService默认是运行在后台的，因此，它的优先级相对比较低，当系统出现内存不足的情况时，它就有可能会被回收掉。如果希望Service可以一直保持运行状态，而不会由于系统内存不足被回收，可以将service运行在前台。 前台服务不仅不会被系统无情地回收，它还会在通知栏显示一条消息，下拉状态后可以看到更加详细的信息。 定义一个服务代码：12345678910111213141516171819202122232425262728293031323334public class WeatherService extends Service &#123;private static final int NOTIFY_ID = 123;@Overridepublic void onCreate() &#123;super.onCreate();showNotification();&#125;private void showNotification() &#123;NotificationCompat.Builder mBuilder =new NotificationCompat.Builder(this).setSmallIcon(R.drawable.weather).setContentTitle(getText(R.string.the_day)).setContentText(getText(R.string.weather));Intent resultIntent = new Intent(this, MainActivity.class);TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);stackBuilder.addParentStack(MainActivity.class);stackBuilder.addNextIntent(resultIntent);PendingIntent resultPendingIntent =stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);mBuilder.setContentIntent(resultPendingIntent);NotificationManager mNotifyMgr =(NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);final Notification notification = mBuilder.build() ;mNotifyMgr.notify(NOTIFY_ID, notification);startForeground(NOTIFY_ID, notification);&#125;&#125; 我们在onCreate函数中调用了showNotification函数显示通知，并且在最后调用startForeground将服务设置为前台服务。在AndroidManifest.xml注册之后我们就可以启动该Service了。 AIDL(Android接口描述语言)AIDL是一种接口描述语言，通常用于进程间通信。编译器根据AIDL文件生成一个系列对应的Java类，通过预先定义的接口以及Binder机制达到进程间通信的目的。 说白了，AIDL就是定义一个接口，客户端通过bindService来与远程服务建立一个连接，在该连接建立时会返回一个IBinder对象，该对象是服务端Binder的BinderProxy,在建立连接时，客户端通过asInterface函数将该BinderProxy对象包装成本地的Proxy,并将远程服务端的BinderProxy对象赋值给Proxy类的mRemote字段，就是通过mRemote执行远程函数调用。 在SsoAuth.aidl文件中会默认有一个basicTypes函数，我们在程序后面添加一个ssoAuth的函数用于SSD授权。 123456interface SsoAuth &#123;void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,double aDouble, String aString);void ssoAuth(String userName, String pwd);&#125; 因此客户端是调用端，只需要定义AIDL文件，此时Rebuild一下工程就会生成一个SsoAuth.java类，该类根据SsoAuth.aidl文件生成，包含了我们在AIDL文件中定义的函数。 因为AIDL通常用于进程间通信，因此，我们新建一个被调用端的工程，我们命名为aidl_server,然后将客户端的AIDL文件夹复制到aidl_server的app/src/main目录下： 此时相当于在客户端和被调用端都有同一份SsoAuth.aidl文件，它们的包名，类名完全一致，生成的SsoAuth.java类也完全一致，这样在远程调用时它们就能够拥有一致的类型。Rebuild被调用端工程之后就会生成SsoAuth.java文件，该文件中有一个Stub类实现了SsoAuth接口。我们首先需要定义一个Service子类，然后再定义一个继承自Stub的子类，并且在Service的onBind函数中返回这个Stub子类的对象。 1234567891011121314151617181920212223242526public class SinaSsoAuthService extends Service &#123;SinaSsoImpl mBinder = new SinaSsoImpl();@Overridepublic void onCreate() &#123;super.onCreate();Log.e(&quot;&quot;,&quot;### sso auth created&quot;) ;&#125;@Nullable@Overridepublic IBinder onBind(Intent intent) &#123;return mBinder;&#125;class SinaSsoImpl extends SsoAuth.Stub &#123;@Overridepublic void ssoAuth(String userName, String pwd) throws RemoteException &#123;Log.e(&quot;&quot;, &quot;用户名 : &quot;+ userName + &quot;, 密码 : &quot; + pwd) ;&#125;@Overridepublic void basicTypes(int anInt, long aLong,boolean aBoolean, float aFloat,double aDouble, String aString) throws RemoteException &#123;&#125;&#125;&#125; 上述完成的功能是继承自Stub的SinaSsolmpl类，Service只提供了一个让SinaSsolmpl依赖的外壳。完成SinaSsoAuthService之后我们需要将它注册在被调用端应用的Manifest中。 123456789&lt;serviceandroid:name=&quot;.service.SinaSsoAuthService&quot;android:exported=&quot;true&quot;android:process=&quot;:remote&quot;android:label=&quot;@string/app_name&quot;&gt;&lt;intent-filter&gt;&lt;action android:name=&quot;book.aidl_server.service.SinaSsoAuthService&quot;/&gt;&lt;/intent-filter&gt;&lt;/service&gt; 然后先运行被调用端（应用），并且在客户端中完成Server的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends AppCompatActivity &#123;SsoAuth mSsoAuth ;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);findViewById(R.id.sso_btn).setOnClickListener(new View.OnClickListener() &#123;@Overridepublic void onClick(View view) &#123;if ( mSsoAuth == null ) &#123;bindSsoAuthService();&#125; else &#123;doSsoAuth();&#125;&#125;&#125;);&#125;private void bindSsoAuthService() &#123;Intent intent = new Intent(&quot;book.aidl_server.service.SinaSsoAuthService&quot;) ;bindService(intent, mConnection, Context.BIND_AUTO_CREATE) ;&#125;ServiceConnection mConnection = new ServiceConnection() &#123;@Overridepublic void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123;mSsoAuth = SsoAuth.Stub.asInterface(iBinder) ;doSsoAuth();&#125;@Overridepublic void onServiceDisconnected(ComponentName componentName) &#123;mSsoAuth = null;&#125;&#125; ;private void doSsoAuth() &#123;try &#123;mSsoAuth.ssoAuth(&quot;Mr.Simple&quot;, &quot;pwd123&quot;);&#125; catch (RemoteException e) &#123;e.printStackTrace();&#125;&#125;@Overrideprotected void onDestroy() &#123;super.onDestroy();unbindService(mConnection);&#125;&#125; 点击登录时会向Server端发起连接Service请求，在建立连接之后会将Binder对象转换为SsoAuth对象，然后调用SsoAuth对象的ssoAuth函数。此时的ssoAuth函数实际上调用的就是Server端中SinaSsolmpl类的实现。运行程序后点击登录按钮。 SsoAuth.java ，Stub类就是该文件中的内部类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public interface SsoAuth extends android.os.IInterface&#123;public static abstract class Stub extends android.os.Binderimplements book.jtm_chap01.SsoAuth &#123;private static final java.lang.String DESCRIPTOR = &quot;book.jtm_chap01.SsoAuth&quot;;public Stub()&#123;this.attachInterface(this, DESCRIPTOR);&#125;public static book.jtm_chap01.SsoAuth asInterface(android.os.IBinder obj)&#123;if ((obj==null)) &#123;return null;&#125;android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);if (((iin!=null)&amp;&amp;(iin instanceof book.jtm_chap01.SsoAuth))) &#123;return ((book.jtm_chap01.SsoAuth)iin);&#125;return new book.jtm_chap01.SsoAuth.Stub.Proxy(obj);&#125;@Override public android.os.IBinder asBinder()&#123;return this;&#125;@Override public boolean onTransact(int code,android.os.Parcel data, android.os.Parcel reply,int flags) throws android.os.RemoteException&#123;switch (code)&#123;case INTERFACE_TRANSACTION:&#123;reply.writeString(DESCRIPTOR);return true;&#125;case TRANSACTION_basicTypes:&#123;data.enforceInterface(DESCRIPTOR);return true;&#125;case TRANSACTION_ssoAuth: &#123;!23data.enforceInterface(DESCRIPTOR);java.lang.String _arg0;_arg0 = data.readString();java.lang.String _arg1;_arg1 = data.readString();this.ssoAuth(_arg0, _arg1);reply.writeNoException();return true;&#125;&#125;return super.onTransact(code, data, reply, flags);&#125;private static class Proxy implements book.jtm_chap01.SsoAuth&#123;private android.os.IBinder mRemote;Proxy(android.os.IBinder remote)&#123;mRemote = remote;&#125;@Override public android.os.IBinder asBinder()&#123;return mRemote;&#125;@Override public void ssoAuth(java.lang.String userName,java.lang.String pwd) throws android.os.RemoteException&#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();try &#123;_data.writeInterfaceToken(DESCRIPTOR);_data.writeString(userName);_data.writeString(pwd);mRemote.transact(Stub.TRANSACTION_ssoAuth, _data, _reply, 0);_reply.readException();&#125;finally &#123;_reply.recycle();_data.recycle();&#125;&#125;&#125;static final int TRANSACTION_basicTypes= (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);static final int TRANSACTION_ssoAuth= (android.os.IBinder.FIRST_CALL_TRANSACTION + 1);&#125;public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, doubleaDouble, java.lang.String aString) throws android.os.RemoteException;public void ssoAuth(java.lang.String userName, java.lang.String pwd)throws android.os.RemoteException;&#125; 总结 本文讲了Android开发进阶从小工到专家第一章四大组件，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android开发进阶从小工到专家读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发进阶从小工到专家读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四节：详细讲解Java中的类和面向对象思想]]></title>
    <url>%2F2018%2F03%2F28%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来详细讲解Java中的类和面向对象思想的概述，希望你们喜欢 类和面向对象在Java中怎样理解对象，创建对象和引用；什么是引用，对于基础学习的同学，要深入了解引用。示例：String str = new String(); ；其中str为引用，并创建了一个对象。 引用 如果一个变量的类型是类的类型，不是基本数据类型，那么这个变量就叫做引用。 对 Person person = new Person(); 这个的理解：person叫做引用，new Person() 为创建了一个对象， “ = “ 表示左边的引用指向右边的对象。 面向对象思想面向过程：就是站在过程的角度去思考问题，功能的执行过程，就是我们在实现功能的过程，类似方法，使用时，调用该函数就成。 面向对象：一种基于面向过程的编程思想，面向对象，就是站在对象的角度去思考问题。 面向对象的三大特征 继承：就是子类继承父类，子类是一种特殊的类，可以直接或间接的获取父类的成员。 封装：就是将对象的实现的细节隐藏起来，通过公共的方法向外暴露对象的功能。 多态：多态就是把子类的对象赋值给父类的变量。 对象对象的定义：状态和行为一切事物都可以认为是对象，具有状态和行为。 类类是对象的模板，类是构建对象的基础，对象的抽象是类，类的具体化则是对象，在代码中我们常说创建一个类，并在类中实例化对象。 对象的创建及其使用在程序中，先有类，再有对象 创建对象： 类 对象名 = new 类名(); 对象调用方法： 对象名.方法名(); 匿名对象：就是该对象没有名字，创建对象时，没有赋给一个变量匿名对象的示例：new Person(); 匿名对象只能被使用一次，由 new Person() 就可以知道，创建后无法再次使用。 一个引用，多个对象1234//当创建了一个引用，再把该引用指向另一个对象Personone one = new Personone();one = new Persontwo(); //代表该引用指向了另一个对象，那么之前的对象将不被该引用指向，那么之前的对象会被Java的回收机制处理 继承在现实世界当中，继承就是儿子得到老子的东西，在面向对象的世界当中，继承就是一个类得到了另一个类当中的成员变量和成员方法 Java只支持单继承，不允许多继承，继承是为了减少重复代码 使用super调用父类构造函数的方法12345678910111213141516class Person&#123;String name;int age;Person()&#123; System.out.prinltn(&quot;Person的无参数构造函数&quot;);&#125;Person(String name,int age)&#123; this.name=name; this.age=age; System.out.println(&quot;Person有参数的构造函数&quot;);&#125;void eat()&#123; System.out.println(&quot;定义吃饭的方法&quot;);&#125;&#125; 123456789101112131415161718class Student extends Person&#123;//子类继承父类Student()&#123; //父类 super(); System.out.println(&quot;Student的无参数构造函数&quot;);&#125;Student(String name,int age,int id)&#123; super(name,age); this.id=id;&#125;&#125;//测试类class Test&#123;public static void main(String args[])&#123; Student student = new Student();&#125;&#125; 重写和重载 重载：方法名一样，但是参数类型不一样（不同的参数个数，不同的参数类型，不同的参数次序） 重写：子类中定义的某个方法与其父类有相同的名称和参数，则该方法被重写了 构造方法12345678public class Person&#123; Person()&#123; //构造方法 &#125; public static void main(String[] args)&#123; Person person = new Person(); &#125;&#125; 四种访问修饰符 private 私有的 default 不写 protected 受保护的 public 公共的 类属性，对象属性 类属性： 叫做静态属性对象属性： 叫实例属性，非静态属性 类方法，对象方法 类方法： 叫做静态方法对象方法： 叫实例方法，非静态方法 对象属性初始化，类属性初始化对象属性初始化3种 声明该属性的时候初始化 构造方法中初始化 初始化块 类属性初始化2种 声明该属性的时候初始化 静态初始化块 书籍Core JavaEffective JavaThinking in JavaFirst Head Java 总结 本文讲了详细讲解Java中的类和面向对象思想，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三节：带你详解Java的操作符，控制流程以及数组]]></title>
    <url>%2F2018%2F03%2F27%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来带你详解Java的操作符，控制流程以及数组的概述，希望你们喜欢 操作符算数操作符一般的 ＋，－，*，/，还有两个自增 自减 ，以及一个取模 % 操作符。这里的操作算法，一定要掌握 好强制类型转换和自动类型转换。 理解%取模取模就是在数学中的求余，输出的结果就是余数的多少123456789//可以亲自试试效果，输出为1public class Test &#123; public static void main(String[] args) &#123; int i = 3; int j = 2; int z = i % j; System.out.println(z); &#125;&#125; 理解自增 自减++ – ， i++ 等价于 i = i+1 ; i– 等价于 i = i-1 ; i++ 的理解为 先取值，再运算； ++i 的理解为 先运算，再取值。123456789//示例代码理解public class Test &#123; public static void main(String[] args) &#123; int i = 2; System.out.println(i++); //先取值，再运算，那么打印的值，就是先取值，为i=2； //如果再次打印i的值 System.out.println(i); //输出i=3; &#125;&#125; 123456789//示例代码理解public class Test &#123; public static void main(String[] args) &#123; int j = 2; System.out.println(++j); //先运算，再取值，那么打印的值，就是先运算，++j，那么j=3，打印结果为3； //如果再次打印i的值 System.out.println(j); //输出j=3; &#125;&#125; 关系操作符 关系操作符：&gt; 大于 ； &gt;= 大于或等于 ；&lt; 小于 ；&lt;= 小于或等于 ；== 是否相等 ；!= 是否不等 逻辑运算符 逻辑运算符：&amp;为长路与， &amp;&amp;为短路与；| 为长路或，|| 为短路或；！为取反；^ 为异或 长路和短路的区别： 长路： 两侧，都会被运算 短路： 只要第一个是false，那么第二个就不进行运算（短路只要第一个通过，那么第二个就不进行运算） 什么是异或：口诀：不同为true，相同为false 位操作符 遵循规则：0看做是false,1看做是true.&amp;：参与运算的两个数，若相应位数的值都为1，则该位结果值为1，否则为0。（相同为1（前提两个都为1，没有0的情况），不同为0）|：参与运算的两个数，若相应位数中，只要有一个1，结果就为1。（有1为1，没1为0）^：参与运算的两个数，若相应位数中，相同则结果为0，否则为1。（相同为0（可以两个数为1，结果为0；可以两个数为0，结果为0），不同为1）~ ：表示把每个二进制位的“1”换成“0”，把“0”换成“1”。 补充原码、补码、反码的一点知识：1.正数的反码、补码都与原码一样2.负数的反码、补码与原码不同。 左移 右移1234567public class Test &#123; public static void main(String[] args)&#123; int i = 12; System.out.println(i&lt;&lt;1); //代表乘2，结果为24 System.out.println(i&gt;&gt;1);//同理，举一反三，结果可得6 &#125;&#125; 三元运算符格式：表达式 ? 值1 : 值2如果表达式为 true，那么结果返回值1；否则返回值2。 控制流程if语句的格式：123if(表达式1)&#123; 表达式2；&#125; if else 语句的格式：12345if(表达式1)&#123; 表达式2；&#125;else&#123; 表达式3；&#125; switch语句格式：123456789101112131415161718192021222324 switch (mon) &#123; case 1: case 2: case 3: System.out.println(mon + &quot;月是春天&quot;); break; case 4: case 5: case 6: System.out.println(mon + &quot;月是夏天&quot;); break; case 7: case 8: case 9: System.out.println(mon + &quot;月是秋天&quot;); break; case 10: case 11: case 12: System.out.println(mon + &quot;月是冬天&quot;); break; default: System.out.println(&quot;一年有12个月&quot;);&#125; while和do-while循环语句 while为true时，继续执行；do-while中条件为true时，继续执行，至少会执行一次。 for语句格式：123for(int i=0;i&lt;10;i++)&#123; 表达式语句；&#125; continue和break continue 为继续下一次循环 break 为结束整个循环 数组 数组是具有相同类型数据的集合声明一个数组 int[] a ；创建数组的长度 int[] a = new int[5]；给数组赋值 int[] a = new int[]{1,2,3,45,5}; 或 int[] a = {2,4,24,5,7,66,55,1,2,3,4}; 数组的选择排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//这种就是排序算法，比如有6个人，第一轮要进行5次比较//第一轮for(int index=1;index&lt;arr.length;index++)&#123;if(arr[0]&gt;arr[index])&#123; int temp = arr[0]; arr[0] = arr[index]; arr[index] = temp;&#125;&#125;print(arr);//第二轮for(int index=2;index&lt;arr.length;index++)&#123;if(arr[1]&gt;arr[index])&#123; int temp = arr[1]; arr[1] = arr[index]; arr[index] = temp;&#125;&#125;print(arr);//第三轮for(int index=3;index&lt;arr.length;index++)&#123;if(arr[2]&gt;arr[index])&#123; int temp = arr[2]; arr[2] = arr[index]; arr[index] = temp;&#125;&#125;print(arr);//第四轮for(int index=4;index&lt;arr.length;index++)&#123;if(arr[3]&gt;arr[index])&#123; int temp = arr[3]; arr[3] = arr[index]; arr[index] = temp; &#125;&#125;print(arr);//第五轮for(int index=5;index&lt;arr.length;index++)&#123;if(arr[4]&gt;arr[index])&#123; int temp = arr[4]; arr[3] = arr[index]; arr[index] = temp; &#125;&#125;print(arr);//第六轮没有，我们arr.length=6举例//int index = 6;index&lt;arr.length; falsepublic static void selectionSort(int[] arr)&#123;for(int count=1;count&lt;arr.length;count++)&#123; for(int index=count;index&lt;arr.length;index++) &#123; if(arr[count-1]&gt;arr[index]) &#123; int temp = arr[count-1]; arr[count-1] = arr[index]; arr[index] = temp; &#125; &#125;&#125; 数组的冒泡排序123456789101112131415public class Demo&#123; public static void main(String[] args)&#123; int[] nums = &#123; 3,1,7,5,8,9,23,45&#125;; for(int i = 0; i&lt; nums.length-1;i++)&#123; for(int j = 0;j&lt;nums.length-1-i;j++)&#123; if(nums[j]&gt;nums[j+1])&#123; int temp = nums[j]; nums[j] = nums [j+1]; nums[j+1] = temp; &#125;&#125; for(int j = 0; j&lt;nums.length;j++)&#123; Systm.out.println(nums[j]); &#125;&#125; 数组的打印12345//使用for int[] i = &#123; 2,3,4,5,6 &#125;; for(int each : i)&#123; System.out.println(each); &#125; 二维数组的表达12345int a[][] = new int[][]&#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;; 总结 本文讲了带你详解Java的操作符，控制流程以及数组，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七节：详细讲解Java中的日期，java.util.date]]></title>
    <url>%2F2018%2F03%2F26%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来详细讲解Java中的日期，java.util.date的概述，希望你们喜欢 类Date Java.lang.Object-&gt;java.util.Date1public class Date extends Object implements Serializable, Cloneable, Comparable Date类表示时间 Date的构造方法12Date(): 为分配Date对象，并初始化对象Date(int year, int month, int date) Date该方法1234after(Date when) 返回boolean值，表示是否在指定日期之后before(Date when) 返回boolean值，表示是否在指定日期之前clone() 返回 Object 对象equals(Object obj) 返回boolean值，比较两个日期的相等 类 CalendarCalendar 类是一个抽象类123public abstract class Calendar extends Object//Calendar 提供了一个类方法 getInstance Calendar rightNow = Calendar.getInstance(); 1234getInstance 返回：一个 Calendar。getTime 返回：表示时间值的 Date。getTimeInMillis 返回：当前时间。toString 返回：此日历的字符串表示形式。 123Date d = new Date();System.out.println(&quot;当前时间:&quot;);System.out.println(d); 总结 本文讲了详细讲解Java中的日期，java.util.date，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六节：详细讲解Java中的装箱与拆箱及其字符串]]></title>
    <url>%2F2018%2F03%2F25%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来详细讲解Java中的装箱与拆箱及其字符串的概述，希望你们喜欢 装箱与拆箱封装类有：Byte , short , Integer , Character , long , Float , Double 记住这些类就可以了，这些都是Number的子类。 了解装箱与拆箱的代码解析12345678910111213141516171819202122232425public class Test&#123; public static void main(String[] args)&#123; int i = 5; Integer integer = new Integer(i);//装箱 //拆箱 int i2 = integer.intValue(); &#125;&#125;//public class Test&#123; public static void main(String[] args)&#123; int i = 5; Integer integer = new Integer(i); Interger i2 = i;//自动装箱 int i3 = integer;//自动拆箱 &#125;&#125;//public class Test&#123; public static void main(String[] args)&#123; char c = &apos;Vic&apos;; character c2 = c; c3 = c2; &#125;&#125; 字符串1234567public class Test&#123; public static void main(String[] args)&#123; int i = 12; String str = String.valueof(i); System.out.println(str); &#125;&#125; 1234567public class Test&#123; public static void main(String[] args)&#123; int i = 12; Integer i2 = i; String str = i2.toString(); &#125;&#125; 要点charAt , toCharArray , subString , split , toLowerCase , toUpperCase 等。 StringBuffer , StringBuilder , String的区别 效率：StringBuilder &gt; StringBuffer &gt; String String 为不可改变的字符串常量；StringBuffer 为线程安全的字符串变量StringBuilder 为线程非安全的字符串变量 总结 本文讲了详细讲解Java中的装箱与拆箱及其字符串，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九节：详细讲解Java中的泛型，多线程，网络编程]]></title>
    <url>%2F2018%2F03%2F24%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来详细讲解Java中的泛型，多线程，网络编程的概述，希望你们喜欢 泛型泛型格式：ArrayList list= new ArrayList();ArrayList list= new ArrayList&lt;&gt;();Type可以为类，接口使用泛型可以使加入的，不用被强制 通配符ArrayList&lt;? extends Type&gt; list= new ArrayList&lt;&gt;();代表任意泛型 多线程在同一时间,做多件事情. 创建线程的方法继承类Thread并重写run()，run()称为线程体；用这种方法定义的类不能再继承其他类。123456789101112131415161718class FirstThread extends Thread&#123;public void run()&#123; for(int i=0;i&lt;100;i++)&#123; System.out.println(&quot;FirstThread&quot;+i); &#125;&#125;&#125;class Test&#123;public static void main(Sting args[])&#123; FirstThread ft = new FirstThread(); ft.start(); for(int i = 0; i&lt;100;i++)&#123; System.out.println(&quot;main&quot;+i): &#125;&#125;&#125; 接口Runnable的类作为线程的目标对象12345678910111213141516class Test implements Runnable&#123;public void run()&#123; for(int i = 0;i&lt;100;i++)&#123; System.out.println(&quot;Runnable&quot;+i); &#125;&#125;&#125;class Test&#123;public static void main(String args[])&#123; Test test = new Test(); Thread t = new Thread(test); System.out.println(t.getPriority()); t.start();&#125;&#125; 中断线程Thread.sleep();Thread.yield();//让出自己正在使用的CPU 设置线程的优先级123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131getPriority();setPriority();class Test implements Runnable&#123;public void run()&#123; for(int i = 0;i&lt;100;i++)&#123; System.out.println(&quot;Runnable&quot;+i); if(i==50)&#123; try&#123; Thread.sleep(2000); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125; &#125;&#125;&#125;class Test&#123;public static void main(String args[])&#123; RunnableImp1 ri = new RunnableImp1(); Thread t = new Thread(ri); t.setPriority(Thread.MAX_PRIORITY); //t.setPriority(Thread.MIN_PRIORITY); t.start(); System.out.println(t.getPriority()); &#125;&#125;class Test&#123;public static void main(String args[])&#123; MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread); Thread t2 = new Thread(myThread); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); //分别启动 t1.start(); t2.start();&#125;&#125;class MyThread implements Runnable&#123;int i = 100;public void run()&#123; while(true)&#123; System.out.println(Thread.currentThread().getName()+i); i--; Thread.yield(); if(i&lt;0)&#123; break; &#125; &#125;&#125;&#125;//同步代码块class MyThread implements Runnable&#123;int i = 100;public void run()&#123; while(true)&#123; synchronized(this)&#123; System.out.println(Thread.currentThread().getName()+i); i--; Thread.yield(); if(i&lt;0)&#123; break; &#125; &#125; &#125;&#125;&#125;深入synchronized关键字class Service&#123;public void fun1()&#123; synchronized(this)&#123; try&#123; Thread.sleep(3*1000); &#125; catch(Exception e)&#123; System.out.println(&quot;fun1&quot;); &#125; &#125; public void fun2()&#123; synchronized(this)&#123; System.out.println(&quot;fun2&quot;); &#125;&#125;&#125;class MyThread1 implements Runnable&#123;private Service service;public MyThread1(Service service)&#123; this.service = service;&#125;public void run()&#123; service.fun1();&#125;&#125;class MyThread2 implements Runable&#123;private Service service;public MyThread2(Service service)&#123; this.service = service;&#125;public void run()&#123; service.fun2();&#125;&#125;class Test&#123;public static void main(String args[])&#123; Service service = new Service(); Thread t1=new Thread(new MyThread1(service)); Thread t2=new Thread(new MyThread2(service)); t1.start(); t2.start();&#125;&#125; 同步锁 锁住的是service同步方法，同步代码块锁住this123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class Service&#123;public synchronized void fun1()&#123; try&#123; Thread.sleep(3*1000); &#125; catch(Exception e)&#123; System.out.println(e); &#125; System.out.println(&quot;fun1&quot;);&#125;public void fun2()&#123; synchronized(this)&#123; System.out.println(&quot;fun2&quot;);&#125;&#125;&#125;数组class Test&#123;public static void main(String args[])&#123; //数组的静态声明 int arr [] = &#123;5,2,7,8,9,0&#125;; arr[3] = 10; //System.out.println(arr[3]); for(int i = 0;i&lt;5;i++)&#123; System.out.println(arr[i]); &#125; &#125;&#125;class Test&#123;public static void main(String args[])&#123; int arr[] = &#123;2,4,6,7,8&#125;; System.out.println(arr.length); &#125;&#125;数组的动态声明class Test&#123;public static void main(String args[])&#123;//动态声明int arr [] = new int [10];System.out.println(&quot;arr数组长度&quot;+arr.length); for(int i = 0;i&lt;arr.length;i++)&#123; System.out.println(arr[i]); &#125;&#125;&#125;二维数组class Test&#123;public static void main(String args[])&#123; //二维数组的定义方法，长度为3 int arr [][] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;； System.out.println(arr[1][1]); for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++)&#123; System.out.println(arr[i][j]); &#125; &#125;&#125;&#125;优化class Test&#123;public static void main(String args[])&#123; //二维数组的定义方法，长度为3 int arr [][] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8&#125;&#125;； System.out.println(arr[1][1]); for(int i = 0; i &lt; arr.length; i++)&#123; for(int j = 0; j &lt; arr[i].length; j++)&#123; System.out.println(arr[i][j]); &#125; &#125;&#125;&#125;动态class Test&#123;public static void main(String args[])&#123; //int arr [][] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8&#125;&#125;； int arr [][] = new int[3][5]; System.out.println(arr[1][1]); for(int i = 0; i &lt; arr.length; i++)&#123; for(int j = 0; j &lt; arr[i].length; j++)&#123; System.out.println(arr[i][j]); &#125; &#125;&#125;&#125; 线程概念进程：就是执行一个任务；线程：就是在进程内部同时做的事情。 网络开发Socket和ServerSocketSocket为“孔”或“插座”，创建Socket，打开连接Socket的输入或输出流，对Socket进行读写，关闭Socket。 Accept方法用于产生“阻塞”，这里有getInputStream方法和getOutInputStream方法，会产生一个IOException， 在Java.net包中，有Socket和ServerSocket两个类。以JDK1.6介绍：12345678public Socket()public Socket(String host, int port)//host - 主机名，或者为 null，表示回送地址//port - 端口号public Socket(InetAddress address,int port)//address - IP 地址//port - 端口号 12345ServerSocket(int port)ServerSocket(int port,int backlog)ServerSocket(int port,int backlog,InetAddress binAddr) 服务器与客户端通信12345678910111213141516171819202122232425262728293031323334353637package two;import java.io.DataInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintStream;import java.net.ServerSocket;import java.net.Socket;public class ServerSocket1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; ServerSocket ss = new ServerSocket(2007); while(true) &#123; Socket s = ss.accept(); InputStream is = s.getInputStream(); OutputStream os = s.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(&quot;helloworld, i am server thinkpad&quot;); DataInputStream dis = new DataInputStream(is); String str = dis.readLine(); System.out.println(str); s.close(); &#125; &#125; catch(IOException ee) &#123; System.out.println(ee); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package two;import java.io.DataInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintStream;import java.net.ConnectException;import java.net.Socket;public class ClientSocket &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; Socket s = new Socket(&quot;########&quot;,2007); InputStream is = s.getInputStream(); OutputStream os = s.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(&quot;hello , i am client&quot;); DataInputStream dis = new DataInputStream(is); String str = dis.readLine(); System.out.println(str); s.close(); &#125; catch(ConnectException eee) &#123; System.out.println(eee); &#125; catch(IOException ee) &#123; System.out.println(ee); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 总结 本文讲了详细讲解Java中的泛型，多线程，网络编程，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二节：Java入门第一行代码]]></title>
    <url>%2F2018%2F03%2F23%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Java入门第一行代码的概述，希望你们喜欢 第一行代码学习Java基础课程，学会使用eclipse，eclipse为Java集成开发坏境IDE，创建第一个Java源文件代码：12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(&quot;hello world&quot;); &#125;&#125; 要点： HelloWorld为类的名字 public static void main(String[] args) 为主方法 System.out.println(“hello world”)为打印输出，并在控制台显示 hello world public 为访问修饰符，表示公开的访问类 Java为面向对象的语法 什么是面向对象？答：在Java中一切皆对象；可以理解为现实世界中的人，物，都可以看做为对象。 在一个Java的类中，该类可以为对象，那么类就是一个对象，一个对象就如人，它有方法和属性，即为动作和状态的特征。 12345678//建立一个人的类public class Person&#123; String name; //人具有姓名的属性 String age; //人具有年龄的属性 public void eat()&#123; System.out.println(&quot;人具有吃的方法&quot;); &#125;&#125; 变量的定义什么是变量，即为可以变化的量，示例 int age = 12; 其中 int 为变量的数据类型，表示整数 age 为变量 “=” 为赋值操作符，把右边的值赋值给左边的变量123456public class Person&#123; int age = 12; public static void main(String[] args)&#123; System.out.println(age); &#125;&#125; 介绍八种基本变量的类型八种基本数据类型 整型 4种：byte(8位)，short(16位)，int(32位)，long(64位) 字符型 1种：char(16位) 浮点型 2种：float(32位)，double(64位) 布尔型 1种：boolean(1位)（true，false） String类型（独立来讲，不是基本数据类型，为final修饰的）String类型一旦被创建，就不能够被更改。字符串类型的表达效果，示例：String name = &quot;Vic&quot; 强制类型转换和自动类型转换 数据类型的转换数据类型的理解：规则口诀小到大自动，大到小强制，表示小杯子里的水可以倒入大杯子里，而大杯子里的水倒入小杯子里，会出现溢出。 / 转换的数据类型比较 /byte-&gt;short(char)-&gt;int-&gt;long-&gt;float-&gt;double Java中的命名规范如果有人问Java中的命名规范，你可以简单的说：英，数，$，_ ，（第一位不能为数字），不能为关键字。 成员变量和局部变量声明在方法体外的变量为成员变量，声明在方法体内的变量为局部变量。 Final修饰符上述表达final修饰的，为不可变得值，final可以修饰变量，修饰类，修饰方法。 被修饰的变量，只能被赋值一次 被修饰的类，不能被继承 被修饰的方法，不可被重写 Static关键字的理解答：“ static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。” —《Java编程思想》 static代码块，只会在类加载的时候执行一次。static变量不需要创建对象就可以引用。 静态成员变量可以通过对象访问，只要访问权限足够就可以。 静态代码块，随着类的加载而执行，只执行一次。12345678910111213141516171819class StaticDemo&#123;static&#123;System.out.println(&quot;静态代码块&quot;);&#125;void show()&#123;System.out.println(&quot;方法&quot;);&#125;&#125;public class Test&#123;public static void main(String[] args)&#123; new StaticDemo().show(); new StaticDemo().show(); &#125;&#125;//result静态代码块方法方法 1234567891011public class Test&#123;static&#123;System.out.println(&quot;静态&quot;);&#125;public static void main(String[] args)&#123;System.out.println(&quot;静态main&quot;);&#125;&#125;//result 静态代码块优先于main函数执行静态静态main 1234567891011121314151617181920212223242526272829303132333435class StaticDemo&#123;static&#123;System.out.println(&quot;parent静态代码块&quot;);&#125;&#123;System.out.println(&quot;parent非静态代码块&quot;);&#125;StaticDemo()&#123;System.out.println(&quot;parent构造方法&quot;);&#125;public class Test extends StaticDemo&#123; static&#123; System.out.println(&quot;child静态&quot;);&#125;&#123;System.out.println(&quot;child非静态&quot;);&#125;Test()&#123;System.out.println(&quot;child构造方法&quot;);&#125;public static void main(String[] args)&#123;System.out.println(&quot;main&quot;);new Test();&#125;&#125;//resultparent静态代码块child静态mainparent非静态代码块parent构造方法child非静态child构造方法 总结 本文讲了Java入门第一行代码，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八节：详细讲解Java中的异常处理情况与I/O流的介绍以及类集合框架]]></title>
    <url>%2F2018%2F03%2F22%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来详细讲解Java中的异常处理情况与I/O流的介绍以及类集合框架的概述，希望你们喜欢 JAVA 异常try…catch…finally结构的使用方法1234567891011121314151617181920212223242526class Test&#123;public static void main(String args[])&#123; try&#123; int i = 1 / 0; &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; finally&#123; System.out.println(&quot;finally&quot;); &#125; System.out.println(5); &#125;&#125;class Test&#123;public static void main(String args[])&#123; try&#123; Thread.sleep(1000); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;&#125; throw和throws的作用区别：1234567891011121314151617181920212223class Person&#123;private int age;public void setAge(int age) throws Exception&#123; if(age&lt;0)&#123; RuntimeException e = new RuntimeException(&quot;年龄不能小于0&quot;); throw e; &#125; this.age = age; &#125;&#125;class Test&#123;public static void main(String args[])&#123; Person person = new Person(); try&#123; person.setAge(-1); &#125; catch(Exception e)&#123; System.out.println(e); &#125;&#125;&#125; Error和Exception的区别 Error是Throwable的子类用于标记严重错误 Exception是Throwable的子类，指示合理的程序想去catch的条件，非严重错误。try/catch的执行过程如果出现异常，系统则会抛出一个异常，进行捕捉（catch操作），或在最后（finally）来进行处理。throw和throws的区别throws 出现在方法声明上，throw出现在方法体内。异常分类异常分类：可查异常，运行时异常和错误说说IO1234567891011121314151617181920//第一种：输入流输出流//第二种：字节流字符流//第三种：节点流处理流//FileInputStreamclass Test&#123; public static void main(String args[])&#123; FileInputStream fis = null; try&#123; fis = new FileInputStream(&quot;e:/read.txt&quot;); byte[] buffer = new byte[100]; fis.read(buffer,0,buffer.length); for(int i = 0;i&lt;buffer.length;i++)&#123; System.out.println(buffer[i]); &#125;&#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; 12345678910111213141516class Test&#123; public static void main(String args[])&#123; FileInputStream fis = null; FileOutputStream fos = null; try&#123; fis = new FileInputStream(&quot;e:/read.txt&quot;); fos = new FileOutputStream(&quot;e:/write.txt&quot;); byte[] buffer = new byte[100]; int temp = fis.read(buffer,0,buffer.length); fos.write(buffer,0,temp); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; 123456789101112131415161718192021222324252627class Test&#123; public static void main(String args[])&#123; FileInputStream fis = null; FileOutputStream fos = null; try&#123; fis = new FileInputStream(&quot;e:/read.txt&quot;); fos = new FileOutputStream(&quot;e:/write.txt&quot;); byte[] buffer = new byte[1024]; while(true)&#123; int temp = fis.read(buffer,o,buffer.length); if(temp = -1)&#123; break; &#125; fos.write(buffer,0,temp); &#125; &#125;catch(Exception e)&#123; System.out.println(e); &#125;finally&#123; try&#123; fis.close(); fos.close(); &#125;catch(Excepiton e)&#123; System.out.println(e); &#125; &#125;&#125;&#125; 12345678910111213141516171819202122232425//字符流public class TextChar public static void main(String args[])&#123; FileReader fr = null; FileWriter fw = null; try&#123; fr = new FileReader(&quot;e:/read.txt&quot;); fw = new FileWriter(&quot;e:/write.txt&quot;); char[] buffer = new char[100]; int temp = fr.read(buffer,0,buffer.length); fw.write(buffer,0,temp); &#125; catch(Exception e)&#123; System.out.println(e); &#125;finally&#123; try&#123; fr.close(); fw.close(); &#125; catch(Excepiton e)&#123; System.out.println(e); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930//FileReader和BufferedReaderclass Test&#123; public static void main(String args[])&#123; FileReader fileReader = null; BufferedReader bufferedReader = null;try&#123; fileReader = new FileReader(&quot;e:/read.txt&quot;); bufferedReader = new BufferedReader(fileReader); String line = null; while(true)&#123; line = bufferedReader.readLine(); if(line == null)&#123; break; &#125; System.out.println(line); &#125; &#125;catch(Exception e)&#123; System.out.println(e); &#125; finally&#123; try&#123; bufferedReader.close(); fileReader.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324public class Test&#123; public static void main(String[] args) throws Exception&#123; //字节流 FileInputStream in = new FileInputStream(&quot;c:/read.txt&quot;); FileOutStream out = new FileOutputStream(&quot;c:/write.txt&quot;); byte[] buffer = new byte[1024]; int len; while( (len = in.read(buffer)) != -1)&#123; out.write(buffer,0,len); &#125; in.close(); out.close(); //字符流 BufferedReader bf = new BufferedReader(new FileReader(&quot;c:/read.txt&quot;); BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;c:/write.txt&quot;); String str; while( (str=bf.readLine()) != null )&#123; bw.write(str); bw.newLine(); &#125; bf.close(); bw.close(); &#125;&#125; 字节流: InputStream字节输入流,OutputStream字节输出流 字符流 : Reader字符输入流 ,Writer字符输出流 数据流: DataInputStream 数据输入流 ,DataOutputStream 数据输出流 集合框架一组类和接口，位于java.util包，主要用于存储和管理对象，主要分为三大类—集合，列表和映射。 什么是集合（Set）集合中对象是没有顺序的，并且没有重复对象； 什么是列表（List）集合中对象可以有重复的对象，可以按照顺序取，也可以指定取。 什么是映射（Map）每一个元素包含一个键对象和一个值对象，键不可以重复，值可以重复。 类集框架主体结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interfaceIterator CollectionListIterator List Set MapLinkeList ArrayList HashSet SortedSet HashMap SortedMapLinkedHashSet TreeSet LinkedHashMap TreeMapComparable Comparator Collections Arrays//arrayList默认10,可无限长，关于泛型public class Test&#123;public static void main(String args[])&#123; //ArrayList arrayList = new ArrayList(); ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(&quot;a&quot;); arrayList.add(&quot;b&quot;); arrayList.add(&quot;c&quot;); //String s = arrayList.get(1); //System.out.println(s); for(int i=0;i&lt;3;i++)&#123; String s = arrayList.get(i); System.out.println(s); &#125; &#125;&#125;优化public class Test&#123;public static void main(String args[])&#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(&quot;a&quot;); arrayList.add(&quot;b&quot;); arrayList.add(&quot;c&quot;); arrayList.add(&quot;d&quot;); for(int i = 0; i&lt;arrayList.size();i++)&#123; String s = arrayList.get(i); System.out.println(s); &#125;&#125;&#125; 类集框架集合 无序 不可重复列表 有序 可重复映射 Set继承了Collection123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class Test&#123; public static void main(String args[])&#123; //HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); //Set&lt;String&gt; set = new HashSet&lt;String&gt;(); //别管就是转，方便 Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;a&quot;); set.add(&quot;b&quot;); set.add(&quot;c&quot;); set.add(&quot;d&quot;); int i = set.size(); System.out.println(i); &#125;&#125;不可以重复public class Test&#123; public static void main(String args[])&#123; //HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); //Set&lt;String&gt; set = new HashSet&lt;String&gt;(); //别管就是转，方便 Set&lt;String&gt; set = new HashSet&lt;String&gt;(); boolean b1 = set.isEmpty(); System.out.println(b1); set.add(&quot;a&quot;); set.add(&quot;b&quot;); set.add(&quot;c&quot;); set.add(&quot;d&quot;); set.add(&quot;c&quot;); boolean b2 = set.isEmpty(); System.out.println(b2); int i = set.size(); System.out.println(&quot;clear之前的长度&quot;+i); set.clear(); int j = set.size(); System.out.println(j); &#125;&#125;取数据，迭代 iterate器 (Iterator)public class Test&#123;public static void main(String args[])&#123; //HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); //Set&lt;String&gt; set = hashSet; //Iterator &lt;-- Collection &lt;-- Set &lt;-- HashSet //hasNext() next() Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;a&quot;); set.add(&quot;b&quot;); set.add(&quot;c&quot;); set.add(&quot;d&quot;); set.add(&quot;c&quot;); Iterator&lt;String&gt; it = set.iterator(); boolean b1 = it.hasNext(); if(b1)&#123; String s = it.next(); System.out.println(s); &#125; boolean b2 = it.hasNext(); if(b2)&#123; String s = it.next(); System.out.println(s); &#125; &#125;&#125;迭代器的使用it.hasNext();还有没有下一个元素，如果这个游标后面有元素就返回true，否则,false;it.next();返回游标所指位置的下一个元素，取出，用hasNext()看有没有，next取优化public class Test&#123;public stattic void main(String args[])&#123; Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;a&quot;); set.add(&quot;b&quot;); set.add(&quot;c&quot;); set.add(&quot;d&quot;); set.add(&quot;c&quot;); Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s);&#125;&#125;&#125; 什么是映射（Map）每一个元素包含一个键对象和一个值对象，键不可以重复，值可以重复。123456789101112131415161718192021222324252627282930313233public class Test&#123;public static void main(String args[])&#123; HashMap&lt;String,String&gt; hasMap = new HashMap&lt;String,String&gt;(); Map&lt;String,String&gt; map = hasMap; map.put(&quot;1&quot;,&quot;a&quot;); map.put(&quot;2&quot;,&quot;b&quot;); map.put(&quot;3&quot;,&quot;c&quot;); map.put(&quot;4&quot;,&quot;d&quot;); int i = map.size(); System.out.println(i);&#125;&#125;public class Test&#123;public static void main(String args[])&#123; HashMap&lt;String,String&gt; hasMap = new HashMap&lt;String,String&gt;(); Map&lt;String,String&gt; map = hasMap; map.put(&quot;1&quot;,&quot;a&quot;); map.put(&quot;2&quot;,&quot;b&quot;); map.put(&quot;3&quot;,&quot;c&quot;); map.put(&quot;4&quot;,&quot;d&quot;); map.put(&quot;3&quot;,&quot;e&quot;); int i = map.size(); System.out.println(i); String s = map.get(&quot;3&quot;); System.out.println(ss);&#125;&#125; 123456789101112public class TestCollection &#123; public static void main(String[] args) &#123; List&lt;Hero&gt; heros = new ArrayList&lt;Hero&gt;(); for (int i = 0; i &lt; 5; i++) &#123; heros.add(new Hero(&quot;hero name &quot; + i)); &#125; for (int i = 0; i &lt; heros.size(); i++) &#123; Hero h = heros.get(i); System.out.println(h); &#125; &#125;&#125; 总结 本文讲了详细讲解Java中的异常处理情况与I/O流的介绍以及类集合框架，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试集合（一）]]></title>
    <url>%2F2018%2F03%2F21%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Java面试集合（一）的概述，希望你们喜欢 一1.Java按应用范围可划分几个版本？答：Java按应用范围有三个版本，分别是JavaSE，JavaEE，JavaME。 2.Java有哪些特性？答：Java的特性有：面向对象，跨平台性，健壮性，安全性，可移植性，多线程性，等。 3.带你走进Java的第一个编程题目？12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World&quot;); &#125;&#125; 4.Java的基本数据类型？答：Java共有八种基本数据类型，分别是： byte，字节型，一个字节short，短整型，两个字节int，整型，四字节long，长整型，八字节float，单精度浮点型，四字节double，双精度浮点型，八字节char，字符型，两个字节boolean，逻辑值，一个字节 5.打印奇数100内之和？123456789public class One&#123; public static void main(String[] args)&#123; int sum = 0; //定义总和变量 for(int i = 1;i&lt;100;i++)&#123; //定义循环1到100的数 if(i%2 ！= 0）&#123; //如果i求余不等于0，得出奇数 System.out.println(i);//打印i sum += i; &#125; &#125; 6.排列数组，按顺序排列？123456789101112131415161718public class Two&#123; public static void main(String[] args) &#123; int[] arr = &#123; 4,51,2,7,6,9,8,10 &#125;; for (int i = 0; i &lt; arr.length-1; i++) &#123; //这里的算法可在Vic-深入浅出的排序算法进行相关复习 for (int j = 0; j &lt; arr.length-1-i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; // 比较相邻元素 int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); // 打印排序完后的元素 &#125; &#125;&#125; 7.Java中的三大特性？答：Java中的三大特性，有继承，封装，多态。 8.进行无参和有参的构造函数以及get，set方法，实例化代码描述？123456789101112131415161718192021222324252627282930class Student &#123; private String name; private int age; public Student() &#123; //无参的构造函数 &#125; public Student(String name, int age) &#123; //有参的构造函数 this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;public class Three &#123; public static void main(String[] args) &#123; Student student = new Student(); //new一个对象 stu1.setName(&quot;zhangsan&quot;); stu1.setAge(17); Student stu2 = new Student(&quot;lisi&quot;, 18); &#125;&#125; 9.如何运用内部类？1234567891011121314class My &#123; class Mylove&#123; public void loveYou() &#123; System.out.println(&quot;I love U&quot;); &#125; &#125;&#125;public class Four &#123; public static void main(String[] args) &#123; My.Mylove love = new My().new Mylove(); love.loveYou();&#125;&#125; 10.用代码表示继承关系？123456789101112131415161718192021222324252627282930313233343536373839404142//定义父类class Person &#123; String name; int age;Person() &#123; System.out.println(&quot;Person的无参构造函数&quot;);&#125;Person(String name, int age)&#123; this.name = name; this.age = age; System.out.println(&quot;Person的有参构造函数&quot;);&#125; public void show()&#123; System.out.println(&quot;name:&quot;+name+&quot;,age:&quot;+age); &#125;&#125;//定义子类继承父类class Student extends Person&#123; public int id; public Student()&#123; super(); System.out.println(&quot;Student的无参构造函数&quot;); &#125; public Student(String name, int age, int id)&#123; super(name,age); this.id=id; &#125; public void show()&#123; System.out.println(&quot;name:&quot;+name+&quot;,age:&quot;+age+&quot;,id&quot;+id); &#125;&#125;//测试类public class Five&#123; public static void main(String[] args)&#123; Person person = new Person(&quot;Vic&quot;,17); person.show(); Student student = new Student(&quot;Vic&quot;,17,123456); student.show(); &#125;&#125; 总结 本文讲了Java面试集合（一），如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Java面试集合</category>
      </categories>
      <tags>
        <tag>Java面试集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试集合（三）]]></title>
    <url>%2F2018%2F03%2F20%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Java面试集合（三）的概述，希望你们喜欢 三1.在Java中是否可以含有多个类？答：可以含有多个类，但只有一个是public类，public类的类名与文件名必须一致。 2.说说&amp;和&amp;&amp;的区别？答：&amp;&amp;短路与，当第一个表达式为false时，第二个表达式不会进行。&amp;，当一个表达式为false时，第二个表达式会进行。 3.char变量类型，能否存储一个中文汉字？答：可以储存一个汉字，因为char是用Unicode编码来存储的，所以可以存储。 4.final关键字修饰变量时，是引用不变，还是引用对象不变？答：使用final关键字修饰变量时，是引用变量不能变，引用变量所指对象中的内容是可以改变的。 5.静态变量和实例变量的区别？答：静态变量前要加static修饰，而实例变量不用。在静态变量中不需要实例对象来调用输出，而实例变量则需要进行实例化，才能使用。123456789public class Test&#123; public int i = 1; public static int j = 0; public static void main(String[] args) &#123; Test in = new Test(); System.out.println(in.i); System.out.println(j); &#125; &#125; 6.如何理解Math类中的ceil，floor，round？答：ceil为天花板，则向上取整为取大的值，补充到整数；floor为地板，则向下取整为取最近小的整数；round为周围，四舍五入，原则在原来基础上+0.5，超过0.5的进位，不超过0.5就取进小整数。 7.Overload和Override的区别？答：Overload为重载，Override为覆盖，重写。 8.请说说分层设计的好处？答： 实现了软件之间的解耦 便于进行分工 便于对软件组件的重用 便于进行维护 便于对功能的扩展 9.Java中实现多态的机制是？答：父类或接口定义的引用变量指向子类具体实现类的实例对象，引用变量指向具体的实例对象。 10.说说abstract，interface？答： abstract修饰class为抽象类，抽象类不能创建实例对象，抽象类中的方法不必要抽象abstract修饰，但是含有abstract修饰的方法的类则必须是抽象类。abstract class内可以没有抽象方法，不可以被实例化，但是可以被声明。 interface接口中的所有方法必须是抽象的，接口中方法默认为public abstract类型，接口中变量类型默认public static final类型。接口中的成员变量必须定义初始化，实现接口类必须在该类实现所有的方法。 在抽象类中有构造方法，接口中没有；抽象类中有普通成员变量，接口中没有；抽象类中可以有静态方法，接口中不能有静态方法。 11.什么是内部类？答：内部类是在一个类的内部定义的类，静态内部类可以有静态成员变量，而非静态内部类不能有静态成员；内部类可以在外部类中的方法中定义，也可以在外部类的方法外定义。 静态内部类中对外部类进行引用，只有非静态外部类才能对外部类进行引用。 在静态内部类中不需要进行外部类的实例，就可以进行实例化，而非静态内部类需要在外面创建内部类的实例对象，创建时，一定要先创建外部类的实例对象，然后用外部类的实例对象去创建内部类的实例对象。 12.String是否可以被继承？答：不可以被继承，因为java.lang.String类是final类型的，不能继承的类，被final关键字修饰的类，并且不能被修改，不能改变！ 当一个final类型中，String s = “Vic”;s = s + “ love “;表示原有的对象并没有被改变而是该引用转向了新的对象，原有的s引用不在指向原有的对象了。 13.1到99累加的String和StringBuffer效率？1234StringBuffer sb = new StringBuffer();for(int i = 0; i&lt;100; i++)&#123; sb.append(i);&#125; 1234String str = new String();for(int i = 0; i&lt;100; i++)&#123; str = str + i;&#125; StringBuffer只创建一个对象，而String创建了多个对象。 14.说说final，finally，finalize？答：final用于修饰属性，方法，类，被修饰的属性是不可以变的，被修饰的方法是不可被覆盖的，被修饰的类是不可以被继承的。 finally这个是在异常处理语句中的一部分，finally中的语句是总要执行的。 finalize是垃圾回收集机制的，记住这点就够了。 15.在Java中有几种方法来实现线程？答：12345//new Thread()&#123;&#125;.start();new Thread()&#123; public void run()&#123; &#125;&#125;.start(); 1234new Thread(new Runnable()&#123; public void run()&#123; &#125; &#125;).start(); 16.说说迭代器模式？答：1234567public static void print(String str)&#123; Iterator it = str.iterator(); while(it.hasNext())&#123; String str = it.next(); System.out.println(str); &#125;&#125; 17.说说装饰者模式？答：1234567891011121314151617181920212223242526public interface Person&#123; void eat();&#125;public class Student implements Person&#123; public void eat()&#123; System.out.println(&quot;eating&quot;); &#125;&#125;public class Me implements Person&#123; private Student student; Me(Student student)&#123; this.student=student;&#125;public void eat()&#123; System.out.println(&quot;study&quot;); student.eat(); System.out.println(&quot;sleeping&quot;); &#125;&#125;public class PersonDemo&#123; public static void main(String[] args)&#123; Student student = new Student(); Me me = new Me(student); me.eat(); &#125;&#125; 18.说说单例模式？123456789//私有构造方法；私有静态引用，返回值为静态的公有方法public class Singleton&#123; private static Singleton singleton = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 19.说说工厂模式？1234567891011121314151617181920212223242526272829303132333435363738394041public interface School&#123; void Study();&#125;public class Studentone implements School&#123; public void Study()&#123; System.out.println(&quot;studyone&quot;); &#125;&#125;public class Studenttwo implements School&#123; public void Study()&#123; System.out.println(&quot;studytwo&quot;); &#125;&#125;public interface AllSchool&#123; School getSchool();&#125;public class Studentone implements AllSchool&#123; public School getSchool()&#123; return new Study(); &#125;&#125; public class Studenttwo implements AllSchool&#123; public School getSchool()&#123; return new Study(); &#125;&#125;public class SchoolDemo&#123; public void test()&#123; AllSchool allSchool = null //one allSchool = new Studentone(); Studentone one = allSchool.getSchool(); one.Study(); //two allSchool = new Studenttwo(); Studenttwo two = allSchool.getSchool(); two.Study(); &#125;&#125; 20.说说原型模式？答：实现Cloneable接口，重写Object类中的clone方法 21.说说生成器模式？答：12345678910111213141516171819class Ym&#123; public void ymRequest()&#123; System.out.println(&quot;getYm&quot;); &#125;&#125;interface Target&#123; public void request();&#125;class Ym extends Ym implements Target&#123; public void request()&#123; super.ymRequest(); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Target adapter = new Adapter(); adapter.request(); &#125;&#125; 22.说说代理模式？1234567891011121314151617181920212223242526272829303132//静态public interface Info&#123; public void infoOne(): public void infoTwo();&#125;public class TrueInfo implements Info&#123; public void infoOne()&#123; &#125; public void infoTwo()&#123; &#125;&#125;public class FlaseInfo implements Info&#123; private Info trueInfo; public FlaseInfo(Info trueInfo)&#123; this.trueInfo = trueInfo; &#125; public void infoOne()&#123; &#125; public void infoTwo()&#123; &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Info trueInfo = new TrueInfo(); Info flaseInfo = new FlaseInfo(trueInfo); flaseInfo.infoOne(); flaseInfo.infoTwo(); &#125;&#125; 23.说说外观模式？1234567891011121314151617181920212223242526272829303132333435public class Studentone&#123; public void One()&#123; System.out.println(&quot;Studentone one&quot;); &#125; public void Two()&#123; System.out.println(&quot;Studentone two&quot;); &#125;&#125;public class Studenttwo&#123; public void One()&#123; System.out.println(&quot;Studenttwo one&quot;); &#125; public void Two()&#123; System.out.println(&quot;Studenttwo two&quot;); &#125;&#125;public class School&#123; public void Study()&#123; Studnetone one = new Studentone(); one.One(); one.Two(); Studenttwo two = new Studnettwo(); two.Ono(); two.Two(); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; School school = new School(); school.Study(); &#125;&#125; 24.说说冒泡排序？123456789101112131415public class Demo&#123; public static void main(String[] args)&#123; int[] nums = &#123; 3,1,7,5,8,9,23,45&#125;; for(int i = 0; i&lt; nums.length-1;i++)&#123; for(int j = 0;j&lt;nums.length-1-i;j++)&#123; if(nums[j]&gt;nums[j+1])&#123; int temp = nums[j]; nums[j] = nums [j+1]; nums[j+1] = temp; &#125;&#125; for(int j = 0; j&lt;nums.length;j++)&#123; Systm.out.println(nums[j]); &#125;&#125; 25.说说选择排序？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//这种就是排序算法，比如有6个人，第一轮要进行5次比较//第一轮for(int index=1;index&lt;arr.length;index++)&#123;if(arr[0]&gt;arr[index])&#123; int temp = arr[0]; arr[0] = arr[index]; arr[index] = temp;&#125;&#125;print(arr);//第二轮for(int index=2;index&lt;arr.length;index++)&#123;if(arr[1]&gt;arr[index])&#123; int temp = arr[1]; arr[1] = arr[index]; arr[index] = temp;&#125;&#125;print(arr);//第三轮for(int index=3;index&lt;arr.length;index++)&#123;if(arr[2]&gt;arr[index])&#123; int temp = arr[2]; arr[2] = arr[index]; arr[index] = temp;&#125;&#125;print(arr);//第四轮for(int index=4;index&lt;arr.length;index++)&#123;if(arr[3]&gt;arr[index])&#123; int temp = arr[3]; arr[3] = arr[index]; arr[index] = temp; &#125;&#125;print(arr);//第五轮for(int index=5;index&lt;arr.length;index++)&#123;if(arr[4]&gt;arr[index])&#123; int temp = arr[4]; arr[3] = arr[index]; arr[index] = temp; &#125;&#125;print(arr);//第六轮没有，我们arr.length=6举例//int index = 6;index&lt;arr.length; falsepublic static void selectionSort(int[] arr)&#123;for(int count=1;count&lt;arr.length;count++)&#123; for(int index=count;index&lt;arr.length;index++) &#123; if(arr[count-1]&gt;arr[index]) &#123; int temp = arr[count-1]; arr[count-1] = arr[index]; arr[index] = temp; &#125; &#125;&#125; 26.说说substring()？答：substring(int beginIndex, int endIndex),返回字符串从beginIndex到endIndex-1的内容。 27.static关键字的用途？答：“ static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。” —《Java编程思想》 static代码块，只会在类加载的时候执行一次。static变量不需要创建对象就可以引用。 静态成员变量可以通过对象访问，只要访问权限足够就可以。 静态代码块，随着类的加载而执行，只执行一次。12345678910111213141516171819class StaticDemo&#123; static&#123; System.out.println(&quot;静态代码块&quot;); &#125; void show()&#123; System.out.println(&quot;方法&quot;); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; new StaticDemo().show(); new StaticDemo().show(); &#125;&#125;//result静态代码块方法方法 1234567891011public class Test&#123; static&#123; System.out.println(&quot;静态&quot;); &#125; public static void main(String[] args)&#123; System.out.println(&quot;静态main&quot;); &#125;&#125;//result 静态代码块优先于main函数执行静态静态main 1234567891011121314151617181920212223242526272829303132333435class StaticDemo&#123; static&#123; System.out.println(&quot;parent静态代码块&quot;); &#125; &#123; System.out.println(&quot;parent非静态代码块&quot;); &#125; StaticDemo()&#123; System.out.println(&quot;parent构造方法&quot;); &#125; public class Test extends StaticDemo&#123; static&#123; System.out.println(&quot;child静态&quot;); &#125;&#123; System.out.println(&quot;child非静态&quot;); &#125; Test()&#123; System.out.println(&quot;child构造方法&quot;); &#125;public static void main(String[] args)&#123; System.out.println(&quot;main&quot;); new Test(); &#125;&#125;//resultparent静态代码块child静态mainparent非静态代码块parent构造方法child非静态child构造方法 28.说说IO？1234567891011121314151617181920//第一种：输入流输出流//第二种：字节流字符流//第三种：节点流处理流//FileInputStreamclass Test&#123; public static void main(String args[])&#123; FileInputStream fis = null; try&#123; fis = new FileInputStream(&quot;e:/read.txt&quot;); byte[] buffer = new byte[100]; fis.read(buffer,0,buffer.length); for(int i = 0;i&lt;buffer.length;i++)&#123; System.out.println(buffer[i]); &#125;&#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; 12345678910111213141516class Test&#123; public static void main(String args[])&#123; FileInputStream fis = null; FileOutputStream fos = null; try&#123; fis = new FileInputStream(&quot;e:/read.txt&quot;); fos = new FileOutputStream(&quot;e:/write.txt&quot;); byte[] buffer = new byte[100]; int temp = fis.read(buffer,0,buffer.length); fos.write(buffer,0,temp); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; 123456789101112131415161718192021222324252627class Test&#123; public static void main(String args[])&#123; FileInputStream fis = null; FileOutputStream fos = null; try&#123; fis = new FileInputStream(&quot;e:/read.txt&quot;); fos = new FileOutputStream(&quot;e:/write.txt&quot;); byte[] buffer = new byte[1024]; while(true)&#123; int temp = fis.read(buffer,o,buffer.length); if(temp = -1)&#123; break; &#125; fos.write(buffer,0,temp); &#125; &#125;catch(Exception e)&#123; System.out.println(e); &#125;finally&#123; try&#123; fis.close(); fos.close(); &#125;catch(Excepiton e)&#123; System.out.println(e); &#125; &#125;&#125;&#125; 12345678910111213141516171819202122232425//字符流public class TextChar public static void main(String args[])&#123; FileReader fr = null; FileWriter fw = null; try&#123; fr = new FileReader(&quot;e:/read.txt&quot;); fw = new FileWriter(&quot;e:/write.txt&quot;); char[] buffer = new char[100]; int temp = fr.read(buffer,0,buffer.length); fw.write(buffer,0,temp); &#125; catch(Exception e)&#123; System.out.println(e); &#125;finally&#123; try&#123; fr.close(); fw.close(); &#125; catch(Excepiton e)&#123; System.out.println(e); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930//FileReader和BufferedReaderclass Test&#123; public static void main(String args[])&#123; FileReader fileReader = null; BufferedReader bufferedReader = null;try&#123; fileReader = new FileReader(&quot;e:/read.txt&quot;); bufferedReader = new BufferedReader(fileReader); String line = null; while(true)&#123; line = bufferedReader.readLine(); if(line == null)&#123; break; &#125; System.out.println(line); &#125; &#125;catch(Exception e)&#123; System.out.println(e); &#125; finally&#123; try&#123; bufferedReader.close(); fileReader.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324public class Test&#123; public static void main(String[] args) throws Exception&#123; //字节流 FileInputStream in = new FileInputStream(&quot;c:/read.txt&quot;); FileOutStream out = new FileOutputStream(&quot;c:/write.txt&quot;); byte[] buffer = new byte[1024]; int len; while( (len = in.read(buffer)) != -1)&#123; out.write(buffer,0,len); &#125; in.close(); out.close(); //字符流 BufferedReader bf = new BufferedReader(new FileReader(&quot;c:/read.txt&quot;); BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;c:/write.txt&quot;); String str; while( (str=bf.readLine()) != null )&#123; bw.write(str); bw.newLine(); &#125; bf.close(); bw.close(); &#125;&#125; 29.同步和异步什么时候用？答：如果数据将在线程间共享，进行同步存取；如果应用程序在对象上调用时间长，建议使用异步。 30.说出一些常用的类，包，接口？答：类：BufferedReader，BufferedWriter，String，Integer，System，Class，FileReader包：java.util，java.io，java.lang，java.sql，javax.servlet接口：List，Map，Set，Remote，Document 总结 本文讲了Java面试集合（三），如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Java面试集合</category>
      </categories>
      <tags>
        <tag>Java面试集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试集合（二）]]></title>
    <url>%2F2018%2F03%2F19%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Java面试集合（二）的概述，希望你们喜欢 二1.请问线程有哪些状态？ 新建状态（New）就绪状态（Runnable）运行状态（Running）阻塞状态（Blocked）死亡状态（Terminated） 2.表达线程代码？123new Thread()&#123; public void run()&#123;&#125;&#125;.start(); 123new Thread(new Runnable()&#123; public void run()&#123;&#125;&#125;).start(); 3.如何表示什么是接口？123456789101112131415161718192021interface Student&#123; public void read(); public void write();&#125;class ChineseStudent implements Student&#123; public void read()&#123; System.out.println(&quot;read&quot;); public void write()&#123; System.out.println(&quot;write&quot;);&#125;&#125;//测试类class Test&#123; public static void main(String args[])&#123; ChineseStudent chinesestudent = new ChineseStudent(); Student student = chinesestudent; student.read(); student.write(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435//implements关键字，继承多个接口interface Student&#123; public void read(); public void write();&#125;interface Teacher&#123; public void teach(); public void test();&#125;class Person implements Student,Teacher&#123; public void read()&#123; system.out.printlln(&quot;read&quot;);&#125; public void write()&#123; System.out.println(&quot;write&quot;);&#125; public void teach()&#123; System.out.println(&quot;teach&quot;);&#125; public void test()&#123; System.out.println(&quot;test&quot;);&#125;&#125;//测试类class Test&#123; public static void main(String args[])&#123; Person person = new Person(); Student student = person; student.read(); student.write(); Teacher teacher = person; teacher.teach(); teacher.close();&#125;&#125; 4.简单说说String类和StringBuffer类之间的区别？答：String类是不可变的类，字符串一旦被初始化就不可能改变；StringBuffer是可变的字符串类，可以修改字符串的值。 5.简单说说List，Set，Map的区别？ List的特点是元素有序，元素可重复；List常见的实现类为ArrayList和LinkedList；Set的特点是元素的无序，元素不可重复，Set常见的实现类有HashSet和TreeSet；Map的特点是存储的元素是键（key）和值（Value）的映射关系，元素都是成对出现的，Map的常见实现类是HashMap和TreeMap。 6.来描述类集合框架？1234567891011121314public class Test&#123; public static void main(String[] args)&#123; ArrayList list = new Arraylist(); for(int i = 0; i&lt;10; i++)&#123; list.add(&quot;Test:&quot;+i); &#125; //打印 Iterator iterator = list.iterator(); while(iterator.hasNext())&#123; //集合不能记住元素的类型 Object object = iterator.next(); System.out.println(object); &#125;&#125; 7.说说字节流和字符流？答：字节流的两个基类分别是InputStream和OutputStream，字符流的两个基类分别是Reader和Writer。字节流是以8位字节为单位的字节流类，而字符流是以16位字节为单位。 8.用代码介绍FileInputStream和FileOutputStream，以及BufferedReader和BufferedWriter？12345678910111213141516171819202122232425public class Test&#123; public static void main(String args) throws Exception&#123; //字节流 FileInputStream in = new FileInputStream(&quot;C:/test.txt&quot;); FileOutStream out = new FileOutputStream(&quot;D:/testone.txt&quot;); byte[] buf = new byte[1024]; int len; while( (len = in.read(buf)) != -1)&#123; out.write(buf，0，len); &#125; in.close(); out.close();//字符流BufferedReader bf = new BufferedReader(new FileReadere(&quot;C:/test.txt&quot;));BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D://testtwo.txt&quot;));String str; while( (str = bf.readLine() ) != null )&#123; bw.write(str); bw.newLine();&#125;bf.close();bw.close();&#125;&#125; 9.网络开发Socket和ServerSocket的表达？123456789101112131415161718192021222324//服务端public class ServerSocket1&#123; public static void main(String[] args)&#123; try&#123; ServerSocket ss = new ServerSocket(2008); while(true)&#123; Socket s = ss.accept(); InputStream is = s.getInputStream(); OutputStream os = s.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(&quot;hello, i am server&quot;); DataInputStream dis = new DataInputStream(is); String str = dis.readLine(); System.out.println(str); s.close();&#125;&#125;catch(IOException ee)&#123; System.out.println(ee);&#125;catch(Excepiton e)&#123; System.out.println(e);&#125; 12345678910111213141516171819202122232425//客户端public class ClientSocket&#123; public static void main(String[] args)&#123; try&#123; Socket s = new Socket(&quot;####id&quot;,2008); InputStream is = s.getInputStream(); OutputStream os = s.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(&quot;hello, i am client&quot;); DataInputStream dis = new DataInputStream(is); String str = dis.readLine(); System.out.println(str); s.close();&#125;catch(ConnectException eee) &#123; System.out.println(eee); &#125; catch(IOException ee) &#123; System.out.println(ee); &#125; catch(Exception e) &#123; System.out.println(e); &#125; &#125;&#125; 10.谈谈，解惑？答：对于我来说，我认为程序员并不是最好的职业，这是从享受生活的角度上看的，我听说过太多程序员的熬夜现象了，这是一门学到老的专业方向，如今IT的发展太快了，并且太多细节需要我们深入了解，这就大大让IT工作太累了，如果不是喜欢，不是兴趣，建议自己重新思考，重新定义。 总结 本文讲了Java面试集合（二），如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Java面试集合</category>
      </categories>
      <tags>
        <tag>Java面试集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-如何显示版本号并制作3秒跳转页]]></title>
    <url>%2F2018%2F03%2F18%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Android-如何显示版本号并制作3秒跳转页的概述，希望你们喜欢 创建布局文件1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayoutxmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:layout_height=&quot;match_parent&quot;android:layout_width=&quot;match_parent&quot;android:background=&quot;@drawable/launch_bg&quot;&gt;&lt;TextViewandroid:id=&quot;@+id/tv_version&quot;android:layout_width=&quot;wrap_content&quot;android:layout_height=&quot;wrap_content&quot;android:layout_centerInParent=&quot;true&quot;android:textColor=&quot;@android:color/white&quot;android:textSize=&quot;14sp&quot;/&gt;&lt;RelativeLayout&gt; 创建一个版本Activity类1234567891011121314151617181920212223242526272829public class SplashActivity extends AppCompatActivity&#123;private TextView textView;@Overrideprotected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); textView = findViewById(R.id.tv_version); try&#123; PackageInfo info = getPackageManager().getPackageInfo(getPackageName(),0); textView.setText(&quot;version:&quot;+info.versionName); &#125;catch(PackageManger.NameNotFoundException e)&#123; e.printStackTrace(); &#125; Timer timer = new Timer(); TimerTask timerTask = new TimeTask()&#123; @Override public void run()&#123; Intent intent = new Intent(SplashActivity.this,MainActivity.class); startActivity(intent); SplashActivity.this.finish(); &#125; &#125;; timer.schedule(timerTask,3000);&#125;&#125; 在清单文件中，添加声明即可。总结 本文讲了Android-如何显示版本号并制作3秒跳转页，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android Studio实战练习V2</category>
      </categories>
      <tags>
        <tag>Android Studio实战练习V2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发工程师文集-1 小时学会各种Drawable]]></title>
    <url>%2F2018%2F03%2F17%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Android开发工程师文集-1 小时学会各种Drawable的概述，希望你们喜欢 Drawable介绍Drawable为抽象类，drawable与view有区别的地方，主要是体现事件和交互性上面。 view是面向用户的，是可见的控件，能给它添加点击事件。drawable则相反，不能面向，也不可见，也不能添加点击事件。 drawable有好多子类，drawable为抽象类，所以有很多子类来继承它。 主要原理方法 draw() setBounds() BitmapDrawable 巴特美drawable该子类为bitmap的包装，可以保持原图片大小，填充，拉伸。1234567&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;@drawable/ic_launcher&quot; android:tileMode=&quot;mirror&quot;//平铺 android:antialias=&quot;true&quot;//消除锯齿 android:dither=&quot;true&quot;&gt;&lt;/bitmap&gt; LayerDrawable 勒儿drawable该子类就是来管理一组drawable的，第一张图片的放置，那么第二张图片会在第一张图片上，由此依次放置。123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:top=&quot;40dp&quot; android:left=&quot;40dp&quot; android:src=&quot;@drawable/picture_1&quot; android:gravity=&quot;center&quot;&gt; &lt;/item&gt; &lt;item android:top=&quot;40dp&quot; android:left=&quot;40dp&quot; android:src=&quot;@drawable/picture_2&quot; android:gravity=&quot;center&quot;&gt; &lt;/item&gt;&lt;/layer-list&gt; StateListDrawable该类StateListDrawable根据不同状态提供不同图片。12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utr-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_focused=&quot;true&quot; android:drawable=&quot;@drawable/botton_1&quot;/&gt; &lt;item android:state_pressed=&quot;true&quot; android:drawable=&quot;@drawable/botton_2&quot;/&gt; &lt;item android:state_selected=&quot;true&quot; android=&quot;@drawable/botton_3&quot;/&gt; &lt;item android:drawable=&quot;@drawable/botton_4&quot;/&gt;&lt;/selector&gt; LevelListDrawable该子类有不同的item -setlevel();12345678910111213&lt;level-list xmlns:android=&quot;http://schemas.android.om/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/off&quot; android:minLevel=&quot;5&quot; android:maxLevel=&quot;10&quot;&gt; &lt;/item&gt; &lt;item android:drawable=&quot;@drawable/on&quot; android:minLevel=&quot;10&quot; android:maxLevel=&quot;20&quot;&gt; &lt;/item&gt;&lt;/level-list&gt; 123public void On(View v)&#123; iv.setImageLevel( //int );&#125; TransitionDrawable — transi tion drawable为LayerDrawable的子类，只有两张图片的变化，没有多个图片，LayerDrawable可以有多个item，而transitiondrawable只有两个item。1234567&lt;transition xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/off&quot;&gt; &lt;/item&gt; &lt;item android:drawable=&quot;@drawable/on&quot;&gt; &lt;/item&gt;&lt;/transition&gt; 12345678910public void On(View v)&#123; TransitionDrawable drawable=iv.getDrawable(); //开启 startTransition(); drawable.startTransition(2000);&#125;public void Off(View v)&#123; TranstionDrawable drawable=iv.getDrawable(); //关闭 reverseTransition(); drawable.reverseTransition(2000);&#125; InsertDrawableInsertDrawable表示嵌入图片==padding12345678&lt;inset xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/background&quot; android:insetLeft=&quot;50dp&quot; android:insetRight=&quot;50dp&quot; android:insetTop=&quot;50dp&quot; android:insetBottom=&quot;50dp&quot;&gt;&lt;/inset&gt; ClipDrawable 可累drawable该ClipDrawabel是一种裁剪的形式，如同进度条。1234&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/picture&quot; android:clipOrientation=&quot;horizontal&quot; android:gravity=&quot;left&quot;/&gt; 123ClipDrawable drawable=iv.getDrawable();drawable.setLevel(5000);//范围0-10000； DIY的Drawable自己动手试试吧梳理：BitmapDrawable,LayerDrawable,StateListDreawable,LevelListDrawable,TransitionDrawable,InsertDrawable,ClipDrawable. 总结 本文讲了Android开发工程师文集-1 小时学会各种Drawable，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android开发工程师文集</category>
      </categories>
      <tags>
        <tag>Android开发工程师文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发工程师文集-1 小时学会SQLite]]></title>
    <url>%2F2018%2F03%2F16%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Android开发工程师文集-1 小时学会SQLite的概述，希望你们喜欢 内容 什么是Sqlite：效率高，开源，小型，程序驱动，支持事务操作，无数据类型，可嵌入的关系型数据库独立的，跨平台的，代码量少，简单易用 创建表语句1create table student(_id Integer primary key, name varchar(10), age Integer not null); 删除表1drop table student; 插入数据123Insert into 表名(字段列表) values (值列表);insert into student(_id,age) values(1,17);insert into student values(1,&quot;vic&quot;,17); 修改数据1update student set name=&quot;vic&quot;,age=17 where _id=1; 更新数据1Update 表名 set 字段=值 列表 更新的条件 删除数据12delete from 表名 [删除条件];delete from student where _id=1; 查询语句123456789select 字段名 from 表名称 [查询条件];select 列名称 from 表名称 where 条件;group by 分组的字段 having 筛选条件 order by 排序字段;select * from student;select _id from student;select * from student where _id=1;select * from student where _id=1 and age&gt;17;select * from student where age like &quot;%1%&quot;;select * from student where age&gt;17 order by _id=1; 内容 创建数据库 实现数据库中的增删改查 要点SQLiteOpenHelper,onCreate(),onUpgrade(),onOpen()1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;创建&quot; android:onClick=&quot;create&quot; android:background=&quot;#000000&quot;/&gt;&lt;/LinearLayout&gt; 12345678910111213//MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; private MySqliteHelper helper; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); helper = DbManger.getIntance(this); &#125; public void createdb(View view)&#123; SQLiteDatabase db=helper.getWritableDatable(); &#125;&#125; 123456789101112131415161718192021222324252627282930//创建一个类//sqliteOpenHelper//提供了onCreate()和onUpgrade()与onOpen()public class MySqliteHelper extends SQLiteOpenHelper&#123; public MySqliteHelper(Context context, String name, SQLitebase.CursorFactory factory, int version)&#123; super(context,name,factory,version); &#125; public MySqliteHelper(Context context)&#123; super(context,Constant.DATABASE_NAME,null,Constant.DATABASE_VERSION);&#125; //数据库创建时回调 @Override public void onCreate(SQLiteDatabase db)&#123; Log.i(&quot;tag&quot;,&quot;--onCreate--&quot;); //String sql=&quot;create table student(_id Integer primary key,name verchar(10),age Integer)&quot;; String sql = &quot;create table &quot;+Constant.TABLE_NAME+&quot;(&quot;+Constant._ID+&quot; Integer primary key,&quot;+Constant.NAME+&quot; varchar(10),&quot;+Constant.AGE+&quot; Integer)&quot;; db.execSQL(sql);//执行数据库语句 &#125; //数据库更新 @Override public void onUpgrade(SQLiteDatabase db,int oldVersion, int newVersion)&#123; Log.i(&quot;tag&quot;,&quot;--onUpgrade--&quot;); &#125; //数据库打开 @Override public void onOpen(SQLiteDatabase db)&#123; super.onOpen(db); Log.i(&quot;tag&quot;,&quot;--onOpen--&quot;); &#125;&#125; 123456789//创建库表public class Contant&#123; public static final String DATABASE_NAME=“info.db”;//数据库名称 public static final int DATABASE_VERSION=1;//数据库的版本号 public static final String TABLE_NAME=&quot;student&quot;;//表名 //用这里表示 public static final String _ID=&quot;_id&quot;; public static final String _NAME=&quot;name&quot;; public static final String AGE=&quot;age&quot;; 123456789public class DbManger&#123; private static MySqliteHelper helper; public static MySqliteHelper getIntance(Context context)&#123; if(helper == null)&#123; helper=new MySqliteHelper(content); &#125; return hepler; &#125;&#125; 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;创建&quot; android:onClick=&quot;create&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_insert&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;插入数据&quot; android:onClick=&quot;click&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324//MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; private MySqliteHelper helper; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); helper = DbManger.getIntance(this); &#125; public void createdb(View view)&#123; SQLiteDatabase db=helper.getWritableDatable(); &#125; public void click(View view)&#123; switch(view.getId())&#123; case R.id.btn_insert: SQLiteDatabase db=helper.getWritableDatabase(); String sql=&quot;insert into &quot;+Constant.TABLE_NAME+&quot; values(1,&apos;vic&apos;,17)&quot;; DbManger.execSQL(db,sql); String sql2=&quot;insert into &quot;+Constant.TABLE_NAME+&quot; values(2,&apos;vic&apos;,23)&quot;; DbManger.execSQL(db,sql2); db.close(); break; &#125;&#125; 123456789101112131415public class DbManger&#123; private static MySqliteHelper helper; public static MySqliteHelper getIntance(Context context)&#123; if(helper == null)&#123; helper=new MySqliteHelper(content); &#125; return hepler; &#125; public static void execSQL(SQLiteDatabase db,String sql)&#123; if(db!=null)&#123; if(sql!=null &amp;&amp; !&quot;&quot;.equals(sql))&#123; db.execSQL(sql); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;创建&quot; android:onClick=&quot;create&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_insert&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;插入数据&quot; android:onClick=&quot;click&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_update&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;修改数据&quot; android:onClick=&quot;click&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930//MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; private MySqliteHelper helper; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); helper = DbManger.getIntance(this); &#125; public void createdb(View view)&#123; SQLiteDatabase db=helper.getWritableDatable(); &#125; public void click(View view)&#123; switch(view.getId())&#123; case R.id.btn_insert: SQLiteDatabase db=helper.getWritableDatabase(); String sql=&quot;insert into &quot;+Constant.TABLE_NAME+&quot; values(1,&apos;vic&apos;,17)&quot;; DbManger.execSQL(db,sql); String sql2=&quot;insert into &quot;+Constant.TABLE_NAME+&quot; values(2,&apos;vic&apos;,23)&quot;; DbManger.execSQL(db,sql2); db.close(); break; case R.id.btn_update: db=helper.getWritableDatabase(); String updateSql=&quot;update &quot;+Constant.TABLE_NAME&quot;+&quot; set &quot;+Contant.NAME+&quot;=&apos;vic2&apos; where &quot;+Contant._ID+&quot;=1&quot;; DbManger.execSQL(db,updateSql); db.close(); break; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;创建&quot; android:onClick=&quot;create&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_insert&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;插入数据&quot; android:onClick=&quot;click&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_update&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;修改数据&quot; android:onClick=&quot;click&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_delete&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;删除数据&quot; android:onClick=&quot;click&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536//MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; private MySqliteHelper helper; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); helper = DbManger.getIntance(this); &#125; public void createdb(View view)&#123; SQLiteDatabase db=helper.getWritableDatable(); &#125; public void click(View view)&#123; switch(view.getId())&#123; case R.id.btn_insert: SQLiteDatabase db=helper.getWritableDatabase(); String sql=&quot;insert into &quot;+Constant.TABLE_NAME+&quot; values(1,&apos;vic&apos;,17)&quot;; DbManger.execSQL(db,sql); String sql2=&quot;insert into &quot;+Constant.TABLE_NAME+&quot; values(2,&apos;vic&apos;,23)&quot;; DbManger.execSQL(db,sql2); db.close(); break; case R.id.btn_update: db=helper.getWritableDatabase(); String updateSql=&quot;update &quot;+Constant.TABLE_NAME&quot;+&quot; set &quot;+Contant.NAME+&quot;=&apos;vic2&apos; where &quot;+Contant._ID+&quot;=1&quot;; DbManger.execSQL(db,updateSql); db.close(); break; case R.id.btn_delete: db=helper.getWritableDatabase(); String delSql=&quot;delete from &quot;+Constant.TABLE_NAME+&quot; where &quot;+Constant._ID+&quot;=2&quot;; DbManger.execSQL(db,delSql); db.close(); break; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;创建&quot; android:onClick=&quot;create&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_insert&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;插入数据&quot; android:onClick=&quot;click&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_update&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;修改数据&quot; android:onClick=&quot;click&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_delete&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;删除数据&quot; android:onClick=&quot;click&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_insertApi&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;插入数据&quot; android:onClick=&quot;onclick&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; private MySqliteHelper helper; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); helper = DbManger.getIntance(this); &#125; public void createdb(View view)&#123; SQLiteDatabase db=helper.getWritableDatable(); &#125; public void onClick(View view)&#123; switch(view.getId())&#123; case R.id.btn_insertApi: SQLiteDatabase db=helper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put(Constant._ID,3); values.put(Constant.NAME,&quot;vic&quot;); values.put(Constant.AGE,17); long result=db.insert(Constant.TABLE_NAME,null,values); if(result&gt;0)&#123; Toast.makeText(MainActivity.this,&quot;插入数据成功!&quot;,Toast.LENGTH_LONG).show(); &#125;else&#123; Toast.makeText(MainActivity.this,&quot;插入数据失败!&quot;,Toast.LENGTH_LONG).show(); &#125; db.close(); break; &#125;&#125; public void click(View view)&#123; switch(view.getId())&#123; case R.id.btn_insert: SQLiteDatabase db=helper.getWritableDatabase(); String sql=&quot;insert into &quot;+Constant.TABLE_NAME+&quot; values(1,&apos;vic&apos;,17)&quot;; DbManger.execSQL(db,sql); String sql2=&quot;insert into &quot;+Constant.TABLE_NAME+&quot; values(2,&apos;vic&apos;,23)&quot;; DbManger.execSQL(db,sql2); db.close(); break; case R.id.btn_update: db=helper.getWritableDatabase(); String updateSql=&quot;update &quot;+Constant.TABLE_NAME&quot;+&quot; set &quot;+Contant.NAME+&quot;=&apos;vic2&apos; where &quot;+Contant._ID+&quot;=1&quot;; DbManger.execSQL(db,updateSql); db.close(); break; case R.id.btn_delete: db=helper.getWritableDatabase(); String delSql=&quot;delete from &quot;+Constant.TABLE_NAME+&quot; where &quot;+Constant._ID+&quot;=2&quot;; DbManger.execSQL(db,delSql); db.close(); break; &#125;&#125; 12345678910111213141516&lt;Button android:id=&quot;@+id/btn_insertApi&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;插入数据&quot; android:onClick=&quot;onclick&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt;&lt;Button android:id=&quot;@+id/btn_updateApi&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;更新数据&quot; android:onClick=&quot;onclick&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt; 1234567891011121314151617181920212223242526272829303132public void onClick(View view)&#123; switch(view.getId())&#123; case R.id.btn_insertApi: SQLiteDatabase db=helper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put(Constant._ID,3); values.put(Constant.NAME,&quot;vic&quot;); values.put(Constant.AGE,17); long result=db.insert(Constant.TABLE_NAME,null,values); if(result&gt;0)&#123; Toast.makeText(MainActivity.this,&quot;插入数据成功!&quot;,Toast.LENGTH_LONG).show(); &#125;else&#123; Toast.makeText(MainActivity.this,&quot;插入数据失败!&quot;,Toast.LENGTH_LONG).show(); &#125; db.close(); break; case R.id.btn_updateApi: //String table 修改的数据表的名称,ContentValues values,String whereClause 表示修改条件,String[] whereArgs db=helper.getWritableDatabase(); //db.update(String table,ContentValues values,String whereClause,String[] whereArgs); ContentValues cv=new ContentValues(); cv.put(Contant.NAME,&quot;vic3&quot;); int count=db.update(Constant.TABLE_NAME,cv,Contant.TABLE_NAME,cv,Constant._ID+&quot;=?&quot;,new String[]&#123;&quot;3&quot;&#125;); if(count&gt;0)&#123; Toast.makeText(MainActivity.this,&quot;插入数据成功!&quot;,Toast.LENGTH_LONG).show(); &#125;else&#123; Toast.makeText(MainActivity.this,&quot;插入数据失败!&quot;,Toast.LENGTH_LONG).show(); &#125; db.close(); break; &#125;&#125; 12345678&lt;Button android:id=&quot;@+id/btn_updateApi&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;更新数据&quot; android:onClick=&quot;onclick&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;#000000&quot;/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243public void onClick(View view)&#123; switch(view.getId())&#123; case R.id.btn_insertApi: SQLiteDatabase db=helper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put(Constant._ID,3); values.put(Constant.NAME,&quot;vic&quot;); values.put(Constant.AGE,17); long result=db.insert(Constant.TABLE_NAME,null,values); if(result&gt;0)&#123; Toast.makeText(MainActivity.this,&quot;插入数据成功!&quot;,Toast.LENGTH_LONG).show(); &#125;else&#123; Toast.makeText(MainActivity.this,&quot;插入数据失败!&quot;,Toast.LENGTH_LONG).show(); &#125; db.close(); break; case R.id.btn_updateApi: //String table 修改的数据表的名称,ContentValues values,String whereClause 表示修改条件,String[] whereArgs db=helper.getWritableDatabase(); //db.update(String table,ContentValues values,String whereClause,String[] whereArgs); ContentValues cv=new ContentValues(); cv.put(Contant.NAME,&quot;vic3&quot;); int count=db.update(Constant.TABLE_NAME,cv,Contant.TABLE_NAME,cv,Constant._ID+&quot;=?&quot;,new String[]&#123;&quot;3&quot;&#125;); if(count&gt;0)&#123; Toast.makeText(MainActivity.this,&quot;插入数据成功!&quot;,Toast.LENGTH_LONG).show(); &#125;else&#123; Toast.makeText(MainActivity.this,&quot;插入数据失败!&quot;,Toast.LENGTH_LONG).show(); &#125; db.close(); break; case R.id.btn_deleteApi: db=helper.getWritableDatabase(); //int count2=db.delete(String table,StringwhereClause,String[] whereArgs); int count2=db.delete(Constant.TABLE_NAME,Constant._ID+&quot;=?&quot;,new String[]&#123;&quot;1&quot;&#125;); if(count2&gt;0)&#123; Toast.makeText(MainActivity.this,&quot;插入数据成功!&quot;,Toast.LENGTH_LONG).show(); &#125;else&#123; Toast.makeText(MainActivity.this,&quot;插入数据失败!&quot;,Toast.LENGTH_LONG).show(); &#125; db.close(); break;&#125; 123456789101112 public int delete(String table,String whereClause,String[] whereArgs)&#123; acquireReference(); try&#123; SQLiteStatement statement = new SQLiteStatement(this,&quot;DELETE FROM &quot;+table+(!TextUtils.isEmpty(whereClause) ? &quot; WHERE &quot;+whereClause : &quot;&quot;), whereArgs; try&#123; return statement.executeUpdateDelete(); &#125;finally&#123; statement.close(); &#125; &#125;finally&#123; releaseReference();&#125; 总结 本文讲了Android开发工程师文集-1 小时学会SQLite，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android开发工程师文集</category>
      </categories>
      <tags>
        <tag>Android开发工程师文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发的插件Code Generator与LayoutCreator的安装与使用,提升你的开发效率]]></title>
    <url>%2F2018%2F03%2F15%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Android开发的插件Code Generator与LayoutCreator的安装与使用，提升你的开发效率的概述，希望你们喜欢 学习目标掌握两个插件的安装和使用，能够实现代码生成功能。 Android Code Generator是一款代码生成的插件，帮助提高app的开发速度，只要打好布局XML文件，就能帮你把Activity/Fragment/Adapter文件生成好。 而LayoutCreator可以让你在Activity/Fragment中自动生成findViewById等布局相关初始化代码。 Android Studio安装插件的方法点击File-&gt;Settings-&gt;plugins，在settings中的Plugins，通过Plugins下载安装，安装完成后要重新启动Android Studio。 Search in respositories/Browse respositories可以查找到本地没有安装的插件，选择想要安装的插件install，重启Android Studio即可完成安装插件过程，然后如果你还要继续下载就进行查询，最后重新启动Android Studio就行了。 补充Code Generator只会帮你声明带id的控件，当XML中出现文字符时，会报错，我们可以先把encoding改成gbk格式，等生成activity后再把gbk改回utf-8就好了。 以上就是比较实用的几个插件，如果大家有更好的解决方法，欢迎讨论。 总结 本文讲了Android开发的插件Code Generator与LayoutCreator的安装与使用，提升你的开发效率，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android精通教程-第一节Android入门简介]]></title>
    <url>%2F2018%2F03%2F14%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Android精通教程-第一节Android入门简介的概述，希望你们喜欢 每日一句If life were predictable it would cease to be life, and be without flavor.— Eleanor Roosevelt 入门工具的安装第一步：要下载的朋友注意了，先看完教程了解个大概，下载Android studio前，先安装jdk和IDE，Android SDK 第二步：下载jdk，提供JDK 9 地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html提供JDK 8 地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 第三步：首先登录Android studio 官网地址https://developer.android.google.cn/studio/index.html接下来我提供中文社区Android studio下载地址：http://tools.android-studio.org/index.php 我以windows64位例子下载教程：点击 android-studio-ide-171.4408382-windows.exe 无 Android SDK 进行下载然后进行点击你所下载的软件，进行安装。 第四步：配置环境变量JAVA_HOME，操作步骤：“计算机（我的电脑）”—-“属性”—-“高级系统设置”—-“环境变量”—-系统变量下的“新建”： 环境变量：JAVA_HOME：D:\Java\jdk1.8.0_25CLASSPATH ：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;Path：;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 常用快捷键Ctrl+C: 复制Ctrl+V: 粘贴Ctrl+X: 剪切Ctrl+D: 在当前行下方复制一行Ctrl+Y: 删除当前行Ctrl+G: 快捷行数定位Ctrl+E: 查看最近打开的文件Ctrl+N: 查找类名，文件名Ctrl+F: 类内搜索Ctrl+R: 查找替换Ctrl+Alt+L: 格式化代码 构件活动、片段、视图、意图、服务和内容提供者 活动（Activity），是一个用户界面屏幕。应用可以定义一个或多个活动，用于处理应用程序的不同阶段。 片段（Fragment），是活动的一个组成部分，通常显示在屏幕上，但并非必须如此。通过片段，能够使应用轻松适应不同尺寸屏幕。 视图（View），是最小的用户界面单元，可以直接包含在活动中，也可以包含在活动的片段中。视图可以用Java代码创建，但更好的方式是使用XML布局来定义。 意图（Intent），是一种行为描述机制（如选择照片，打电话等）。在Android中，几乎一切都是通过意图来实现的，这给我们提供了大量替换或重用组件的机会。 服务（Service）,是运行在后台的任务，无需用户直接与之交互。 内容提供者，是一组数据和用于读取它们的自定义API，这是在应用之间共享全局数据的最好方法。 下面重要了，上课学不到的，在这里统统学习一下，学习靠自己 Android Studio2.0 教程从入门到精通Windows版 - 安装篇 Android Studio2.0 教程从入门到精通Windows版 - 入门篇 Android Studio2.0 教程从入门到精通Windows版 - 提高篇 Android Studio2.0 教程从入门到精通MAC版 - 安装篇 Android Studio2.0 教程从入门到精通MAC版 - 入门篇 Android Studio2.0 教程从入门到精通MAC版 - 提高篇 授人以鱼，不如授人以渔（1）学习android需要积极的心态 （2）注重实践 （3）学以致用 （4）多敲代码 总结 本文讲了Android精通教程-第一节Android入门简介，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android精通教程</category>
      </categories>
      <tags>
        <tag>Android精通教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio制作欢迎界面与应用图标]]></title>
    <url>%2F2018%2F03%2F13%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来AndroidStudio制作欢迎界面与应用图标的概述，希望你们喜欢 欢迎界面与应用图标本项目使用Android Studio 3.0.1作为开发工具 activity_splash.xml创建了一个activity_splash.xml布局文件，为欢迎界面布局，首先修改为 RelativeLayout 布局12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--添加一张欢迎界面的背景--&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width = &quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/launch_bg&quot;&gt; &lt;!--显示版本号--&gt; &lt;TextView android:id=&quot;@+id/tv_version&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;14sp&quot; android:layout_centerInParent=&quot;true&quot;/&gt;&lt;/RelativeLayout&gt; SplashActivity.java创建 SplashActivity.java 类，欢迎界面实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.edu.gdmec.android.androidstudiodemo;import android.content.Intent;import android.content.pm.ActivityInfo;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.widget.TextView;import java.util.Timer;import java.util.TimerTask;public class SplashActivity extends AppCompatActivity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); //设置此界面为 // 竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); init(); &#125; private void init() &#123; TextView tv_version = findViewById(R.id.tv_version); try &#123; PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(),0); tv_version.setText(&quot;version:&quot;+packageInfo.versionName); &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); tv_version.setText(&quot;version&quot;); &#125; //利用timer让此界面延迟3秒后跳转，timer有一个线程，该线程不断执行task Timer timer = new Timer(); TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; //发送intent实现页面跳转，第一个参数为当前页面的context，第二个参数为要跳转的主页 Intent intent = new Intent(SplashActivity.this,MainActivity.class); startActivity(intent); //跳转后关闭当前欢迎页面 SplashActivity.this.finish(); &#125; &#125;; //调度执行timerTask，第二个参数传入延迟时间（毫秒） timer.schedule(timerTask,3000); &#125;&#125; AndroidManifest.xml在清单文件 AndroidManifest.xml 中配置欢迎界面，将应用入口修改为欢迎界面，再去除 ActionBar 效果1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;cn.edu.gdmec.android.androidstudiodemo&quot;&gt; &lt;!--原为android:theme=&quot;@style/AppTheme&quot;--&gt; &lt;!--去除ActionBar标题栏--&gt; &lt;!--添加应用图标，app_icon--&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@drawable/app_icon&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;&gt; &lt;activity android:name=&quot;.SplashActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--添加实现类--&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 补充该制作过程中有如背景图片的加入，可以自行找相关图片的加入或者独自DIY。其中MainActivity.java和activity_main.xml未做过任何改变。 总结 本文讲了AndroidStudio制作欢迎界面与应用图标，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android Studio实战练习V2</category>
      </categories>
      <tags>
        <tag>Android Studio实战练习V2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio制作底部导航栏以及用Fragment实现切换功能]]></title>
    <url>%2F2018%2F03%2F12%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来AndroidStudio制作底部导航栏以及用Fragment实现切换功能的概述，希望你们喜欢 学习目标AndroidStudio制作底部导航栏以及用Fragment实现切换功能，用户点击底部导航栏可以实现三个模块的跳转。 图片资源需要底部导航栏三个点击按钮的图片资源main_button_1.png,main_button_2.png,main_button_3.png 以及点击变换的图片资源main_button_1_selected.png,main_button_2_selected.png,main_button_3_selected.png. 以上图片资源都放进drawable文件夹中 activity_main 布局在 MainActivity 页面中主要有两个区域： 一个是放 Fragment 的 main_body 一个是放底部导航栏的 main_bottom_bar 主要的Fragment代码块：123456789101112131415&lt;LinearLayout android:orientation=&quot;vertical&quot; android:background=&quot;@android:color/white&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--标题栏--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot; /&gt; &lt;!--放置Fragment的main_body--&gt; &lt;RelativeLayout android:id=&quot;@+id/main_body&quot; android:background=&quot;@android:color/white&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; 主要的底部导航栏的代码块：12345678910111213141516171819202122232425262728293031323334353637&lt;!--实现在底部，水平排列按钮--&gt;&lt;LinearLayout android:id=&quot;@+id/main_bottom_bar&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;#F2F2F2&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;55dp&quot;&gt; &lt;RelativeLayout android:layout_weight=&quot;1&quot; android:id=&quot;@+id/bottom_bar_1_btn&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/bottom_bar_text_1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginBottom=&quot;3dp&quot; android:gravity=&quot;center&quot; android:singleLine=&quot;true&quot; android:text=&quot;button_1&quot; android:textColor=&quot;#666666&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;ImageView android:layout_width=&quot;27dp&quot; android:layout_height=&quot;27dp&quot; android:layout_above=&quot;@+id/bottom_bar_text_1&quot; android:layout_alignParentTop=&quot;true&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_marginTop=&quot;3dp&quot; android:id=&quot;@+id/bottom_bar_image_1&quot; android:src=&quot;@drawable/main_button_1&quot;/&gt; &lt;/RelativeLayout&gt; ....&lt;!--布局的代码总是繁琐又无聊的，记得要自己补全--&gt;&lt;/LinearLayout&gt; 实例化控件实例化控件一些琐碎的代码：12345678910111213//先实例化控件，那我给出自己打的实例化代码//来自main_title_bar.xml private TextView tv_main_title;//标题 private TextView tv_back;//返回按钮 private RelativeLayout title_bar;//来自activity_main.xml private RelativeLayout main_body; private TextView bottom_bar_text_1; private ImageView bottom_bar_image_1; ... private LinearLayout main_bottom_bar; private RelativeLayout bottom_bar_1_btn; private RelativeLayout ...; 然后123456789101112131415161718192021222324initView();//实例化private void initView()&#123; //标题显示 tv_back=findViewById(R.id.tv_back); tv_main_title=findViewById(R.id.tv_main_title); title_bar=findViewById(R.id.title_bar); //底部导航栏 main_body=findViewById(R.id.main_body); bottom_bar_text_1=findViewById(R.id.bottom_bar_text_1); bottom_bar_image_1=findViewById(R.id.bottom_bar_image_1); ... //包含底部 android:id=&quot;@+id/main_bottom_bar&quot; main_bottom_bar=findViewById(R.id.main_bottom_bar); //private RelativeLayout bottom_bar_1_btn; bottom_bar_1_btn=findViewById(R.id.bottom_bar_1_btn); //添加点击事件 bottom_bar_1_btn.setOnClickListener(this); ... //技巧 //tv_back.setVisibility(View.GONE); tv_main_title.setText(&quot;课程&quot;); title_bar.setBackgroundColor(Color.parseColor(&quot;#30B4FF&quot;));&#125; 底部导航栏状态的切换方法给MainActivity加一个setSelectStatus() 方法，方法里用参数index来判断当前选的按钮 示例代码123456789101112131415161718192021private void setSelectStatus(int index) &#123; switch (index)&#123; case 0: //图片点击选择变换图片，颜色的改变，其他变为原来的颜色，并保持原有的图片 bottom_bar_image_1.setImageResource(R.drawable.main_button_1_selected); bottom_bar_text_1.setTextColor(Color.parseColor(&quot;#0097F7&quot;)); //其他的文本颜色不变 bottom_bar_text_2.setTextColor(Color.parseColor(&quot;#666666&quot;)); bottom_bar_text_3.setTextColor(Color.parseColor(&quot;#666666&quot;)); //图片也不变 bottom_bar_image_2.setImageResource(R.drawable.main_button_2); bottom_bar_image_3.setImageResource(R.drawable.main_button_3); break; case 1://同理如上 ... break; case 2://同理如上 ... break; &#125;&#125; 实现底部导航栏的响应导航栏文本颜色和图片切换效果的方法写好了，接下来是点击响应的方法 给MainActivity加上View.OnClickListener接口 在生成的 onClick() 方法中加上导航栏区域的响应1234567891011121314@Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bottom_bar_1_btn: setSelectStatus(0); break; case R.id.bottom_bar_2_btn: setSelectStatus(1); break; case R.id.bottom_bar_3_btn: setSelectStatus(2); break; &#125;&#125; 别忘了在initView() 中添加监听器1bottom_bar_1_btn.setOnClickListener(this); 三个 fragment 的创建就是简单的创建三个布局，展现Fragment_1/2/3 即可 示例代码块12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;TextView android:text=&quot;Fragment_1&quot; android:textColor=&quot;@android:color/black&quot; android:textSize=&quot;50sp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; 然后通过我之前写的插件自动生成三个Fragemnt ，就可以了不用管生成的Fragement_1/2/3.java文件了，插件文章《 Android开发的插件Code Generator与LayoutCreator的安装与使用，提升你的开发效率 》 三个fragment的显示和切换在MainActivity里把AppCompatActivity改为FragmentActivity 把Fragment加到Activity里的代码通常用这个来展示，但是代码过长，我们来简化一下12345/** FragmentManager manager = getSupportFragmentManager();* FragmentTransaction transaction = manager.beginTransaction();* transaction.add(R.id.main_body,new CourseFragment()).commit();* */ 我们先来添加一个setMain() 方法，来显示打开界面时，显示的初始页面12345/用于打开初始页面 private void setMain() &#123; //getSupportFragmentManager() -&gt; beginTransaction() -&gt; add -&gt; (R.id.main_boy,显示课程 new CourseFragment() this.getSupportFragmentManager().beginTransaction().add(R.id.main_body,new CourseFragment()).commit(); &#125; 上面的代码中可以看到相对来说比较少，那我们就用这个，然后我们来实现点击底部导航栏来切换响应的fragment,我们在onClick()中添加即可。12345case R.id.bottom_bar_1_btn: //添加 getSupportFragmentManager().beginTransaction().replace(R.id.main_body,new Button_1Fragment()).commit(); setSelectStatus(0); break; 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了AndroidStudio制作底部导航栏以及用Fragment实现切换功能，界面的布局介绍，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android Studio实战练习V2</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio制作登录和注册功能的实现，界面的布局介绍]]></title>
    <url>%2F2018%2F03%2F11%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来AndroidStudio制作登录和注册功能的实现，界面的布局介绍的概述，希望你们喜欢 每日一句：Success is connecting with the world and making people feel. - 《名扬四海》 设计思路当我们面临制作登录和注册功能的实现时，我们需要先设计登录界面的布局和注册界面的布局，做到有完整的思路时才开始实现其功能效果会更好。 我们需要做个标题栏，登陆界面，实现登陆界面的功能代码块，注册界面，实现测试界面的功能模块即可完成。 标题栏的设计思路每个APP都基本上有个标题栏，即是显示标题，标题栏的两侧大多数都有一个返回建。那么标题栏即是一个返回键和一个标题栏的制作布局。 为了避免大多数代码的冗杂，我们把这个标题栏的制作布局独立起来，标题的显示我们可以在每块主题模块上，用setText()方法来显示不同的标题。 接下来我们创建main_title_bar.xml布局文件：具体代码如下：123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--这里代码的是创建一个标题栏，左边是返回键--&gt;&lt;!--我们设置RelativeLayout布局，id = &quot;title_bar&quot;--&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/title_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;@android:color/transparent&quot;&gt; &lt;!--一个是显示返回键，一个是显示标题框--&gt; &lt;!--通过TextView来显示，id ： tv_back , tv_main_title --&gt; &lt;TextView android:id=&quot;@+id/tv_back&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_alignParentLeft=&quot;true&quot; android:background=&quot;@drawable/go_back_selector&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_main_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot;/&gt; &lt;!--其中android:background=&quot;@drawable/go_back_selector&quot;为点击回退键时，会变化效果，其实就是一个点击更换个图片而已。--&gt; &lt;!--我们先用这种老方法，接下来以后的文章才做代码优化效果--&gt;&lt;/RelativeLayout&gt; 补充：现在标题栏布局做好了，我们需要了解怎么换图片，就是在android:background=&quot;@drawable/go_back_selector&quot;,其实就是在drawable中创建这个go_back_selector.xml文件而已，用到了android:state_pressed=&quot;true&quot;这个属性，当点击时就是变化的图片效果，记住state_pressed就OK。 登录界面布局创建登录界面，我们需要标题栏显示“登录”，那么就要通过标签。 我们需要设计想好美化登录界面，需要以下图片：登录背景图片login_bg.png,默认的头像图片default_icon,输入用户名的背景图片login_user_name_bg,在用户名前需要一个小标图user_name_icon,同理，输入密码框需要图片有login_psw_bg,psw_icon,按钮需要图片加以美观register_selector,根据需要的图片可自行制作。 登录界面布局模块代码创建activity_login.xml布局文件，具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--登录界面,用LinearLayout--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/login_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--标题栏--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot;&gt;&lt;/include&gt; &lt;!--显示头像，记得加入id iv_head --&gt; &lt;ImageView android:id=&quot;@+id/iv_head&quot; android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:layout_marginTop=&quot;25dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/default_icon&quot;/&gt; &lt;!--输入框--&gt; &lt;EditText android:id=&quot;@+id/et_user_name&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_marginTop=&quot;35dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/login_user_name_bg&quot; android:drawableLeft=&quot;@drawable/user_name_icon&quot; android:drawablePadding=&quot;10dp&quot; android:paddingLeft=&quot;8dp&quot; android:gravity=&quot;center_vertical&quot; android:hint=&quot;请输入用户名&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;!--输入框--&gt; &lt;EditText android:id=&quot;@+id/et_psw&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:background=&quot;@drawable/login_psw_bg&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:paddingLeft=&quot;8dp&quot; android:gravity=&quot;center_vertical&quot; android:hint=&quot;请输入密码&quot; android:inputType=&quot;textPassword&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;!--按钮--&gt; &lt;Button android:id=&quot;@+id/btn_login&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_marginTop=&quot;15dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/register_selector&quot; android:text=&quot;登 录&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot;/&gt; &lt;!--显示tv register , find_psw --&gt; &lt;LinearLayout android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:gravity=&quot;center_horizontal&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_register&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center_horizontal&quot; android:padding=&quot;8dp&quot; android:text=&quot;立即注册&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;!--layout_weight=&quot;1&quot; layout_width=&quot;0dp&quot;实现均分效果--&gt; &lt;TextView android:id=&quot;@+id/tv_find_psw&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center_horizontal&quot; android:padding=&quot;8dp&quot; android:text=&quot;找回密码?&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 同理注册界面布局设计思路创建注册界面，我们需要标题栏显示“注册”，那么就要通过标签。那么我做了效果图，提供思路参考： 注册布局模块代码创建activity_register.xml布局文件，具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--注册界面--&gt;&lt;!--这里的布局放置是： 1 个 ImageView 控件，用于显示用户头像；3 个 EditText 控件，用于输入用户名、密码、再次输入密码；1 个 Button 控件为注册按钮--&gt;&lt;!--修改 activity_register.xml 为 LinearLayout 布局--&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/activity_register&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@drawable/register_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;include layout=&quot;@layout/main_title_bar&quot;&gt;&lt;/include&gt;&lt;!--引入标题栏--&gt; &lt;ImageView android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginTop=&quot;25dp&quot; android:src=&quot;@drawable/default_icon&quot;/&gt; &lt;!--三个编辑框--&gt; &lt;EditText android:id=&quot;@+id/et_user_name&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;35dp&quot; android:background=&quot;@drawable/register_user_name_bg&quot; android:drawableLeft=&quot;@drawable/user_name_icon&quot; android:drawablePadding=&quot;10dp&quot; android:gravity=&quot;center_vertical&quot; android:hint=&quot;请输入用户名&quot; android:paddingLeft=&quot;8dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_psw&quot; android:layout_width=&quot;fill_parent&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_height=&quot;48dp&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:background=&quot;@drawable/register_psw_bg&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:hint=&quot;请输入密码&quot; android:inputType=&quot;textPassword&quot; android:paddingLeft=&quot;8dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;EditText android:id=&quot;@+id/et_psw_again&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;48dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:background=&quot;@drawable/register_psw_again_bg&quot; android:drawableLeft=&quot;@drawable/psw_icon&quot; android:drawablePadding=&quot;10dp&quot; android:hint=&quot;请再次输入密码&quot; android:inputType=&quot;textPassword&quot; android:paddingLeft=&quot;8dp&quot; android:singleLine=&quot;true&quot; android:textColor=&quot;#000000&quot; android:textColorHint=&quot;#a3a3a3&quot; android:textSize=&quot;14sp&quot;/&gt; &lt;Button android:id=&quot;@+id/btn_register&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_marginLeft=&quot;35dp&quot; android:layout_marginRight=&quot;35dp&quot; android:layout_marginTop=&quot;15dp&quot; android:background=&quot;@drawable/register_selector&quot; android:text=&quot;注 册&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;18sp&quot;/&gt;&lt;/LinearLayout&gt; MD5算法MD5 为 Message-Digest Algorithm 5（信息–摘要算法），记住几个要点就可以了。 Message Digest MessageDigest MessageDigest.getInstance( );由于注册登录涉及密码，我们需要对用户的密码进行 MD5 算法加密，MD5 算法是把任意长度的字符串变成固定长度（通常是128位）的16进制字符串，且此算法不可逆。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536package cn.edu.gdmec.android.androidstudiodemo.utils;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Utils &#123; //md5 加密算法 public static String md5(String text) &#123; MessageDigest digest = null; try &#123; digest = MessageDigest.getInstance(&quot;md5&quot;); // 数组 byte[] result -&gt; digest.digest( ); 文本 text.getBytes(); byte[] result = digest.digest(text.getBytes()); //创建StringBuilder对象 然后建议StringBuffer，安全性高 //StringBuilder sb = new StringBuilder(); StringBuffer sb = new StringBuffer(); // result数组，digest.digest ( ); -&gt; text.getBytes(); // for 循环数组byte[] result; for (byte b : result)&#123; // 0xff 为16进制 int number = b &amp; 0xff; // number值 转换 字符串 Integer.toHexString( ); String hex = Integer.toHexString(number); if (hex.length() == 1)&#123; sb.append(&quot;0&quot;+hex); &#125;else &#123; sb.append(hex); &#125; &#125; //sb StringBuffer sb = new StringBuffer();对象实例化 return sb.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); //发送异常return空字符串 return &quot;&quot;; &#125; &#125;&#125; 实现注册逻辑功能代码完成注册页面的布局与 MD5 工具类后，进行注册界面的逻辑编写。 当在注册界面点击注册按钮后，需要获取用户名，用户密码和再次确认密码，当两次密码相同时，将用户名和密码（经过 MD5 加密）保存到 SharedPreferences 中，同时当注册成功后，需要将用户名传递到登录界面中。 RegisterActivity.java具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package cn.edu.gdmec.android.androidstudiodemo;import android.content.Intent;import android.content.SharedPreferences;import android.content.pm.ActivityInfo;import android.graphics.Color;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.RelativeLayout;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.androidstudiodemo.utils.MD5Utils;public class RegisterActivity extends AppCompatActivity &#123; private TextView tv_main_title;//标题 private TextView tv_back;//返回按钮 private Button btn_register;//注册按钮 //用户名，密码，再次输入的密码的控件 private EditText et_user_name,et_psw,et_psw_again; //用户名，密码，再次输入的密码的控件的获取值 private String userName,psw,pswAgain; //标题布局 private RelativeLayout rl_title_bar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //设置页面布局 ,注册界面 setContentView(R.layout.activity_register); //设置此界面为竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); init(); &#125; private void init() &#123; //从main_title_bar.xml 页面布局中获取对应的UI控件 tv_main_title=findViewById(R.id.tv_main_title); tv_main_title.setText(&quot;注册&quot;); tv_back=findViewById(R.id.tv_back); //布局根元素 rl_title_bar=findViewById(R.id.title_bar); rl_title_bar.setBackgroundColor(Color.TRANSPARENT); //从activity_register.xml 页面中获取对应的UI控件 btn_register=findViewById(R.id.btn_register); et_user_name=findViewById(R.id.et_user_name); et_psw=findViewById(R.id.et_psw); et_psw_again=findViewById(R.id.et_psw_again); tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //返回键 RegisterActivity.this.finish(); &#125; &#125;); //注册按钮 btn_register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //获取输入在相应控件中的字符串 getEditString(); //判断输入框内容 if(TextUtils.isEmpty(userName))&#123; Toast.makeText(RegisterActivity.this, &quot;请输入用户名&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(TextUtils.isEmpty(psw))&#123; Toast.makeText(RegisterActivity.this, &quot;请输入密码&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(TextUtils.isEmpty(pswAgain))&#123; Toast.makeText(RegisterActivity.this, &quot;请再次输入密码&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(!psw.equals(pswAgain))&#123; Toast.makeText(RegisterActivity.this, &quot;输入两次的密码不一样&quot;, Toast.LENGTH_SHORT).show(); return; /** *从SharedPreferences中读取输入的用户名，判断SharedPreferences中是否有此用户名 */ &#125;else if(isExistUserName(userName))&#123; Toast.makeText(RegisterActivity.this, &quot;此账户名已经存在&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else&#123; Toast.makeText(RegisterActivity.this, &quot;注册成功&quot;, Toast.LENGTH_SHORT).show(); //把账号、密码和账号标识保存到sp里面 /** * 保存账号和密码到SharedPreferences中 */ saveRegisterInfo(userName, psw); //注册成功后把账号传递到LoginActivity.java中 // 返回值到loginActivity显示 Intent data = new Intent(); data.putExtra(&quot;userName&quot;, userName); setResult(RESULT_OK, data); //RESULT_OK为Activity系统常量，状态码为-1， // 表示此页面下的内容操作成功将data返回到上一页面，如果是用back返回过去的则不存在用setResult传递data值 RegisterActivity.this.finish(); &#125; &#125; &#125;); &#125; /** * 获取控件中的字符串 */ private void getEditString()&#123; userName=et_user_name.getText().toString().trim(); psw=et_psw.getText().toString().trim(); pswAgain=et_psw_again.getText().toString().trim(); &#125; /** * 从SharedPreferences中读取输入的用户名，判断SharedPreferences中是否有此用户名 */ private boolean isExistUserName(String userName)&#123; boolean has_userName=false; //mode_private SharedPreferences sp = getSharedPreferences( ); // &quot;loginInfo&quot;, MODE_PRIVATE SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //获取密码 String spPsw=sp.getString(userName, &quot;&quot;);//传入用户名获取密码 //如果密码不为空则确实保存过这个用户名 if(!TextUtils.isEmpty(spPsw)) &#123; has_userName=true; &#125; return has_userName; &#125; /** * 保存账号和密码到SharedPreferences中SharedPreferences */ private void saveRegisterInfo(String userName,String psw)&#123; String md5Psw = MD5Utils.md5(psw);//把密码用MD5加密 //loginInfo表示文件名, mode_private SharedPreferences sp = getSharedPreferences( ); SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //获取编辑器， SharedPreferences.Editor editor -&gt; sp.edit(); SharedPreferences.Editor editor=sp.edit(); //以用户名为key，密码为value保存在SharedPreferences中 //key,value,如键值对，editor.putString(用户名，密码）; editor.putString(userName, md5Psw); //提交修改 editor.commit(); editor.commit(); &#125;&#125; 实现登录逻辑功能代码完成登录界面布局后，来实现登录界面的逻辑代码。 当点击登录按钮时，需判断用户名和密码是否为空。 若为空，则提示请输入用户名或密码，这里的判断事项比较一开始凌乱，需要细细品味；若不为空，则获取用户输入的用户名，由于用的是本地数据，需要根据用户名在 SharedPreferences 中查询是否有对应的密码，若有对应的密码且与用户输入的密码（需通过 MD5 加密）比对一致情况，则登录成功。 LoginActivity.java具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package cn.edu.gdmec.android.androidstudiodemo;import android.content.Intent;import android.content.SharedPreferences;import android.content.pm.ActivityInfo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import android.widget.Toast;import cn.edu.gdmec.android.androidstudiodemo.utils.MD5Utils;public class LoginActivity extends AppCompatActivity&#123; private TextView tv_main_title;//标题 private TextView tv_back,tv_register,tv_find_psw;//返回键,显示的注册，找回密码 private Button btn_login;//登录按钮 private String userName,psw,spPsw;//获取的用户名，密码，加密密码 private EditText et_user_name,et_psw;//编辑框 @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); //设置此界面为竖屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); init(); &#125; //获取界面控件 private void init() &#123; //从main_title_bar中获取的id tv_main_title=findViewById(R.id.tv_main_title); tv_main_title.setText(&quot;登录&quot;); tv_back=findViewById(R.id.tv_back); //从activity_login.xml中获取的 tv_register=findViewById(R.id.tv_register); tv_find_psw=findViewById(R.id.tv_find_psw); btn_login=findViewById(R.id.btn_login); et_user_name=findViewById(R.id.et_user_name); et_psw=findViewById(R.id.et_psw); //返回键的点击事件 tv_back.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //登录界面销毁 LoginActivity.this.finish(); &#125; &#125;); //立即注册控件的点击事件 tv_register.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //为了跳转到注册界面，并实现注册功能 Intent intent=new Intent(LoginActivity.this,RegisterActivity.class); startActivityForResult(intent, 1); &#125; &#125;); //找回密码控件的点击事件 tv_find_psw.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //跳转到找回密码界面（此页面暂未创建） &#125; &#125;); //登录按钮的点击事件 btn_login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //开始登录，获取用户名和密码 getText().toString().trim(); userName=et_user_name.getText().toString().trim(); psw=et_psw.getText().toString().trim(); //对当前用户输入的密码进行MD5加密再进行比对判断, MD5Utils.md5( ); psw 进行加密判断是否一致 String md5Psw= MD5Utils.md5(psw); // md5Psw ; spPsw 为 根据从SharedPreferences中用户名读取密码 // 定义方法 readPsw为了读取用户名，得到密码 spPsw=readPsw(userName); // TextUtils.isEmpty if(TextUtils.isEmpty(userName))&#123; Toast.makeText(LoginActivity.this, &quot;请输入用户名&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else if(TextUtils.isEmpty(psw))&#123; Toast.makeText(LoginActivity.this, &quot;请输入密码&quot;, Toast.LENGTH_SHORT).show(); return; // md5Psw.equals(); 判断，输入的密码加密后，是否与保存在SharedPreferences中一致 &#125;else if(md5Psw.equals(spPsw))&#123; //一致登录成功 Toast.makeText(LoginActivity.this, &quot;登录成功&quot;, Toast.LENGTH_SHORT).show(); //保存登录状态，在界面保存登录的用户名 定义个方法 saveLoginStatus boolean 状态 , userName 用户名; saveLoginStatus(true, userName); //登录成功后关闭此页面进入主页 Intent data=new Intent(); //datad.putExtra( ); name , value ; data.putExtra(&quot;isLogin&quot;,true); //RESULT_OK为Activity系统常量，状态码为-1 // 表示此页面下的内容操作成功将data返回到上一页面，如果是用back返回过去的则不存在用setResult传递data值 setResult(RESULT_OK,data); //销毁登录界面 LoginActivity.this.finish(); //跳转到主界面，登录成功的状态传递到 MainActivity 中 startActivity(new Intent(LoginActivity.this, MainActivity.class)); return; &#125;else if((spPsw!=null&amp;&amp;!TextUtils.isEmpty(spPsw)&amp;&amp;!md5Psw.equals(spPsw)))&#123; Toast.makeText(LoginActivity.this, &quot;输入的用户名和密码不一致&quot;, Toast.LENGTH_SHORT).show(); return; &#125;else&#123; Toast.makeText(LoginActivity.this, &quot;此用户名不存在&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125; /** *从SharedPreferences中根据用户名读取密码 */ private String readPsw(String userName)&#123; //getSharedPreferences(&quot;loginInfo&quot;,MODE_PRIVATE); //&quot;loginInfo&quot;,mode_private; MODE_PRIVATE表示可以继续写入 SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //sp.getString() userName, &quot;&quot;; return sp.getString(userName , &quot;&quot;); &#125; /** *保存登录状态和登录用户名到SharedPreferences中 */ private void saveLoginStatus(boolean status,String userName)&#123; //saveLoginStatus(true, userName); //loginInfo表示文件名 SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); SharedPreferences sp=getSharedPreferences(&quot;loginInfo&quot;, MODE_PRIVATE); //获取编辑器 SharedPreferences.Editor editor=sp.edit(); //存入boolean类型的登录状态 editor.putBoolean(&quot;isLogin&quot;, status); //存入登录状态时的用户名 editor.putString(&quot;loginUserName&quot;, userName); //提交修改 editor.commit(); &#125; /** * 注册成功的数据返回至此 * @param requestCode 请求码 * @param resultCode 结果码 * @param data 数据 */ @Override //显示数据， onActivityResult //startActivityForResult(intent, 1); 从注册界面中获取数据 //int requestCode , int resultCode , Intent data // LoginActivity -&gt; startActivityForResult -&gt; onActivityResult(); protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; //super.onActivityResult(requestCode, resultCode, data); super.onActivityResult(requestCode, resultCode, data); if(data!=null)&#123; //是获取注册界面回传过来的用户名 // getExtra().getString(&quot;***&quot;); String userName=data.getStringExtra(&quot;userName&quot;); if(!TextUtils.isEmpty(userName))&#123; //设置用户名到 et_user_name 控件 et_user_name.setText(userName); //et_user_name控件的setSelection()方法来设置光标位置 et_user_name.setSelection(userName.length()); &#125; &#125; &#125;&#125; 补充如做了效果，需要在清单文件中实现该类，文件的跳转，可以自己了解一下。主要介绍注册模块，登录模块。里面的注解我写的如果有不全的或者错误点，可以联系讨论。 接下来你看到如上代码有点多，那么我们可以进行代码的优化来减少代码量。 总结 本文讲了AndroidStudio制作登录和注册功能的实现，界面的布局介绍，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android Studio实战练习V2</category>
      </categories>
      <tags>
        <tag>Android Studio实战练习V2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio项目制作倒计时模块]]></title>
    <url>%2F2018%2F03%2F10%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来AndroidStudio项目制作倒计时模块的概述，希望你们喜欢 项目难度AndroidStudio项目制作倒计时模块的难度，不是很大，就是主要用了Timer和TimerTask这两个，接着就是现实界面的一些基础效果。 设计界面做个倒计时的界面就比较好想了，就如下界面控件 填写倒计时时间 获取倒计时时间 显示倒计时 开始计时 停止计时就在自动创建的activity_main.xml中写入代码：123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;cn.edu.gdmec.android.counttime.MainActivity&quot;&gt; &lt;!--填写倒计时时间--&gt; &lt;EditText android:id=&quot;@+id/input&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot;/&gt; &lt;!--获取倒计时时间--&gt; &lt;Button android:id=&quot;@+id/get&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;获取倒计时时间&quot;/&gt; &lt;!--显示倒计时--&gt; &lt;TextView android:id=&quot;@+id/time&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;!--开始计时--&gt; &lt;Button android:id=&quot;@+id/starttime&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;开始计时&quot;/&gt; &lt;!--停止计时--&gt; &lt;Button android:id=&quot;@+id/stoptime&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;停止计时&quot;/&gt;&lt;/LinearLayout&gt; 实现功能需求接下来我们需要在MainActivity.java中现实功能模块需求，主要来显示界面和获取按钮功能效果，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package cn.edu.gdmec.android.counttime;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private EditText inputet; private Button get, startTime, stopTime; private TextView time; private int i = 0; private Timer timer = null; private TimerTask task = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; private void initView() &#123; inputet = findViewById(R.id.input); get = findViewById(R.id.get); startTime = findViewById(R.id.starttime); stopTime = findViewById(R.id.stoptime); time = findViewById(R.id.time); get.setOnClickListener(this); startTime.setOnClickListener(this); stopTime.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.get: time.setText(inputet.getText().toString()); i = Integer.parseInt(inputet.getText().toString()); break; case R.id.starttime: startTime(); break; case R.id.stoptime: stopTime(); break; default: break; &#125; &#125; private Handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; time.setText(msg.arg1 + &quot;&quot;); startTime(); &#125;; &#125;; public void startTime() &#123; timer = new Timer(); task = new TimerTask() &#123; @Override public void run() &#123; if (i &gt; 0) &#123; //加入判断不能小于0 i--; Message message = mHandler.obtainMessage(); message.arg1 = i; mHandler.sendMessage(message); &#125; &#125; &#125;; timer.schedule(task, 1000); &#125; public void stopTime()&#123; timer.cancel(); &#125;&#125; 心得重点123456789101112131415161718192021222324252627//获取的按钮实现：time.setText(inputet.getText().toString());i = Integer.parseInt(inputet.getText().toString());//Handler的加入private Handler mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; time.setText(msg.arg1 + &quot;&quot;); startTime(); &#125;; &#125;;//倒计时主要核心public void startTime() &#123; timer = new Timer(); task = new TimerTask() &#123; @Override public void run() &#123; if (i &gt; 0) &#123; //加入判断不能小于0 i--; Message message = mHandler.obtainMessage(); message.arg1 = i; mHandler.sendMessage(message); &#125; &#125; &#125;; timer.schedule(task, 1000); &#125; 总结 本文讲了AndroidStudio项目制作倒计时模块，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android项目开发实战</category>
      </categories>
      <tags>
        <tag>Android项目开发实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio环境安装与配置]]></title>
    <url>%2F2018%2F03%2F09%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来AndroidStudio环境安装与配置的概述，希望你们喜欢 AndroidStudio IDE下载我们选择用Android Studio开发Android的App，Android Studio提供给Windows、MacOS、Linux三个平台官方下载地址：Android Studio 配置Android Studio下载相关的SDK AndroidStudio项目托管平台用GitHub进行协作开发，首先去GitHub官网注册GitHub帐号GitHub是一个面向开源及私有软件项目的托管平台，方便大家存储和管理自己的项目，拥有自己的Github，那么就赶紧注册吧！ 配置Git在Windows下，下载Git进行使用，官方下载地址：Git安装时一般使用默认设置即可，一路next装完即可，安装完成后进入控制面板-系统和安全-系统，然后进行配置高级系统设置，再点击环境变量，在系统变量中点击Path，然后进入编辑，将Git的bin目录添加进去，最后点击确定完成Git配置。 总结 本文讲了AndroidStudio环境安装与配置，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android Studio实战练习V2</category>
      </categories>
      <tags>
        <tag>Android Studio实战练习V2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发进阶从小工到专家第九章开发人员必备的技能单元测试]]></title>
    <url>%2F2018%2F03%2F08%2F1%2F</url>
    <content type="text"><![CDATA[前言点击来看的朋友，这本书很好，可以作为一个秘籍作为保存。笔记记录为了更好的学习。为了方便学习，记录下了重点笔记。 单元测试学习单元测试，集成测试，黑盒测试，白盒测试等。 我们只有单元测试是我们开发人员需要自己完成的，其他的测试类型则是由测试人员进行验证。 什么是单元测试单元测试从本质上讲也是代码，与普通代码的区别是，它是验证代码准确性的代码。因此，可以给单元测试做个简单的定义：单元测试是开发人员编写的，用于检测在特定条件下目标代码准确性的代码。 软件开发具有天生的复杂性，没有人能做到不测试就能够保证代码正确运行。 为啥要做单元测试 便于后期重构。 优化设计。 文档记录。 具有回归性。 不写单元测试的借口 测试太花时间了 测试不是我的工作 代码都编译过了还测什么 单面原来就没有单元测试，且难以测试 总结 本文讲了Android开发进阶从小工到专家第九章开发人员必备的技能单元测试，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android开发进阶从小工到专家读书笔记</category>
      </categories>
      <tags>
        <tag>Android开发进阶从小工到专家读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十节：详细讲解一下Java多线程，随机文件]]></title>
    <url>%2F2018%2F03%2F07%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来第十节：详细讲解一下Java多线程，随机文件的概述，希望你们喜欢 多线程的概念 线程的生命周期 多线程程序的设计 多线程的概念 多线程的概念：程序是静态的，进程是动态的。多进程是操作系统中多个程序同时执行。线程是最小的执行单位，同类的线程共享内存空间和系统资源。 多线程独享资源有：寄存器，系统堆栈，多线程就是多个线程同时执行。 多线程指多个线程同时运行，并且每个线程可以执行不同的任务。 线程（可称为轻负荷进程） 线程特点：可以共享内存空间和系统资源。 线程的生命周期进程有创建和销毁过程，线程也是，线程也是从创建，运行到销毁的过程。 线程：创建，可运行，运行中，挂起，死亡五种。 编程个多线程： 通过继承线程类Thread来创建； 通过建立实现Runnable接口的类。 Thread类，必须覆盖父类的run()方法：1234class Mythread extends Thread&#123; public void run()&#123; &#125;&#125; 创建一个实现Runnable接口的类，该接口只有一个方法：1public void run() 实现了Runnable接口的类，调用该对象的start()的方法来启动线程。 对于继承Thread类，就不能再次继承别的类了，是因为在Java中只允许单继承，不能多继承。而实现Runable接口，接口可以多实现多个接口。 线程的状态 常用方法 线程的一生，也就是生命周期，从创建，运行到消亡的过程。 创建：使用new创建线程对象后，系统没有提供运行的资源。 可运行状态：使用start()方法启动线程后系统就分配资源。 运行状态：线程用CPU进行。 阻塞状态：12public static native void sleep()public final void wait() 死亡：1public final boolean isAlive() 常用方法12currentThread():该方法表示当前正在使用的线程；Interrupt():该方法是“吵醒”处理休眠的线程。 线程的同步问题 wait与notifyall方法 线程的同步关键字synchronized 多线程就是调用这个synchronized的方法的， 当线程用了这个方法，那么其他线程想使用这个方法时就得等，直到线程使用完该调用的方法。 同步中的等待 wait()方法：暂时让出cpu； notifyAll()方法：等待结束。 线程的联合方式12A.join(); //等线程 A 执行完毕A.join(1000); //等待 A, 等待时间是1000毫秒 随机文件RandomAccessFile，它既可以输入又可以输出1234RandomAccessFile(File file,String mode)&quot;rw&quot;写RandomAccessFile(String name,String mode)r读 12345678writeXXX()----写对应信息readXXX()----读对应的数据writeInt()write(byte类型数组)writeDouble()readInt()read(byte类型数组)readDouble() 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了第十节：详细讲解一下Java多线程，随机文件，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一节：讲述类的继承，数据库，文件的读写，图形绘制]]></title>
    <url>%2F2018%2F03%2F06%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来第十一节：讲述类的继承，数据库，文件的读写，图形绘制的概述，希望你们喜欢 类的继承 类的继承 类的多态性 final的使用 对象类型的转换 类的继承格式：1[类修饰符] class 子类名 extends 父类名&#123; ... ...&#125; 如：1class Student extends People&#123; ... ...&#125; 类的继承：Object-&gt;People-&gt;Student Java中的类只支持单继承，不支持多继承。 类成员的继承：对于继承：一个类中有成员变量和方法。子类继承父类，可以有部分继承它的父类，也可以自己定义。 子类能继承public和protected的成员变量，不能继承private的成员变量，可以继承同包中的默认修饰符。 同理，子类继承父类的方法，能够继承public和protedted的方法，不能继承private的方法，不能继承构造方法。 成员变量的隐藏：什么是成员变量的隐藏：就是子类定义的成员变量与继承父类的成员变量同名时，我们就说子类隐藏了父类的成员变量。 那么，如果访问对象就是子类重新定义的成员变量，子类方法访问的也是子类重新定义的成员变量。 方法的重写方法的重写就是：子类定义的方法和父类中的方法全一样时，就是可以说子类重写了从父类继承的方法。 从名字，返回类型，和参数个数以及类型都完全相同。重写时，不可以降低方法的访问权限。 super关键字super，如果子类想使用父类的构造的方法，那么可以使用super的关键字，默认是由super（）；调用父类不带参数的构造方法。1如：super.x、super.f() 调用父类的变量和方法。 类的多态性什么是多态性？多态性：同名的多个方法产生不同的行为。 表现形式：重载与重写。 关键字final对于final，可以修饰类，成员变量，成员方法。 修饰类，该类不能被继承 修饰成员变量，给变量为常理，常理必须被赋值，不能再次被赋值 如果修饰带有参数的方法，那么该参数不能被改变 如果一个类或方法被final修饰，那么该类不能被继承，不能被重写 Java的数据库在Java中有Java.sql，用于提供执行数据库结构化查询语句。程序可以跨平台，可以连接不同的数据库系统。 SQL语句关系型数据库是由多个表组成。表是主要的操作的对象。各表之间具有关联性。 属性值，字段，记录 SQL1insert into student values(&quot;077555&quot;,&quot;vic&quot;,&quot;1444.2.2&quot;,&quot;男&quot;); 12select...from...where...update student set...where... 123456//classClass.forName(&quot;com.mysql.jdb.Student&quot;);getConnection( )创建与数据库的连接对象；//DriverManager用户程序和数据库系统之间维护着数据库与驱动程序之间的连接 文件的读写 FileInputStream FileOutputStream FileReader FileWriter BufferedReader BufferedWriter Reader类和Writer类的层次结构Reader-BufferedReader-LineNumberReader-CharArrayReader-FilterReader-InputStreamReader-FileReader-PipedReader-StringReader Writer-BufferedWriter-CharArrayWriter-FilterReader-OutputStreamReader-FileWriter-PipedWriter-StringWriter-PrintWriter FileWriter可以在已有文件后追加内容 123456789101112131415class Demo&#123; public static void main(String args[])&#123; FileInputStream fis = null; try&#123; fis = new FileInputStream(&quot;e:/read.txt&quot;); byte[] buffer = new byte[100]; fis.read(buffer,0,buffer.length); for(int i = 0;i&lt;buffer.length;i++)&#123; System.out.println(buffer[i]); &#125; &#125;catch(Exception e)&#123; System.out.println(e); &#125; &#125;&#125; FileInputStream和FileOutputStream12345678910111213141516171819202122class Test&#123;public static void main(String args[])&#123; FileInputStream fis = null; FileOutputStream fos = null; try&#123; fis = new FileInputStream(&quot;e:/read.txt&quot;): fos = new FileOutputStream(&quot;e:/write.txt&quot;); byte[] buffer = new byte[100]; int temp = fis.read(buffer,0,buffer.length); fos.write(buffer,0,temp); //String s = new String(buffer); //s = s.trim(); //System.out.println(s); &#125; catch(Exception e)&#123; System.out.println(e); &#125;&#125;&#125; 优化：1234567891011121314151617181920212223242526272829class Demo&#123; public static void main(String args[])&#123; FileInputStream fis=null; FileOutputStream fos=null; try&#123; fis=new FileInputStream(&quot;e:/read.txt&quot;); fos=new FileOutStream(&quot;e:/write.txt&quot;); byte[] buffer=new byte[1024]; while(true)&#123; int temp=fis.read(buffer,buffer.length); if(temp==-1)&#123; break; &#125; fos.write(buffer,0,temp); &#125; &#125;catch(Exception e)&#123; System.out.println(e); &#125; finally&#123; try&#123; fis.close(); fos.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125; &#125;&#125; Reader &lt;– FileReaderint read(char[] c,int off,int len)Writer &lt;– FileWritervoid write(char[] c,int off,int len) 1234567891011121314151617181920212223public class TestChar&#123;public static void main(String args[])&#123; FileReader fr = null; FileWriter fw = null; try&#123; fr = new FileReader(&quot;e:/read.txt&quot;); fw = new FileWriter(&quot;e:/write.txt&quot;); char[] buffer=new char[100]; int temp = fr.read(buffer,0,buffer.length); fw.write(buffer,0,temp); &#125; catch(Exception e)&#123; System.out.println(e); &#125; finally&#123; try&#123; &#125; catch(Excepiton e)&#123; System.out.println(e); &#125; &#125;&#125; FileReader 和 BufferedReader BufferedReader属于字符流，输入流，然后呢？它又是处理流BufferedReader全称字符输入处理流 123456789101112131415161718192021222324252627282930313233class Test&#123;public static void main(String args[])&#123; FileReader fileReader = null; BufferReader bufferReader = null; try&#123; fileReader = new FileReader(&quot;e:/read.txt&quot;); bufferedReader = new BufferedReader(fileReader); String line = null; while(true)&#123; line = bufferedReader.readLine(); if(line == null)&#123; break; &#125; System.out.println(line); &#125; //String line = bufferedReader.readLine(); //System.out.println(line); &#125; catch(Exception e)&#123; System.out.println(e); &#125; finally&#123; try&#123; bufferedReader.close(); fileReader.close(); &#125; catch(Exception e)&#123; System.out.println(e); &#125; &#125; &#125;&#125; 图形绘制 窗口中图形的绘制 鼠标事件 键盘事件 绘制组件public void paint(Graphics g) 更新组件public void update(Graphics g) 重绘组件public void repaint() 鼠标事件12345mouseClicked();mouseEntered();mouseExited();mousePressed();mouseReleased(); 键盘事件123keyPressed();keyReleased();keyTyped(); 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了第十一节：讲述类的继承，数据库，文件的读写，图形绘制，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的读文件，文件的创建，写文件]]></title>
    <url>%2F2018%2F03%2F05%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来Java中的读文件，文件的创建，写文件的概述，希望你们喜欢 读文件1234567891011121314151617public static void read(String path,String filename)&#123; try&#123; int length=0; String str=&quot;&quot;; byte buffer[] = new byte[10]; FileInputStream fis = new FileInputStream(new File(path,filename)); while((length=fis.read(buffer,0,buffer.length))!=-1)&#123; str+=new String(buffer,0,length); &#125; System.out.println(str); fis.close(); &#125;catch(FileNotFoundException e)&#123; System.out.println(&quot;文件不存在&quot;); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;&#125; 文件的创建123456789101112131415161718192021222324252627public class FileDemo&#123; public static void createFolder(String path)&#123; File folder=new File(path); if(folder.exists())&#123; System.out.println(&quot;文件夹已存在!&quot;); &#125;else&#123; folder.mkdir(); &#125; &#125; public static void createFile(String path,String filename)&#123; File file=new File(path,filename); if(file.exists())&#123; System.out.println(&quot;文件已存在!&quot;); System.out.println(file.length()); &#125;else&#123; try&#123; file.createNewFile(); &#125;catch(IOException e)&#123; System.out.println(&quot;文件创建失败&quot;); &#125; &#125; &#125; public static void main(String[] args)&#123; FileDemo.createFolder(&quot;c:/text&quot;); FileDemo.createFile(&quot;c:/text&quot;,&quot;1.txt&quot;); &#125;&#125; 写文件123456789101112public static void write(String path,String filename)&#123; try&#123; String str=&quot;123456789&quot;; byte b[] = str.getBytes(); FileOutputStream fos=new FileOutputStream(new File(path,filename)); fos.write(b); &#125;catch(FileNotFoundException e)&#123; System.out.println(&quot;文件不存在&quot;); &#125;catch(IOException e)&#123; System.out.println(&quot;写文件失败&quot;); &#125;&#125; 获取文件的属性 String getName() boolean canRead()boolean canWrite() boolean exits() boolean isFile()boolean isDirectory()boolean isHidden() 相关知识与技术boolean mkdir()：创建目录，若成功返回true boolean createNewFile()：创建一个文件 boolean delete()：删除一个文件 Java中流的分类 流的运动方向:分为输入流和输出流两种 流的数据类型:分为字节流和字符流 所有的输入流类都是抽象类，所有的输出流类都是抽象类。 字节：InputStream，OutputStream字符：Reader类，Writer类 从输入流读取数据：123FileInputStream vFile=new FileInputStream(&quot;File1.dat&quot;);vFile.read();vFile.close(); 输出流:123FileOutputStream oFile=new FileOutputStream(&quot;File2.dat&quot;);oFile.write(vFile.read()):oFile.close(); 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了Java中的读文件，文件的创建，写文件，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[讲解SQL数据库语句]]></title>
    <url>%2F2018%2F03%2F04%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来讲解SQL数据库语句的概述，希望你们喜欢 数据库语句12345678910create database teach;use teach;create table `teach`.`producttype`( `pt_id` int not null auto_increment primary key, `pt_name&apos; varchar(20) not null unique);create table `teach`.`client`(`cl_id` char(4) not null primary key, `cl_name` varchar(20) not null, `cl_type` char(6) not null, `cl_guimo` char(2) not null, `cl_tel` varchar(15) not null, `cl_duanjiao` bit(2) not null);create table if not exists product (pr_id int auto_increment primary key not null);alter table product add pr_typeid int not null;desc product;insert into client(cl_id,cl_name,cl_type,cl_guimo,cl_tel,cl_duanjiao) values (1,&apos;vic&apos;,&apos;hh&apos;,&apos;xiao&apos;,34455);//create table `teach`.`orders`( `or_id` int not null auto_increment primary key, `cl_id` char(4) not null, `pr_id` char(4) not null, `or_price` int not null, `or_num` int not null, `or_date` datetime not null); 123select * from producttype;update producttype set pt_name=&apos;休闲食品&apos; where pt_id=2;delete from producttype where pt_id=4; 1234select cl_id,cl_name,cl_guimo from client where cl_guimo = &apos;大&apos;|| &apos;小&apos;;select * from orders where or_date = 2010;select cl_id &apos;编号&apos; ,cl_name &apos;姓名&apos; from client order by cl_id desc;select * from client where cl_name like &apos;%c&apos;; 123456select pr_num from product group by pr_typeid;select pr_id,or_num from orders where or_num &gt; 2 group by pr_id;select * from orders group by cl_id;select * from client where cl_duanjiao = 1 &amp;&amp; cl_guimo = &apos;小&apos; group by cl_id order by cl_id desc;select or_id,cl_name,pr_name,or_price,or_num,or_date from client crass join orders join product;select * from product crass join producttype join orders where producttype = &apos;食品&apos;; 1234567891011use information_schema;show tables;desc tables;select table_name from tables;create database teach;use teach;create table if not exists characters(id int auto_increment primary key,name varchar(20) not null, description text);create table if not exists access(id int auto_increment primary key,name varchar(2) not null, description text);create table if not exists c_a(cid int not null,aid int not null, primary key (cid, aid),foreign key(cid) references characters(id),foreign key (aid) references access(id));alter table c_a drop foreign key c_a_ibfk_1;create table if not exists c_b(cid int not null references characters(id),aid int not null,primary key(cid, aid),foreign key(aid) references access(id)); 1234567891011alter table accesses add username varchar(20) not null;alter table accesses modify mame varchar(30) not null;alter table characters drop mane;alter table accesses modify description varchar(50); // 修改rename table acc to accesses;alter table accesses rename acc; 123456789create table if not exists characters(id int auto_increment primary key, name varchar(20) not null, description text);create table if not exists access (id int auto_increment primary key, name varchar(2) not null, description text);create table if not exists c_a(cid int not null , aid int not null , primary key(cid, aid), foreign key(cid) references characters(id) , foreign key(aid) references access(id) ) ;create table if not exists c_b(cid int not null oreign key(cid) references characters(id) , aid int not null , primary key(cid, aid), foreign key(aid) references access(id) ) ;alter table access modify description varchar(50); 123456789101112131415161718192021222324252627select a.id ,a.name from characters a;create table if not exists employess(id int auto_increment primary key, first_name varchar(10) not null,last_name varchar(20),salary float);insert into employees (first_name,last_name,salary)values(&apos;junx&apos;,&apos;zheng&apos;,1000),(&apos;ting&apos;,&apos;xue&apos;,1300);select last_name,salary,salary*12 sum from employees;//select last_name || job_id from employees;select last_name &apos;fname&apos; from employees; //创建名insert into employees(first_name, last_name, salary)values(&apos;wang&apos;,&apos;guang&apos;,1000);select distinct salary , id from employees;insert into employees value (4,&apos;ting&apos;,&apos;cue&apos;,1300);select distinct first_name, last_name, salary from employees;select * from employees where salary &gt; 1200;select * from employess first_name like &apos;%j%&apos;;select * from employess where salary in (1200,100);select * from employess where salary is null; 123456789101112131415161718192021222324252627282930313233select lower(&apos;aBx&apos;);select upper(&apos;polill&apos;);select length(&apos;lojol&apos;);select char_length(&apos;lsjlf&apos;);select replace(&apos;zzjjjp&apos;,&apos;zj&apos;,&apos;hello&apos;);select substring(&apos;zjxx&apos;,2,6);select curdate();select curtime();select now();select minute(&apos;15:34:21&apos;);select monthname(&apos;2017-4-1&apos;);select date_format(&apos;2009-10-04 22:23:00&apos;,&apos;%w %m %y&apos;);select database();select user();select version();select inet_aton(&apos;192.168.0.1&apos;);select password(&apos;adlfllsf&apos;); 12345678910111213141516SELECT * FROM pet WHERE name LIKE &apos;b%&apos;;为了找出以“b”开头的名字，使用“^”匹配名字的开始：SELECT * FROM pet WHERE name REGEXP &apos;^b&apos;;select * from pet where name regexp binary &apos;^b&apos;;为了找出以“fy”结尾的名字，使用“$”匹配名字的结尾：select * from pet where name regexp &apos;fy$&apos;;为了找出包含一个“w”的名字，使用以下查询：SELECT * FROM pet WHERE name REGEXP &apos;w&apos;;SELECT * FROM pet WHERE name REGEXP &apos;^.....$&apos;;SELECT * FROM pet WHERE name REGEXP &apos;^.&#123;5&#125;$&apos;; 1234567891011121314151617181920SELECT * FROM shop;列的最大值SELECT MAX(article) AS article FROM shop;找出最贵物品的编号、销售商和价格。SELECT article, dealer, priceFROM shopWHERE price=(SELECT MAX(price) FROM shop);SELECT article, dealer, priceFROM shopORDER BY price DESCLIMIT 1;任务：每项物品的的最高价格是多少？SELECT article, MAX(price) AS priceFROM shopGROUP BY article; 1234567891011121314151617181920(1)select s#(学号),SName(学生名字) from S where Age &lt; 17 and sex=&apos;女生&apos;;(2)select C.C#(课程号),Cname(课程名) from S,SC,C where S.S#=SC.S# and SC.C#=C.C# and sex=&apos;男生&apos;;(3)select T.T#,TName from S,SC,C,T where S.S#=SC.S# and SC.C#=C.C#and C.T#=T.T# and sex=&apos;男生&apos;;(4)select S# from SC group by S# having count(*)&gt;1;(5)select distinct X.C# from SC as X, SC as Y where X.S#=&apos;S2&apos; and Y.S#=&apos;S4&apos; and X.C#=Y.C#;(6)select C# from C where C# not in(select C# from S,SC where S.S#=SC.S# and SName=&apos;wang&apos;);(7)select C#,Cname from C where not exists (select * from S where not exists(select * from SC where C.C#=SC.C# and SC.S#=S.S#));(8)select distinct S# from SC as X where not exists (select * from C,T where C.T#=T.T# and TName=&apos;liu&apos; and not exists (select * from SC as Y where Y.S#=X.S# and Y.C#=C.C#));(9)select count(distinct C#) from SC;(10)select avg(age) from S where sex=&apos;女生&apos; and S# in(select S# from SC where C#=&apos;C4&apos;); 123脏读：到达广州结果走到一半不可重复读：一样的语句，可能被人复读幻读：同样两条语句，你在用别人也在用。 12345678910111213141516171819202122232425262728293031323334353637设有教学数据库中有4个关系教师关系 T（T#，TName, Title）工号，名字，职称课程关系 C（C#，Cname,T#）课程号，课程名，任课老师工号学生关系S（S#，ＳＮａｍｅ，Ａｇｅ，ｓｅｘ）选课关系 SC（S#，ｃ＃，Score）（１）检索年龄小于１７岁的女学生的学号和姓名 Select s#,sname from S where age&lt;17 and sex=’f’;（２）检索男学生所学课程的课程号和课程名 Select c#, cname from c where c# in (select distinct b.c# from s a inner join sc b on a.s#=b.s# where a.sex=’m’);（３）检索男学生所学课程的任课老师的工号和姓名 Select T.T#, T.Tname from T inner join C on T.T#=C.T# where C.C# in (select distinct b.c# from s a inner join sc b on a.s#=b.s# where a.sex=’m’);（４）检索至少选修两门课程的学生学号Select s# from sc group by s# having count()&gt;=2;检索至少有学号为 Ｓ２和Ｓ４的学生选修的课程的课程号 Select c# from sc where c# in (select c# from sc where s#=’s4’) and c# in (select c# from sc where s#=’s2’);（５）检索ｗａｎｇ同学不学的课程的课程号select distinct c# from sc where c# not in (select c# from s inner join sc on s.s#=sc.s# where s.sname=’wang’);（６）检索全部学生都选修的课程的课程号与课程名 Select c# from sc group by c# having count()=(Select count() from s);（７）检索选修课程包含ｌｉｕ老师所授全部课程的学生学号 select distinct sc.s# from T inner join c inner join sc on T.T#=c.T# and c.c#=sc.c# where T.Tname=’liu’;（８）统计有学生选修的课程门数Select count() from c where c# in (select distinct c# from sc);（９）求选修Ｃ４课程的女学生的平均年龄Select avg(age) from s where sex=’f’ and s# in (select s# from sc where c#=’c4’);（１０）求ｌｉｕ老师所授每门课程的平均成绩Select avg(score) from sc where c# in (select c# from c inner join t on c.t#=t.t# where t.name=’liu’);（１１）统计选修每门课程的学生人数（超过１０人的课程才统计）。要求显示课程号和人数，查询结果按照人数降序排列，诺人数相同，则按照课程号升序排列。Select c#, count() number from sc group by c# having count()&gt;=10 order by number desc, c# asc;（１２）检索学号比Ｗａｎｇ同学大，而年龄比他小的同学的学生姓名。 Select sname from s where s#&gt;(select s# from s where sname=’wang’) and age&lt;(select age from s where sname=’wang’);（１３）在表ＳＣ中检索成绩为空值的学生的学号和课程号（１４）检索姓名以 Ｌ开头的所有学生的学号和课程号 Select s.sname, sc.c# from s inner join sc on s.s#=sc.s# where s.sname like ‘L%’;（１５）求年龄大于女同学平均年龄的男同学的姓名和年龄Select sname,age from s where sex=’m’ and age&gt;(select avg(age) from s where sex=’f’); 1234567891011声明光标DECLARE cursor_name CURSOR FOR select_statement光标OPEN语句OPEN cursor_name光标FETCH语句FETCH cursor_name INTO var_name [, var_name] ...光标CLOSE语句CLOSE cursor_name 数据库技术 数据库技术1234567891011121314151617181920create database teach;use teach;（1）CREATE TABLE `teach`.`producttype` ( `pt_id` INT NOT NULL AUTO_INCREMENT primary key, `pt_name` VARCHAR(20) NOT NULL unique );（2）CREATE TABLE `teach`.`client` ( `cl_id` CHAR(4) NOT NULL primary key, `cl_name` VARCHAR(20) NOT NULL , `cl_type` CHAR(6) NOT NULL , `cl_guimo` CHAR(2) NOT NULL , `cl_tel` VARCHAR(15) NOT NULL , `cl_duanjiao` BIT(2) NOT NULL );（3）create table if not exists product(pr_id int auto_increment primary key not null);alter table product add pr_typeid int not null;desc product;insert into client(cl_id,cl_name,cl_type,cl_guimo,cl_tel,cl_duanjiao)values(1,&apos;小 明&apos;,&apos;经销商&apos;,&apos;大&apos;,88810615,0);insert into client(cl_id,cl_name,cl_type,cl_guimo,cl_tel,cl_duanjiao)values(2,&apos;小 红&apos;,&apos;经销商&apos;,&apos;中&apos;,88815615,0);insert into client(cl_id,cl_name,cl_type,cl_guimo,cl_tel,cl_duanjiao)values(3,&apos;小 微&apos;,&apos;零售商&apos;,&apos;小&apos;,88825615,0);（4）CREATE TABLE `teach`.`orders` ( `or_id` INT NOT NULL AUTO_INCREMENT primary key, `cl_id` CHAR(4) NOT NULL , `pr_id` CHAR(4) NOT NULL , `or_price` INT NOT NULL , `or_num` INT NOT NULL , `or_date` DATETIME NOT NULL );项目3insert into producttype(pt_id,pt_name)values(1,&apos;洗里理日用品&apos;),(2,&apos;食品&apos;),(3,&apos;家用电器&apos;),(4,&apos;肉食&apos;);select * from producttype;update producttype set pt_name=&apos;休闲食品&apos; where pt_id=2;delete from producttype where pt_id=4; 12345678910111213141516171819202122232425项目1（1）select cl_id,cl_name,cl_guimo from client where cl_guimo = &apos;大&apos;|| &apos;小&apos;;(2) select * from orders where or_date = 2010;(3) select cl_id &apos;编号&apos; ,cl_name &apos;姓名&apos; from client order by cl_id desc;(4) select pr_typeid from product; select distinct pr_typeid from product;(5) select * from client where cl_name like &apos;%c&apos;;项目2(1) select pr_num from product group by pr_typeid;(2) select pr_id,or_num from orders where or_num &gt; 2 group by pr_id;(3)select * from orders group by cl_id;项目3(1) select * from client where cl_duanjiao = 1 &amp;&amp; cl_guimo = &apos;小&apos; group by cl_id order by cl_id desc;(2) select or_id,cl_name,pr_name,or_price,or_num,or_date from client crass join orders join product;(3) select * from product crass join producttype join orders where producttype = &apos;食品&apos;; 关系数据完整性是对关系的某种约束条件 实体完整性：对主码进行限制 参照完整性：对外码进行限制 用户定义完整性 ：对具体数据进行限制 函数依赖： R（X，Y）（1）完全函数依赖：（学号、课程号） →f 成绩（2）部分函数依赖 ：（学号、课程号） →p 姓名（3）传递函数依赖 ：学号→所属系号，所属系号→宿舍楼号，学号→t宿舍楼号 关系数据库 关系数据库是因为采用关系模型而得名，它是目前数据库应用中的主流技术。 关系数据库的出现标志着数据库技术走向成熟。 关系数据库的特点（1）数据结构简单。（2）功能强。（3）使用方便。（4）数据独立性高。 关系模型的基本术语（1）关系。一个关系对应一个二维表，二维表名就是关系名。（2）属性及值域。二维表中的列称为关系的属性。属性值的取值范围称为值域，每一个属性对应一个值域，不同属性的值域可以相同。（3）关系模式。二维表中的行定义、记录的类型，即对关系的描述称为关系模式。（4）元组。每一条记录的值称为关系的一个元组。（5）键。由一个或多个属性组成。 关系模式关系模式是对关系的描述。 关系的完整性有3类完整性约束：实体完整性、参照完整性和用户定义的完整性。 SQL的主要功能（1）数据定义功能。（2）数据操纵功能。（3）数据控制功能。 数据库由3种类型组成：系统数据库、用户数据库数和数据库快照。 系统数据库master 系统信息数据库model 模板信息数据库msdb 代理信息数据库tempdb 临时信息数据库resource 资源信息数据库 用户数据库用户数据库包括用户自定义的数据库和系统的示例数据库。 数据库快照数据库快照是一个数据库的只读副本和静态视图，它是数据库所有数据的映射，由快照被执行的时间点来决定它的内容。 数据库的储存结构逻辑储存结构 数据库的逻辑储存结构是以用户观点看到的数据库的体系结构。 物理存储结构数据库的物理存储结构是以数据库设计者观点看到的数据库的体系结构。 数据库文件划分为两类：数据文件和日志文件。 文件组是数据文件的逻辑集合。 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了讲解SQL数据库语句，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio制作RecyclerView完成习题详情的展示]]></title>
    <url>%2F2018%2F03%2F03%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来AndroidStudio制作RecyclerView完成习题详情的展示的概述，希望你们喜欢 适配器Adapter：12345678910111213141516171819202122232425262728293031323334353637383940private List&lt;ExercisesBean&gt; objects = new ArrayList&lt;ExercisesBean&gt;(); private Context context; private LayoutInflater layoutInflater; public ExercisesListItemAdapter(Context context)&#123; this.context=context; this.layoutInflater=LayoutInflater.from(context); &#125; /** * 设置数据更新界面 */ public void setData(List&lt;ExercisesBean&gt; objects)&#123; this.objects = objects; notifyDataSetChanged(); &#125; // public void updateView(List&lt;ExercisesBean&gt; objects)&#123; this.objects = objects; this.notifyDataSetChanged(); &#125; @Override public int getCount() &#123; return objects == null ? 0 : objects.size(); &#125; /** * 根据position得到对应的Item的对象 */ @Override public ExercisesBean getItem(int position) &#123; return objects.get(position); &#125; /** * 根据position得到对应Item的对象 */ @Override public long getItemId(int position) &#123; return position; &#125; 布局1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!--标题栏--&gt; &lt;include layout=&quot;@layout/main_title_bar&quot;/&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginTop=&quot;15dp&quot; android:text=&quot;选择题&quot; android:gravity=&quot;center&quot; android:textColor=&quot;#000000&quot; android:textSize=&quot;16sp&quot; android:textStyle=&quot;bold&quot;/&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/rv_list&quot; /&gt; &lt;TextView android:id=&quot;@+id/tv_di&quot; android:text=&quot;第一页&quot; android:gravity=&quot;center&quot; android:textSize=&quot;20sp&quot; android:textColor=&quot;@android:color/black&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; 导入依赖库 build.gradle(Moudle:app)的图给大家做参考 同时也可以这样：12345678910111213141516171819202122android &#123; compileSdkVersion 26 defaultConfig &#123; &#125; buildTypes &#123; release &#123; &#125; &#125; buildToolsVersion &apos;26.0.2&apos;&#125;dependencies &#123; implementation fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos; implementation &apos;com.android.support:recyclerview-v7:26.1.0&apos;&#125; 添加跳转页面的代码12345//跳转到习题界面 Intent intent = new Intent(context, ExercisesDetailActivity.class); intent.putExtra(&quot;id&quot;, bean.id); intent.putExtra(&quot;title&quot;, bean.title); ((Activity) context).startActivityForResult(intent, 000); 再到MainActivity里添加回调方法 如果觉得不错，那就点个赞吧！❤️ 总结 本文讲了AndroidStudio制作RecyclerView完成习题详情的展示，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>Android Studio实战练习V2</category>
      </categories>
      <tags>
        <tag>Android Studio实战练习V2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android2-1]]></title>
    <url>%2F2018%2F03%2F02%2F1%2F</url>
    <content type="text"><![CDATA[用一切抱怨的时间去努力 Fragment12FragmentManager fragmentManager = getFragmentManager();FragmentTransaction beginTransaction = fragmentManager.beginTransaction(); 事务 add(),remove(),replace(),commit() 12345MyFragment2 fragment2=new MyFragment2();FragmentManager fragmentManager = getFragmentManager();FragmentTransaction beginTransaction = fragmentManager.beginTransaction();beginTransaction.add(R.id.frame,fragement2);beginTransaction.commit(); fragment的生命周期 Created1onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated() Started1onStart() Resumed1onResume() Paused1onPause() Stopped1onStop() Destroyed1onDestroyView()-&gt;onDestroy()-&gt;onDetach() 12345//当Fragment被添加到Activity的时候回调这个方法，并且只调用一次@Overridepublic void onAttach(Activity activity)&#123; super.onAttach(activity);&#125; 12345//创建Fragment时会回调，只调用一次@Overridepublic void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState);&#125; 12345//每次创建回调@Overridepublic View onCreateView(## ##)&#123;&#125; 12345//当Fragment所在的Activity启动完成后调用@Overridepublic void onActivityCreated(Bundle savedInstanceState)&#123; super.onActivityCreated(savedInstanceState);&#125; 12345//启动onStart()@Overridepublic void onStart()&#123; super.onStart();&#125; 12345//onResume@Overridepublic void onResume()&#123; super.onResume();&#125; 12345//onPause 暂停@Overridepublic void onPause()&#123; super.onPause();&#125; 12345//onStop 停止@Overridepublic void onStop()&#123; super.onStop();&#125; //last12345//onDestroyView@Overridepublic void onDestroyView()&#123; super.onDestroyView();&#125; //销毁12345//onDestroy@Overridepublic void onDestroy()&#123; super.onDestroy();&#125; 重点删除Fragment//onDetach1234@Overridepublic void onDetach()&#123; super.onDetach();&#125; 启动Fragment onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() 暂停Fragment - //暂停和停止的方法 onPause()-&gt;onStop() 重新看到Fragment onStart()-&gt;onResume() Fragment1 -&gt; Fragment212Fragment1: onPause()-&gt;onStop()-&gt;onDestroyView-&gt;onDestroy()-&gt;onDetach()Fragment2: onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()-&gt;onResume() Fragment2回到主界面时 onPause()-&gt;onStop() 又重新看见12//Fragment2回到界面 onStart()-&gt;onResume() Fragment2 退出1onPause()-&gt;onStop()-&gt;onDestroyView()-&gt;onDestroy()-&gt;onDetach() Fragment与Activity Fragment是通过调用getActivity()的方法获取Activity的； Activity是通过调用FragmentManager的findFramentById()的，也可以用findFragmentByTag()方法获取Fragment片段的。 重点12345678910public class MyFragment extends Fragment&#123; @Override public View onCreateView(LayoutInflater inflater,ViewGrop container,Bundle savedInstanceState)&#123; return super.onCreateView(inflater,container,savedInstanceState); //View view = inflater.inflate(R.layout.fragment, container, false); //TextView tv = view.findViewById(R.id.textview); //return view; &#125;&#125; 一个Activity调用Fragment的界面显示数据内容 1234567891011String text = editext.getText().toString();MyFragment fragment = new MyFragment();Bundle bundle = new Bundle();bundle.putString(&quot;name&quot;,text);fragment.setArguments(bundle);FragmentManager fragmentManager = getFragmentManager();FragmentTransaction beginTransaction = fragmentManager.beginTransaction();//beginTransaction.add(containerViewId,fragment,tag)beginTransaction.add(R.id.layout.textview,fragment,&quot;fragment&quot;);beginTransaction.commit(); 在Fragement中设置123456789public class MyFragment extends Fragment&#123; @0verride public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)&#123; View view = inflater.infate(R.layout.fragement,container,false); TextView tv=view.findViewById(R.id.textview); String text = getArguments().get(&quot;name&quot;)+&quot;&quot;; tv.setText(text); &#125;&#125; Fragment12345private String name = &quot;v&quot;;public interface Myvoid&#123; public void name(String name);&#125; Activity1implements Myvoid fragment12345@Overridepublic void onAttach(Activity activity)&#123; myvoid = activity; super.onAttach(activity);&#125; 回到Activity1覆盖方法 另类xml12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/white&quot; android:orientation=&quot;vertical&quot;&gt; &lt;/LinearLayout&gt; Fragment123456789101112131415161718public class MyinfoFragment extends Fragment implements View.OnClickListener&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment_myinfo, null); &#125; @Override public void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); &#125; @Override public void onClick(View v) &#123; &#125;&#125; MainActivity123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends FragmentActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setMain(); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; &#125; private void setMain() &#123; &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); &#125; private void setSelectStatus(int index) &#123; switch (index)&#123; &#125; &#125; private void initView() &#123; &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; &#125; &#125;&#125; 继续12FragmentManager fragmentManager = getFragmentManager();Fragment findFragmentById = fragmentManager.findFragmentById(R.id.fragment); ViewPager左右滑动12345&lt;android.support.v4.view.ViewPager android:id=&quot;@+id/viewpager&quot; android:... android:...&gt;&lt;/android.support.v4.view.ViewPager&gt; ViewPager是一种容器，可以盛装两种类型的对象：一种是View对象； 也可以放置Fragment。 12getLayoutInflater().form(this);getLayoutInflater().form(this).inflate(resource,root); 配置Adapter： 准备数据源 -&gt; 准备适配器 -&gt;加载适配器 ListPagerAdapter ViewPager的声明：&lt;android.support.v4.view.ViewPager&gt;是为了解决版本兼容性问题 过程我们创建好布局文件，然后在MainActivity中添加，进行实例 准备数据源1private List&lt;View&gt; viewList; 1viewList = new ArrayList&lt;View&gt;(); 显示1View view = View.inflate(this, R.layout.view, null); 添加1viewList.add(view); 准备适配器1234@Overridepublic Object instantiateItem(ViewGroup container, int position)&#123;&#125; 搭建构造方法123public MyPagerAdapter(List&lt;View&gt; viewList)&#123; this.viewList=viewList;&#125; 12container.addview();return viewList.get(position); 1container.removeView(viweList.get(position)); Adapter创建Adapter1PagerAdapter pagerAdapter = new PagerAdapter(viewList); setAdapter(pagerAdapter); 对象 PagerTabStrip和PagerTitleStrip 1234567一个View显示ViewPager，然后在ViewPager中添加PagerTabStrip&lt;android.support.v4.view.ViewPager ... &lt;android.support.v4.view.PagerTabStrip ...&gt; &lt;/android.support.v4.view.PagerTabStrip&gt;&lt;/android.support.v4.view.ViewPager&gt; 然后加入标题，private List&lt;String&gt; titleList; 同理，ViewPager添加题目12345titleList = new ArrayList&lt;String&gt;();titleList.add(&quot;第一题&quot;)；titleList.add(&quot;第二题&quot;)；titleList.add(&quot;第三题&quot;)；titleList.add(&quot;第五题&quot;); 在加入PagerAdapter中，创建Adapter下创建，MyPagerAdapter.java MyPagerAdapter.java12345678public class MyPagerAdapter extends PagerAdapter&#123; private List&lt;View&gt; viewList; private List&lt;String&gt; titleList; public MyPagerAdapter(List&lt;View&gt; viewList, List&lt;String&gt; titleList)&#123; this.viewList=viewList; this.titleList=titleList; &#125;&#125; 加入题目数量第几题显示标题getPageTitle(),显示所对应的标题12345@Overridepublic CharSequence getPageTitle(int position)&#123; //return super.getPageTitle(position); return titleList.get(position);&#125; PagerTabStrip的属性背景 setBackgroundColor(Color.RED);文本setTextColor();下划线setDrawFullUnderline(false);分割线setTabIndicatorColor(); PagerTitleStrip 与 PagerTabStrip 类似适配器 FragmentPagerAdapter 12345678910111213141516171819202122232425262728293031323334353637383940import android.os.Bundle;import android.support.v4.app.Fragment;public class ExercisesFragment extends Fragment &#123; private ListView lvList;//来源fragment private ListItemAdapter adapter; //适配器 private List&lt;&gt; ebl; //列表集合 @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; return inflater.inflate(R.layout.fragment, null); &#125; @Override public void onViewCreated(View view, Bundle savedInstanceState) &#123; super.onViewCreated(view, savedInstanceState); initData(); lvList = view.findViewById(R.id.lv_list); adapter = new ListItemAdapter(getActivity()); adapter.setData(ebl); lvList.setAdapter(adapter); &#125; private void initData()&#123; ebl = new ArrayList&lt;Bean&gt;(); for (int i=0;i&lt;10;i++)&#123; Bean bean = new Bean(); bean.id=(i+1); switch (i)&#123; case 0: case 9: default: break; &#125; &#125; &#125;&#125; 设置MyFragment继承Fragment1234567public class MyFragment extends Fragment&#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)&#123; return inflater.infate(R.layout.view, container, false); //return inflater.infate(R.layout.view, null); &#125;&#125; 点击跳转Fragment12345678910111213141516public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.bottom1: //getSupportFragmentManager().beginTransaction().add(R.id.main_body,new CFragment()).commit(); break; case R.id.bottom2: //getSupportFragmentManager().beginTransaction().add(R.id.main_body,new EFragment()).commit(); break; case R.id.bottom3: //getSupportFragmentManager().beginTransaction().add(R.id.main_body,new MFragment()).commit(); break; &#125; &#125; 实例1private List&lt;Fragment&gt; fragmentList; Fragment作为数据源12345添加FragmentfragmentList = new ArrayList&lt;Fragment&gt;();fragmentList.add(new Fragment());添加创建的Fragment//fragmentList.add(new Fragment%()); 导入的包1import android.support.v4.app.Fragment; 配置数据适配器如果用FragmentPagerAdapter，一次性加载同理123456789public class MyFragment extends FragmentPagerAdapter&#123; private List&lt;Fragment&gt; fragmentList; private List&lt;String&gt; titleList; public MyFragment(FragmentManager fm，List&lt;Fragment&gt; fragmentList，List&lt;String&gt; titleList)&#123; super(fm) this.fragmentList=fragmentList; this.titleList=titleList; &#125;&#125; MainActivity.java123456789101112131415161718192021222324252627282930313233public class MainActivity extends FragmentActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; private void setMain() &#123; &#125; private void setSelectStatus(int index) &#123; switch (index)&#123; &#125; &#125; private void initView() &#123; &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; //getSupportFragmentManager().beginTransaction().add(R.id.main_body,new CourseFragment()).commit(); //getSupportFragmentManager().beginTransaction().add(R.id.main_body,new ExercisesFragment()).commit(); //getSupportFragmentManager().beginTransaction().add(R.id.main_body,new MyinfoFragment()).commit(); &#125; &#125;&#125; 1FragmentPagerAdapter adapter=new FragmentPagerAdapter(getSupportFragmentManager()); 轮播图ViewFlipper自动播放 静态的方法导入： 12345678910111213141516171819202122&lt;ViewFlipper android:id=&quot;@+id/flipper&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:flipInterval=&quot;4000&quot;&gt; &lt;ImageView android:scaleType=&quot;matrix&quot; android:id=&quot;@+id/ex2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;ImageView android:scaleType=&quot;matrix&quot; android:id=&quot;@+id/ex3&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;ImageView android:scaleType=&quot;matrix&quot; android:id=&quot;@+id/ex4&quot; android:android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/ViewFlipper&gt; 动态导入： flipper = findViewById(R.id.flipper);flipper.addView(getImageView(R.drawable.picture)); 自己定义动态效果，一般用anim的文件夹表示： 然后创建布局界面：创建轮播图 12345&lt;ViewFlipper android:id=&quot;@+id/flipper&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/ViewFlipper&gt; MainActivity.java 1234567public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125;&#125; 声明变量 1private ViewFlipper flipper; 进行初始化 1flipper = findViewById(R.id.flipper); 动态导入：addView(getImageView(R.drawable.picture)); 轮播图有多张图片，创建数组，分别导入 获取图片 12345private ImageView getImageView(int imageId)&#123; ImageView image = new ImageView(this); image.setImageResource(imageId); return image;&#125; 123for(int i=0; i&lt;imageId.length;i++)&#123; flipper.addView(getImageView( 数组[i] ));&#125; 手势滑动的方法 1234@Overridepublic boolean onTouchEvent(MotionEvent event)&#123; return super.onTouchEvent(event);&#125; 自动播放效果： 12flipper.setFlipInterval(3000);flipper.startFlipping(); ScrollViewHorizontalScrollView,ScrollView 滚动视图 不能滚动，因为布局不是ScrollVeiw，而是&lt;TextView&gt; 1tv.setText(getResources().getString(R.string.content)); 如果是这样就可以 1234567&lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/ScrollView&gt; setOnTouchListener的方法 123scroll.setOnTouchListener(new OnTouchListener)&#123;&#125; 记得 scrollBy 和 scrollTo 的区别 Gallery 图片浏览器Gallery像一个走廊，ImageSwitcher像幻灯片 显示图片，就要对图片进行封装，声明数组 12345布局&lt;Gallery android:... /&gt; 老样子 图片id,private int[] res 定义数组 我们学过的适配器，都是继承BaseAdapter 12ArrayAdapter&lt;String&gt; adapter;SimpleAdapter adapter; 继承BaseAdapter中必须要实现的方法 public int getCount() public long getItemId(int position) public Object getItem(int position) public View gtView(int position, View convertView, ViewGroup parent) 如果自己定义一个适配器，定义后，实现BaseAdapter中的方法，然后创建构造函数 12345private int[] images;public ImageAdapter(int []images)&#123; this.images = images;&#125; 说明获取视图 12345private Context context;public ImageAdapter(int[] images, Context context)&#123; this.images = images; this.context = context;&#125; public View gtView(int position, View convertView, ViewGroup parent) 123456789&#123; //ImageView image=new ImageView(this); ImageView image = new ImageView(context); image.setBackgroundResource(数组[position]); //设置图片大小 image.setLayoutParams(new Gallery.LayoutParams(400,300)); return image;&#125; 加载适配器 MainActivity.java 声明适配器： private ImageAdapter adapter; 初始化： adapter = new ImageAdapter(数组的变量名，上下文(this)); 1gallery.setAdapter(adapter); 无限制浏览 return Interger.MAX_VALUE; 监听器setOnItemSelectedListener(this); 同样也要布局 声明 private ImageSwitcher is; 进行初始化 is = findViewById(R.id.is); 监听器：gallery.setOnItemSelectedListener(this); 现实的接口：implements OnItemSelectedListener,ViewFactory 123public View makeView()&#123; &#125; is.setFactory(this); 12345public View makeView()&#123; ImageView image = new ImageView(this); return image;&#125; SeekBar 拖动进度条 setOnSeekBarChangeListener(this); 123&lt;SeekBar style=&quot;@android:style/Widget.SeekBar&quot; /&gt; 12345&lt;selecter xmlns:android=&quot;http....&quot; &lt;item android:android:state_pressed=&quot;true&quot; android:state_window_focused=&quot;true&quot; andeoid:drawable=&quot;&quot;/&gt; Android常用布局样式线性布局LinearLayout 相对布局RelativeLayout 表格布局TableLayout 可以使用GridView替代 绝对布局AbsoluteLayout 帧布局(主要布局叠加)FrameLayout 多用LinearLayout和RelativeLayout 少用AbsoluteLayout ok]]></content>
      <categories>
        <category>Android开发工程师文集</category>
      </categories>
      <tags>
        <tag>Android开发工程师文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试-开始软件测试]]></title>
    <url>%2F2017%2F04%2F11%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来开始软件测试的概述，希望你们喜欢 软件测试软件测试的基本概念、方法、常用测试工具的使用 常用测试工具的使用性能自动化测试工具：jmeter、loadrunner接口自动化测试工具：SoapUI、postman手机自动化测试工具：appium、robotiumWeb自动化测试工具：selenium、QTP 操作系统Windows,android, linux,macOS苹果操作系统 Web服务Apache,Tomcat 数据库Mysql,Oracle,Sqlserver,sqlite软件测试相关学习网站http://www.51testing.com/html/index.html开始软件测试 测试一个软件 测试的目的 开发的过程 软件质量的保证 理解软件测试 软件测试的分类测试的目的1.测试的目的：在于发现错误（缺陷），保证整个软件开的质量，但软件的质量不能以软件测试为依据2.成功的测试：是发现了未曾发现的软件错误（缺陷）3.好的测试用例：是能有效地发现别的测试用例未发现的软件错误开发的过程在软件开发的过程中，我们要明确软件开发的目标以及软件的需求，进行制定各种软件开发过程中的计划，并进行编写文档测试，软件测试，进行有效地测试和修复，然后提交测试完成的软件。软件测试生存期模型1.瀑布模型答：对于瀑布模型，我知道有六个阶段：计划，需求分析，设计，编码，测试，运行维护。计划–&gt;需求分析–&gt;设计–&gt;编码–&gt;测试–&gt;运行维护 2.原型模型答：就是建立一个能反映用户需求的原型系统，如何对原型系统进行反复的改进和求精，建立一个符合用户的目标系统。 3.增量模型答：对于增量模型，记住的是在每个阶段都会生成一个可发布的正式版本，而且每个软件版本是逐步完善的。 4.螺旋模型答：螺旋模型是瀑布模型和原型模型结合起来的，记住这个模型是有四个阶段，这四个阶段都是主要的，一是制定计划，二是风险分析，三是实施工程，四是评审。 生存周期定义-&gt;计划-&gt;实现-&gt;稳定化-&gt;部署-&gt;运行与维护 软件质量的定义软件质量的定义：满足用户的需求，满足软件测试的需求，保持合理的进度和成本 软件错误的定义软件错误的定义：没有实现其最终的软件需求（文档内的软件需求）就表示错误 错误处理测试：软件错误等级分为：致命错误，严重错误，一般错误，轻微错误，改进建议。 描述错误分三步走，摘要，重建步骤和隔离。 错误测试：为了发现软件中不符合软件需求的事情，做了用户不满意的期望事情。在进行错误处理测试中可能发现的问题不会被修复。 重现错误：在写文档时，记录重现错误步骤是至关重要的，只有你把步骤重现出来程序员要能足够理解，发生了什么错误，并且对程序进行修复，如果你告诉程序员这里错误了，可是不指出问题所在，程序员鸟都不鸟你！ 然而重现步骤，也不是你所重现就重现的，测试人员需要进行发现错误时的所有操作，必须保证操作与原先发生错误时步骤一致和测试环境一致，有可能遇见偶发性，不一定就能马上发现出来，这就需要进行重复的步骤了。 一旦满足了确切的要求，错误才会再次浮现出来。 ##软件错误的状态：软件错误的状态，软件错误的状态就是写在文档中的，状态包含，开放，已分配，被拒绝，被忽略，修复，关闭，达到关闭就ok。简单说就是描述文档的状态，这些状态可理解字面意思。 总体设计定义设计目标，说明每项测试的目标，定义测试环境和配置，编写测试设计文档 开发测试用例测试用例是专门为测试人员写的，根据测试用例能够很好加强测试效果，也能提高测试工作效率，但是，一个好的测试用例，并不是那么简单的，一个好的测试用例应该可以发现软件中的错误，而且测试人员能够很好的并清晰知道测试输入，执行条件和预期的结果等 在我们测试的过程中，测试用例则是测试过程中的辅助，我们在执行一系列测试用例就是我们的测试的过程，测试过程中我们需要知道预期的结果，这在测试用例中必须也明白，在测试人员测试的过程中可以方便记录bug测试文档 总之测试用例越详细越好，但是不能够添加无关的条件或者信息，测试用例的编写需要考虑到测试执行者是否对系统有足够的了解，而且要让测试人员看懂，这一步是非常关键的 明白软件测试测试只能证明错误存在，不能说明软件错误不存在。 软件测试的难度是不知道如何进行测试，不知道如何结束，这需要慢慢地自己去理解了。 重点名句：80％的错误聚集在20％的模块中 软件测试的分类基于软件结构与算法 黑盒测试和白盒测试基于执行被测试软件 静态测试和动态测试基于不同阶段 单元测试，集成测试，系统测试，验收测试 白盒测试白盒测试，我们知道是结构测试方法，是按照程序内部的结构测试程序的，白盒测试又称为结构测试，对代码结构进行测试，可属于程序员的测试~ 黑盒测试黑盒测试又叫做功能测试，适用于用户测试，可以理解为进行性能测试，表面的测试~ 对于黑盒测试是不考虑程序的内部结构和特性的，只是对程序功能或程序的外部设计的测试方法 等价分类法等价分类法：分两种为有效等价类和无效等价类 有效等价类，就是输入的数据是合理的，有意义的，并且符合程序的规格说明。 无效等价类，就是输入的数据是不合理的，没有意义的，并且不符合程序的规格说明。 边界分析法对于边界分析法，是基于等价类划分的，选择等价类的边界值作为测试用例。 错误推测法错误推测法，是靠经验或者直觉推测可能会出现错误的，列出可能出错的和容易出错的，来选择作为测试用例。 因果图法因果图法，理解为把“因”看作输入条件，把“果”看作输出条件，有因就有果，因果图是一种形式化语言，可以根据这种关系选择高效的测试用例。 测试工作流程测试计划，测试用例设计与开发，配置测试环境（软件配置，测试配置，测试工具），撰写适当的测试文档，执行测试 测试人员需要的要求 熟悉软件测试和软件开发流程 有较强的文档能力 会编写测试用例，测试方案文档，测试总结报告等 熟悉测试工具 熟悉一些开发工具等 学习能力，沟通能力 ，团队精神 总结 本文讲了开始软件测试，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一节：学会Java前提-手把手教你配置JDK环境变量]]></title>
    <url>%2F2017%2F04%2F10%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来学会Java前提-手把手教你配置JDK环境变量的概述，希望你们喜欢 下载地址下载jdk，和eclipse就比较简单了，提供JDK 9 地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html提供JDK 8 地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 讲述JDK的配置JDK包安装完成后，需要配置环境变量。点击桌面上的“我的电脑”或者“此电脑”，选择“属性”，接着选择“高级”，点击其中的“环境变量”弹出“环境变量”对话框，其中包含“用户变量”和“系统变量”两部分。 设置系统“变量名”为“JAVA_HOME”,”变量值”为“C:\ProgramFiles\Java\jre1.8.0_112”,即是JDK安装路径，你也可以将地址栏中的路径直接复制过来。 再次选择”系统变量”列表中找到其”Path”（双击）–&gt;”编辑”,弹出”编辑系统变量”,点击新建； 然后，单击”系统变量”下面的“新建”按钮，创建名为”classpath“的环境变量，值为”.”,英文的一点，代表当前路径。 环境变量：JAVA_HOME：D:\Java\jdk1.8.0_25CLASSPATH ：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;Path：;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 验证是否配置成功点WIN键-&gt;运行（或者使用win+r) 输入cmd命令 输入java -version然后在控制台输入，显示出现版本信息即可代表成功。 下载ecplise下载eclipse链接（官网）：https://www.eclipse.org/downloads/接下来我们进入到这个链接：https://www.eclipse.org/downloads/eclipse-packages/ 你可以看到的是，这么多，你点击Eclipse IDE for Java Developers ，然后自己选32或64旁边点击下载就好，下载的一个压缩包，解压后就可以用了。是不是很简单啊。有人遇到eclipse不兼容JDK 9.0的情况，解决方案就是打开eclipse.ini文件，在文件末尾添加一行：–add-modules=ALL-SYSTEM 总结 本文讲了学会Java前提-手把手教你配置JDK环境变量，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五节：详细讲解Java中的接口与继承]]></title>
    <url>%2F2017%2F04%2F09%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来详细讲解Java中的接口与继承的概述，希望你们喜欢 什么是接口（interface）接口中的方法都是抽象方法，public权限，全是抽象函数，不能生成对象123456789101112131415161718192021222324interface Student&#123;public void read();public void write();&#125;class ChineseStudent implements Student&#123;//复写public void read()&#123; System.out.println(&quot;read&quot;);&#125;public void write()&#123; System.out.println(&quot;write&quot;);&#125;&#125;class Test&#123;public static void main(String args[])&#123; ChineseStudent chinesestudent = new ChineseStudent(); Student student = chinesestudent; student.read(); student.write();&#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041实现接口用implements关键字，一个接口可以实现多个接口，一个接口可以继承多个接口interface Student&#123;public void read();public void write();&#125;interface Teacher&#123;public void teach();public void test();&#125;class Person implements Student,Teacher&#123;public void read()&#123; System.out.println(&quot;read&quot;):&#125;public void write()&#123; System.out.println(&quot;write&quot;);&#125;public void teach()&#123; System.out.println(&quot;teach&quot;):&#125;public void test()&#123; System.out.println(&quot;test&quot;):&#125;&#125;class Test&#123;public static void main(String args[])&#123; Person person = new Person(); Student student = person; student.read(); student.write(); Teacher teacher = person; teacher.teach(); teacher.close();&#125;&#125; swith( char byte short int)只允许四种类型1234567891011121314151617181920public class Test&#123;public static void main(String args[])&#123; int score = 90; if(score &gt; 85 &amp;&amp; score &lt;= 100)&#123; System.out.println(&quot;成绩为优&quot;); &#125; else if(score &gt; 75 &amp;&amp; score &lt;= 85)&#123; System.out.println(&quot;成绩为良&quot;); &#125; else if(score &gt; 60 &amp;&amp; score &lt;= 75)&#123; System.out.println(&quot;成绩为中&quot;); &#125; else if(score &lt;= 60 &amp;&amp; score &gt;= 0)&#123; System.out.println(&quot;成绩为差&quot;); &#125; else if(score &gt; 100 || score &lt; 0)&#123; System.out.println(&quot;成绩不在正常的范围之内&quot;); &#125;&#125;&#125; 对象就是引用数据类型123456789class Test&#123;public static void main(String args[])&#123; Dog d = new Dog(); d.name=&quot;哈哈&quot;; d.age=2; d.jump(); System.out.println(&quot;名字是&quot;+d.name); &#125;&#125; 重载的表达1234567891011class A&#123;void funA()&#123; System.out.println(&quot;没有参数的funA函数&quot;);&#125;void funA(int i)&#123; System.out.println(&quot;有参数的funA函数&quot;);&#125;void funA(int i,double d)&#123; System.out.println(&quot;拥有两个参数的funA函数&quot;);&#125;&#125; 什么是继承在现实世界当中，继承就是儿子得到老子的东西，在面向对象的世界当中，继承就是一个类得到了另一个类当中的成员变量和成员方法 Java只支持单继承，不允许多继承，继承是为了减少重复代码 使用super调用父类构造函数的方法12345678910111213141516class Person&#123;String name;int age;Person()&#123; System.out.prinltn(&quot;Person的无参数构造函数&quot;);&#125;Person(String name,int age)&#123; this.name=name; this.age=age; System.out.println(&quot;Person有参数的构造函数&quot;);&#125;void eat()&#123; System.out.println(&quot;定义吃饭的方法&quot;);&#125;&#125; 123456789101112class Student extends Person&#123;//子类继承父类Student()&#123; //父类 super(); System.out.println(&quot;Student的无参数构造函数&quot;);&#125;Student(String name,int age,int id)&#123; super(name,age); this.id=id;&#125;&#125; 在Java中的继承，其实就是继承全部属性和方法(除了构造方法)，除了private修饰的变量或者方法，子类无法进行访问 什么是复写具有父子关系的两个类中，父类和子类各有一个函数，这两个函数的定义（返回值类型，函数名，参数列表）完全相同 对象的转型（多态性地体现） 父类引用指向子类对象，同一个类型，调用同一个方法，却能呈现不同的状态 什么是向上转型:向上转型就是将子类的对象赋值给父类的引用。 什么是向下转型:向下转型就是将父类的对象赋值给子类的引用。123Student s1 = new Student();Person p = s1;Student s2 = (Student)p; ##类的多态 父类引用指向子类对象 调用的方法有重写 所谓的转型 类型转换指:把一个引用所指向的对象的类型，转换为另一个引用的类型 没有继承关系的类型进行转换,一定会失败了解Object类 Object类是所有类的父类 Object类提供一个toString方法，返回当前对象的字符串表达 equals() 判断两个对象的内容是否相同详解final final可以修饰类（该类不能够被继承），成员变量（修饰基本类型变量，该变量只有一次赋值机会，修饰引用，该引用只有一次指向对象的机会），成员方法（不能够被重写） String类是public final class String,不能被继承什么是抽象函数没有函数体的函数被称为抽象函数什么是抽象类使用abstract定义的类称为抽象类 抽象类不能够生成对象 抽象类不能实例化，继承抽象类，那么该类必须为抽象类 一个类被声明为抽象类，不能够被直接实例化12345678910111213141516abstract class Person&#123;abstract void eat();&#125;class Chinese extends Person&#123;void eat()&#123; System.out.pritln(&quot;hhh&quot;);&#125;&#125;class Test&#123;public static void main(String args[])&#123; Person p = new Chinese(); p.eat();&#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142abstract class Person&#123;Person()&#123; System.out.println(&quot;Person没有参数的构造函数&quot;);&#125;Person(String name,String age)&#123; this.name=name; this.age=age;&#125;String name;int age;void introduce()&#123; System.out.println(&quot;我的名字是&quot;+name+&quot;，我的年龄是&quot;+age);&#125;abstract void eat();&#125;&#125;class Chinese extends Person&#123;String address;Chinese()&#123; super(); System.out.println(&quot;Chinese的构造函数&quot;); &#125; Chinese(String name,int age,String address)&#123; super(name,age); this.address=address; &#125; void eat()&#123; //复写 System.out.println(&quot;吃饭&quot;); &#125;&#125;class Test&#123;public static void main(String args[])&#123; Person p = new Chinese(); p.eat(); &#125;&#125; 如何生成内部类的对象1234567891011121314151617181920212223242526272829303132333435363738394041424344class Test&#123;public static void main(String args[])&#123; A a = new A(); A.B b = new A().new B(); //或者A.B b = a.new B();&#125;&#125;class A&#123;int i;class B&#123; int j; int funB()&#123; int result = i+j; return result; &#125;&#125;&#125;class Test&#123;public static void main(String args[])&#123; A a = new A(); A.B b = a.new B(); a.i=3; a.j=1; int result = b.funB(); System.out.println(result); &#125;&#125;class A&#123;int i;class B&#123; int j; int funB()&#123; int result = A.this.i+this.j; return result; &#125;&#125;&#125; 内部类内部类有 非静态，静态，匿名类语法: new 外部类().new 内部类() 匿名内部类1234567891011121314151617181920212223242526interfacce A&#123;public void doSomething();&#125;class B&#123;public void fun(A a)&#123; System.out.println(&quot;B函数&quot;); a.doSomething();&#125;&#125;class Work implements A&#123;public void doSomething()&#123; System.out.println(&quot;doSomething&quot;);&#125;&#125;class Test&#123;public static void main(String args[])&#123; Work work = new Work(); A a = work; B b = new B(); b.fun(a); &#125;&#125; 12345678910class Test&#123;public static void main(String args[])&#123; B b = new B(); b.fun(new A()&#123; public void doSomething()&#123; System.out.println(&quot;匿名内部类&quot;); &#125; &#125;);&#125;&#125; 总结 本文讲了详细讲解Java中的接口与继承，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>带你学会Java基础课程</category>
      </categories>
      <tags>
        <tag>带你学会Java基础课程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出的排序算法-选择排序]]></title>
    <url>%2F2016%2F04%2F09%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来选择排序算法，希望你们喜欢 选择排序选择排序比冒泡排序快一些，现在讲的选择排序比冒泡排序快一些，也是常用的排序算法。 选择排序是第一个人和后续排序的人进行比较，若第一个人大于第二个人，就进行交换，那么这时第一人就是最小的，然后这时的第一个人和第三个人进行比较，若这时的第一个人大于第三个人，就进行交换位置，这时第一个人又换人了，也变得更小了，就这样，把剩下的人以这种方法进行比较，直到最后，第一轮结束，在第一位的就是最小的值。 这种就是排序算法，比如有6个人，第一轮要进行5次比较，不是。 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//第一轮 for(int index=1;index&lt;arr.length;index++) &#123; if(arr[0]&gt;arr[index]) &#123; int temp = arr[0]; arr[0] = arr[index]; arr[index] = temp; &#125; &#125; print(arr); //第二轮 for(int index=2;index&lt;arr.length;index++) &#123; if(arr[1]&gt;arr[index]) &#123; int temp = arr[1]; arr[1] = arr[index]; arr[index] = temp; &#125; &#125; print(arr); //第三轮 for(int index=3;index&lt;arr.length;index++) &#123; if(arr[2]&gt;arr[index]) &#123; int temp = arr[2]; arr[2] = arr[index]; arr[index] = temp; &#125; &#125; print(arr); //第四轮 for(int index=4;index&lt;arr.length;index++) &#123; if(arr[3]&gt;arr[index]) &#123; int temp = arr[3]; arr[3] = arr[index]; arr[index] = temp; &#125; &#125; print(arr); //第五轮 for(int index=5;index&lt;arr.length;index++) &#123; if(arr[4]&gt;arr[index]) &#123; int temp = arr[4]; arr[3] = arr[index]; arr[index] = temp; &#125; &#125; print(arr); //第六轮没有，我们arr.length=6举例 //int index = 6;index&lt;arr.length; false 优化 1234567891011121314public static void selectionSort(int[] arr) &#123; for(int count=1;count&lt;arr.length;count++) &#123; for(int index=count;index&lt;arr.length;index++) &#123; if(arr[count-1]&gt;arr[index]) &#123; int temp = arr[count-1]; arr[count-1] = arr[index]; arr[index] = temp; &#125; &#125; &#125; 总结 本文讲了选择排序，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>深入浅出的排序算法</category>
      </categories>
      <tags>
        <tag>深入浅出的排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出的排序算法-冒泡排序]]></title>
    <url>%2F2016%2F03%2F09%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是Vic，今天给大家带来冒泡排序算法，希望你们喜欢 冒泡排序为什么这个排序要叫冒泡呢？为什么不叫其他名词呢？其实这个取名是根据排序算法的基本思路命名的，见名知意，冒泡排序，就是想泡泡在水里一样，在水里大的泡泡先浮出水面，就是大的先排出来，最小的最慢排出。 冒泡排序，是对排序的各个元素从头到尾依次进行相邻的大小比较，比如你是队长，在你的面前有一排人，你要将其进行排序，依次按照从小到大排序。 怎么理解最大的值被排除，你是队长，你对面前的一群人看不惯，进行排序，从左到右开始，第一个和第二个进行比较，大的那个就被挑出来，与第三个进行比较，接下来就是依次按照这个方法比较，就能把那个最大的值，最高的给挑出来不是，这就是第一轮的比较。 接下来，最大的就不用跟他比较了，上面所述，在排序时，你面前的人，是不能乱动的，一旦比较哪个大，两者就换位，如果第一比第二个小，就是第二个大时，两者不用换位，第二个就与第三个进行比较。 依照这个方法，两两比较，大的都被排到了最后，那么一旦排完，是不是都依照从小到大，（从低到高）的顺序在你面前排好了。 代码示例 我们用索引下标来解释123456789101112131415161718192021222324252627282930313233//第一轮 for(int index=0;index &lt; arr.length-1; index++）&#123; //相邻两个比较 if(arr[index] &gt; arr[index+1])&#123; int temp = arr[index]; arr[index] = arr[index+1]; arr[index+1] = temp; &#125; &#125; print(arr); for(int index=0;index &lt; arr.length-2;index++)&#123; //这里arr.length-2,为什么比上一次多减了1呢？ //因为第一轮，把最大的排出来了，就不用比较了，少了一个人 if(arr[index] &gt; arr[index+1])&#123; int temp = arr[index]; arr[index] = arr[index+1]; arr[index+1] = temp; &#125; &#125; print(arr); for(int index=0;index &lt; arr.length-3;index++)&#123; if(arr[index]&gt;arr[index+1])&#123; int temp = arr[index]; arr[index] = arr[index+1]; arr[index+1] = temp; &#125; &#125; print(arr); 优化1234567891011for(int num=1;num&lt;arr.length;num++)&#123; for(int index=0;index&lt;arr.length-num;index++)&#123; if(arr[index]&gt;arr[index+1])&#123; int temp = arr[index]; arr[index] = arr[index+1]; arr[index+1] = temp; &#125; &#125; &#125; 总结 本文讲了冒泡排序，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>深入浅出的排序算法</category>
      </categories>
      <tags>
        <tag>深入浅出的排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试模型以及测试方法]]></title>
    <url>%2F2015%2F04%2F09%2F1%2F</url>
    <content type="text"><![CDATA[前言大家好，我是 Vic，今天给大家带来软件测试模型以及测试方法的概述，希望你们喜欢 软件测试 软件开发过程 软件质量保证 理解软件测试 软件测试分类 测试工作流程 思考软件测试 软件测试时一门很重要的学科，软件测试能提高软件的质量，进行软件测试能明确软件的需求，提高工作效率。 进行软件测试不要误解为这是一项很简单的事情，世界上没有什么问题是简单，软件开发过程中，我们需要定义，计划，实现，稳定化和部署，运行和维护，这是软件生存的周期，那么就有了软件生存期模型。 那么软件生存期模型有什么内容呢 瀑布模型 原型模型 增量模型 螺旋模型1.瀑布模型 答：对于瀑布模型，我知道有六个阶段：计划，需求分析，设计，编码，测试，运行维护。计划–&gt;需求分析–&gt;设计–&gt;编码–&gt;测试–&gt;运行维护，是不是很难背。 2.什么是原型模型答：就是建立一个能反映用户需求的原型系统，如何对原型系统进行反复的改进和求精，建立一个符合用户的目标系统。 3.什么是增量模型答：对于增量模型，记住的是在每个阶段都会生成一个可发布的正式版本，而且每个软件版本是逐步完善的。 4.什么是螺旋模型答：螺旋模型是瀑布模型和原型模型结合起来的，记住这个模型是有四个阶段，这四个阶段都是主要的，一是制定计划，二是风险分析，三是实施工程，四是评审。 对于软件错误的定义： 什么是软件错误的理解呢？如果你认为当一个软件程序出现错误时，程序错误时，就是软件错误的话，那你就错了。 进行软件测试为了发现软件程序中的错误，因为在软件开发中，可能在软件需求，设计，编码等阶段都是有可能出错的，为了保证软件质量就需要对软件进行软件测试，通过不断地验证和确认，保证软件的质量哦！ 进行软件测试是为了发现可能存在的错误，提高软件的质量，但是不能通过软件测试来提高软件质量，不能误解为通过软件测试来提高软件测试，这个做法是错误的。 还有，不能说进行了软件测试就说明错误就不存在了，进行软件测试是保证错误存在率降低。 软件测试 不同角度和方向进行分类 软件结构与算法：黑河测试和白盒测试 执行被测试软件：静态测试和动态测试 测试的不同阶段：单元测试，集成测试，系统测试，验收测试 黑盒测试又叫做功能测试，适用于用户测试，可以理解为进行性能测试，表面的测试~ 白盒测试又称为结构测试，对代码结构进行测试，可属于程序员的测试~ 静态好比对车子在车库中的检查，而动态就好比，开车来检查，测试~ 单元测试，集成测试，系统测试，验收测试答：单元测试怎么理解，可以认为程序员编写完模块，对单个模块进行测试的，单元测试由程序员测试，那么它是用什么测试呢？你应该知道的上述有讲，那么集成测试就是，所有模块集合在一起，集成测试时，会有黑盒测试和白盒测试，这一点要牢记。 系统测试也没什么，如下图：对于验收测试，由验收就知道是由用户进行完成的，对软件的验收测试。 所有的测试都是为了验收软件是否符合需求的。总结 本文讲了软件测试模型以及测试方法，如果您还有更好地理解，欢迎沟通 定位：分享 Android&amp;Java知识点，有兴趣可以继续关注]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
      </tags>
  </entry>
</search>
